{
  "timestamp": "2025-09-15T01:45:58.366494",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 457,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution:\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \"\"\"\n        Method 1:\n\n        * Create a monotonically increasing array - monotonic_arr\n        * Using a window sliding algorithm, keep track of the\n        minimum and maximum values in the monotonic_arr\n        * Update the monotonic_arr using the current\n        window\n        * At the end, return the max of the monotonic_arr\n\n        Your runtime beats 66.15 % of python3 submissions.\n        \"\"\"\n        # #Code block 1\n        monotonic_arr = [nums[0]]\n        max_val = monotonic_arr[-1]\n        min_val = monotonic_arr[-1]\n\n        for i in range(1, len(nums)):\n            if nums[i] > max_val:\n                max_val = nums[i]\n            elif nums[i] < min_val:\n                min_val = nums[i]\n\n            monotonic_arr.append(min(max_val * nums[i], min_val * nums[i]))\n\n        return max(monotonic_arr)\n        # #Code block 2\n        # max_prod = nums[0]\n        # max_so_far = nums[0]\n        # min_so_far = nums[0]\n\n        # for i in range(1, len(nums)):\n        #     temp = max_so_far\n        #     max_so_far = max(nums[i], temp * nums[i])\n        #     min_so_far = min(nums[i], temp * nums[i])\n\n        #     max_prod = max(max_prod, max_so_far)\n\n        # return max_prod"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from typing import List\n\n\n# Time complexity: O(n)\n# Space complexity: O(1)\ndef max_product(nums: List[int]) -> int:\n    max_so_far = nums[0]\n    min_so_far = nums[0]\n    max_global = nums[0]\n\n    for num in nums[1:]:\n        if num > 0:\n            max_so_far, min_so_far = max(num, max_so_far * num), min(num, min_so_far * num)\n        else:\n            max_so_far, min_so_far = min(num, max_so_far * num), max(num, min_so_far * num)\n\n        max_global = max(max_so_far, max_global)\n\n    return max_global\n\n\ndef main():\n    print(max_product([2, 3, -2, 4]))\n    print(max_product([-2, 0, -1]))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def max_product_subsequence(arr):\n    arr.sort()\n    max_prod = arr[-1]\n    min_prod = arr[-1]\n    for i in range(len(arr)-2, -1, -1):\n        max_prod = max(arr[i], max_prod*arr[i])\n        min_prod = min(arr[i], min_prod*arr[i])\n    return max(max_prod, min_prod)\n\n\ndef main():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(max_product_subsequence(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def max_product(arr):\n    # Initializing max_ending_here and min_ending_here\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n\n    # Initialize max_so_far as the first element in the array\n    max_so_far = arr[0]\n\n    for i in range(1, len(arr)):\n        # get the maximum and minimum of the current element and\n        # previous max_ending_here and min_ending_here\n        max_ending_here = max(arr[i], max_ending_here * arr[i],\n                              min_ending_here * arr[i])\n\n        min_ending_here = min(arr[i], max_ending_here * arr[i],\n                              min_ending_here * arr[i])\n\n        # update max_so_far\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == '__main__':\n    arr = [10, 20, 3, 4, 5, 6, 7, 8, 9]\n    max_product(arr)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "from typing import List\n\n\n# O(n) time | O(1) space\ndef maxProduct(array: List[int]) -> int:\n    # find the max and min so far\n    max_so_far = array[0]\n    min_so_far = array[0]\n    max_product = array[0]\n    for i in range(1, len(array)):\n        # update the max so far\n        max_so_far = max(array[i], max_so_far * array[i])\n        # update the min so far\n        min_so_far = min(array[i], min_so_far * array[i])\n        # update the max product\n        max_product = max(max_so_far, max_product)\n\n    return max_product\n\n\n# O(n) time | O(n) space\ndef maxProduct_brute_force(array: List[int]) -> int:\n    # create subsequence\n    sequences = []\n    for i in range(len(array)):\n        sequences.append([array[i]])\n\n    for i in range(1, len(array)):\n        for j in range(i):\n            sequences[i].append(sequences[j][-1] * array[i])\n\n    max_product = array[0]\n    for sequence in sequences:\n        max_product = max(max_product, max(sequence))\n\n    return max_product\n\n\nprint(maxProduct([2, 3, -2, 4]))\nprint(maxProduct([-1, 3, -2, 4]))\nprint(maxProduct([-1, -2, -3, -4]))\nprint(maxProduct_brute_force([2, 3, -2, 4]))\nprint(maxProduct_brute_force([-1, 3, -2, 4]))\nprint(maxProduct_brute_force([-1, -2, -3, -4]))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def max_product(array):\n    # Write your code here.\n\tif len(array) == 0:\n\t\treturn 0\n\tif len(array) == 1:\n\t\treturn array[0]\n\tif len(array) == 2:\n\t\treturn max(array[0] * array[1], array[0], array[1])\n\t\n\tleft = [array[0]]\n\tright = []\n\t\n\tfor i in range(1, len(array)):\n\t\tif array[i] <= 0:\n\t\t\tif len(left) == 0:\n\t\t\t\tleft.append(array[i])\n\t\t\telse:\n\t\t\t\tleft.append(array[i] * left[-1])\n\t\t\tright = []\n\t\telse:\n\t\t\tif len(right) == 0:\n\t\t\t\tright.append(array[i])\n\t\t\telse:\n\t\t\t\tright.append(array[i] * right[-1])\n\t\t\tleft.append(array[i])\n\t\n\treturn max(max(left), max(right))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def max_product_subsequence(array):\n    \"\"\"\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,6])\n    90\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,-6])\n    45\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,6,0])\n    60\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,6,10])\n    120\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,6,-10])\n    180\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,6,-10,-10])\n    180\n    >>> max_product_subsequence([-3,-10,-5,-2,1,2,3,4,5,6,0,-10,-10])\n    180\n    \"\"\"\n    min_neg, max_pos = float(\"inf\"), float(\"-inf\")\n    max_product = float(\"-inf\")\n    for num in array:\n        if num > 0:\n            max_pos = max(max_pos, num)\n            min_neg = float(\"-inf\")\n        elif num == 0:\n            min_neg = 0\n            max_pos = 0\n        else:\n            max_pos = max(min_neg * num, max_pos * num)\n            min_neg = min(min_neg * num, max_pos * num)\n        max_product = max(max_product, max_pos)\n    return max_product\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_local = arr[0]\n\n    for num in arr[1:]:\n        if num > 0:\n            max_local = max(num, max_local * num)\n            min_so_far = min(min_so_far * num, num)\n        elif num == 0:\n            max_local = num\n            min_so_far = num\n        else:\n            max_local = max(num, min_so_far * num)\n            min_so_far = min(num * min_so_far, num)\n\n        max_so_far = max(max_so_far, max_local)\n\n    return max_so_far\n\n\ndef main():\n    print(max_product([2, 4, 6, 8, 10]))\n    print(max_product([10, 5, 2, 7, 6, 12]))\n    print(max_product([2, 3, -2, 4, 0]))\n    print(max_product([-2, -3, -4]))\n\n\nmain()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef max_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param nums: list of numbers\n    :return: maximum product\n    \"\"\"\n    # edge case\n    if len(nums) == 0:\n        return 0\n\n    # max_so_far and min_so_far will store the maximum and minimum product formed by the first number\n    # max_ending_here and min_ending_here will store the maximum and minimum product formed by the last number\n    max_so_far, min_so_far = nums[0], nums[0]\n    max_ending_here, min_ending_here = nums[0], nums[0]\n\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        # max_ending_here and min_ending_here are multiplied with the number\n        # to find the maximum and minimum product of the subsequence ending at the current number\n        max_ending_here = max(max_ending_here * num, min_ending_here * num, num)\n        min_ending_here = min(min_ending_here * num, max_ending_here * num, num)\n\n        # max_so_far and min_so_far are updated for the subsequence starting from the current number\n        max_so_far = max(max_ending_here, max_so_far)\n        min_so_far = min(min_ending_here, min_so_far)\n\n    return max(max_so_far, max_ending_here)\n\n\nif __name__ == \"__main__\":\n    assert max_product([1, 2, 3, 4, 5]) == 120\n    assert max_product([-1, 2, 3, 4, 5]) == 120\n    assert max_product([-10, 1, 2, 3, 4]) == 240\n    assert max_product([-1, -2, -3, -4, -"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def find_max_product(arr):\n    # max_positive is the maximum product of positive integers\n    # max_negative is the maximum product of negative integers\n    # max_positive is the minimum product of negative integers\n    # max_negative is the minimum product of positive integers\n    max_positive = arr[0]\n    max_negative = arr[0]\n    min_positive = arr[0]\n    min_negative = arr[0]\n\n    for i in range(1, len(arr)):\n        # If the number is positive, max_positive and min_negative will be updated\n        if arr[i] > 0:\n            max_positive = max(max_positive * arr[i], arr[i])\n            min_negative = min(min_negative * arr[i], arr[i])\n        # If the number is negative, max_negative and min_positive will be updated\n        else:\n            max_negative = max(max_negative * arr[i], arr[i])\n            min_positive = min(min_positive * arr[i], arr[i])\n    return max(max_positive, max_negative)\n\n\ndef main():\n    print(find_max_product([2, 4, 6, 8, 1, 3]))\n    print(find_max_product([-1, 2, 3, 4, 5]))\n    print(find_max_product([-1, -2, -3, -4, -5]))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def max_product(arr):\n    max_num = arr[0]\n    min_num = arr[0]\n    max_product = arr[0]\n    for i in range(1, len(arr)):\n        temp = max_num\n        max_num = max(arr[i], max_num * arr[i])\n        min_num = min(arr[i], min_num * arr[i])\n        max_product = max(max_product, max_num, min_num)\n    return max_product\n\n\narr = [2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(\"Maximum product of numbers in increasing subsequence:\", max_product(arr))"
    },
    {
      "rank": 12,
      "score": 9.0,
      "candidate": "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_prod = arr[0]\n    min_prod = arr[0]\n    max_prod_cur = arr[0]\n\n    for num in arr[1:]:\n        max_prod_cur, min_prod_cur = max(num, max_prod_cur * num, min_prod_cur * num), min(num, max_prod_cur * num, min_prod_cur * num)\n        max_prod = max(max_prod, max_prod_cur)\n        min_prod = min(min_prod, min_prod_cur)\n\n    return max(max_prod, min_prod)\n\n\nif __name__ == \"__main__\":\n    arr = [10, 5, 2, 7, 8, 7]\n    print(max_product(arr))"
    },
    {
      "rank": 13,
      "score": 9.0,
      "candidate": "def max_product(arr):\n    max_prod = arr[0]\n    min_val = arr[0]\n    max_val = arr[0]\n\n    for i in range(1, len(arr)):\n        temp = max_val\n        max_val = max(max_val * arr[i], min_val * arr[i], arr[i])\n        min_val = min(temp * arr[i], min_val * arr[i], arr[i])\n        max_prod = max(max_prod, max_val)\n\n    return max_prod\n\n\ndef main():\n    arr = [10, 2, 1, 4, 5, 8, 12, 15, 10]\n    print(max_product(arr))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 14,
      "score": 8.0,
      "candidate": "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\n# TODO: Add test case for this\ndef get_max_product_increasing_subsequence(nums: List[int]) -> int:\n    length = len(nums)\n\n    if length == 0:\n        return 0\n\n    min_so_far = nums[0]\n    max_so_far = nums[0]\n    result = nums[0]\n\n    for i in range(1, length):\n        num = nums[i]\n\n        temp = max_so_far\n        max_so_far = max(num, max_so_far * num)\n        min_so_far = min(num, min_so_far * num)\n        result = max(result, max_so_far)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(get_max_product_increasing_subsequence([2, 4, 3, 6, 2, 6]))"
    },
    {
      "rank": 15,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef find_max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n\n    min_ending_here = arr[0]\n    max_ending_here = arr[0]\n    max_so_far = arr[0]\n\n    for num in arr[1:]:\n        temp = max_ending_here\n        max_ending_here = max(num, max(max_ending_here * num, min_ending_here * num))\n        min_ending_here = min(num, min(temp * num, min_ending_here * num))\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert find_max_product([1, 2, 3, 4, 5, 6]) == 120\n    assert find_max_product([2, 3, 4, 5, 6]) == 120\n    assert find_max_product([3, 4, 5, 2]) == 120\n    assert find_max_product([3, 5, 2, 6]) == 300"
    },
    {
      "rank": 16,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n    for x in arr[1:]:\n        temp_max = max_ending_here\n        max_ending_here = max(x, max_ending_here*x, min_ending_here*x)\n        min_ending_here = min(x, temp_max*x, min_ending_here*x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    arr = [2, 3, 4, 5]\n    print(max_product(arr))"
    },
    {
      "rank": 17,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_globally = arr[0]\n\n    for num in arr[1:]:\n        if num > 0:\n            max_so_far, min_so_far = max(num, num * max_so_far, num * min_so_far), min(num, num * max_so_far, num * min_so_far)\n        else:\n            max_so_far, min_so_far = max(num, num * max_so_far, num * min_so_far), min(num, num * max_so_far, num * min_so_far)\n\n        max_globally = max(max_so_far, max_globally)\n\n    return max_globally\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 4, 3, 6, 2, 7]) == 56"
    },
    {
      "rank": 18,
      "score": 8.0,
      "candidate": "def max_product_subseq(nums):\n    # Find the max product of subsequence\n    max_ending = 0\n    min_ending = 0\n    max_product = -1000\n\n    for num in nums:\n        temp = max_ending\n        max_ending = max(max_ending * num, min_ending * num, num)\n        min_ending = min(temp * num, min_ending * num, num)\n        max_product = max(max_product, max_ending)\n\n    return max_product\n\n\ndef main():\n    nums = [1, 2, 3, 4, 5, 6]\n    result = max_product_subseq(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 19,
      "score": 8.0,
      "candidate": "def max_product_subseq(arr):\n    max_product = arr[0]\n    min_product = arr[0]\n    max_product_so_far = arr[0]\n\n    for num in arr[1:]:\n        temp_max = max_product\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        max_product_so_far = max(max_product_so_far, max_product, temp_max * num)\n\n    return max_product_so_far\n\n\nif __name__ == \"__main__\":\n    arr = [10, 5, 2, 7, 8, 7]\n    assert max_product_subseq(arr) == 400"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    inc_max, dec_min = arr[0], arr[0]\n\n    for i in range(1, len(arr)):\n        temp = inc_max\n        inc_max = max(arr[i], inc_max * arr[i])\n        dec_min = min(arr[i], dec_min * arr[i])\n        inc_max = max(inc_max, dec_min * temp)\n\n    return inc_max\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([-4, -3, -2, -1, 72]) == 2592"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_ending = arr[0]\n    min_ending = arr[0]\n    max_overall = arr[0]\n\n    for num in arr[1:]:\n        max_ending, min_ending = max(num, max_ending * num, min_ending * num), min(num, max_ending * num, min_ending * num)\n        max_overall = max(max_overall, max_ending)\n\n    return max_overall\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, -2, 4, -1]) == 6\n    assert max_product_subsequence([-2, -3, 4, -1, -2]) == 24"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) < 2:\n        return -1\n\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n\n    for num in arr[1:]:\n        temp = max_ending_here\n        max_ending_here = max(num, max(max_ending_here * num, min_ending_here * num))\n        min_ending_here = min(num, min(temp * num, min_ending_here * num))\n        max_so_far = max(max_ending_here, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    arr = [-1, -2, -3, -4, -5]\n    assert max_product(arr) == -1\n    arr = [-1, -2, -3, -4, -5, -6]\n    assert max_product(arr) == -1\n    arr = [1, 2, 3, 4, 5]\n    assert max_product(arr) == 120\n    arr = [1, 2, 3, 4, 5, 6]\n    assert max_product(arr) == 720\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    assert max_product(arr) == 5040\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    assert max_product(arr) == 40320\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert max_product(arr) == 362880"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    inc_subseq = []\n    inc_subseq.append(arr[0])\n\n    for i in range(1, len(arr)):\n        if arr[i - 1] < arr[i]:\n            inc_subseq.append(arr[i])\n        else:\n            inc_subseq[-1] = arr[i]\n\n    if len(inc_subseq) == 0:\n        return -1\n\n    return max(inc_subseq) * min(inc_subseq)\n\n\nprint(max_product([-1, -2, -3, -4, 3, 2, 1]))"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    length = len(nums)\n\n    if length == 0:\n        return 0\n\n    min_so_far = [nums[0]] * length\n    max_so_far = [nums[0]] * length\n\n    for i in range(1, length):\n        min_so_far[i] = min(nums[i], max_so_far[i - 1] * nums[i], min_so_far[i - 1] * nums[i])\n        max_so_far[i] = max(nums[i], max_so_far[i - 1] * nums[i], min_so_far[i - 1] * nums[i])\n\n    return max(max_so_far)\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 3, -2, 4, 0, 2]) == 12"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "def max_product(nums):\n    \"\"\"\n    :param nums: list[int]\n    :return: int\n    \"\"\"\n    if len(nums) < 2:\n        return nums[0]\n\n    max_prod = nums[0]\n    min_prod = nums[0]\n    max_sub_prod = nums[0]\n\n    for i in range(1, len(nums)):\n        cur = nums[i]\n        cur_max_prod = max(cur, max_prod * cur, min_prod * cur)\n        cur_min_prod = min(cur, max_prod * cur, min_prod * cur)\n\n        max_prod = max(max_prod, cur_max_prod)\n        min_prod = min(min_prod, cur_min_prod)\n        max_sub_prod = max(max_sub_prod, cur_max_prod)\n\n    return max_sub_prod"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    n = len(arr)\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n\n    for i in range(1, n):\n        # check if the number is positive\n        # if positive then max_ending_here and min_ending_here will change\n        # if negative then max_ending_here and min_ending_here will remain same\n        if arr[i] > 0:\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n\n        # check if the number is negative\n        # if negative then max_ending_here and min_ending_here will change\n        # if positive then max_ending_here and min_ending_here will remain same\n        elif arr[i] < 0:\n            temp = max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(temp * arr[i], arr[i])\n\n        # if number is 0 then max_ending_here and min_ending_here will become 0\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\nif __name__ == \"__main__\":\n    arr = [10, 20, 3, 4, 5, 1, 7, 9, 8, 6, 5]\n    print(max_product_subsequence(arr))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    :param arr: list of numbers\n    :return: maximum product of numbers in an increasing subsequence\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_global = arr[0]\n    for i in range(1, len(arr)):\n        max_local = max(arr[i], max_so_far * arr[i], min_so_far * arr[i])\n        min_local = min(arr[i], max_so_far * arr[i], min_so_far * arr[i])\n        max_so_far = max_local\n        min_so_far = min_local\n        max_global = max(max_global, max_so_far)\n    return max_global\n\ndef main():\n    arr = [3, 5, -2, 2, -1, 3]\n    print(max_product_subsequence(arr))\n\n    arr = [-2, 0, 3, -1, 2, 1, -2, 5, -3]\n    print(max_product_subsequence(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param arr: list of integers\n    :return: maximum product of increasing subsequence\n    \"\"\"\n    if len(arr) == 0:\n        return None\n\n    max_prod, min_prod, max_num, min_num = 1, 1, -1, -1\n    for num in arr:\n        if num > max_num:\n            max_num = num\n            max_prod *= num\n        elif num < min_num:\n            min_num = num\n            min_prod *= num\n        else:\n            max_prod = max(max_prod, num)\n            min_prod = min(min_prod, num)\n    return max(max_prod, min_prod)\n\n\nif __name__ == \"__main__\":\n    arr = [10, 3, 5, 6, 20]\n    print(max_product(arr))"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    # maximum product of increasing subsequence\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0] * arr[1], arr[0], arr[1])\n\n    inc_subseq = [arr[0]]\n    max_product = arr[0] * arr[1]\n    max_so_far = arr[0]\n\n    for i in range(1, len(arr)):\n        if max_so_far * arr[i] >= arr[i]:\n            max_so_far *= arr[i]\n            inc_subseq.append(max_so_far)\n        else:\n            max_so_far = arr[i]\n            inc_subseq.append(max_so_far)\n\n        max_product = max(max_product, inc_subseq[-1])\n\n    return max_product\n\n\ndef main():\n    arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n    print(max_product_subsequence(arr))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    if len(arr) == 0:\n        return None\n\n    if len(arr) == 1:\n        return arr[0]\n\n    if len(arr) == 2:\n        if arr[0] == 0 or arr[1] == 0:\n            return arr[0] * arr[1]\n        else:\n            return max(arr[0], arr[1])\n\n    max_product = -1\n    max_ending = max_so_far = 1\n\n    for num in arr:\n        if num == 0:\n            max_product = max(max_product, max_ending)\n            max_ending = 1\n        else:\n            max_ending = max_ending * num\n            max_so_far = max(max_so_far, max_ending)\n\n    return max(max_product, max_so_far)\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 3, -2, 4]))\n    print(max_product([2, 3, 0, 4]))\n    print(max_product([2, 3]))\n    print(max_product([2, 3, 4]))\n    print(max_product([]))\n    print(max_product([0, 1, 2, 3, 4, 5]))\n    print(max_product([-2, -3, -4]))\n    print(max_product([-2, 0, 3, 4, 5]))"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "def max_prod_subseq(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return max(arr[0] * arr[1], arr[0], arr[1])\n    prod = 1\n    max_prod = -float(\"inf\")\n    for i in range(len(arr)):\n        prod *= arr[i]\n        if prod > max_prod:\n            max_prod = prod\n        if prod == 0:\n            prod = 1\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    print(max_prod_subseq([2, 3, 4, 5]))\n    print(max_prod_subseq([2, 3, 4, 5, 2]))\n    print(max_prod_subseq([2, 3, 4, 5, 2, 1]))\n    print(max_prod_subseq([2, 3, 4, 5, 2, 1, 2]))\n    print(max_prod_subseq([2, 3, 4, 5, 2, 1, 2, 2]))"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    n = len(arr)\n\n    if n == 0:\n        return 0\n\n    max_product = arr[0]\n    max_ending = arr[0]\n    min_ending = arr[0]\n\n    for i in range(1, n):\n        current_number = arr[i]\n\n        max_ending = max(current_number, current_number * max_ending)\n        min_ending = min(current_number, current_number * min_ending)\n\n        max_product = max(max_product, max_ending)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_increasing_subsequence([1, 2, 3, 4, 5, 6]) == 120"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    # edge case\n    if len(arr) == 1:\n        return arr[0]\n\n    # dp\n    dp = [[0 for _ in range(len(arr))] for _ in range(len(arr))]\n\n    for i in range(len(arr)):\n        dp[i][i] = arr[i]\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            dp[i][j] = max(dp[i][j - 1] * arr[j], dp[i][j - 1], arr[j] * arr[i])\n\n    return max(dp[0][-1], dp[-1][0])\n\n\nprint(max_product([1, 2, 3, 4]))\nprint(max_product([-1, -2, -3, -4]))\nprint(max_product([-1, 2, 3, 4]))\nprint(max_product([2, 3, 4, 5]))\nprint(max_product([-2, -3, -4, -5]))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "def max_product(nums):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n\n    max_so_far = nums[0]\n    max_ending_here = nums[0]\n    min_ending_here = nums[0]\n\n    for i in range(1, len(nums)):\n        temp = max_ending_here\n        max_ending_here = max(nums[i], max_ending_here * nums[i])\n        min_ending_here = min(nums[i], min_ending_here * nums[i])\n        max_so_far = max(max_ending_here, min_ending_here, temp * nums[i], max_so_far)\n\n    return max_so_far\n\n\ndef main():\n    nums = [2, 3, -2, 4]\n    print(max_product(nums))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    if len(arr) == 0:\n        return 0\n\n    max_product = arr[0]\n\n    min_product = arr[0]\n\n    for i in range(1, len(arr)):\n        temp = min_product\n        min_product = min(arr[i], min_product * arr[i])\n        max_product = max(max_product, temp * arr[i])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product([-10, -10, -10]) == 0\n    assert max_product([-10, -10, 10]) == 0\n    assert max_product([-10, 10]) == 0\n    assert max_product([10, 2, 3, 5]) == 60\n    assert max_product([1, 2, 3, 5]) == 6\n    assert max_product([-1, -2, -3, -5]) == 30"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "def max_product_subseq(arr):\n    max_ending_here = max_so_far = arr[0]\n\n    for x in arr[1:]:\n        max_ending_here = max(x, max_ending_here * x)\n        max_so_far = max(max_ending_here, max_so_far)\n\n    return max_so_far\n\n\ndef main():\n    arr = [10, 3, 5, 6, 20]\n    print(max_product_subseq(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(numbers: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_ending_here = max_so_far = numbers[0]\n\n    for number in numbers[1:]:\n        if number > max_ending_here:\n            max_ending_here = number\n        elif number < max_ending_here:\n            max_ending_here = max_ending_here * number\n            max_so_far = max(max_ending_here, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([-1, 2, -3, 4, -1, 2, 1, -5, 4]) == 6"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_here = arr[0]\n\n    for i in range(1, len(arr)):\n        max_here = max(arr[i], max_here * arr[i], min_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i], max_so_far * arr[i])\n        max_so_far = max(max_so_far, max_here)\n\n    return max_so_far\n\n\nassert max_product([1, 2, 3, 4, 5, 6]) == 24\nassert max_product([2, 3, 4, 5, 6, 7]) == 504\nassert max_product([-1, 2, 3, 4, 5, 6]) == 120\nassert max_product([-1, -2, -3, -4, -5, -6]) == -6\nassert max_product([-1, -2, -3, -4, -5, 6]) == 720\nassert max_product([-1, -2, -3, -4, -5, -6]) == 120\nassert max_product([-1, -2, -3, -4, -5, -6, -7]) == 144\nassert max_product([-1, -2, -3, -4, -5, -6, -7, -8]) == 256"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "def max_product(array):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_ending = array[0]\n    min_ending = array[0]\n    max_so_far = array[0]\n\n    for num in array[1:]:\n        if num > max_ending:\n            max_ending = num\n            min_ending = max_ending\n        elif num < min_ending:\n            min_ending = num\n\n        max_so_far = max(max_ending * num, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    print(max_product([-10, -2, -1, -3, -4, -5]))\n    print(max_product([-1, -2, -3, -4, -5]))\n    print(max_product([-10, -2, -1, -3, -4]))\n    print(max_product([-10, -2, -1, -3, -4, 1, 2, 3, 4]))\n    print(max_product([-1, 2, -1, 2, -1, 2]))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    n = len(array)\n    result = array[0]\n\n    for i in range(1, n):\n        if array[i - 1] > 0:\n            array[i] = array[i] * array[i - 1]\n        elif array[i - 1] < 0:\n            array[i] = max(array[i], array[i - 1] * array[i])\n\n        result = max(result, array[i])\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert max_product_increasing_subsequence([-10, -10, 2, 3, 4, 5, 6, 7]) == 420"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    min_index, max_index = 0, 0\n    prod_min = arr[0]\n    prod_max = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[max_index]:\n            max_index = i\n            prod_max = arr[i]\n        if arr[i] < arr[min_index]:\n            min_index = i\n            prod_min = arr[i]\n\n        temp = prod_max\n        prod_max = max(arr[i], prod_max * arr[i])\n        prod_min = min(arr[i], prod_min * arr[i])\n\n    return max(prod_max, prod_min)\n\n\nprint(max_product([-1, -3, 0, 2, 3, 1, -2, 5, 6]))"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param arr: list of numbers\n    :return: int\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_here = arr[0]\n\n    for num in arr[1:]:\n        temp = max_here\n        max_here = max(num, max_here * num, min_so_far * num)\n        min_so_far = min(num, temp * num, min_so_far * num)\n        max_so_far = max(max_so_far, max_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    print(max_product([-10, -10, -10, -10, 5]))"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    max_so_far = -float(\"inf\")\n    min_so_far = -float(\"inf\")\n    max_ending = -float(\"inf\")\n    min_ending = -float(\"inf\")\n\n    for i in arr:\n        if i > max_ending:\n            max_ending = i\n            min_ending = max_ending\n        elif i > min_ending:\n            min_ending = i\n        elif i < max_ending:\n            max_ending = i\n            min_ending = max_ending\n        elif i < min_ending:\n            min_ending = i\n\n        max_so_far = max(max_so_far, max_ending)\n        min_so_far = min(min_so_far, min_ending)\n\n    return max(max_so_far, min_so_far)\n\n\nif __name__ == \"__main__\":\n    print(max_product([2, 4, 3, 6, 2, 5]))\n    print(max_product([-2, 0, 2, -3, 0, 2, 3]))\n    print(max_product([-2, -3, 4, -1, -2, 1, 5, -3]))"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param arr: List[int]\n    :return: int\n    \"\"\"\n    max_so_far = -float(\"inf\")\n    min_so_far = float(\"inf\")\n    max_ending_here = 1\n\n    for num in arr:\n        temp = max_ending_here * num\n        max_ending_here = max(num, max_ending_here * num)\n        min_so_far = min(min_so_far, temp)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([-10, -10, -10, -10]) == 1000\n    assert max_product_subsequence([-1, -2, -3, -4, -5]) == 120\n    assert max_product_subsequence([-10, -4, -3, -8, -9]) == 240\n    assert max_product_subsequence([1, 2, 3, 4, 5]) == 120\n    assert max_product_subsequence([-1, 2, -3, 4, -5]) == 24\n    assert max_product_subsequence([-1, 2, -3, 4, -5, 6]) == 36\n    assert max_product_subsequence([-1, 2, -3, 4, -5, 6, -7]) == 42\n    assert max_product_subsequence([-1, 2, -3, 4, -5, 6, -7, -8]) == 32\n    assert max_product_subsequence([-1, 2, -3, 4, -5, 6, -7, -8, -9]) == 24"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "from typing import List\n\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)\ndef max_subsequence_product(nums: List[int]) -> int:\n    curr_max = nums[0]\n    prev_max = nums[0]\n\n    for num in nums[1:]:\n        curr_max, prev_max = max(num, curr_max * num, prev_max * num), curr_max\n\n    return curr_max\n\n\nif __name__ == \"__main__\":\n    print(max_subsequence_product([2, 3, -2, 4]))\n    print(max_subsequence_product([-2, 0, 2]))"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    # Incremental Product\n    inc_prod = arr[0]\n    # Decremental Product\n    dec_prod = arr[0]\n    # Maximum Product\n    max_prod = arr[0]\n    # Minimum Product\n    min_prod = arr[0]\n    # Maximum Product Ending Index\n    max_prod_idx = 0\n\n    for i in range(1, len(arr)):\n        # Incremental Product\n        inc_prod = max(inc_prod * arr[i], arr[i])\n        # Decremental Product\n        dec_prod = min(dec_prod * arr[i], arr[i])\n        # Maximum Product\n        max_prod = max(inc_prod, dec_prod, arr[i], max_prod)\n        # Minimum Product\n        min_prod = min(inc_prod, dec_prod, arr[i], min_prod)\n        # Maximum Product Ending Index\n        if max_prod == arr[i]:\n            max_prod_idx = i\n    return max_prod, max_prod_idx\n\n\nif __name__ == \"__main__\":\n    print(max_product([-10, -10, -10, -10, -10]))\n    print(max_product([-10, -10, -10, -10, -10, 10, 10, 10, 10, 10]))\n    print(max_product([-10, 10, 10, 10, 10, -10, -10, -10, -10, -10]))\n    print(max_product([-10, -10, -10, -10, 10, 10, 10, 10, 10, 10]))\n    print(max_product([-10, -10, -10, -10, 10, 10, 10, 10, 10, 10, 10, 10]))"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    arr.sort()\n    max_value = arr[-1]\n    min_value = arr[-1]\n    result = arr[-1]\n\n    for i in range(len(arr) - 2, -1, -1):\n        max_value, min_value = max(arr[i], max_value * arr[i]), min(arr[i], min_value * arr[i])\n        result = max(result, max_value)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([-10, -20, -30, 10, 20, 30, 40, -10, -20, -30, -40]) == 2400"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from typing import List\n\n\n# O(n) time | O(1) space\ndef maxProduct(array: List[int]) -> int:\n    max_so_far = array[0]\n    max_ending_here = array[0]\n    min_ending_here = array[0]\n\n    for num in array[1:]:\n        temp = max_ending_here\n        max_ending_here = max(num, max_ending_here * num, min_ending_here * num)\n        min_ending_here = min(num, temp * num, min_ending_here * num)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nprint(maxProduct([-100, -90, -20, -10, -5, -1, 2, 3, 4, 5]))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_product_1 = max_product_2 = arr[0]\n\n    for num in arr[1:]:\n        max_product_1, max_product_2 = max(num, max_product_1 * num, max_product_2 * num), max_product_1 * num\n\n    return max(max_product_1, max_product_2)\n\n\nif __name__ == \"__main__\":\n    assert max_product([-100, -90, -20, -10, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 720\n    assert max_product([-1, -2, -3, -4, -5, -6]) == -120\n    assert max_product([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]) == -1"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not nums:\n        return 0\n\n    min_index = 0\n    max_index = 0\n\n    max_product = nums[max_index]\n\n    for index in range(1, len(nums)):\n        if nums[index] > max_product:\n            max_index = index\n            max_product = nums[max_index]\n        elif nums[index] < nums[min_index]:\n            min_index = index\n\n        if index - min_index > max_index - min_index:\n            max_index = index\n            max_product = nums[max_index] * nums[min_index]\n        else:\n            max_product = max(max_product, nums[max_index] * nums[index])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_increasing_subsequence([2, 0, 1, 3, 5]) == 15"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    result = arr[0]\n\n    for num in arr[1:]:\n        if num > 0:\n            max_so_far, min_so_far = max(num, max_so_far * num), min(num, min_so_far * num)\n        else:\n            max_so_far, min_so_far = max(num, min_so_far * num), min(num, max_so_far * num)\n\n        result = max(result, max_so_far)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(max_product_subsequence([-1, -3, -10, 0, 6]))\n    print(max_product_subsequence([-1, -1, -1, -1]))\n    print(max_product_subsequence([-1, -3, -10, 0, 6, 6, 6]))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n\n    for num in arr[1:]:\n        temp_max_product = max(num, max_product * num, min_product * num)\n        min_product = min(num, max_product * num, min_product * num)\n        max_product = temp_max_product\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, 1, 4, 5]) == 120"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def max_product_increasing_subsequence(arr):\n    \"\"\"\n    :param arr: list of integers\n    :return: max product of increasing subsequence\n    \"\"\"\n    n = len(arr)\n    max_product = -10 ** 6\n    min_product = 10 ** 6\n    max_product_end = max_product\n    min_product_end = min_product\n    for i in range(n):\n        max_product = max(max_product, arr[i] * max_product_end, arr[i] * min_product_end)\n        min_product = min(min_product, arr[i] * max_product_end, arr[i] * min_product_end)\n        max_product_end = max(max_product_end, arr[i])\n        min_product_end = min(min_product_end, arr[i])\n    return max_product\n\n\na = [10, 20, 30, 5, 100]\nprint(max_product_increasing_subsequence(a))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "def max_product(arr):\n    if len(arr) < 2:\n        return 0\n    max_so_far = max(arr)\n    min_so_far = max_so_far\n    max_prod = max_so_far * min_so_far\n    for num in arr:\n        if num > max_so_far:\n            max_so_far = num\n            min_so_far = max_so_far * min_so_far\n        elif num < min_so_far:\n            min_so_far = num\n        max_prod = max(max_prod, max_so_far * min_so_far)\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    arr = [2, 4, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n\n    for num in arr[1:]:\n        temp = max_ending_here\n        max_ending_here = max(num, max(num * max_ending_here, num * min_ending_here))\n        min_ending_here = min(num, min(num * temp, num * min_ending_here))\n        max_so_far = max(max_ending_here, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, -2, 4]) == 6\n    assert max_product_subsequence([-2, 0, 2]) == 4"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "def max_product_subsequence(arr):\n    max_ending_at_i = arr[0]\n    min_ending_at_i = arr[0]\n    max_so_far = arr[0]\n\n    for i in range(1, len(arr)):\n        # If current number is positive, max_ending_at_i and min_ending_at_i are unchanged.\n        # If current number is negative, swap the two variables\n        if arr[i] > 0:\n            max_ending_at_i = max(max_ending_at_i * arr[i], arr[i])\n            min_ending_at_i = min(min_ending_at_i * arr[i], arr[i])\n        else:\n            temp = max_ending_at_i\n            max_ending_at_i = min(min_ending_at_i * arr[i], arr[i])\n            min_ending_at_i = max(temp * arr[i], arr[i])\n\n        # Update the maximum product\n        max_so_far = max(max_so_far, max_ending_at_i)\n\n    return max_so_far\n\n\ndef test_max_product_subsequence():\n    assert max_product_subsequence([-1, 3, -10, 5, -2]) == 30\n\n\ndef main():\n    test_max_product_subsequence()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "def max_product(arr):\n    max_ending = 0\n    min_ending = 0\n    max_prod = -float('inf')\n\n    for num in arr:\n        temp = max_ending\n        max_ending = max(num, max_ending * num, min_ending * num)\n        min_ending = min(num, temp * num, min_ending * num)\n        max_prod = max(max_prod, max_ending)\n\n    return max_prod\n\n\ndef max_product_recursive(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    return _max_product(arr, 0)\n\n\ndef _max_product(arr, i):\n    if i == len(arr) - 1:\n        return arr[i]\n\n    max_ending = 0\n    min_ending = 0\n    max_prod = -float('inf')\n\n    for j in range(i, len(arr)):\n        temp = max_ending\n        max_ending = max(arr[j], max_ending * arr[j], min_ending * arr[j])\n        min_ending = min(arr[j], temp * arr[j], min_ending * arr[j])\n        max_prod = max(max_prod, max_ending)\n\n    return max(max_prod, _max_product(arr, i+1))\n\n\nif __name__ == \"__main__\":\n    assert max_product([-10, -10]) == -100\n    assert max_product([-1, -1, -1]) == -1\n    assert max_product([-1, 2, -1, 3, 4]) == 4\n    assert max_product([-1, 2, -1, 3, -1, 4]) == 4\n    assert max_product([-1, 2, -1, 3, -1, -1, 4]) == 4\n    assert max_product([-1, 2, -1, 3, -1, 4, -1]) == 4\n    assert max"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "def max_product(arr: list) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    if len(arr) == 1:\n        return arr[0]\n\n    inc_subseq_max_product = [0] * len(arr)\n    inc_subseq_max_product[0] = arr[0]\n    inc_subseq_max_product[1] = max(arr[0], arr[1])\n\n    for i in range(2, len(arr)):\n        inc_subseq_max_product[i] = max(\n            arr[i],\n            arr[i] * inc_subseq_max_product[i - 1],\n            arr[i] * inc_subseq_max_product[i - 2],\n        )\n\n    return max(inc_subseq_max_product)\n\n\nif __name__ == \"__main__\":\n    assert max_product([-10, -10, -10]) == 0\n    assert max_product([-10, -2, -30, -4, -5, -6, -7]) == 0\n    assert max_product([-10, -2, -30, -4, -5, -6, -7, 100, 50]) == 5000\n    assert max_product([-10, -2, -30, -4, -5, -6, -7, 100, 50, 5000]) == 50000000"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    :param arr: list of numbers\n    :return: maximum product of an increasing subsequence\n    \"\"\"\n\n    if len(arr) == 0:\n        return 0\n\n    result = arr[0]\n    dp_max = arr[0]\n    dp_min = arr[0]\n\n    for i in range(1, len(arr)):\n        cur_num = arr[i]\n        temp_max = dp_max * cur_num\n        temp_min = dp_min * cur_num\n        dp_max = max(temp_max, dp_max * temp_min, dp_min, cur_num)\n        dp_min = min(temp_max, dp_max * temp_min, dp_max, cur_num)\n        result = max(result, dp_max)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert max_product_increasing_subsequence([2, 3, 4, 5, 6, 7, 8, 9, 10]) == 90\n    assert max_product_increasing_subsequence([3, 5, 2, 6, 7, 8, 10, 12, 9]) == 72\n    assert max_product_increasing_subsequence([-2, -3, -4, -5, -6, -7, -8, -9, -10]) == -84\n    assert max_product_increasing_subsequence([-3, -5, -2, -6, -7, -8, -10, -12, -9]) == -72"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "def max_product_increasing_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return None\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_current = arr[0]\n\n    for i in arr[1:]:\n        # if i is greater than max_current, update max_current\n        if i > max_current:\n            max_current = i\n        # if i is less than min_so_far, update min_so_far\n        if i < min_so_far:\n            min_so_far = i\n        # update max_so_far\n        max_so_far = max(max_so_far, max_current, i)\n\n    return max(max_so_far, min_so_far)\n\n\ndef max_product_increasing_subsequence2(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return None\n\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n    max_current = arr[0]\n\n    for i in arr[1:]:\n        # if i is greater than max_current, update max_current\n        if i > max_current:\n            max_current = i\n        # if i is less than min_so_far, update min_so_far\n        if i < min_so_far:\n            min_so_far = i\n        # update max_so_far\n        max_so_far = max(max_so_far, i, max_current * i)\n\n    return max(max_so_far, min_so_far)\n\n\ndef max_product_increasing_subsequence3(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not arr:\n        return None\n\n    max_so_far = arr[0]\n    min"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "def find_max_product(arr):\n    arr.sort()\n    max_num = arr[-1]\n    min_num = arr[0]\n    max_product = max(max_num, arr[-2] * max_num)\n    min_product = min(min_num, arr[-2] * min_num)\n    for i in range(len(arr) - 2, -1, -1):\n        max_product = max(max_num, arr[i] * max_num)\n        min_product = min(min_num, arr[i] * min_num)\n        max_num = max(max_num, arr[i])\n        min_num = min(min_num, arr[i])\n    return max(max_product, min_product)\n\n\nif __name__ == '__main__':\n    test_cases = [\n        ([2, 3, -2, 4], 6),\n        ([-2, 0, 2], 4),\n        ([-2, 3, -4], 24),\n        ([-2, -3, -4], -24),\n        ([-2, -4, 3, 5, -6], 30),\n        ([-2, 2, 3, -4, 5], 60),\n    ]\n    for test_case, exp in test_cases:\n        assert find_max_product(test_case) == exp"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n\n    if len(arr) == 1:\n        return arr[0]\n\n    max_ending_here = max_so_far = arr[0]\n\n    for i in range(1, len(arr)):\n        num = arr[i]\n\n        if num > 0:\n            max_ending_here = max(num, max_ending_here * num)\n        else:\n            max_ending_here = max(num, max_ending_here * num)\n\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, -2, 4]) == 6\n    assert max_product_subsequence([-2, -3, 4, -1]) == 24\n    assert max_product_subsequence([-4, -3, -2]) == -12"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "def max_product(arr):\n    \"\"\"\n    O(n) time and space\n    \"\"\"\n    max_prod, min_prod = arr[0], arr[0]\n    max_global, min_global = arr[0], arr[0]\n    for num in arr[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(max_prod * num, num)\n        min_prod = min(min_prod * num, num)\n        max_global = max(max_global, max_prod)\n    return max_global\n\nprint(max_product([2, 3, -2, 4])) # 6\nprint(max_product([2, 3, 2, 4])) # 12\nprint(max_product([2, -5, -2, -4, 3])) # 24\nprint(max_product([2, -5, 2, -4, 3])) # 24\nprint(max_product([-2, -5, 2, -4, 3])) # 24\nprint(max_product([-2, -5, -2, -4, 3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2, -5, -2, -4, -3])) # 24\nprint(max_product([-2,"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        min_nums = [0] * len(nums)\n        max_nums = [0] * len(nums)\n        min_nums[0] = max_nums[0] = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            min_nums[i] = min(nums[i], min_nums[i - 1] * nums[i], max_nums[i - 1] * nums[i])\n            max_nums[i] = max(nums[i], min_nums[i - 1] * nums[i], max_nums[i - 1] * nums[i])\n            result = max(result, max_nums[i])\n        return result\n\n\nif __name__ == \"__main__\":\n    nums = [2, 3, -2, 4]\n    out = 6\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)\n\n    nums = [-2, 0, -1]\n    out = 0\n    res = Solution().maxProduct(nums)\n    assert res == out, (res, out)"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def max_product(self, array: List[int]) -> int:\n        if not array:\n            return None\n        elif len(array) == 1:\n            return array[0]\n        elif len(array) == 2:\n            return max(array)\n        else:\n            max_product = array[0] * array[1]\n            min_product = array[0] * array[1]\n            for num in array[2:]:\n                max_product, min_product = self.update_max_min(num, max_product, min_product)\n            return max_product\n\n    def update_max_min(self, num: int, max_product: int, min_product: int) -> (int, int):\n        max_product, min_product = self.update_max(num, max_product, min_product)\n        max_product, min_product = self.update_min(num, max_product, min_product)\n        return max_product, min_product\n\n    def update_max(self, num: int, max_product: int, min_product: int) -> (int, int):\n        if num > max_product:\n            max_product = num\n        elif num * max_product > max_product:\n            max_product = num * max_product\n        return max_product, min_product\n\n    def update_min(self, num: int, max_product: int, min_product: int) -> (int, int):\n        if num < min_product:\n            min_product = num\n        elif num * min_product < min_product:\n            min_product = num * min_product\n        return max_product, min_product\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    a = [1, 2, 3]\n    print(s.max_product(a))\n\n    a = [10, 5, 2, 6]\n    print(s.max_product(a))\n\n    a = [2, 3, 4, 5, 6, 7, 8"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n\n    for num in arr[1:]:\n        if num > max_ending_here:\n            max_ending_here = num\n            min_ending_here = max(num, min_ending_here)\n        elif num < max_ending_here:\n            max_ending_here = max(num, max_ending_here)\n            min_ending_here = min(num, min_ending_here)\n\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([-1, -2, -3, -4, -5]) == 120"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "class Solution:\n    def maxProduct(self, nums: list[int]) -> int:\n        if not nums:\n            return 0\n\n        max_product = nums[0]\n        cur_max = nums[0]\n        cur_min = nums[0]\n\n        for num in nums[1:]:\n            if num > cur_max:\n                max_product = max(max_product, num * cur_max)\n                cur_max = num\n            elif num < cur_min:\n                cur_min = num\n            else:\n                max_product = max(max_product, num)\n\n        return max_product\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.maxProduct([2, 3, -2, 4]))\n    print(s.maxProduct([-2, 0, -1]))"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n\n    for i in arr[1:]:\n        if i < 0:\n            max_ending_here, min_ending_here = (\n                min_ending_here,\n                max_ending_here,\n            )\n\n        max_ending_here = max(i, max_ending_here * i)\n        min_ending_here = min(i, min_ending_here * i)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    arr = [2, 3, -2, 4]\n    print(max_product(arr))\n\n    arr = [-4, -3, -2]\n    print(max_product(arr))\n\n    arr = [-4, -3, 2, 1, 1]\n    print(max_product(arr))"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    n = len(arr)\n\n    max_product = -float(\"inf\")\n\n    max_ending = 1\n    min_ending = 1\n\n    for i in range(n):\n        if arr[i] > 0:\n            max_ending = max(max_ending * arr[i], arr[i])\n            min_ending = min(min_ending * arr[i], arr[i])\n        else:\n            max_ending, min_ending = min_ending, max_ending\n\n        max_product = max(max_product, max_ending)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, 4, -1, 5]) == 120\n    assert max_product_subsequence([-1, -1, -1, -1, -1]) == -1\n    assert max_product_subsequence([-1, -2, -3, -4, -5]) == -120"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "class Solution:\n    def maxProduct(self, nums: list[int]) -> int:\n        # If the array is empty or there is only one element, return the array\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        # Create a new array to store the maximum product of the increasing subsequence\n        max_product: list[int] = [0] * len(nums)\n\n        # Since the maximum product will always be greater than 0, we can set the first element to 1\n        max_product[0] = 1\n\n        # For every element in the array\n        for i in range(len(nums)):\n            # If the element is 0, the maximum product is 0\n            if nums[i] == 0:\n                max_product[i] = 0\n            # If the element is positive\n            elif nums[i] > 0:\n                # If the previous element is 0, the maximum product is 0\n                if max_product[i - 1] == 0:\n                    max_product[i] = 0\n                # If the previous element is negative, the maximum product is the current element\n                elif max_product[i - 1] < 0:\n                    max_product[i] = nums[i]\n                # If the previous element is positive, the maximum product is the maximum of the previous element and the current element\n                else:\n                    max_product[i] = max(max_product[i - 1] * nums[i], nums[i])\n            # If the element is negative\n            else:\n                # If the previous element is 0, the maximum product is 0\n                if max_product[i - 1] == 0:\n                    max_product[i] = 0\n                # If the previous element is positive, the maximum product is the current element\n                elif max_product[i - 1] > 0:\n                    max_product[i] = nums[i]\n                # If the previous element is negative, the maximum product is the minimum of the previous element and"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "def max_product(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_product = arr[0]\n    min_product = arr[0]\n    max_product_of_subsequence = arr[0]\n\n    for i in range(1, len(arr)):\n        max_product, min_product = swap_if_necessary(max_product, min_product, arr[i])\n        max_product_of_subsequence = max(max_product, max_product_of_subsequence * arr[i])\n\n    return max_product_of_subsequence\n\n\ndef swap_if_necessary(max_product, min_product, curr_num):\n    \"\"\"\n    If curr_num is greater than max_product, swap max_product and min_product\n    \"\"\"\n    if curr_num > max_product:\n        max_product, min_product = curr_num, max_product\n\n    elif curr_num < min_product:\n        min_product = curr_num\n\n    return max_product, min_product\n\n\nif __name__ == \"__main__\":\n    print(max_product([-10, -10, -10]))\n    print(max_product([-10, -10, -10, 100]))\n    print(max_product([-10, -10, -10, 100, 100, 100, 100, 100, 100, 100]))\n    print(max_product([-10, -10, -10, 100, 100, 100, 100, 100, 100, 100, 100]))"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef get_max_product(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_product = nums[0]\n    min_product = nums[0]\n    max_product_so_far = nums[0]\n\n    for i in range(1, len(nums)):\n        max_product, min_product = (\n            max(nums[i], max_product * nums[i], min_product * nums[i]),\n            min(nums[i], max_product * nums[i], min_product * nums[i]),\n        )\n        max_product_so_far = max(max_product_so_far, max_product)\n\n    return max_product_so_far\n\n\nif __name__ == \"__main__\":\n    print(get_max_product([-1, -3, -10, 0, 6]))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    length = len(arr)\n\n    # If array is empty or has only one element, then maximum product of increasing subsequence is 0\n    if length < 2:\n        return 0\n\n    # If array has two elements, then maximum product of increasing subsequence is the maximum of the two elements\n    if length == 2:\n        return max(arr)\n\n    # To store the maximum product of increasing subsequence\n    max_prod = -1000000\n\n    # To store the maximum product that can be obtained by multiplying with the first element\n    max_ending_here = 1\n\n    # To store the minimum product that can be obtained by multiplying with the first element\n    min_ending_here = 1\n\n    # To store the first element of the current subsequence\n    first = 0\n\n    # Traverse the array\n    for i in range(length):\n\n        # If the current element is greater than the first element, then it becomes the first element of the\n        # current subsequence.\n        if arr[i] > arr[first]:\n            first = i\n\n        # Multiply the current element with the maximum product of the current subsequence\n        max_ending_here *= arr[i]\n\n        # Multiply the current element with the minimum product of the current subsequence\n        min_ending_here *= arr[i]\n\n        # Update the maximum product\n        max_prod = max(max_prod, max_ending_here, min_ending_here)\n\n        # If the product is less than 0, then swap the maximum product with the minimum product\n        if min_ending_here < 0:\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n\n    # Return the maximum product of increasing subsequence\n    return max_prod\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4,"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def max_product(arr):\n    n = len(arr)\n    max_product = arr[0]\n    max_so_far = arr[0]\n    min_so_far = arr[0]\n\n    for i in range(1, n):\n        if arr[i] > 0:\n            max_so_far = max(max_so_far * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        else:\n            temp = max_so_far\n            max_so_far = max(min_so_far * arr[i], arr[i])\n            min_so_far = min(temp * arr[i], arr[i])\n\n        max_product = max(max_so_far, max_product)\n\n    return max_product\n\n\ndef max_product_2(arr):\n    n = len(arr)\n    max_product = arr[0]\n    min_product = arr[0]\n\n    for i in range(1, n):\n        temp = max_product\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        if temp < 0:\n            max_product = max(min_product, max_product)\n\n    return max_product\n\n\nassert max_product([-10, -10, -10, -10]) == 0\nassert max_product([1, -2, -3, -4, -5]) == 120\nassert max_product([-1, -2, -3, -4, -5]) == 120\nassert max_product([-1, 2, -3, 4, -5]) == 96\nassert max_product([-1, -2, 3, -4, 5]) == 180\nassert max_product([-1, -2, 3, 4, 5]) == 180\nassert max_product([-1, 2, -3, -4, 5]) =="
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "def max_product_subsequence(arr):\n    min_so_far = arr[0]\n    max_so_far = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        temp = max_so_far\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n        result = max(result, max_so_far)\n\n    return result\n\n\nprint(max_product_subsequence([-3, -10, 1, 9, -2, 1, 2, -10, 3, -10, -2]))"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    :param: arr - list of integers\n    return: int - maximum product of a subsequence\n    \"\"\"\n    # Base case\n    if len(arr) == 0:\n        return 0\n\n    # Initialise max_product as max of first element and min as min of first element\n    max_product = max(arr[0], 0)\n    min_product = min(arr[0], 0)\n\n    # Iterate over the array from 2nd element onwards\n    for i in range(1, len(arr)):\n        # Update max_product and min_product based on the current element\n        max_product = max(max_product * arr[i], min_product * arr[i], arr[i])\n        min_product = min(max_product * arr[i], min_product * arr[i], arr[i])\n\n    return max_product\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    solution = test_case[1]\n    output = max_product_subsequence(arr)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narr = [3, -4, 0, 2]\nsolution = 48\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [-3, -4, 0, 2]\nsolution = 24\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [-3, 0, 1, 3, -2]\nsolution = 36\ntest_case = [arr, solution]\ntest_function(test_case)"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Let's say we have a subsequence ending at the i-th number,\n        then we have two cases:\n        1. The i-th number is greater than the largest number in the subsequence.\n            Then we have two choices:\n            a) We can include the i-th number in the subsequence.\n            b) We can exclude the i-th number from the subsequence.\n\n        2. The i-th number is less than the smallest number in the subsequence.\n            Then we have two choices:\n            a) We can include the i-th number in the subsequence.\n            b) We can exclude the i-th number from the subsequence.\n\n        In case 1a, the maximum product of the subsequence is the product of the subsequence multiplied by the i-th number.\n        In case 1b, the maximum product of the subsequence is the product of the subsequence excluding the i-th number.\n        In case 2a, the maximum product of the subsequence is the product of the subsequence multiplied by the i-th number.\n        In case 2b, the maximum product of the subsequence is the product of the subsequence excluding the i-th number.\n        \"\"\"\n        min_sub, max_sub = nums[0], nums[0]\n        max_product = nums[0]\n        for i in range(1, len(nums)):\n            num = nums[i]\n            min_sub, max_sub = min(min_sub * num, max_sub * num, num), max(min_sub * num, max_sub * num, num)\n            max_product = max(max_product, max_sub)\n        return max_product\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [2, 3, -2, 4]\n    print(s.maxProduct(nums))"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "def get_max_product(arr):\n    \"\"\"\n    Get the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\n    Args:\n       arr(array): Input array\n    Returns:\n       (int): Maximum product of an increasing subsequence of that array\n    \"\"\"\n    if not arr:\n        return None\n    if len(arr) == 1:\n        return arr[0]\n\n    min_value = 0\n    max_value = 1\n    max_product = 0\n    for i in arr:\n        temp = max_value\n        max_value = max(i * max_value, i * min_value)\n        min_value = min(i * temp, i * min_value)\n        max_product = max(max_product, max_value)\n\n    return max_product\n\n\n\n# Tests\ndef test_function(test_case):\n    arr = test_case[0]\n    solution = test_case[1]\n    output = get_max_product(arr)\n\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narr = [2, 4, 7, 1, 5, 3]\nsolution = 56\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [4, 2, 5, 9, 7, 6, 3]\nsolution = 1680\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [1, 5, 4, 5]\nsolution = 125\ntest_case = [arr, solution]\ntest_function(test_case)\n\narr = [3, 4, 7, 6, 10]\nsolution = 5040\ntest_case = [arr, solution]\ntest_function(test_case)"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def max_product(self, nums: List[int]) -> int:\n        result = nums[0]\n        max_so_far = nums[0]\n        min_so_far = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] > max_so_far:\n                max_so_far = nums[i]\n                min_so_far = max_so_far\n            elif nums[i] < min_so_far:\n                min_so_far = nums[i]\n            elif nums[i] > min_so_far:\n                max_so_far = nums[i]\n\n            result = max(result, max_so_far)\n\n        return result\n\n\nif __name__ == \"__main__\":\n    nums = [10, 1, 2, 3, 4, 5]\n    out = 90\n    res = Solution().max_product(nums)\n    assert res == out, (res, out)\n\n    nums = [2, 3, 4, 5]\n    out = 120\n    res = Solution().max_product(nums)\n    assert res == out, (res, out)\n\n    nums = [1, 2, 3, 4, 5]\n    out = 120\n    res = Solution().max_product(nums)\n    assert res == out, (res, out)\n\n    nums = [2, 3, 4, 5, 1]\n    out = 90\n    res = Solution().max_product(nums)\n    assert res == out, (res, out)"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "def max_product(arr):\n    # TODO: Write your code here\n    pass\n\n\n# Test Cases:\nprint(max_product([2, 3, 7, 5, 1, 3, 9]))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    length = len(arr)\n\n    if length < 2:\n        return 0\n\n    # Max of all sub-arrays with one element\n    max_arr = [arr[0]] * length\n    # Min of all sub-arrays with one element\n    min_arr = [arr[0]] * length\n\n    # Initialize the max and min arrays\n    for i in range(1, length):\n        max_arr[i] = max(max_arr[i - 1] * arr[i], arr[i], min_arr[i - 1] * arr[i])\n        min_arr[i] = min(min_arr[i - 1] * arr[i], arr[i], max_arr[i - 1] * arr[i])\n\n    return max(max_arr)\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, -2, 4]) == 6"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    :param: arr - input array\n    return: int - maximum product of an increasing subsequence of arr\n    \"\"\"\n    max_product = arr[0]\n    min_product = arr[0]\n    max_subsequence = arr[0]\n    for i in range(1, len(arr)):\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_subsequence = max(max_product, max_subsequence)\n    return max_subsequence\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    solution = test_case[1]\n    output = max_product_subsequence(arr)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narr = [3, 4, -5, -2, 2, 3, 1, -1, 5, -2]\nsolution = 40\ntest_case = [arr, solution]\ntest_function(test_case)"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product(numbers: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    if len(numbers) == 0:\n        return 0\n\n    max_product = numbers[0]\n    min_product = numbers[0]\n    max_product_global = numbers[0]\n\n    for i in range(1, len(numbers)):\n        max_product, min_product = (\n            max(numbers[i], max_product * numbers[i], min_product * numbers[i]),\n            min(numbers[i], max_product * numbers[i], min_product * numbers[i]),\n        )\n\n        max_product_global = max(max_product_global, max_product)\n\n    return max_product_global\n\n\nif __name__ == \"__main__\":\n    assert max_product([2, 0, -2, 2]) == 4"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        \"\"\"\n        Time complexity: O(n)\n        Space complexity: O(1)\n        \"\"\"\n        if not nums:\n            return 0\n\n        # max product of increasing subsequence\n        max_product = nums[0]\n        # max product of decreasing subsequence\n        min_product = nums[0]\n        # max product of full sequence\n        max_seq_product = nums[0]\n\n        for i in range(1, len(nums)):\n            prev_max = max_product\n            prev_min = min_product\n\n            max_product = max(nums[i], max(prev_max * nums[i], prev_min * nums[i]))\n            min_product = min(nums[i], min(prev_max * nums[i], prev_min * nums[i]))\n            max_seq_product = max(max_product, max_seq_product)\n\n        return max_seq_product"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def max_product(self, nums: List[int]) -> int:\n        \"\"\"\n        Time complexity: O(n)\n        Space complexity: O(n)\n        \"\"\"\n        if not nums:\n            return 0\n        \n        inc_sub_products = [0] * len(nums)\n        inc_sub_products[0] = nums[0]\n        for i in range(1, len(nums)):\n            num = nums[i]\n            if num >= 0:\n                inc_sub_products[i] = max(inc_sub_products[i - 1] * num, num)\n            else:\n                inc_sub_products[i] = min(inc_sub_products[i - 1] * num, num)\n        \n        dec_sub_products = [0] * len(nums)\n        dec_sub_products[-1] = nums[-1]\n        for i in range(len(nums) - 2, -1, -1):\n            num = nums[i]\n            if num >= 0:\n                dec_sub_products[i] = min(dec_sub_products[i + 1] * num, num)\n            else:\n                dec_sub_products[i] = max(dec_sub_products[i + 1] * num, num)\n        \n        return max(inc_sub_products) * max(dec_sub_products)\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    assert s.max_product([2, 3, -2, 4]) == 6\n    assert s.max_product([-2, 0, 2]) == 4\n    assert s.max_product([-2, -3, -4]) == -24\n    assert s.max_product([-2, -3, -4, -5]) == -120\n    assert s.max_product([-2, -3, -4, -5, -6]) == -720"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return\n\n    max_product_of_subseq = 0\n    curr_max = arr[0]\n    curr_min = arr[0]\n\n    for num in arr[1:]:\n        temp_max = curr_max * num\n        temp_min = curr_min * num\n\n        curr_max = max(num, temp_max, temp_min)\n        curr_min = min(num, temp_max, temp_min)\n\n        max_product_of_subseq = max(max_product_of_subseq, curr_max)\n\n    return max_product_of_subseq\n\n\nif __name__ == \"__main__\":\n    assert max_product_increasing_subsequence([2, 4, 3, 6, 2, 6, 4, 3, 3]) == 48"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    min_num = max_num = nums[0]\n    result = nums[0]\n\n    for i in range(1, len(nums)):\n        max_num, min_num = (\n            max(nums[i], max_num * nums[i], min_num * nums[i]),\n            min(nums[i], max_num * nums[i], min_num * nums[i]),\n        )\n        result = max(result, max_num)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([-1, -3, -10, 0, 60]) == 600"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def max_product(array):\n    \"\"\"\n    :param array: list of numbers\n    :return: the maximum product of an increasing subsequence\n    :rtype: int\n    \"\"\"\n    # initialize variables\n    max_prod = -float('inf')\n    min_prod = 1\n    max_num = -float('inf')\n    min_num = -float('inf')\n    # iterate through array\n    for num in array:\n        # if num is larger than max num, update max num\n        if num > max_num:\n            max_num = num\n        # if num is smaller than min num, update min num\n        if num < min_num:\n            min_num = num\n        # update the max product\n        max_prod = max(max_prod, max_num * num, min_num * num)\n        # update the min product\n        min_prod = min(min_prod, max_num * num, min_num * num)\n    return max_prod\n\n\ndef test_max_product():\n    \"\"\" Tests for max_product \"\"\"\n    assert max_product([-10, -10, 5, 2, 4, 3, -10]) == 400\n    assert max_product([-10, -10, 5, 2, 4, 3, 10]) == 300\n    assert max_product([-10, -10, 5, 2, 4, 3, -10, 10]) == 300\n    assert max_product([-10, -10, 5, 2, 4, 3, -10, 10, 10]) == 300\n    assert max_product([-10, -10, 5, 2, 4, 3, -10, 10, 10, 10]) == 300\n    assert max_product([-10, -10, 5, 2, 4, 3, -10, 10, 10, 10, 10]) == 300\n    assert max_"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_increasing_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    max_ending = arr[0]\n    min_ending = arr[0]\n    max_so_far = arr[0]\n\n    for i in range(1, len(arr)):\n        num = arr[i]\n\n        temp_max = max_ending\n        temp_min = min_ending\n\n        max_ending = max(num, max_ending * num, min_ending * num)\n        min_ending = min(num, temp_max * num, temp_min * num)\n\n        max_so_far = max(max_so_far, max_ending)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_increasing_subsequence([2, 7, 4, 1, 5, 3]) == 45"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if not arr:\n        return 0\n\n    max_so_far = min_so_far = arr[0]\n\n    for num in arr[1:]:\n        max_so_far, min_so_far = (\n            max(max_so_far * num, min_so_far * num, num),\n            min(max_so_far * num, min_so_far * num, num),\n        )\n\n    return max(max_so_far, min_so_far)\n\n\nif __name__ == \"__main__\":\n    arr: List[int] = [-4, -3, -2]\n    print(max_product_subsequence(arr))\n    arr = [-4, -3, -2, 0, 6, 2, 1, 4]\n    print(max_product_subsequence(arr))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def max_product(arr):\n    max_ending = arr[0]\n    min_ending = arr[0]\n    max_product = max_ending\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_ending, min_ending = min_ending, max_ending\n        max_ending = max(arr[i], max_ending * arr[i])\n        min_ending = min(arr[i], min_ending * arr[i])\n        max_product = max(max_product, max_ending)\n    return max_product\n\n\ndef max_product_2(arr):\n    max_ending = arr[0]\n    min_ending = arr[0]\n    max_product = max_ending\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_ending, min_ending = min_ending, max_ending\n        max_ending = max(arr[i], max_ending * arr[i])\n        min_ending = min(arr[i], min_ending * arr[i])\n        max_product = max(max_product, max_ending)\n    return max_product\n\n\ndef main():\n\n    arr = [1, 2, -1, -2, 3, -3]\n    result = max_product(arr)\n    print(result)\n\n    arr = [1, 2, -1, -2, 3, -3]\n    result = max_product_2(arr)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def max_product_sub_seq(self, arr: List[int]) -> int:\n        \"\"\"\n        Time complexity: O(n)\n        Space complexity: O(1)\n        \"\"\"\n        if not arr:\n            return None\n\n        inc_subseq_max = arr[0]\n        dec_subseq_min = arr[0]\n        inc_subseq_prod = 1\n        dec_subseq_prod = 1\n\n        for num in arr[1:]:\n            inc_subseq_prod = max(num, inc_subseq_prod * num, dec_subseq_min * num)\n            dec_subseq_prod = min(num, dec_subseq_prod * num, inc_subseq_max * num)\n            inc_subseq_max = max(inc_subseq_max, num)\n            dec_subseq_min = min(dec_subseq_min, num)\n\n        return max(inc_subseq_max, dec_subseq_min, inc_subseq_prod)\n\n\nif __name__ == \"__main__\":\n    arr = [10, 10, 10, 20, 20]\n    # Output: 2000\n    print(Solution().max_product_sub_seq(arr))\n\n    arr = [10, 20, 30, 40, 50, 60, 70]\n    # Output: 5040\n    print(Solution().max_product_sub_seq(arr))\n\n    arr = [10, 20, 30, 40, 50, 60, 70, 80]\n    # Output: 705600\n    print(Solution().max_product_sub_seq(arr))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "def max_product_increasing_subsequence(arr):\n    \"\"\"\n    :param: arr - list of integers\n    return: int - maximum product of increasing subsequence\n    TODO: complete this function so that it has the same signature as required\n    \"\"\"\n    if not arr:\n        return 0\n    n = len(arr)\n    max_product = 0\n    for i in range(n):\n        max_product = max(max_product, arr[i])\n    return max_product"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def max_product_increasing_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    :param arr: list of numbers\n    :return: max product of increasing subsequence\n    \"\"\"\n\n    n = len(arr)\n    max_product = -float(\"inf\")\n\n    # dp[i] is max product ending with arr[i]\n    dp = [0] * n\n\n    dp[0] = arr[0]\n\n    for i in range(1, n):\n        dp[i] = max(dp[i - 1] * arr[i], arr[i], dp[i - 1])\n        max_product = max(max_product, dp[i])\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    arr = [10, 20, 30, 40, 50, 60, 70]\n    assert max_product_increasing_subsequence(arr) == 7000"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "from typing import List\n\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            temp = max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n\n        return result\n\n\nif __name__ == \"__main__\":\n    max_product = Solution().maxProduct([2, 3, -2, 4])\n    print(max_product)"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "def max_product_subsequence(arr):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    inc = [1] * len(arr)\n    dec = [1] * len(arr)\n    max_inc = arr[0]\n    max_dec = arr[0]\n    min_inc = arr[0]\n    min_dec = arr[0]\n    for i in range(1, len(arr)):\n        inc[i] = max(arr[i] * inc[i - 1], dec[i - 1] * arr[i], arr[i])\n        dec[i] = min(arr[i] * dec[i - 1], inc[i - 1] * arr[i], arr[i])\n        max_inc = max(max_inc, inc[i])\n        max_dec = max(max_dec, dec[i])\n        min_inc = min(min_inc, inc[i])\n        min_dec = min(min_dec, dec[i])\n    return max(max_inc, max_dec, arr[-1])\n\n\nif __name__ == \"__main__\":\n    arr = [10, 5, 2, 7, 8, 7]\n    assert max_product_subsequence(arr) == 400"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(arr: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    max_so_far = arr[0]\n\n    for num in arr[1:]:\n        if num > max_ending_here:\n            max_ending_here = num\n            min_ending_here = max_ending_here\n        elif num < min_ending_here:\n            min_ending_here = num\n\n        max_so_far = max(max_ending_here, min_ending_here, max_so_far)\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, -2, 4]) == 6\n    assert max_product_subsequence([-2, -3, -4]) == -24\n    assert max_product_subsequence([-2, 4, -3, 5, -1]) == 120"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(numbers: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n\n    :param numbers: list of integers\n    :return: maximum product of a subsequence\n    \"\"\"\n\n    max_product = numbers[0]\n    max_product_so_far = numbers[0]\n    min_product_so_far = numbers[0]\n\n    for number in numbers[1:]:\n        max_product_so_far, min_product_so_far = (\n            max(number, max_product_so_far * number, min_product_so_far * number),\n            min(number, max_product_so_far * number, min_product_so_far * number),\n        )\n        max_product = max(max_product, max_product_so_far)\n\n    return max_product\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) == 288"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def max_prod_inc_sub_seq(arr):\n    max_prod = 1\n    min_prod = 1\n    max_prod_end = 1\n\n    for i in range(len(arr)):\n        max_prod_end *= arr[i]\n        max_prod = max(max_prod, max_prod_end)\n\n        min_prod_end = 1\n        for j in range(i+1, len(arr)):\n            min_prod_end *= arr[j]\n            min_prod = min(min_prod, min_prod_end)\n\n        max_prod = max(max_prod, max_prod_end // min_prod)\n\n    return max_prod\n\n\ndef max_prod_inc_sub_seq2(arr):\n    max_prod = 1\n    min_prod = 1\n    max_prod_end = 1\n\n    for i in range(len(arr)):\n        max_prod_end *= arr[i]\n        max_prod = max(max_prod, max_prod_end)\n\n        min_prod_end = 1\n        for j in range(0, i):\n            min_prod_end *= arr[j]\n            min_prod = min(min_prod, min_prod_end)\n\n        max_prod = max(max_prod, max_prod_end // min_prod)\n\n    return max_prod\n\n\ndef main():\n\n    arr = [10, 3, 5, 6, 20]\n    print(max_prod_inc_sub_seq(arr))\n    print(max_prod_inc_sub_seq2(arr))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef max_product_subsequence(array: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    \"\"\"\n    if not array:\n        return 0\n\n    max_product_ending_at_i = array[0]\n    min_product_ending_at_i = array[0]\n\n    max_product_so_far = array[0]\n\n    for i in range(1, len(array)):\n        temp_max_product_ending_at_i = max_product_ending_at_i\n        temp_min_product_ending_at_i = min_product_ending_at_i\n\n        max_product_ending_at_i = max(\n            array[i], max(temp_max_product_ending_at_i * array[i], temp_min_product_ending_at_i * array[i])\n        )\n        min_product_ending_at_i = min(\n            array[i], min(temp_max_product_ending_at_i * array[i], temp_min_product_ending_at_i * array[i])\n        )\n\n        max_product_so_far = max(max_product_so_far, max_product_ending_at_i)\n\n    return max_product_so_far\n\n\nif __name__ == \"__main__\":\n    assert max_product_subsequence([2, 3, -2, 4]) == 6\n    assert max_product_subsequence([-2, -3, -4]) == -24\n    assert max_product_subsequence([]) == 0\n    assert max_product_subsequence([1, 2, 3, 4]) == 24\n    assert max_product_subsequence([-1, -2, -3, -4]) == 24"
    }
  ]
}