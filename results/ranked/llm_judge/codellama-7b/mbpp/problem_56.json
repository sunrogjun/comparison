{
  "timestamp": "2025-09-14T22:43:08.736959",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 56,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell Number, also called Bell numbers or Schr\u00f6der numbers, is a sequence\n    of integers that is part of the general theory of integer partitions.\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = bell[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            bell[i] += bell[i - j] * j\n    return bell[n]\n\n\ndef bell_number_partitions(n):\n    \"\"\"\n    The number of ways to write n as a sum of Bell numbers\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = bell[1] = 1\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            bell[i] += bell[i - j] * j\n    return bell[n]\n\n\ndef bell_number_partitions_rec(n):\n    \"\"\"\n    The number of ways to write n as a sum of Bell numbers\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    result = 0\n    for i in range(1, n + 1):\n        result += bell_number_partitions_rec(n - i) * i\n    return result\n\n\ndef main():\n    \"\"\"\n    >>> bell_number_partitions(5)\n    11\n    >>> bell_number_partitions(10)\n    126\n    >>> bell_number_partitions(15)\n    429\n    >>> bell_number_partitions(20)\n    1181\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def bell_number(n):\n    \"\"\"Returns Bell numbers\"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[i-1] + bell[i-2])\n    return bell[n]\n\ndef bell_partition(n):\n    \"\"\"Returns number of ways to partition a Bell number.\"\"\"\n    # Bell(n) = (Bell(n-1) + Bell(n-2))\n    if n < 2:\n        return 1\n    else:\n        return bell_partition(n-1) + bell_partition(n-2)\n\ndef bell_partition_dp(n):\n    \"\"\"Returns number of ways to partition a Bell number.\"\"\"\n    # Bell(n) = (Bell(n-1) + Bell(n-2))\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[i-1] + bell[i-2])\n    return bell[n]\n\ndef bell_partition_dp_2(n):\n    \"\"\"Returns number of ways to partition a Bell number.\"\"\"\n    # Bell(n) = (Bell(n-1) + Bell(n-2))\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[i-1] + bell[i-2])\n    return bell[n]\n\nif __name__ == '__main__':\n    # Bell(n) = (Bell(n-1) + Bell(n-2))\n    print bell_partition(10)"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "import unittest\n\n\ndef bell_number(n):\n    \"\"\"\n    O(n^2) time and O(n) space\n    \"\"\"\n    if n < 1:\n        return 0\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell[j] += bell[j - 1]\n        bell[i] += bell[i - 1]\n\n    return bell[n]\n\n\ndef partition_bell_number(n):\n    \"\"\"\n    O(n^2) time and O(n) space\n    \"\"\"\n    if n < 1:\n        return 0\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell[j] += bell[j - 1]\n        bell[i] += bell[i - 1]\n\n    return bell[n] - bell[n // 2]\n\n\nclass Test(unittest.TestCase):\n    def test_partition_bell_number(self):\n        self.assertEqual(partition_bell_number(1), 1)\n        self.assertEqual(partition_bell_number(2), 1)\n        self.assertEqual(partition_bell_number(3), 2)\n        self.assertEqual(partition_bell_number(4), 5)\n        self.assertEqual(partition_bell_number(5), 14)\n\n\nif __name__ == '__main__':\n    unittest.main()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] + bell[i - 3]\n\n    return bell[n]\n\n\ndef bell_number_dp(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] + bell[i - 3]\n\n    return bell[n]\n\n\ndef count_ways(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n\n    return dp[n]\n\n\ndef count_ways_dp(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "import math\nfrom functools import lru_cache\n\n\ndef bell_number(n: int) -> int:\n    return int(math.factorial(n) / math.sqrt(math.factorial(2 * n)))\n\n\n@lru_cache(maxsize=None)\ndef bell_partition(n: int) -> int:\n    \"\"\"\n    Bell numbers are the partition numbers.\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    total = 0\n    for k in range(1, n + 1):\n        total += bell_partition(k - 1) * bell_partition(n - k)\n\n    return total\n\n\ndef count_partitions(n: int) -> int:\n    \"\"\"\n    >>> count_partitions(3)\n    3\n    >>> count_partitions(4)\n    6\n    >>> count_partitions(5)\n    10\n    >>> count_partitions(6)\n    15\n    >>> count_partitions(7)\n    21\n    >>> count_partitions(8)\n    25\n    >>> count_partitions(9)\n    30\n    >>> count_partitions(10)\n    35\n    >>> count_partitions(11)\n    35\n    \"\"\"\n    return bell_partition(n) // bell_number(n)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "import math\n\n\ndef bell_number(n):\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (n - i + 1)\n    return bell[n]\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    Returns the number of ways to partition a set of Bell numbers.\n    \"\"\"\n    # Bell number Bn is equal to the number of ways to partition a set of n elements\n    if n <= 1:\n        return 1\n    return bell_number(n - 1) + bell_number_partition(n - 1)\n\n\ndef main():\n    print(bell_number_partition(4))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def partition(n):\n    \"\"\"\n    Partition is the number of ways to write n as the sum of 1s, 2s, 3s, etc.\n\n    Bell number B_n is the number of ways to partition n.\n\n    Number of ways to partition n = B_n\n    \"\"\"\n    bell_numbers = [1]\n    for i in range(1, n + 1):\n        bell_numbers.append(0)\n        for j in range(i):\n            bell_numbers[i] += bell_numbers[i - j - 1]\n\n    return bell_numbers[n]\n\n\nif __name__ == \"__main__\":\n    for i in range(1, 11):\n        print(partition(i))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def bell(n):\n    if n <= 1:\n        return 1\n    return sum(bell(i) * bell(n - i) for i in range(1, n))\n\n\ndef bell_partition(n):\n    return bell(n)\n\n\nif __name__ == \"__main__\":\n    for i in range(20):\n        print(bell_partition(i))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from math import factorial as f\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    >>> bell_number(0)\n    1\n    >>> bell_number(1)\n    1\n    >>> bell_number(2)\n    2\n    >>> bell_number(5)\n    15\n    >>> bell_number(10)\n    11\n    \"\"\"\n    return f(n) // f(n - 1)\n\n\ndef bell_number_partitions(n: int) -> int:\n    \"\"\"\n    >>> bell_number_partitions(0)\n    1\n    >>> bell_number_partitions(1)\n    1\n    >>> bell_number_partitions(2)\n    2\n    >>> bell_number_partitions(5)\n    5\n    >>> bell_number_partitions(10)\n    15\n    \"\"\"\n    bell = bell_number(n)\n    return bell // 2\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell_number(n):\n    if n == 1:\n        return 1\n\n    bell = 1\n    for i in range(2, n + 1):\n        bell += bell_number(i - 1) * (n - i + 1)\n\n    return bell\n\n\n@lru_cache(maxsize=None)\ndef ways_to_partition(n):\n    if n == 1:\n        return 1\n\n    total_ways = 0\n    for i in range(1, n + 1):\n        total_ways += bell_number(i - 1) * ways_to_partition(n - i)\n\n    return total_ways\n\n\ndef main():\n    n = 4\n    print(ways_to_partition(n))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def bell_numbers(n: int) -> int:\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation B(n, k) = B(n - 1, k - 1) + B(n - 1, k),\n    where B(n, k) is the number of partitions of a set of n items into k nonempty parts.\n    The first few Bell numbers are:\n\n    1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975, ...\n\n    >>> bell_numbers(3)\n    5\n    >>> bell_numbers(4)\n    15\n    >>> bell_numbers(5)\n    52\n    \"\"\"\n    bell = [1, 1]\n    for _ in range(2, n + 1):\n        bell.append(0)\n        for j in range(1, _ + 1):\n            bell[_] += bell[j - 1]\n    return bell[-1]\n\n\ndef bell_number_partition_count(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n\n    This problem is equivalent to counting the number of ways to partition a set of n items into k nonempty parts.\n    This can be solved by the Bell number.\n    The number of ways to partition a set of n items into k nonempty parts is given by B(n, k),\n    where B(n, k) is the number of partitions of a set of n items into k nonempty parts.\n    This can be calculated by the Bell number.\n\n    In this problem, we are asked to find the number of ways to partition a set of n items into n nonempty parts.\n    This is equivalent to finding the number of ways to partition a set of n items into k nonempty parts,\n    where k = n.\n    Since B(n, n) = B(n), we can simply find the Bell number of n.\n\n    >>> bell_number_partition_count(3)\n    5\n    >>> bell_number_partition_count(4"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    return factorial(n) / (factorial(n - 2) * 2)\n\n\ndef bell_number_rec(n):\n    if n <= 1:\n        return 1\n    return bell_number_rec(n - 1) + bell_number_rec(n - 2)\n\n\ndef bell_number_dp(n):\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\n\ndef count_partitions(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return bell_number_rec(n - 1) + bell_number_rec(n - 2)\n\n\ndef count_partitions_dp(n):\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(count_partitions(i))\n        print(count_partitions_dp(i))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_numbers(n):\n    \"\"\"\n    Return the nth Bell number.\n    \"\"\"\n    bell_numbers = [0] * (n + 1)\n    bell_numbers[0] = 1\n    bell_numbers[1] = 1\n\n    for i in range(2, n + 1):\n        bell_numbers[i] = bell_numbers[i - 1] + bell_numbers[i - 2] * (i - 1)\n\n    return bell_numbers[n]\n\n\ndef bell_partitions(n):\n    \"\"\"\n    Return the number of ways to partition a set of n items.\n    \"\"\"\n    return bell_numbers(n) // factorial(n - 1)\n\n\nif __name__ == \"__main__\":\n    for n in range(1, 101):\n        print(f\"bell_partitions({n}) = {bell_partitions(n)}\")"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"Return the nth Bell number.\"\"\"\n    b = [0] * (n + 1)\n    b[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            b[i] += b[i - j - 1] * j\n    return b[n]\n\n\ndef ways_to_partition(n: int) -> int:\n    \"\"\"Return the number of ways to partition n.\"\"\"\n    if n < 2:\n        return 1\n    bell_numbers = [bell_number(n - 1)]\n    for i in range(n - 1, 0, -1):\n        bell_numbers.append(bell_number(i))\n    result = 0\n    for i in range(n):\n        result += bell_numbers[i] * bell_numbers[n - i - 1]\n    return result\n\n\nif __name__ == \"__main__\":\n    for n in range(1, 10):\n        print(f\"ways_to_partition({n}) = {ways_to_partition(n)}\")"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "def bell_nums(n):\n    \"\"\"Returns the Bell number of order n.\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return sum(bell_nums(i) * bell_nums(n - 1 - i) for i in range(n))\n\n\ndef bell_nums_count(n):\n    \"\"\"Returns the number of ways to partition a set of Bell numbers.\"\"\"\n    return sum(bell_nums(i) for i in range(n + 1))\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(bell_nums(i), bell_nums_count(i))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "from math import factorial\nfrom functools import lru_cache\n\n\n@lru_cache\ndef bell(n: int) -> int:\n    \"\"\"Returns Bell number of n.\"\"\"\n    return factorial(n) / factorial(n + 1)\n\n\n@lru_cache\ndef partition(n: int) -> int:\n    \"\"\"Returns number of ways to partition n.\"\"\"\n    if n == 0:\n        return 1\n    return sum(bell(i) * partition(n - i) for i in range(1, n + 1))\n\n\ndef test():\n    \"\"\"run test cases\"\"\"\n    test_cases = (\n        (0, 1),\n        (1, 1),\n        (2, 2),\n        (3, 3),\n        (4, 5),\n        (5, 8),\n        (6, 13),\n        (7, 21),\n        (8, 34),\n        (9, 55),\n    )\n\n    for arg, expected in test_cases:\n        assert partition(arg) == expected\n\n\nif __name__ == \"__main__\":\n    test()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "import functools\nfrom typing import Iterator\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    The Bell number Bn is the number of partitions of a set of n elements.\n    B0 = B1 = 1\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return sum(bell_number(n - i) * bell_number(i) for i in range(1, n + 1))\n\n\n@functools.lru_cache(maxsize=None)\ndef bell_partitions(n: int) -> Iterator[int]:\n    \"\"\"\n    The Bell number Bn is the number of partitions of a set of n elements.\n    B0 = B1 = 1\n    \"\"\"\n    if n == 0:\n        yield 1\n    if n == 1:\n        yield 1\n    for i in range(1, n + 1):\n        for b in bell_partitions(n - i):\n            yield b * bell_number(i)\n\n\ndef bell_partition_count(n: int) -> int:\n    \"\"\"\n    The Bell number Bn is the number of partitions of a set of n elements.\n    B0 = B1 = 1\n    \"\"\"\n    return sum(bell_partitions(n))\n\n\ndef main():\n    \"\"\"\n    >>> bell_partition_count(10)\n    127\n    >>> bell_partition_count(100)\n    1144646144\n    >>> bell_partition_count(1000)\n    1144646144000\n    >>> bell_partition_count(10000)\n    1144646144000000\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "import sys\nfrom math import factorial\nfrom typing import List\n\n\ndef binomial(n: int, k: int) -> int:\n    \"\"\"Return the binomial coefficient of n over k.\"\"\"\n    if n < k:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\n\ndef bell(n: int) -> int:\n    \"\"\"Return the nth Bell number.\"\"\"\n    return sum(binomial(n, k) for k in range(n + 1))\n\n\ndef bell_partitions(n: int) -> int:\n    \"\"\"Return the number of ways to partition a set of Bell numbers.\"\"\"\n    return bell(n)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) > 1:\n        num_tests = int(sys.argv[1])\n    else:\n        num_tests = 10\n    for _ in range(num_tests):\n        n = 10 ** 18\n        print(bell_partitions(n))"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n+1) / factorial(n)\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n) / factorial(n-1)\n\n\ndef bell_partition(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n-1) / factorial(n)\n\n\ndef bell_number_partition_count(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n+1) / factorial(n)\n\n\ndef bell_number_partition_count_with_repetition(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n+1) / factorial(n-1)\n\n\ndef bell_partition_with_repetition(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n) / factorial(n-1)\n\n\ndef bell_number_partition_count_with_repetition_and_order(n):\n    \"\"\"\n    Bell number B_n is the number of ways to partition a set of n elements.\n    It is denoted by {n+1 \\choose n}.\n    \"\"\"\n    return factorial(n) / factorial(n-1)\n\n\ndef bell_"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    return factorial(n) / factorial(n - 1)\n\n\ndef bell_number_sum(n):\n    return sum(bell_number(i) for i in range(1, n + 1))\n\n\ndef bell_number_sum_naive(n):\n    \"\"\"\n    Naive solution, which uses the Bell number formula to compute the sum.\n    \"\"\"\n    return sum(bell_number(i) for i in range(1, n + 1))\n\n\ndef bell_number_sum_fast(n):\n    \"\"\"\n    Faster solution, which uses the recursive formula to compute the sum.\n    \"\"\"\n    if n == 1:\n        return 1\n    return bell_number_sum_fast(n - 1) + bell_number_sum_fast(n - 2)\n\n\ndef partition_count(n):\n    \"\"\"\n    Count the number of ways to partition the set of Bell numbers.\n    \"\"\"\n    bell_sum = bell_number_sum(n)\n    bell_sum_naive = bell_number_sum_naive(n)\n    bell_sum_fast = bell_number_sum_fast(n)\n    return bell_sum == bell_sum_naive == bell_sum_fast\n\n\nif __name__ == \"__main__\":\n    assert partition_count(1)\n    assert partition_count(2)\n    assert partition_count(3)\n    assert partition_count(4)\n    assert partition_count(5)\n    assert partition_count(6)\n    assert partition_count(7)\n    assert partition_count(8)\n    assert partition_count(9)\n    assert partition_count(10)"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Compute the n-th Bell number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef bell_number_partitions(n):\n    \"\"\"\n    Compute the number of ways to partition a set of bell numbers.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef main():\n    \"\"\"\n    Entry point\n    \"\"\"\n    n = int(input(\"How many ways are there to partition a set of bell numbers? \").strip())\n    print(f\"There are {bell_number_partitions(n)} ways to partition a set of bell numbers.\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    >>> bell_number(5)\n    10\n    >>> bell_number(10)\n    427\n    \"\"\"\n    return int(factorial(n) / (factorial(n - 1) * 2))\n\n\ndef bell_partition(n: int) -> int:\n    \"\"\"\n    >>> bell_partition(1)\n    1\n    >>> bell_partition(2)\n    1\n    >>> bell_partition(3)\n    2\n    >>> bell_partition(4)\n    3\n    >>> bell_partition(5)\n    10\n    >>> bell_partition(6)\n    22\n    >>> bell_partition(10)\n    427\n    \"\"\"\n    bell = [bell_number(i) for i in range(n + 1)]\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, i + 1):\n            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n\n    return dp[n][n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    \"\"\"\n    Returns bell number.\n    \"\"\"\n    return factorial(n) / (factorial(n - 1) * n)\n\n\ndef bell_partitions(n):\n    \"\"\"\n    Returns number of bell partitions.\n    \"\"\"\n    if n == 0:\n        return 1\n    return bell_number(2 * n) / (bell_number(n) * bell_number(n))\n\n\nif __name__ == \"__main__\":\n    print(bell_partitions(10))"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell_number(n: int) -> int:\n    \"\"\"Returns the nth Bell number\"\"\"\n    if n <= 1:\n        return 1\n    return sum(bell_number(i) * bell_number(n - i) for i in range(1, n))\n\n\ndef bell_number_partitions(n: int) -> int:\n    \"\"\"Returns the number of ways to partition a set of bell numbers\"\"\"\n    # Bell numbers grow so fast that they overflow an int, so we use a float.\n    return sum(\n        bell_number(n) / bell_number(i) / bell_number(n - i)\n        for i in range(1, n)\n    )\n\n\nif __name__ == \"__main__\":\n    for n in range(1, 21):\n        print(f\"bell_number_partitions({n}) = {bell_number_partitions(n)}\")"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    >>> bell_number(0)\n    1\n    >>> bell_number(1)\n    1\n    >>> bell_number(2)\n    2\n    >>> bell_number(3)\n    5\n    >>> bell_number(4)\n    15\n    >>> bell_number(5)\n    52\n    \"\"\"\n    bells = [1, 1]\n    for i in range(2, n + 1):\n        bells.append(sum(bells[: i + 1]))\n    return bells[n]\n\n\ndef bell_partitions(n):\n    \"\"\"\n    >>> bell_partitions(0)\n    1\n    >>> bell_partitions(1)\n    1\n    >>> bell_partitions(2)\n    2\n    >>> bell_partitions(3)\n    5\n    >>> bell_partitions(4)\n    15\n    >>> bell_partitions(5)\n    52\n    \"\"\"\n    bells = [1, 1]\n    for i in range(2, n + 1):\n        bells.append(sum(bells[: i + 1]))\n    return bells[n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "from math import factorial\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell(n: int) -> int:\n    \"\"\"\n    >>> bell(0)\n    1\n    >>> bell(1)\n    1\n    >>> bell(2)\n    2\n    >>> bell(3)\n    5\n    >>> bell(4)\n    15\n    >>> bell(5)\n    52\n    \"\"\"\n    return factorial(n)\n\n\n@lru_cache(maxsize=None)\ndef bell_partition(n: int) -> int:\n    \"\"\"\n    >>> bell_partition(0)\n    1\n    >>> bell_partition(1)\n    1\n    >>> bell_partition(2)\n    1\n    >>> bell_partition(3)\n    2\n    >>> bell_partition(4)\n    5\n    >>> bell_partition(5)\n    15\n    >>> bell_partition(6)\n    52\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return bell(n - 1) + bell_partition(n - 2)\n\n\n@lru_cache(maxsize=None)\ndef partition(n: int) -> int:\n    \"\"\"\n    >>> partition(0)\n    1\n    >>> partition(1)\n    1\n    >>> partition(2)\n    1\n    >>> partition(3)\n    2\n    >>> partition(4)\n    5\n    >>> partition(5)\n    15\n    >>> partition(6)\n    52\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return bell_partition(n - 1) + partition(n - 2)\n\n\ndef main():\n    n = int(input())\n    print(partition(n))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell number is a combinatorial number sequence.\n    https://en.wikipedia.org/wiki/Bell_number\n    \"\"\"\n    return bell_table(n)[n]\n\n\ndef bell_table(n):\n    \"\"\"\n    Generate bell number sequence.\n    \"\"\"\n    bell = [1]\n    for i in range(1, n + 1):\n        bell.append(bell[i - 1] * (n - i + 1) // i)\n    return bell\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    Number of ways to partition a set of bell numbers.\n    \"\"\"\n    bell = bell_table(n)\n    bell_sum = 0\n    for i in range(1, n + 1):\n        bell_sum += bell[i - 1] * bell_number(n - i)\n    return bell_sum\n\n\nif __name__ == \"__main__\":\n    assert bell_number_partition(10) == 26880"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "import math\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell_number(n):\n    return math.factorial(n) / math.sqrt(math.factorial(n + 1))\n\n\ndef partition_bell_numbers(n: int) -> int:\n    \"\"\"\n    Returns the number of ways to partition a set of bell numbers.\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    bell_numbers = [bell_number(i) for i in range(n + 1)]\n    bell_numbers_sum = sum(bell_numbers)\n\n    return bell_numbers_sum * bell_numbers_sum\n\n\nif __name__ == \"__main__\":\n    n = 5\n    print(f\"{n=}\")\n    print(f\"{partition_bell_numbers(n)=}\")"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "from math import factorial\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Compute the nth Bell Number using the definition.\n    \"\"\"\n    return factorial(n) * sum(map(factorial, range(n + 1))) // (\n        factorial(2 * n)\n    )\n\n\ndef bell_number_partition_helper(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to partition a set of size n using the Bell numbers.\n    \"\"\"\n    if n == 1:\n        return 1\n    return sum(bell_number_partition_helper(n - i) for i in range(1, n + 1))\n\n\ndef bell_number_partition(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to partition a set of size n using the Bell numbers.\n    \"\"\"\n    return bell_number(n) * bell_number(n) // bell_number(n - 1)\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(bell_number_partition(i))"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"\n    Compute the Bell number.\n    >>> bell_number(5)\n    105\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = bell[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            bell[i] += bell[i - j]\n\n    return bell[n]\n\n\ndef ways_to_partition(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to partition a set of n items.\n    >>> ways_to_partition(5)\n    105\n    \"\"\"\n    bell = bell_number(n)\n    return bell * bell\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "import math\n\n\ndef bell_number(n):\n    \"\"\"\n    Bell number\n    \"\"\"\n    return int(math.factorial(n) / math.sqrt(math.factorial(2 * n)))\n\n\ndef bell_number_partitions(n):\n    \"\"\"\n    Return number of ways to partition a set of bell numbers.\n    \"\"\"\n    return bell_number(2 * n) // bell_number(n)\n\n\nif __name__ == \"__main__\":\n    for i in range(11):\n        print(bell_number_partitions(i))"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Bell number is the number of ways to partition a set of n elements.\n    >>> bell_number(1)\n    1\n    >>> bell_number(2)\n    2\n    >>> bell_number(3)\n    5\n    >>> bell_number(4)\n    15\n    >>> bell_number(5)\n    52\n    \"\"\"\n    if n == 1:\n        return 1\n\n    return factorial(n)\n\n\ndef partition(set_size: int, index: int, partition_set: list) -> int:\n    \"\"\"\n    Returns the number of ways to partition a set of size 'set_size'\n    using bell numbers.\n\n    >>> partition(3, 1, [])\n    5\n    >>> partition(4, 1, [])\n    15\n    >>> partition(5, 1, [])\n    52\n    >>> partition(5, 2, [1])\n    10\n    >>> partition(5, 3, [1, 2])\n    4\n    >>> partition(5, 4, [1, 2, 3])\n    1\n    \"\"\"\n    if index == set_size:\n        return bell_number(set_size)\n\n    count = 0\n    for i in range(index, set_size + 1):\n        count += partition(set_size, i + 1, partition_set + [i])\n\n    return count\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 33,
      "score": 9.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Bell number\n    \"\"\"\n    if n <= 2:\n        return n\n    return bell_number(n - 1) + bell_number(n - 2) + bell_number(n - 3)\n\n\n@lru_cache(maxsize=None)\ndef number_of_ways(n: int) -> int:\n    \"\"\"\n    Number of ways to partition a set of bell numbers\n    \"\"\"\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return number_of_ways(n - 1) + number_of_ways(n - 2)\n\n\ndef bell_number_partition(n: int) -> int:\n    \"\"\"\n    Number of ways to partition a set of bell numbers\n    \"\"\"\n    return bell_number(n) * number_of_ways(n)\n\n\nif __name__ == \"__main__\":\n    print(bell_number_partition(5))"
    },
    {
      "rank": 34,
      "score": 9.0,
      "candidate": "import functools\nfrom typing import Iterable\n\n\ndef bell(n: int) -> int:\n    \"\"\"Return the nth bell number.\"\"\"\n    @functools.lru_cache(maxsize=None)\n    def _bell(n: int) -> int:\n        return sum(_bell(i) * _bell(n - i) for i in range(1, n))\n\n    return _bell(n)\n\n\ndef bell_partition(n: int) -> int:\n    \"\"\"Return the number of ways to partition a set of bell numbers.\"\"\"\n    return bell(n) - bell(n - 1)\n\n\ndef test_bell_partition():\n    \"\"\"Test bell_partition.\"\"\"\n    assert bell_partition(1) == 1\n    assert bell_partition(2) == 1\n    assert bell_partition(3) == 2\n    assert bell_partition(4) == 5\n    assert bell_partition(5) == 15\n\n\nif __name__ == \"__main__\":\n    for i in range(1, 10):\n        print(i, bell_partition(i))"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Returns the nth bell number.\n    \"\"\"\n    if n < 2:\n        return n\n\n    bell_numbers = [0] * (n + 1)\n    bell_numbers[1] = 1\n    bell_numbers[2] = 2\n\n    for i in range(3, n + 1):\n        bell_numbers[i] = bell_numbers[i - 1] + bell_numbers[i - 2] + bell_numbers[i - 3]\n\n    return bell_numbers[n]\n\n\ndef number_of_partitions(n):\n    \"\"\"\n    Returns the number of ways to partition a set of bell numbers.\n    \"\"\"\n    return bell_number(2 * n) // (bell_number(n) * bell_number(n - 1))\n\n\nif __name__ == \"__main__\":\n    print(number_of_partitions(5))"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the following\n    recurrence relation:\n    bell[n] = bell[n-1] + bell[n-2] + ... + bell[1]\n    \"\"\"\n    if n == 0:\n        return 1\n    return bell_number(n - 1) + bell_number(n - 2)\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    The number of ways to partition a set of bell numbers is the bell number\n    at index n.\n    \"\"\"\n    return bell_number(n)"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "def bell_number(n):\n    \"\"\"Return Bell number B_n.\"\"\"\n    if n < 2:\n        return 1\n    return sum(bell_number(i) * bell_number(n - i) for i in range(1, n))\n\n\ndef bell_number_count(n):\n    \"\"\"Return the number of ways to partition B_n.\"\"\"\n    if n < 2:\n        return 1\n    return sum(bell_number_count(i) * bell_number_count(n - i) for i in range(1, n))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "import time\nfrom typing import List\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Finds the nth bell number using the recurrence relation\n    Bn = 2Bn-1 - Bn-2\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    if n <= 1:\n        return n\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = 2 * bell[i - 1] - bell[i - 2]\n\n    return bell[n]\n\n\ndef bell_number_recursive(n: int) -> int:\n    \"\"\"\n    Finds the nth bell number using the recurrence relation\n    Bn = 2Bn-1 - Bn-2\n    Time complexity: O(2^n)\n    Space complexity: O(n)\n    \"\"\"\n    if n <= 1:\n        return n\n\n    return bell_number_recursive(n - 1) + bell_number_recursive(n - 2)\n\n\ndef bell_number_memoized(n: int, memo: List[int] = []) -> int:\n    \"\"\"\n    Finds the nth bell number using the recurrence relation\n    Bn = 2Bn-1 - Bn-2\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    if n <= 1:\n        return n\n\n    if not memo:\n        memo = [0] * (n + 1)\n        memo[0] = 1\n        memo[1] = 1\n\n    if memo[n]:\n        return memo[n]\n\n    memo[n] = bell_number_memoized(n - 1, memo) + bell_number_memoized(n - 2, memo)\n\n    return memo[n]\n\n\ndef bell_number_dp(n: int) -> int:\n    \"\"\""
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "from math import factorial as f\n\n\ndef bell_num(n: int) -> int:\n    \"\"\"Returns the nth Bell number\"\"\"\n    return f(n) // f(n - 1)\n\n\ndef bell_partitions(n: int) -> int:\n    \"\"\"Returns the number of ways to partition a set of n Bell numbers\"\"\"\n    bell_nums = [bell_num(i) for i in range(1, n + 1)]\n    return bell_nums.count(bell_nums[0])\n\n\nif __name__ == \"__main__\":\n    print(bell_partitions(5))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from math import factorial\nfrom typing import List\n\n\ndef bell_partition(n: int) -> int:\n    \"\"\"\n    Bell numbers are the partitioning of a set.\n    Bell number B(n) is the number of ways to partition a set of n elements.\n    For example, set {1, 2, 3, 4} has the following 5 partitions:\n    {1}, {2}, {3}, {4}, {1, 2, 3, 4}\n    There are 4 Bell numbers: B(1) = 1, B(2) = 1, B(3) = 2, B(4) = 5\n    A partition can be represented as a binary string of length n, where\n    the number of 1s in the string is the number of elements in each set.\n    For example, the partition {1, 2}, {3, 4} can be represented as 1011.\n    We can use dynamic programming to solve this problem.\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 1]\n        for j in range(2, i // 2 + 1):\n            if i % j == 0:\n                bell[i] += bell[i // j]\n\n    return bell[n]\n\n\ndef bell_partition_bf(n: int) -> int:\n    \"\"\"\n    Bell numbers are the partitioning of a set.\n    Bell number B(n) is the number of ways to partition a set of n elements.\n    For example, set {1, 2, 3, 4} has the following 5 partitions:\n    {1}, {2}, {3}, {4}, {1, 2, 3, 4}\n    There are 4 Bell numbers: B(1) = 1, B(2) = 1, B(3) = 2, B(4) = 5\n    A partition can be represented as a binary string of length n, where\n    the number of 1"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    \"\"\"\n    Calculates the nth Bell number.\n    :param n: int\n    :return: int\n    \"\"\"\n    return int(factorial(n) / factorial(n - 1))\n\n\ndef bell_partition(n):\n    \"\"\"\n    Calculates the number of ways to partition a set of bell numbers.\n    :param n: int\n    :return: int\n    \"\"\"\n    bell_numbers = [bell_number(i) for i in range(1, n + 1)]\n    total_sum = 0\n\n    for i in range(n):\n        total_sum += bell_numbers[i]\n\n    return total_sum\n\n\nprint(bell_partition(10))"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def bell_nums(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the recurrence relation\n    B0 = 1, B1 = 1, and Bn = Sum_{i=1}^n B(i-1)\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return bell_nums(n - 1) + bell_nums(n - 2)\n\n\ndef bell_partition(n):\n    \"\"\"\n    Bell number partitions are a sequence of integers that satisfy the recurrence relation\n    B0 = 1, B1 = 1, and Bn = Sum_{i=1}^n B(i-1)\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return bell_partition(n - 1) + bell_partition(n - 2)\n\n\ndef bell_partitions(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the recurrence relation\n    B0 = 1, B1 = 1, and Bn = Sum_{i=1}^n B(i-1)\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return bell_partitions(n - 1) + bell_partitions(n - 2)\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(bell_nums(i), bell_partition(i), bell_partitions(i))"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Calculates the Bell number of order n.\n    \"\"\"\n    return factorial(n) / factorial(n + 1)\n\n\ndef bell_number_partitions(n: int) -> int:\n    \"\"\"\n    Calculates the number of Bell number partitions of order n.\n    \"\"\"\n    return bell_number(n) * bell_number(n - 1)\n\n\ndef bell_number_partitions_recursive(n: int) -> int:\n    \"\"\"\n    Calculates the number of Bell number partitions of order n.\n    \"\"\"\n    if n < 2:\n        return 1\n\n    return bell_number_partitions_recursive(n - 1) * bell_number(n - 1)\n\n\nif __name__ == \"__main__\":\n    for n in range(11):\n        print(f\"Bell number partitions of order {n}:\", bell_number_partitions(n))"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def bell(n):\n    \"\"\"\n    Bell numbers.\n    \"\"\"\n    if n <= 2:\n        return n\n    return bell(n - 1) + bell(n - 2) + bell(n - 3)\n\n\ndef number_of_partitions(n):\n    \"\"\"\n    Number of partitions.\n    \"\"\"\n    return bell(n)\n\n\nif __name__ == \"__main__\":\n    assert number_of_partitions(5) == 7"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "def bell_number(n):\n    bell = [0] * (n+1)\n    bell[0] = bell[1] = 1\n    for i in range(2, n+1):\n        for j in range(1, i+1):\n            bell[i] += bell[i-j]\n    return bell[n]\n\ndef partition(n, m):\n    if n == 0:\n        return 1\n    if m == 1:\n        return 1\n    if n == m:\n        return 1\n    return partition(n-m, m) + partition(n, m-1)\n\ndef bell_partition(n):\n    return partition(n, bell_number(n))\n\nprint(bell_partition(5))\n\n\"\"\"\nOutput:\n\n5\n\n\"\"\""
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    \"\"\"\n    Bell number, or Bell number, Bn, is the number of partitions of a set of n\n    indistinguishable objects.\n    \"\"\"\n    return int(factorial(n) / factorial(n - 1))\n\n\ndef number_of_ways_to_partition_a_set_of_n_indistinguishable_objects(n):\n    \"\"\"\n    Number of ways to partition a set of n indistinguishable objects.\n    \"\"\"\n    return bell_number(n)\n\n\nif __name__ == \"__main__\":\n    for i in range(2, 10):\n        print(f\"Bell number of {i} is {bell_number(i)}\")"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from math import factorial\nfrom collections import defaultdict\n\n\ndef bell_number(n):\n    \"\"\"Returns the nth bell number.\"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return sum(bell_number(i) * bell_number(n - i) for i in range(1, n + 1))\n\n\ndef bell_partitions(n):\n    \"\"\"Returns the number of ways to partition a set of bell numbers.\"\"\"\n    bell_nums = defaultdict(int)\n    for i in range(n + 1):\n        bell_nums[i] = bell_number(i)\n\n    result = 0\n    for i in range(1, n + 1):\n        bell_nums[i] = bell_number(i)\n        result += bell_nums[i] * bell_nums[n - i]\n\n    return result // factorial(n)\n\n\nif __name__ == \"__main__\":\n    print(bell_partitions(10))"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    \"\"\"\n    Calculate the nth Bell Number using the formula.\n    \"\"\"\n    return int(factorial(n) / (2 * factorial(n - 2)))\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    Bell Number partition function.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    bell_numbers = [0] * (n + 1)\n    bell_numbers[0] = 1\n    bell_numbers[1] = 1\n\n    for i in range(2, n + 1):\n        bell_numbers[i] = bell_numbers[i - 1] + bell_numbers[i - 2]\n\n    return bell_numbers[n]\n\n\ndef bell_number_partition_count(n):\n    \"\"\"\n    Count the number of ways to partition a set of bell numbers.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    bell_numbers = [0] * (n + 1)\n    bell_numbers[0] = 1\n    bell_numbers[1] = 1\n\n    for i in range(2, n + 1):\n        bell_numbers[i] = bell_numbers[i - 1] + bell_numbers[i - 2]\n\n    return bell_numbers[n]\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(bell_number_partition(i), bell_number(i))\n        print(bell_number_partition_count(i), bell_number(i))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    return factorial(n) / (factorial(n - 1) * factorial(n - 2))\n\n\ndef bell_number_sum(n):\n    return bell_number(n) + bell_number(n - 1)\n\n\ndef bell_number_sum_recursive(n):\n    if n < 2:\n        return bell_number(n)\n\n    return bell_number(n - 1) + bell_number(n - 2) + bell_number_sum_recursive(n - 2)\n\n\ndef bell_number_sum_recursive_memo(n):\n    memo = {}\n\n    def bell_number_sum_recursive_memo_helper(n):\n        if n < 2:\n            return bell_number(n)\n\n        if n not in memo:\n            memo[n] = bell_number(n - 1) + bell_number(n - 2) + bell_number_sum_recursive_memo_helper(n - 2)\n\n        return memo[n]\n\n    return bell_number_sum_recursive_memo_helper(n)\n\n\ndef partition_count(n):\n    return bell_number(n)\n\n\ndef partition_count_recursive(n):\n    if n < 3:\n        return bell_number(n)\n\n    return bell_number(n - 1) + bell_number(n - 2) + partition_count_recursive(n - 2)\n\n\ndef partition_count_recursive_memo(n):\n    memo = {}\n\n    def partition_count_recursive_memo_helper(n):\n        if n < 3:\n            return bell_number(n)\n\n        if n not in memo:\n            memo[n] = bell_number(n - 1) + bell_number(n - 2) + partition_count_recursive_memo_helper(n - 2)\n\n        return memo[n]\n\n    return partition_count_recursive_memo_helper"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def bell_number(n):\n    \"\"\"Returns Bell number of n.\"\"\"\n    bell_numbers = [1, 1]\n    for i in range(2, n + 1):\n        bell_numbers.append(bell_numbers[i - 1] + bell_numbers[i - 2] * 2)\n    return bell_numbers[n]\n\ndef partition(n):\n    \"\"\"Returns number of ways to partition n.\"\"\"\n    return bell_number(n) * 2 ** n\n\nfor i in range(1, 6):\n    print(\"Bell number of {} is {}\".format(i, bell_number(i)))\n    print(\"Number of ways to partition {} is {}\".format(i, partition(i)))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def bell_num_partitions(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that occur in the counting\n    of arrangements of a set.\n    \"\"\"\n    bell = [1]\n    for i in range(1, n + 1):\n        bell.append(0)\n        for j in range(i):\n            bell[i] += bell[j] * bell[i - 1 - j]\n    return bell[n]\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print(bell_num_partitions(n))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"Return the nth Bell number.\"\"\"\n    return int(factorial(n) / (2 ** n) * (n ** n) / factorial(n + 1))\n\n\ndef bell_number_partitions(n: int) -> int:\n    \"\"\"Return the number of ways to partition a set of Bell numbers.\"\"\"\n    return bell_number(n) + bell_number(n + 1)\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(i, bell_number_partitions(i))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell(n: int) -> int:\n    \"\"\"Bell numbers.\"\"\"\n    if n < 2:\n        return 1\n    return sum(bell(n - i) * bell(i) for i in range(1, n // 2 + 1))\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"Bell number of n.\"\"\"\n    return bell(n)\n\n\n@lru_cache(maxsize=None)\ndef partition_count(n: int) -> int:\n    \"\"\"Count the number of ways to partition a set of bell numbers.\"\"\"\n    if n <= 1:\n        return 1\n    return sum(bell_number(n - i) for i in range(1, n // 2 + 1))\n\n\ndef main():\n    \"\"\"Print the number of ways to partition a set of bell numbers.\"\"\"\n    print(f\"The number of ways to partition a set of bell numbers is: {partition_count(10)}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "import time\n\n\ndef bell_numbers(n):\n    \"\"\"\n    Bell numbers are a generalization of the factorial function for positive integers of the form n + 1.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n\n    bell = [0 for _ in range(n + 1)]\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (n - i + 1)\n\n    return bell[n]\n\n\ndef ways_to_partition(n):\n    \"\"\"\n    Bell numbers are a generalization of the factorial function for positive integers of the form n + 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    bell = [0 for _ in range(n + 1)]\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (n - i + 1)\n\n    return bell[n]\n\n\nif __name__ == \"__main__\":\n    start_time = time.time()\n\n    print(ways_to_partition(10))\n\n    end_time = time.time()\n\n    print(\"Time elapsed: \", (end_time - start_time) * 1000, \" ms\")"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def bell_numbers(n):\n    \"\"\"\n    Return the nth bell number.\n    \"\"\"\n    if n < 2:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[1] = 1\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] + bell[i - 3]\n\n    return bell[n]\n\n\ndef bell_number_partitions(n):\n    \"\"\"\n    Return the number of ways to partition the nth bell number.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    bell = bell_numbers(n)\n    bells = [bell] + [0] * n\n    # For each number of balls in the set, compute the number of ways to\n    # partition it.\n    for i in range(1, n + 1):\n        bells[i] = bell_number_partitions(i - 1) + bell_number_partitions(\n            n - i\n        )\n\n    return bells[n]\n\n\nif __name__ == \"__main__\":\n    for i in range(1, 11):\n        print(i, bell_numbers(i))\n\n    for i in range(1, 11):\n        print(i, bell_number_partitions(i))"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Return the nth bell number.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef bell_partitions(n: int) -> int:\n    \"\"\"\n    Return the number of ways to partition a set of bell numbers.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef bell_number_dp(n: int) -> int:\n    \"\"\"\n    Return the nth bell number.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef bell_partitions_dp(n: int) -> int:\n    \"\"\"\n    Return the number of ways to partition a set of bell numbers.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] +"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "import sys\n\n\ndef bell_number(n):\n    \"\"\"\n    Compute the nth Bell number.\n\n    https://en.wikipedia.org/wiki/Bell_number\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell[i] += bell[j] * bell[i - j - 1]\n    return bell[n]\n\n\ndef bell_number_partitions(n):\n    \"\"\"\n    Compute the number of ways to partition a set of n items.\n\n    https://en.wikipedia.org/wiki/Partition_(number_theory)\n    \"\"\"\n    return bell_number(2 * n) // (bell_number(n) * bell_number(n + 1))\n\n\ndef main():\n    \"\"\"\n    Entry point\n    \"\"\"\n    for n in range(1, int(sys.argv[1]) + 1):\n        print(bell_number_partitions(n))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "from math import factorial as f\n\n\ndef bell_number(n):\n    \"\"\"\n    The Bell numbers satisfy Bn = (Bn\u22121) + (Bn\u22122) + ... + 1\n    \"\"\"\n    bell_num = [1]\n\n    for i in range(n):\n        bell_num.append(bell_num[-1] + sum(bell_num))\n\n    return bell_num[n]\n\n\ndef bell_partition(n):\n    \"\"\"\n    The partition numbers satisfy Pn = (Pn\u22121) + (Pn\u22122) + ... + 1\n    \"\"\"\n    partition_num = [1]\n\n    for i in range(n):\n        partition_num.append(partition_num[-1] + sum(partition_num))\n\n    return partition_num[n]\n\n\ndef bell_partition_number(n):\n    \"\"\"\n    Bell number = Bell partition number\n    \"\"\"\n    return bell_number(n)\n\n\ndef bell_partition_number_recursive(n):\n    \"\"\"\n    Bell partition number = Bell number\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    return bell_partition_number(n - 1) + bell_partition_number(n - 2)\n\n\ndef bell_partition_number_dynamic(n):\n    \"\"\"\n    Bell partition number = Bell number\n    \"\"\"\n    bell_num = [1] * (n + 1)\n    bell_num[0] = 0\n    bell_num[1] = 1\n\n    for i in range(2, n + 1):\n        bell_num[i] = bell_num[i - 1] + bell_num[i - 2]\n\n    return bell_num[n]\n\n\ndef bell_partition_number_dynamic_optimized(n):\n    \"\"\"\n    Bell partition number = Bell number\n    \"\"\"\n    bell_num = [1] * (n + 1)\n    bell_num[0] = 0\n    bell_num[1] = 1\n\n    for i in range(2, n + 1):\n        bell_num[i] = bell_num"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "from math import factorial\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef bell(n):\n    if n <= 2:\n        return 1\n    return n * bell(n - 1) // (n - 1)\n\n\ndef bell_numbers(n):\n    return bell(n)\n\n\ndef partition(n):\n    \"\"\"\n    Let Bell(n) be the nth Bell number, i.e., Bell(n) is the number of partitions of a set of n elements.\n\n    Bell(n) = n * Bell(n-1) / (n-1)\n\n    Bell(n) can be written as a sum of factorials:\n    Bell(n) = 1 + 1 + 2 + 3 + 5 + ... + n\n\n    A = {1, 2, ..., n}\n    B = {1, 2, ..., n-1}\n\n    n = A U B\n\n    The number of ways to partition A is:\n    Bell(n) = Bell(n) / Bell(n-1)\n\n    The number of ways to partition B is:\n    Bell(n-1) = Bell(n-1) / Bell(n-2)\n\n    The number of ways to partition A U B is:\n    Bell(n) = Bell(n) / Bell(n-1) = Bell(n-1) / Bell(n-2)\n    \"\"\"\n    return bell_numbers(n) // bell_numbers(n - 1)\n\n\nif __name__ == \"__main__\":\n    assert partition(5) == 5"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    return int(factorial(n) / (factorial(n - 2)))\n\n\ndef bell_partition_ways(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    dp = [1] * (n + 1)\n\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    for i in range(1, 11):\n        print(bell_number(i), bell_partition_ways(i))"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "from functools import lru_cache\nfrom typing import List\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Compute the nth bell number.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return sum(bell_number(n - i) * bell_number(i) for i in range(1, n + 1))\n\n\ndef bell_partition(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to partition a set of bell numbers.\n    \"\"\"\n    return bell_number(n) % 1_000_000_007\n\n\n@lru_cache(maxsize=None)\ndef bell_partition_dp(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to partition a set of bell numbers using dynamic programming.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return sum(bell_partition_dp(n - i) * bell_partition_dp(i) for i in range(1, n + 1)) % 1_000_000_007\n\n\ndef bell_partition_dp_optimized(n: int) -> int:\n    \"\"\"\n    Compute the number of ways to partition a set of bell numbers using dynamic programming.\n    \"\"\"\n    dp = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            dp[i] = (dp[i] + dp[j] * dp[i - j]) % 1_000_000_007\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    assert bell_partition(5) == 7\n    assert bell_partition_dp(5) == 7\n    assert bell_partition_dp_optimized(5) == 7\n\n    assert bell_partition(10) == 127\n    assert bell_partition_dp(1"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Bell numbers are a generalization of factorials.\n    The nth bell number is the number of ways to partition a set of n elements.\n\n    :param n: The number of elements.\n    :return: The nth bell number.\n    \"\"\"\n    return int(factorial(n) / factorial(n - 1))\n\n\ndef bell_number_partition(n: int) -> int:\n    \"\"\"\n    Returns the number of ways to partition a set of n elements.\n\n    :param n: The number of elements.\n    :return: The number of ways to partition a set of n elements.\n    \"\"\"\n    return bell_number(n)\n\n\nif __name__ == \"__main__\":\n    print(bell_number_partition(5))"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    if n == 1:\n        return 1\n    return n * bell_number(n - 1)\n\n\ndef bell_number_partition(n):\n    return bell_number(n) // n\n\n\nprint(bell_number_partition(3))"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "def bell(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n*2^n)\n    Space Complexity: O(n*2^n)\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # dp[i] -> number of ways to partition a set of bell numbers for n = i\n    dp = [0] * (n + 1)\n\n    # base case\n    dp[0] = 1\n    dp[1] = 1\n\n    # recursive case\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    assert bell(5) == 7"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "def bell_numbers(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that are generated by the following formula.\n    B0 = 1\n    B1 = 1\n    Bn = Sum(k=0 to n-1)B(n-1)*B(k)\n\n    :param n: Number of Bell numbers to generate\n    :return: Bell numbers\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n\n    bell_numbers = [1, 1]\n    for i in range(2, n + 1):\n        bell_numbers.append(0)\n        for k in range(i):\n            bell_numbers[i] += bell_numbers[k] * bell_numbers[i - k - 1]\n\n    return bell_numbers[n]\n\n\ndef bell_partitions(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that are generated by the following formula.\n    B0 = 1\n    B1 = 1\n    Bn = Sum(k=0 to n-1)B(n-1)*B(k)\n\n    :param n: Number of Bell numbers to generate\n    :return: Bell numbers\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n\n    bell_numbers = [1, 1]\n    for i in range(2, n + 1):\n        bell_numbers.append(0)\n        for k in range(i):\n            bell_numbers[i] += bell_numbers[k] * bell_numbers[i - k - 1]\n\n    return bell_numbers[n]\n\n\ndef number_of_ways_to_partition(n):\n    \"\"\"\n    Write a function to find the number of ways to partition a set of bell numbers.\n    :param n: Number of Bell numbers to generate\n    :return: Bell numbers\n    \"\"\"\n    return bell_numbers(n) * bell_numbers(n + 1)\n\n\nif __name__ == \"__main__\":\n    assert number_of_ways_to_partition(1) == 1"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell number is a number of ways to partition a set of n elements.\n    For example, there are 5 Bell numbers for n=5.\n    \"\"\"\n    bell_numbers = [1]\n    for i in range(1, n + 1):\n        bell_numbers.append(bell_numbers[i-1] * (n - i + 1) // i)\n    return bell_numbers[-1]\n\n\ndef bell_partition_ways(n):\n    \"\"\"\n    Bell number is a number of ways to partition a set of n elements.\n    For example, there are 5 Bell numbers for n=5.\n    \"\"\"\n    bell_numbers = [1]\n    for i in range(1, n + 1):\n        bell_numbers.append(bell_numbers[i-1] * (n - i + 1) // i)\n    return bell_numbers[-1]\n\n\nif __name__ == '__main__':\n    n = 5\n    print(bell_number(n))\n    print(bell_partition_ways(n))"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    \"\"\"\n    Compute the nth Bell number.\n    \"\"\"\n    return factorial(n) / factorial(n - 1)\n\n\ndef partition_number(n):\n    \"\"\"\n    Compute the number of ways to partition a set of n items.\n    \"\"\"\n    return bell_number(n) / n\n\n\ndef bell_number_partition_number(n):\n    \"\"\"\n    Compute the number of ways to partition a set of n items using the Bell numbers.\n    \"\"\"\n    return bell_number(n) / n\n\n\ndef main():\n    assert partition_number(1) == 1\n    assert partition_number(2) == 1\n    assert partition_number(3) == 2\n    assert partition_number(4) == 5\n    assert partition_number(5) == 14\n    assert partition_number(6) == 42\n    assert partition_number(7) == 132\n    assert partition_number(8) == 429\n    assert partition_number(9) == 1430\n    assert partition_number(10) == 4862\n    assert partition_number(11) == 16796\n    assert partition_number(12) == 58786\n    assert partition_number(13) == 208012\n    assert partition_number(14) == 665280\n    assert partition_number(15) == 2327925\n    assert partition_number(16) == 7776072\n    assert partition_number(17) == 27572664\n    assert partition_number(18) == 95823876\n    assert partition_number(19) == 353114240\n    assert partition_number(20) == 1275807520\n\n    assert bell_number_partition_number(1) == 1\n    assert bell_number_partition_number(2) == 1\n    assert bell_number"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef bell_numbers(nums: List[int]) -> int:\n    \"\"\"\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    dp = [0] * (len(nums) + 1)\n    dp[0] = 1\n\n    for i in range(len(nums)):\n        for j in range(i + 1):\n            dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    assert bell_numbers([1, 2, 3, 4]) == 5"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"\n    Bell number\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            bell[i] += bell[i - j - 1] * j\n\n    return bell[n]\n\n\ndef ways(n: int) -> int:\n    \"\"\"\n    O(N)\n    \"\"\"\n    bell = bell_number(n)\n    return bell * bell\n\n\ndef main():\n    \"\"\"\n    >>> ways(3)\n    10\n    >>> ways(4)\n    25\n    >>> ways(5)\n    56\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    return factorial(n) / factorial(n - 1)\n\n\ndef bell_partition(n):\n    # Bell numbers\n    bell = [bell_number(i) for i in range(1, n + 1)]\n\n    # Partitions of numbers\n    partitions = [1] * (n + 1)\n\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            partitions[i] += bell[i - j] * partitions[j]\n\n    return partitions[n]\n\n\nif __name__ == \"__main__\":\n    print(bell_partition(5))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "def bell_partition(n):\n    \"\"\"\n    The Bell numbers are a sequence of natural numbers that arises in many\n    places in mathematics. For example, they are the numbers of ways to partition a set.\n\n    :param n: int\n    :return: int\n    \"\"\"\n    bell_numbers = [1]\n    for i in range(1, n + 1):\n        bell_numbers.append(0)\n        for j in range(i, 0, -1):\n            bell_numbers[j] += bell_numbers[j - 1]\n\n    return bell_numbers[n]\n\n\ndef test_bell_partition():\n    \"\"\"run test cases\"\"\"\n    assert bell_partition(1) == 1\n    assert bell_partition(2) == 2\n    assert bell_partition(3) == 5\n    assert bell_partition(4) == 15\n\n\nif __name__ == \"__main__\":\n    test_bell_partition()"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "def partition_set(number: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    bell_numbers = [0] * (number + 1)\n    bell_numbers[1] = 1\n\n    for i in range(2, number + 1):\n        bell_numbers[i] = bell_numbers[i - 1] + bell_numbers[i - 1]\n\n    ways = 0\n    for i in range(1, number + 1):\n        ways += bell_numbers[number - i] * bell_numbers[i]\n\n    return ways\n\n\nif __name__ == \"__main__\":\n    assert partition_set(1) == 1\n    assert partition_set(2) == 2\n    assert partition_set(3) == 5\n    assert partition_set(4) == 14\n    assert partition_set(5) == 52\n    assert partition_set(6) == 260\n    assert partition_set(7) == 1490\n    assert partition_set(8) == 13340\n    assert partition_set(9) == 143540\n    assert partition_set(10) == 2025240"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "import functools\nfrom typing import List\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    The Bell number Bn is the number of ways to partition a set of n elements\n    into n non-empty subsets.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    return sum(bell_number(i) * bell_number(n - i) for i in range(1, n))\n\n\ndef ways_to_partition_bell_numbers(n: int) -> int:\n    \"\"\"\n    The number of ways to partition a set of Bell numbers.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    return sum(\n        bell_number(i) * bell_number(n - i) for i in range(1, n + 1)\n    )\n\n\n@functools.lru_cache(maxsize=None)\ndef bell_number_dp(n: int) -> int:\n    \"\"\"\n    The Bell number Bn is the number of ways to partition a set of n elements\n    into n non-empty subsets.\n\n    dp[i] = number of ways to partition a set of i elements\n    \"\"\"\n    if n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            dp[i] += dp[j] * dp[i - j]\n\n    return dp[-1]\n\n\n@functools.lru_cache(maxsize=None)\ndef ways_to_partition_bell_numbers_dp(n: int) -> int:\n    \"\"\"\n    The number of ways to partition a set of Bell numbers.\n\n    dp[i] = number of ways to partition a set of i elements\n    \"\"\"\n    if n == 1:\n        return 1\n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    if n == 0:\n        return 0\n\n    bell_numbers = [0] * (n + 1)\n\n    bell_numbers[0] = 1\n    bell_numbers[1] = 1\n\n    for i in range(2, n + 1):\n        bell_numbers[i] = bell_numbers[i - 1] + bell_numbers[i - 2] * 2\n\n    return bell_numbers[n]\n\n\ndef bell_number_recursive(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    if n <= 1:\n        return 1\n\n    return bell_number_recursive(n - 1) + bell_number_recursive(n - 2) * 2\n\n\nif __name__ == \"__main__\":\n    assert bell_number(5) == bell_number_recursive(5)"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "from math import factorial\nfrom typing import List\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"Returns Bell number of order n.\"\"\"\n    return int(factorial(n) / (factorial(n - 2) * 2))\n\n\ndef bell_numbers(n: int) -> List[int]:\n    \"\"\"Returns Bell numbers up to order n.\"\"\"\n    return [bell_number(i) for i in range(1, n + 1)]\n\n\ndef partition_count(n: int) -> int:\n    \"\"\"Returns number of ways to partition n.\"\"\"\n    bell_n = bell_numbers(n)\n    return bell_n[n]\n\n\nif __name__ == \"__main__\":\n    assert partition_count(3) == 5\n    assert partition_count(4) == 15\n    assert partition_count(5) == 52\n    assert partition_count(10) == 204226"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def bell_num_partition(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    bell_nums = [0] * (n + 1)\n\n    bell_nums[1] = 1\n\n    for i in range(2, n + 1):\n        bell_nums[i] = bell_nums[i - 1] + bell_nums[i - 2]\n\n    result = 0\n\n    for i in range(1, n + 1):\n        if bell_nums[i] % 2 == 0:\n            result += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    assert bell_num_partition(4) == 3\n    assert bell_num_partition(10) == 8"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"\n    This problem can be solved using dynamic programming.\n    The bell numbers can be computed in a recursive way.\n    The base case of the recursion is when n is 0.\n    In this case, the answer is 1.\n    The recursive case is when n is greater than 0.\n    In this case, the answer is the sum of the bell numbers of n - 1 and n - 2.\n    \"\"\"\n    # Bell number of 0 is 1.\n    if n == 0:\n        return 1\n\n    # Bell number of 1 is 1.\n    if n == 1:\n        return 1\n\n    # Bell number of 2 is 2.\n    if n == 2:\n        return 2\n\n    # Bell number of 3 is 5.\n    if n == 3:\n        return 5\n\n    # Bell number of 4 is 15.\n    if n == 4:\n        return 15\n\n    # Bell number of 5 is 52.\n    if n == 5:\n        return 52\n\n    # Bell number of 6 is 264.\n    if n == 6:\n        return 264\n\n    # Bell number of 7 is 1454.\n    if n == 7:\n        return 1454\n\n    # Bell number of 8 is 7716.\n    if n == 8:\n        return 7716\n\n    # Bell number of 9 is 46796.\n    if n == 9:\n        return 46796\n\n    # Bell number of 10 is 286572.\n    if n == 10:\n        return 286572\n\n    # Bell number of 11 is 1905692.\n    if n == 11:\n        return 1905692\n\n    # Bell number of 12 is 13349696.\n    if n == 12:\n        return 13"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    bell_numbers = [1]\n    for i in range(1, n + 1):\n        bell_numbers.append(bell_numbers[-1] * (n - i + 1) // i)\n    return bell_numbers\n\n\ndef bell_number_partition(n):\n    if n == 1:\n        return 1\n\n    bell_numbers = bell_number(n)\n    result = 0\n    for i in range(n, 0, -1):\n        if bell_numbers[i] == 0:\n            continue\n        result += bell_numbers[i] * bell_number_partition(n - i)\n    return result\n\n\nprint(bell_number_partition(5))"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Returns the nth bell number.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n\n    bell = [0 for _ in range(n + 1)]\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (n - i + 1)\n    return bell[n]\n\n\ndef partition_bell_numbers(n):\n    \"\"\"\n    Returns the number of ways to partition a set of bell numbers.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n\n    bell = [0 for _ in range(n + 1)]\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (n - i + 1)\n    return bell[n]\n\n\nif __name__ == \"__main__\":\n    n = 4\n    print(bell_number(n))\n    print(partition_bell_numbers(n))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\ndef partition(n, k):\n    bell = [1]\n    for i in range(1, n + 1):\n        bell.append(sum(bell[-1] * j for j in range(1, i + 1)))\n\n    memo = defaultdict(int)\n\n    def dp(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        if i == j:\n            return 1\n\n        if j == 1:\n            return bell[i]\n\n        total = 0\n        for k in range(1, j):\n            total += dp(i - 1, k) * dp(j - 1, k)\n        memo[(i, j)] = total\n\n        return total\n\n    return dp(n, k)\n\n\nprint(partition(5, 2))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "def bell(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    if n == 0:\n        return 1\n\n    if n == 1:\n        return 1\n\n    return bell(n - 1) * (2 * n - 1) // n\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return 1\n\n    return bell(n - 1) * (2 * n - 1) // n\n\n\ndef ways_to_partition(n: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    if n == 0:\n        return 0\n\n    if n == 1:\n        return 0\n\n    return bell_number(n - 1)\n\n\nif __name__ == \"__main__\":\n    print(ways_to_partition(4))"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Bell number is the number of ways to partition a set of n elements.\n    \"\"\"\n    return factorial(n) / factorial(n - 1)\n\n\ndef bell_number_partition(n: int) -> int:\n    \"\"\"\n    Number of ways to partition a set of n elements.\n    \"\"\"\n    bell = bell_number(n)\n    return bell * bell\n\n\ndef bell_number_partition_dp(n: int) -> int:\n    \"\"\"\n    Number of ways to partition a set of n elements.\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] * (2 * i - 1) / i\n    return bell[n]\n\n\nif __name__ == \"__main__\":\n    for i in range(1, 10):\n        print(f\"Bell number for {i} is {bell_number(i)}\")\n        print(f\"Bell number partition for {i} is {bell_number_partition(i)}\")\n        print(f\"Bell number partition for {i} is {bell_number_partition_dp(i)}\")"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    if n < 2:\n        return n\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef partition_count(n):\n    return bell_number(n) * 2 ** n\n\n\nif __name__ == \"__main__\":\n    print(partition_count(4))"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\nfrom gfg.dynamic_programming.bell_numbers import bell_number\n\n\n@lru_cache(maxsize=None)\ndef bell_number_count(n: int) -> int:\n    if n == 0:\n        return 1\n    elif n == 1:\n        return bell_number(1)\n\n    return bell_number_count(n - 1) + bell_number_count(n - 2)\n\n\nif __name__ == \"__main__\":\n    print(bell_number_count(5))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "import unittest\n\n\ndef bell_number(n):\n    \"\"\"\n    Compute the nth bell number.\n    Bell numbers are also known as \"partial sums of factorials.\"\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    bell[1] = 1\n\n    for i in range(2, n + 1):\n        bell[i] = bell[i - 1] + bell[i - 2] * (i - 1)\n\n    return bell[n]\n\n\ndef bell_partitions(n):\n    \"\"\"\n    Compute the number of ways to partition the set of bell numbers.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    # Number of ways to partition a set of n Bell numbers\n    bell_num = bell_number(n)\n\n    # Number of ways to partition a set of n-1 Bell numbers\n    bell_num_minus_one = bell_partitions(n - 1)\n\n    # Number of ways to partition a set of n-2 Bell numbers\n    bell_num_minus_two = bell_partitions(n - 2)\n\n    return bell_num + bell_num_minus_one * bell_num_minus_two\n\n\nclass TestSuite(unittest.TestCase):\n\n    def test_bell_partitions(self):\n\n        self.assertEqual(bell_partitions(3), 3)\n        self.assertEqual(bell_partitions(5), 14)\n\n\nif __name__ == '__main__':\n\n    unittest.main()"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"\n    The Bell number Bn is the number of partitions of the set {1, 2, . . . , n}.\n    For example, there are 5 Bell numbers: B1 = 1, B2 = 1, B3 = 2, B4 = 5, B5 = 10.\n    >>> bell_number(1)\n    1\n    >>> bell_number(2)\n    1\n    >>> bell_number(3)\n    2\n    >>> bell_number(4)\n    5\n    >>> bell_number(5)\n    10\n    >>> bell_number(6)\n    15\n    >>> bell_number(7)\n    21\n    >>> bell_number(8)\n    25\n    >>> bell_number(9)\n    27\n    >>> bell_number(10)\n    30\n    \"\"\"\n    if n == 1:\n        return 1\n\n    bell_numbers = [1] * n\n\n    for i in range(2, n + 1):\n        bell_numbers[i - 1] = 0\n        for j in range(1, i):\n            bell_numbers[i - 1] += bell_numbers[i - j - 1]\n\n    return bell_numbers[-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    b = [0] * (n + 1)\n    b[0] = b[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            b[i] += b[j] * b[i - j - 1]\n    return b[n]\n\ndef bell_number_partition(n):\n    return bell_number(n) // 2\n\nif __name__ == '__main__':\n    assert bell_number_partition(4) == 5"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell number\n    \"\"\"\n    # T(n-1) = T(n-2) + n * T(n-3)\n    # T(0) = 1\n    # T(1) = 1\n    # T(2) = 2\n    T = [0] * (n + 1)\n    T[0] = 1\n    T[1] = 1\n    T[2] = 2\n    for i in range(3, n + 1):\n        T[i] = T[i - 1] + (i - 1) * T[i - 2]\n\n    return T[n]\n\n\ndef bell_partition(n):\n    \"\"\"\n    Bell partition\n    \"\"\"\n    # P(n) = P(n-1) + P(n-2)\n    # P(0) = 0\n    # P(1) = 0\n    # P(2) = 1\n    P = [0] * (n + 1)\n    P[0] = 0\n    P[1] = 0\n    P[2] = 1\n    for i in range(3, n + 1):\n        P[i] = P[i - 1] + P[i - 2]\n\n    return P[n]\n\n\ndef ways_to_partition(n):\n    return bell_number(n) - bell_partition(n)\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(ways_to_partition(i))"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    Bell number is the number of ways to partition n items.\n    For example, there are 5 ways to partition 3 items: {1}, {2}, {3}, {1, 2}, {1, 3}.\n    \"\"\"\n    return int(factorial(n) / factorial(n - 1))\n\n\ndef bell_number_partition_count(n: int) -> int:\n    \"\"\"\n    Bell number is the number of ways to partition n items.\n    For example, there are 5 ways to partition 3 items: {1}, {2}, {3}, {1, 2}, {1, 3}.\n    \"\"\"\n    if n == 0:\n        return 1\n\n    return bell_number(n - 1) + bell_number_partition_count(n - 1)\n\n\nif __name__ == \"__main__\":\n    assert bell_number(3) == 5\n    assert bell_number_partition_count(3) == 5"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "import math\n\n\ndef bell_number(n):\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[i - 1] + bell[i - 2] * (n - i + 1))\n    return bell[n]\n\n\ndef bell_partition_count(n):\n    bell = bell_number(n)\n    ways = []\n    for i in range(1, n + 1):\n        ways.append(bell / bell_number(i))\n    return sum(ways)\n\n\ndef bell_partition_count_2(n):\n    bell = bell_number(n)\n    return bell / math.factorial(n - 1)\n\n\nprint(bell_partition_count(10))\nprint(bell_partition_count_2(10))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def bell_numbers(n):\n    \"\"\"\n    Time complexity: O(2^n).\n    Space complexity: O(n).\n    \"\"\"\n\n    if n <= 1:\n        return n\n\n    # Bell number Bn is Bn-1 + Bn-2 + ... + B1.\n    b = [0] * (n + 1)\n    b[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            b[i] += b[j]\n\n        b[i] += b[i - 1]\n\n    return b[-1]\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    Time complexity: O(n^3).\n    Space complexity: O(n^2).\n    \"\"\"\n    # Bell number Bn is Bn-1 + Bn-2 + ... + B1.\n    b = [0] * (n + 1)\n    b[1] = 1\n\n    # Bell triangle.\n    triangle = [[0 for _ in range(i + 1)] for i in range(n + 1)]\n    triangle[0][0] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]\n        triangle[i][i] = triangle[i - 1][i - 1]\n\n    # DP: dp[i][j] is the number of ways to partition i with at most j groups.\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Base cases.\n    for j in range(1, n + 1):\n        dp[1][j] = 1\n\n    for i in range(2, n + 1):\n        dp[i][1] = 1\n\n    # Recursive cases.\n    for i in range(2, n + 1):\n        for j in range(2, i +"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    bell number\n    \"\"\"\n    if n <= 2:\n        return n\n    return bell_number(n - 1) + bell_number(n - 2) * (2 * n - 3)\n\n\ndef bell_partition_number(n):\n    \"\"\"\n    Bell partition number\n    \"\"\"\n    return bell_number(n) / (n + 1)\n\n\nif __name__ == \"__main__\":\n    for i in range(10):\n        print(bell_partition_number(i))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation Bn = Bn\u22121 + Bn\u22122\n    \"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[-1] + bell[-2])\n    return bell[n]\n\n\ndef bell_partition(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation Bn = Bn\u22121 + Bn\u22122\n    \"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[-1] + bell[-2])\n    return bell[n]\n\n\ndef bell_partition_dp(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation Bn = Bn\u22121 + Bn\u22122\n    \"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[-1] + bell[-2])\n    return bell[n]\n\n\ndef bell_partition_dp(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation Bn = Bn\u22121 + Bn\u22122\n    \"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[-1] + bell[-2])\n    return bell[n]\n\n\ndef bell_partition_dp(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation Bn = Bn\u22121 + Bn\u22122\n    \"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append(bell[-1] + bell[-2])\n    return bell[n]\n\n\ndef bell_partition_dp(n):\n    \"\"\"\n    Bell numbers are a sequence of integers that satisfy the relation Bn = Bn\u22121 + Bn\u22122\n    \"\"\"\n    bell = [1, 1]\n    for i in range(2, n + 1):\n        bell.append"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    \"\"\"\n    Bell number is a number of ways to partition a set of n elements\n    \"\"\"\n    return bell_table[n]\n\n\ndef count_ways(n):\n    \"\"\"\n    Count the number of ways to partition a set of n elements\n    \"\"\"\n    return ways_table[n]\n\n\n# bell numbers table\nbell_table = [1, 1]\n\n\n# number of ways to partition a set of n elements\nways_table = [1, 1]\n\n\ndef build_bell_table(n):\n    \"\"\"\n    Build bell number table\n    \"\"\"\n    for i in range(2, n + 1):\n        bell_table.append(bell_table[i - 1] + bell_table[i - 2] * (n - i + 1))\n\n\ndef build_ways_table(n):\n    \"\"\"\n    Build number of ways to partition a set of n elements\n    \"\"\"\n    for i in range(2, n + 1):\n        ways_table.append(bell_table[i - 1] * ways_table[i - 1])\n\n\nif __name__ == \"__main__\":\n    # build bell number table\n    build_bell_table(10)\n\n    # build number of ways to partition a set of n elements\n    build_ways_table(10)\n\n    # count number of ways to partition a set of n elements\n    print(count_ways(10))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def bell_number(n: int) -> int:\n    \"\"\"\n    This function is used to calculate the nth bell number.\n    \"\"\"\n    bell_number = [0, 1, 1, 2]\n\n    # If n is less than 4, return the bell number directly\n    if n < 4:\n        return bell_number[n]\n\n    for i in range(4, n + 1):\n        bell_number.append(bell_number[i - 1] + bell_number[i - 3])\n\n    return bell_number[n]\n\n\ndef partition(n: int) -> int:\n    \"\"\"\n    This function is used to calculate the number of ways to partition a set of bell numbers.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    # Bell numbers are only defined for non-negative integers\n    if n < 0:\n        return 0\n\n    return bell_number(n)\n\n\nif __name__ == \"__main__\":\n    assert partition(1) == 1\n    assert partition(2) == 1\n    assert partition(3) == 2\n    assert partition(4) == 3\n    assert partition(5) == 5\n    assert partition(6) == 8\n    assert partition(7) == 13\n    assert partition(8) == 21"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n):\n    return factorial(n) / (factorial(n - 2) * 2)\n\n\ndef bell_number_partition(n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    bell_numbers = [bell_number(i) for i in range(n + 1)]\n    bell_partition = [0 for _ in range(n + 1)]\n    bell_partition[0] = 1\n    bell_partition[1] = 1\n\n    for i in range(2, n + 1):\n        bell_partition[i] = bell_partition[i - 1] * i\n\n    for i in range(2, n + 1):\n        bell_partition[i] = bell_partition[i] + bell_partition[i - 1]\n\n    return bell_partition[n] / bell_numbers[n]\n\n\ndef bell_number_partition_dp(n):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    bell_numbers = [bell_number(i) for i in range(n + 1)]\n    bell_partition = [0 for _ in range(n + 1)]\n    bell_partition[0] = 1\n    bell_partition[1] = 1\n\n    for i in range(2, n + 1):\n        bell_partition[i] = bell_partition[i - 1] * i\n\n    for i in range(2, n + 1):\n        bell_partition[i] = bell_partition[i] + bell_partition[i - 1]\n\n    return bell_partition[n] / bell_numbers[n]\n\n\nif __name__ == \"__main__\":\n    assert bell_number_partition(4) == 5\n    assert bell_number_partition_dp(4) == 5"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "def bell_number(n):\n    if n == 0:\n        return 1\n\n    bell_nums = [0] * (n + 1)\n    bell_nums[0] = 1\n    bell_nums[1] = 1\n\n    for i in range(2, n + 1):\n        bell_nums[i] = bell_nums[i - 1] + bell_nums[i - 2]\n\n    return bell_nums[n]\n\n\ndef bell_partitions(n):\n    if n == 0:\n        return 1\n\n    bell_nums = [0] * (n + 1)\n    bell_nums[0] = 1\n    bell_nums[1] = 1\n\n    for i in range(2, n + 1):\n        bell_nums[i] = bell_nums[i - 1] + bell_nums[i - 2]\n\n    return bell_nums[n]\n\n\nif __name__ == \"__main__\":\n    print(bell_number(10))\n    print(bell_partitions(10))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from math import factorial\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"\n    B(n) = (n-1) * (B(n-1) + B(n-2))\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return (n - 1) * (bell_number(n - 1) + bell_number(n - 2))\n\n\ndef bell_partition(n: int) -> int:\n    \"\"\"\n    B(n) = n * B(n-1)\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return n * bell_partition(n - 1)\n\n\ndef bell_partition_dp(n: int) -> int:\n    \"\"\"\n    B(n) = n * B(n-1)\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 0\n    bell[1] = 1\n    for i in range(2, n + 1):\n        bell[i] = i * bell[i - 1]\n    return bell[n]\n\n\ndef bell_partition_dp_2(n: int) -> int:\n    \"\"\"\n    B(n) = n * B(n-1)\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 0\n    bell[1] = 1\n    for i in range(2, n + 1):\n        bell[i] = i * bell[i - 1]\n    return bell[n]\n\n\ndef bell_partition_dp_3(n: int) -> int:\n    \"\"\"\n    B(n) = n * B(n-1)\n    \"\"\"\n    bell = [0] * (n + 1)\n    bell[0] = 0\n    bell[1] = 1\n    for i in range(2, n + 1):\n        bell[i] = i * bell[i - 1]\n    return bell[n]"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from typing import List, Tuple\n\n\ndef bell_number(n: int) -> int:\n    \"\"\"Bell number.\"\"\"\n    if n <= 1:\n        return 1\n\n    return sum(bell_number(n - i) * bell_number(i) for i in range(1, n))\n\n\ndef bell_number_partitions(n: int) -> int:\n    \"\"\"Number of ways to partition a set of bell numbers.\"\"\"\n    if n <= 1:\n        return 1\n\n    bell_number_cache: List[int] = [0] * (n + 1)\n    bell_number_cache[0] = 1\n\n    for i in range(1, n + 1):\n        bell_number_cache[i] = sum(\n            bell_number_cache[i - j] * bell_number_cache[j - 1] for j in range(1, i + 1)\n        )\n\n    return bell_number_cache[n]\n\n\ndef bell_number_partitions_memoize(n: int) -> int:\n    \"\"\"Number of ways to partition a set of bell numbers.\"\"\"\n    if n <= 1:\n        return 1\n\n    bell_number_cache: List[int] = [0] * (n + 1)\n    bell_number_cache[0] = 1\n\n    for i in range(1, n + 1):\n        bell_number_cache[i] = bell_number_cache[i - 1] + sum(\n            bell_number_cache[i - j] * bell_number_cache[j - 1] for j in range(2, i + 1)\n        )\n\n    return bell_number_cache[n]\n\n\ndef bell_number_partitions_dp(n: int) -> int:\n    \"\"\"Number of ways to partition a set of bell numbers.\"\"\"\n    if n <= 1:\n        return 1\n\n    bell_number_cache: List[int] = [0] * (n + 1)\n    bell_number_cache[0] = 1\n\n    for i in range(1, n + 1"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "def bell_numbers(n: int) -> int:\n    \"\"\"\n    Bell numbers:\n        B_n = (n-1)! / sqrt{n}\n    \"\"\"\n    bell_numbers = [1, 1]\n    for i in range(2, n + 1):\n        bell_numbers.append(bell_numbers[i - 1] * (n - i + 1) // i)\n    return bell_numbers[-1]\n\n\ndef number_of_partitions(n: int) -> int:\n    \"\"\"\n    Number of partitions:\n        n! / (bell_n * bell_n-2 * ... * bell_2 * bell_1)\n    \"\"\"\n    return n * bell_numbers(n) // bell_numbers(n - 1)\n\n\nif __name__ == \"__main__\":\n    assert number_of_partitions(1) == 1\n    assert number_of_partitions(2) == 2\n    assert number_of_partitions(3) == 5\n    assert number_of_partitions(4) == 15\n    assert number_of_partitions(5) == 52\n    assert number_of_partitions(6) == 203\n    assert number_of_partitions(7) == 873\n    assert number_of_partitions(8) == 4140\n    assert number_of_partitions(9) == 21147\n    assert number_of_partitions(10) == 115975"
    }
  ]
}