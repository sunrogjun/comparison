{
  "timestamp": "2025-09-15T01:02:18.210061",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 361,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def heap_sort(arr):\n    # create a heap\n    for i in range(len(arr)):\n        heapify(arr, i)\n\n    # extract elements one by one\n    for i in range(len(arr) - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, 0)\n\n\ndef heapify(arr, i):\n    # find largest among root and children\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < len(arr) and arr[largest] < arr[left]:\n        largest = left\n    if right < len(arr) and arr[largest] < arr[right]:\n        largest = right\n\n    # if root is not largest, swap with largest and continue heapifying\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, largest)\n\n\ndef main():\n    arr = [3, 7, 4, 6, 1, 0, 9, 8, 9, 4]\n    heap_sort(arr)\n    print(arr)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    for element in arr:\n        heappush(heap, element)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    heapify(heap)\n    for i in range(len(arr)):\n        heappush(heap, arr[i])\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\ndef main():\n    arr = [12, 11, 13, 5, 6, 7]\n    result = heap_sort(arr)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "def heap_sort(input_list: list) -> list:\n    \"\"\"\n    Input:\n    - A list of elements\n    Output:\n    - A list of elements in ascending order\n    \"\"\"\n    heap = list(input_list)\n    heapify(heap)\n\n    for i in range(len(heap) - 1, 0, -1):\n        heap[i], heap[0] = heap[0], heap[i]\n        heapify(heap, i)\n    return heap\n\n\ndef heapify(heap: list, i=0):\n    left = 2 * i + 1\n    right = 2 * i + 2\n    largest = i\n\n    if left < len(heap) and heap[largest] < heap[left]:\n        largest = left\n    if right < len(heap) and heap[largest] < heap[right]:\n        largest = right\n    if largest != i:\n        heap[i], heap[largest] = heap[largest], heap[i]\n        heapify(heap, largest)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(arr):\n    heapify(arr)\n    return [heappop(arr) for _ in range(len(arr))]\n\n\ndef main():\n    arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    result = heap_sort(arr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from gfg.queues.priority_queue import PriorityQueue\n\n\ndef heap_sort(items: list) -> list:\n    queue = PriorityQueue()\n\n    for item in items:\n        queue.enqueue(item)\n\n    result = []\n\n    while not queue.is_empty():\n        result.append(queue.dequeue())\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 5, 8, 2, 9, 26, 1, 4, 3]))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(nums: list) -> list:\n    \"\"\"Returns the sorted list using heap queue algorithm.\n\n    Args:\n        nums (list): list of elements to be sorted\n\n    Examples:\n        >>> heap_sort([4, 2, 3, 1, 5])\n        [1, 2, 3, 4, 5]\n\n    Returns:\n        list: sorted list\n    \"\"\"\n    if not nums:\n        return nums\n\n    heapify(nums)\n\n    result = []\n    while nums:\n        result.append(heappop(nums))\n\n    return result\n\n\ndef heap_sort_2(nums: list) -> list:\n    \"\"\"Returns the sorted list using heap queue algorithm.\n\n    Args:\n        nums (list): list of elements to be sorted\n\n    Examples:\n        >>> heap_sort_2([4, 2, 3, 1, 5])\n        [1, 2, 3, 4, 5]\n\n    Returns:\n        list: sorted list\n    \"\"\"\n    if not nums:\n        return nums\n\n    heap = []\n    for num in nums:\n        heappush(heap, num)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([4, 2, 3, 1, 5]))\n    print(heap_sort_2([4, 2, 3, 1, 5]))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from heap import Heap\n\n\ndef heap_sort(arr):\n    heap = Heap()\n    heap.build_heap(arr)\n    for i in range(len(arr)-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heap.heap_size -= 1\n        heap.heapify(0)\n    return arr\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([3, 1, 6, 0, 2, 5, 4]))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(input_list):\n    # Create a heap queue\n    heap = []\n\n    # Iterate over the input list and add each element to the heap queue\n    for element in input_list:\n        heappush(heap, element)\n\n    # Now, empty the heap queue into the input list\n    for i in range(len(input_list)):\n        input_list[i] = heappop(heap)\n\n    return input_list\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 5, 3, 10, 9, 8, 4, 7, 6]))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    heapify(heap)\n    for i in range(len(arr)):\n        heappush(heap, arr[i])\n    for i in range(len(arr)):\n        arr[i] = heappop(heap)\n    return arr\n\n\ndef main():\n    arr = [3, 2, 1, 4, 5]\n    print(f\"Array before sorting: {arr}\")\n    arr = heap_sort(arr)\n    print(f\"Array after sorting: {arr}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def heap_sort(elements):\n    heap = Heap(elements)\n    heap.heapify()\n    return [heap.remove() for _ in range(heap.size)]\n\n\nclass Heap:\n\n    def __init__(self, elements):\n        self.size = len(elements)\n        self.elements = elements\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def max_heapify(self, i):\n        l = self.left_child(i)\n        r = self.right_child(i)\n        largest = i\n        if l < self.size and self.elements[l] > self.elements[largest]:\n            largest = l\n        if r < self.size and self.elements[r] > self.elements[largest]:\n            largest = r\n        if largest != i:\n            self.elements[i], self.elements[largest] = self.elements[largest], self.elements[i]\n            self.max_heapify(largest)\n\n    def build_max_heap(self):\n        for i in range(self.size // 2, -1, -1):\n            self.max_heapify(i)\n\n    def heapify(self):\n        self.build_max_heap()\n\n    def remove(self):\n        if self.size < 1:\n            raise Exception(\"Heap underflow\")\n        self.elements[0], self.elements[self.size - 1] = self.elements[self.size - 1], self.elements[0]\n        element = self.elements.pop()\n        self.size -= 1\n        self.max_heapify(0)\n        return element\n\n\ndef main():\n    print(heap_sort([3, 4, 9, 2, 10, 12, 1, 8, 5, 16, 7, 11]))"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef sort(list_):\n    \"\"\"\n    >>> sort([5, 3, 6, 2, 10])\n    [2, 3, 5, 6, 10]\n\n    >>> sort([])\n    []\n\n    >>> sort([-5, -3, -6, -2, -10])\n    [-10, -6, -3, -5, -2]\n    \"\"\"\n    if not list_:\n        return []\n\n    heapify(list_)\n\n    sorted_list = []\n\n    while list_:\n        sorted_list.insert(0, heappop(list_))\n\n    return sorted_list\n\n\ndef sort_2(list_):\n    \"\"\"\n    >>> sort_2([5, 3, 6, 2, 10])\n    [2, 3, 5, 6, 10]\n\n    >>> sort_2([])\n    []\n\n    >>> sort_2([-5, -3, -6, -2, -10])\n    [-10, -6, -3, -5, -2]\n    \"\"\"\n    if not list_:\n        return []\n\n    sorted_list = []\n\n    while list_:\n        current_min = min(list_)\n        list_.remove(current_min)\n        sorted_list.insert(0, current_min)\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def heap_sort(elements):\n    \"\"\"\n    Time complexity: O(n*log(n)).\n    Space complexity: O(1).\n    \"\"\"\n    def heapify(elements, heap_size, root_index):\n        largest = root_index\n        left_child = (2 * root_index) + 1\n        right_child = (2 * root_index) + 2\n\n        if left_child < heap_size and elements[left_child] > elements[largest]:\n            largest = left_child\n\n        if right_child < heap_size and elements[right_child] > elements[largest]:\n            largest = right_child\n\n        if largest != root_index:\n            elements[root_index], elements[largest] = elements[largest], elements[root_index]\n            heapify(elements, heap_size, largest)\n\n    n = len(elements)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(elements, n, i)\n\n    for i in range(n - 1, 0, -1):\n        elements[i], elements[0] = elements[0], elements[i]\n        heapify(elements, i, 0)\n\n\ndef main():\n    elements = [10, 4, 9, 3, 5, 8, 2, 7, 1, 6]\n    heap_sort(elements)\n    print(elements)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def heap_sort(arr):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(1)\n    \"\"\"\n    heapify(arr)\n\n    for i in range(len(arr) - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapsort(arr, 0, i)\n\n    return arr\n\n\ndef heapify(arr):\n    for i in range(len(arr) // 2, -1, -1):\n        heapsort(arr, i, len(arr))\n\n\ndef heapsort(arr, i, end):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < end and arr[largest] < arr[left]:\n        largest = left\n\n    if right < end and arr[largest] < arr[right]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapsort(arr, largest, end)"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\ndef heap_sort(elements):\n    heap = []\n    heapify(heap)\n\n    for i in range(len(elements)):\n        heappush(heap, elements[i])\n\n    for i in range(len(elements)):\n        elements[i] = heappop(heap)\n\n    return elements\n\nif __name__ == \"__main__\":\n    elements = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(\"Sorted elements using heap queue algorithm: \" + str(heap_sort(elements)))"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def heap_sort(input_list):\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    Space Complexity: O(1)\n\n    :param input_list: List - a list of integers to be sorted\n    :return: List - a list of integers sorted in ascending order\n    \"\"\"\n    def heapify(input_list, heap_size, root_index):\n        largest = root_index\n        left_child = (2 * root_index) + 1\n        right_child = (2 * root_index) + 2\n\n        if left_child < heap_size and input_list[left_child] > input_list[largest]:\n            largest = left_child\n\n        if right_child < heap_size and input_list[right_child] > input_list[largest]:\n            largest = right_child\n\n        if largest != root_index:\n            input_list[root_index], input_list[largest] = input_list[largest], input_list[root_index]\n            heapify(input_list, heap_size, largest)\n\n    n = len(input_list)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(input_list, n, i)\n\n    for i in range(n - 1, 0, -1):\n        input_list[i], input_list[0] = input_list[0], input_list[i]\n        heapify(input_list, i, 0)\n\n    return input_list\n\n\ndef main():\n    print(\"List sorted using heap sort algorithm: \" + str(heap_sort([34, 56, 23, 12, 89, 11])))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "from heap_queue import HeapQueue\n\n\ndef heap_sort(lst):\n    heap = HeapQueue()\n    for num in lst:\n        heap.add(num)\n    for i in range(len(lst)):\n        lst[i] = heap.remove()\n    return lst\n\n\nif __name__ == \"__main__\":\n    lst = [5, 2, 1, 8, 7, 9, 5, 10, 3, 6]\n    print(heap_sort(lst))"
    },
    {
      "rank": 18,
      "score": 9.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef sort_ascending_heap_queue(l):\n    heap = list(l)\n    heapify(heap)\n\n    for i in range(len(heap)):\n        heap[0], heap[-(i+1)] = heap[-(i+1)], heap[0]\n        heappop(heap)\n\n    return heap\n\n\ndef main():\n    l = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(sort_ascending_heap_queue(l))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 19,
      "score": 9.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(nums: list) -> list:\n    \"\"\"Returns the sorted list.\n\n    >>> heap_sort([5, 3, 6, 2, 10])\n    [2, 3, 5, 6, 10]\n\n    >>> heap_sort([])\n    []\n\n    >>> heap_sort([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(nums) == 0:\n        return []\n\n    heapify(nums)\n\n    sorted_list = []\n\n    while len(nums) > 0:\n        sorted_list.append(heappop(nums))\n\n    return sorted_list\n\n\ndef heap_sort_optimized(nums: list) -> list:\n    \"\"\"Returns the sorted list.\n\n    >>> heap_sort_optimized([5, 3, 6, 2, 10])\n    [2, 3, 5, 6, 10]\n\n    >>> heap_sort_optimized([])\n    []\n\n    >>> heap_sort_optimized([-2, -5, -45])\n    [-45, -5, -2]\n    \"\"\"\n    if len(nums) == 0:\n        return []\n\n    sorted_list = []\n\n    for num in nums:\n        heappush(sorted_list, num)\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([5, 3, 6, 2, 10]))\n    print(heap_sort([]))\n    print(heap_sort([-2, -5, -45]))\n\n    print(heap_sort_optimized([5, 3, 6, 2, 10]))\n    print(heap_sort_optimized([]))\n    print(heap_sort_optimized([-2, -5, -45]))"
    },
    {
      "rank": 20,
      "score": 9.0,
      "candidate": "from heap import Heap\n\n\ndef heap_sort(arr):\n    heap = Heap()\n    for i in arr:\n        heap.push(i)\n    for i in range(len(arr)):\n        arr[i] = heap.pop()\n\n\nif __name__ == \"__main__\":\n    array = [4, 5, 6, 1, 2, 3]\n    print(array)\n    heap_sort(array)\n    print(array)"
    },
    {
      "rank": 21,
      "score": 9.0,
      "candidate": "def heap_sort(input_list):\n    \"\"\"\n    Sorts the given list in ascending order using heap queue algorithm.\n\n    :param input_list: list to be sorted\n    :return: sorted list\n\n    >>> heap_sort([])\n    []\n\n    >>> heap_sort([-1, -5, -10])\n    [-10, -5, -1]\n\n    >>> heap_sort([-2, 1, -1, 4, -5])\n    [-5, -2, -1, 1, 4]\n    \"\"\"\n    def heapify(input_list, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and input_list[i] < input_list[left]:\n            largest = left\n\n        if right < n and input_list[largest] < input_list[right]:\n            largest = right\n\n        if largest != i:\n            input_list[i], input_list[largest] = input_list[largest], input_list[i]\n            heapify(input_list, n, largest)\n\n    n = len(input_list)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(input_list, n, i)\n\n    for i in range(n - 1, 0, -1):\n        input_list[i], input_list[0] = input_list[0], input_list[i]\n        heapify(input_list, i, 0)\n\n    return input_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 9.0,
      "candidate": "from heap import Heap\n\ndef sort(arr):\n    h = Heap()\n    for i in arr:\n        h.insert(i)\n    for i in range(len(arr)):\n        arr[i] = h.delete()\n\narr = [2, 3, 4, 1, 5]\nsort(arr)\nprint(arr)"
    },
    {
      "rank": 23,
      "score": 9.0,
      "candidate": "def heap_sort(nums):\n    def heapify(nums, heap_size, root_index):\n        largest = root_index\n        left_child = (2 * root_index) + 1\n        right_child = (2 * root_index) + 2\n\n        if left_child < heap_size and nums[left_child] > nums[largest]:\n            largest = left_child\n\n        if right_child < heap_size and nums[right_child] > nums[largest]:\n            largest = right_child\n\n        if largest != root_index:\n            nums[root_index], nums[largest] = nums[largest], nums[root_index]\n            heapify(nums, heap_size, largest)\n\n    n = len(nums)\n\n    for i in range(n, -1, -1):\n        heapify(nums, n, i)\n\n    for i in range(n - 1, 0, -1):\n        nums[i], nums[0] = nums[0], nums[i]\n        heapify(nums, i, 0)\n\n\ndef main():\n    print(\"Heap sort!\")\n    nums = [5, 12, 1, 3, 8, 2, 14, 11]\n    print(nums)\n    heap_sort(nums)\n    print(nums)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 24,
      "score": 9.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    for i in range(len(arr)):\n        heappush(heap, arr[i])\n\n    for i in range(len(arr)):\n        arr[i] = heappop(heap)\n\n    return arr\n\n\narr = [2, 1, 3, 5, 4, 6, 8, 7]\nprint(heap_sort(arr))"
    },
    {
      "rank": 25,
      "score": 9.0,
      "candidate": "from heap_priority_queue import HeapPriorityQueue\n\n\ndef heap_sort(arr):\n    hpq = HeapPriorityQueue()\n    for i in range(len(arr)):\n        hpq.enqueue(arr[i], arr[i])\n    for i in range(len(arr)):\n        arr[i] = hpq.dequeue()\n\n\nif __name__ == \"__main__\":\n    arr = [1, 5, 6, 3, 5, 4, 2, 1, 4, 3]\n    heap_sort(arr)\n    print(arr)"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n\n    for i in arr:\n        heappush(heap, i)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([3, 4, 1, 2, 9, 8, 6, 7, 5, 0]))"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "from heap_queue import HeapQueue\n\ndef heap_sort(lst):\n    \"\"\"\n    >>> lst = [5, 2, 1, 8, 4]\n    >>> heap_sort(lst)\n    [1, 2, 4, 5, 8]\n    \"\"\"\n    hq = HeapQueue()\n    for i in lst:\n        hq.enqueue(i)\n    return [hq.dequeue() for i in range(len(lst))]\n\nif __name__ ==  \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(array):\n    heap = []\n\n    for i in range(len(array)):\n        heappush(heap, array[i])\n\n    return [heappop(heap) for i in range(len(heap))]\n\n\ndef main():\n    array = [5, 6, 7, 1, 2, 3]\n    result = heap_sort(array)\n    print(f\"Array: {array}\")\n    print(f\"Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        l = 2 * i + 1\n        r = 2 * i + 2\n\n        if l < n and arr[i] < arr[l]:\n            largest = l\n\n        if r < n and arr[largest] < arr[r]:\n            largest = r\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n\narr = [34, 2, 10, -9]\nheap_sort(arr)\nprint(arr)"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "from heap_priority_queue import MaxHeapPriorityQueue, MinHeapPriorityQueue\n\ndef build_min_heap(array):\n    heap = MinHeapPriorityQueue()\n    for value in array:\n        heap.insert(value)\n    return heap\n\ndef build_max_heap(array):\n    heap = MaxHeapPriorityQueue()\n    for value in array:\n        heap.insert(value)\n    return heap\n\ndef heap_sort(array):\n    \"\"\"\n    Heap Sort\n\n    Time complexity: O(nlogn)\n    Space complexity: O(1)\n    \"\"\"\n    heap = build_max_heap(array)\n    for i in range(len(array)):\n        array[i] = heap.extract_max()\n    return array\n\ndef heap_sort_min(array):\n    \"\"\"\n    Heap Sort (min)\n\n    Time complexity: O(nlogn)\n    Space complexity: O(1)\n    \"\"\"\n    heap = build_min_heap(array)\n    for i in range(len(array)):\n        array[i] = heap.extract_min()\n    return array\n\ndef main():\n    array = [1, 5, 3, 2, 4, 7, 6, 9, 8]\n    heap_sort(array)\n    print(array)\n\n    array = [1, 5, 3, 2, 4, 7, 6, 9, 8]\n    heap_sort_min(array)\n    print(array)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "from gfg.que_dac.heap_priority_queue import HeapPriorityQueue\n\n\ndef heap_sort(elements: list) -> list:\n    heap = HeapPriorityQueue()\n\n    for element in elements:\n        heap.insert(element)\n\n    return [heap.pop() for _ in range(len(elements))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([5, 3, 6, 2, 10]))"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef heap_sort(arr):\n    heap = []\n    for num in arr:\n        heappush(heap, num)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([2, 5, 1, 8, 6, 9, 4, 7, 3]))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef heap_sort(arr):\n    \"\"\"\n    Heap Sort algorithm.\n\n    :param arr: list of elements to be sorted.\n    :return: sorted list of elements.\n    \"\"\"\n    heap = []\n    for element in arr:\n        heappush(heap, element)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\ndef heap_sort_inplace(arr):\n    \"\"\"\n    Heap Sort algorithm.\n\n    :param arr: list of elements to be sorted.\n    :return: sorted list of elements.\n    \"\"\"\n    heapify(arr)\n    return [heappop(arr) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    arr = [1, 5, 2, 7, 10, 3, 4, 6, 9, 8]\n    print(heap_sort(arr))\n    print(heap_sort_inplace(arr))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "from gfg.queues.priority_queue import PriorityQueue\n\n\ndef heap_sort(nums: list) -> list:\n    heap = PriorityQueue()\n\n    for num in nums:\n        heap.enqueue(num)\n\n    sorted_nums = []\n\n    while heap:\n        sorted_nums.append(heap.dequeue())\n\n    return sorted_nums\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([3, 2, 1, 4, 5]))"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "from heap import MinHeap\n\n\ndef heap_sort(array):\n    heap = MinHeap()\n    for element in array:\n        heap.insert(element)\n\n    for i in range(len(array)):\n        array[i] = heap.extract_min()\n\n\nif __name__ == \"__main__\":\n    array = [5, 4, 3, 2, 1]\n    heap_sort(array)\n    print(array)"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(arr):\n    heapify(arr)\n    return [heappop(arr) for _ in range(len(arr))]\n\n\ndef main():\n    arr = [2, 5, 2, 0, 3, 1]\n    result = heap_sort(arr)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(nums):\n    heap = []\n    heapify(heap)\n    for n in nums:\n        heappush(heap, n)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 1, 3, 5, 2, 0, 5]))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(l: list) -> list:\n    heapify(l)\n    return [heappop(l) for _ in range(len(l))]\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9]"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    # create a heap queue\n    heap_queue = list(arr)\n    heap_size = len(heap_queue)\n    # build a max heap\n    for i in range(heap_size // 2 - 1, -1, -1):\n        heapify(heap_queue, i, heap_size)\n\n    # extract elements one by one\n    for i in range(heap_size - 1, 0, -1):\n        # swap\n        heap_queue[i], heap_queue[0] = heap_queue[0], heap_queue[i]\n        # heap size = heap size - 1\n        heap_size = heap_size - 1\n        # call max heapify on last element\n        heapify(heap_queue, 0, heap_size)\n\n\ndef heapify(heap_queue, i, heap_size):\n    \"\"\"\n    A utility function to heapify a given subtree\n    :param heap_queue:\n    :param i:\n    :param heap_size:\n    :return:\n    \"\"\"\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    # compare with left child\n    if left < heap_size and heap_queue[largest] < heap_queue[left]:\n        largest = left\n\n    # compare with right child\n    if right < heap_size and heap_queue[largest] < heap_queue[right]:\n        largest = right\n\n    # swap if needed\n    if largest != i:\n        heap_queue[i], heap_queue[largest] = heap_queue[largest], heap_queue[i]\n        # recurse\n        heapify(heap_queue, largest, heap_size)\n\n\ndef main():\n    arr = [3, 4, 9, 2, 8, 5, 1, 7, 6]\n    heap_sort(arr)\n    print(arr)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(nums):\n    heap = []\n\n    for num in nums:\n        heappush(heap, num)\n\n    return [heappop(heap) for _ in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    unsorted_nums = [4, 1, 2, 4, 3, 6, 5, 3, 4, 5]\n    sorted_nums = heap_sort(unsorted_nums)\n    print(sorted_nums)"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from collections import deque\n\ndef heapify(arr, n, i):\n    # Find largest among root and children\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n\n    if l < n and arr[i] < arr[l]:\n        largest = l\n\n    if r < n and arr[largest] < arr[r]:\n        largest = r\n\n    # If root is not largest, swap with largest and continue heapifying\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    # Build max heap\n    for i in range(n//2, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        # swap\n        arr[i], arr[0] = arr[0], arr[i]\n\n        # heapify root element\n        heapify(arr, i, 0)\n\n\narr = [3, 1, 10, 5, 2]\nheap_sort(arr)\nn = len(arr)\nprint(\"Sorted array is\")\nfor i in range(n):\n    print(\"%d \" % arr[i], end='')"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def heap_sort(elements):\n    heap = []\n    for element in elements:\n        heap.append(element)\n        heap_bubble_up(heap, len(heap) - 1)\n\n    for i in range(len(elements) - 1, 0, -1):\n        heap[i], heap[0] = heap[0], heap[i]\n        heap_bubble_down(heap, 0, i - 1)\n\n    return heap\n\n\ndef heap_bubble_up(heap, index):\n    if index == 0:\n        return\n    parent = (index - 1) // 2\n    if heap[parent] < heap[index]:\n        heap[parent], heap[index] = heap[index], heap[parent]\n        heap_bubble_up(heap, parent)\n\n\ndef heap_bubble_down(heap, index, size):\n    left = 2 * index + 1\n    right = 2 * index + 2\n    largest = index\n\n    if left <= size and heap[left] > heap[largest]:\n        largest = left\n\n    if right <= size and heap[right] > heap[largest]:\n        largest = right\n\n    if largest != index:\n        heap[largest], heap[index] = heap[index], heap[largest]\n        heap_bubble_down(heap, largest, size)"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    # create a heap\n    heap = Heap()\n    # insert elements in the heap\n    for element in arr:\n        heap.insert(element)\n    # extract elements from the heap\n    sorted_list = []\n    for i in range(len(arr)):\n        sorted_list.append(heap.extract_min())\n    return sorted_list\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def insert(self, data):\n        self.heap.append(data)\n        self.size += 1\n        self.heapify_up()\n\n    def heapify_up(self):\n        i = self.size - 1\n        while i > 0:\n            parent = (i - 1) // 2\n            if self.heap[i] < self.heap[parent]:\n                self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]\n            i = parent\n\n    def extract_min(self):\n        if self.size == 0:\n            return None\n        min = self.heap[0]\n        self.heap[0] = self.heap[self.size - 1]\n        self.size -= 1\n        self.heap.pop()\n        self.heapify_down()\n        return min\n\n    def heapify_down(self):\n        i = 0\n        while 2 * i + 1 < self.size:\n            min_child_index = self.get_min_child_index(i)\n            if self.heap[i] > self.heap[min_child_index]:\n                self.heap[i], self.heap[min_child_index] = self.heap[min_child_index], self.heap[i]\n            i = min_child_index\n\n    def get_min_child_index(self, i):\n        if 2 * i + 2 >= self.size:\n            return 2 * i + 1\n        else"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "from gfg.pqueue.priority_queue import PriorityQueue\nfrom gfg.pqueue.max_heap import MaxHeap\n\n\ndef heap_sort(lst: list) -> list:\n    \"\"\"\n    Time complexity: O(nlogn)\n    Space complexity: O(n)\n    \"\"\"\n    heap = MaxHeap(len(lst))\n\n    for i in range(len(lst)):\n        heap.insert(lst[i])\n\n    for i in range(len(lst)):\n        lst[i] = heap.extract_max()\n\n    return lst\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([2, 4, 1, 3, 5]))\n\n    pqueue = PriorityQueue()\n    pqueue.insert(2)\n    pqueue.insert(4)\n    pqueue.insert(1)\n    pqueue.insert(3)\n    pqueue.insert(5)\n\n    print(pqueue.get_max())\n    print(pqueue.get_max())"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(array):\n    heap = []\n    for element in array:\n        heappush(heap, element)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nprint(heap_sort([10, 2, 1, 3, 9, 4, 15, 2, 3]))"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n\n    for i in range(len(arr)):\n        heappush(heap, arr[i])\n\n    return [heappop(heap) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef sort_list(list_elems: list) -> list:\n    \"\"\"Sort list in ascending order using heap queue algorithm.\"\"\"\n    heap = []\n    for elem in list_elems:\n        heappush(heap, elem)\n\n    sorted_list = []\n    while heap:\n        sorted_list.append(heappop(heap))\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    unsorted_list = [5, 4, 7, 1, 2, 3, 6]\n    sorted_list = sort_list(unsorted_list)\n    print(sorted_list)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(nums):\n\n    heap = []\n\n    for num in nums:\n        heappush(heap, num)\n\n    return [heappop(heap) for i in range(len(heap))]\n\n\nprint(heap_sort([1, 4, 2, 8, 9, 10, 5, 7]))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def heap_sort(arr: list) -> list:\n    \"\"\"\n    >>> heap_sort([1, 3, 2, 5, 6, 7, 4])\n    [1, 2, 3, 4, 5, 6, 7]\n\n    >>> heap_sort([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> heap_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    length = len(arr)\n\n    def heapify(arr, length, index):\n        largest = index\n        left = 2 * index + 1\n        right = 2 * index + 2\n\n        if left < length and arr[largest] < arr[left]:\n            largest = left\n\n        if right < length and arr[largest] < arr[right]:\n            largest = right\n\n        if largest != index:\n            arr[largest], arr[index] = arr[index], arr[largest]\n            heapify(arr, length, largest)\n\n    for i in range(length // 2 - 1, -1, -1):\n        heapify(arr, length, i)\n\n    for i in range(length - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "from gfg.queues.heap_queue import HeapQueue\n\n\ndef heap_sort(elements: list) -> list:\n    heap: HeapQueue = HeapQueue(len(elements))\n\n    for element in elements:\n        heap.enqueue(element)\n\n    sorted_list = []\n\n    while not heap.is_empty():\n        sorted_list.append(heap.dequeue())\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([4, 6, 1, 5, 2, 3, 7, 8]))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "from Heap import Heap\n\ndef sort_using_heap(items):\n    heap = Heap(items)\n    return heap.get_items()\n\nif __name__ == \"__main__\":\n    print(sort_using_heap([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef sort_list(arr):\n    heapify(arr)\n    sorted_list = []\n\n    while arr:\n        sorted_list.append(heappop(arr))\n\n    return sorted_list\n\n\ndef main():\n    print(sort_list([1, 3, 2, 5, 6, 4]))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef sort_asc(arr: list) -> list:\n    heap = []\n\n    for element in arr:\n        heappush(heap, element)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(sort_asc([1, 2, 3, 4, 5, 6, 7, 8, 9]))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef sort_ascending_order(arr):\n    heap = []\n    heapify(heap)\n\n    for element in arr:\n        heappush(heap, element)\n\n    return [heappop(heap) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    print(sort_ascending_order([3, 1, 2, 4, 5]))"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef sort_asc(elements):\n    \"\"\"\n    Sorts a given list of elements in ascending order using heap queue algorithm.\n    :param elements: List[int]\n    :return: None\n    \"\"\"\n    heap = []\n    for element in elements:\n        heappush(heap, element)\n\n    return [heappop(heap) for _ in range(len(elements))]\n\n\nif __name__ == \"__main__\":\n    elements = [1, 4, 3, 9, 0, 2, 7, 11, 14, 6]\n    print(sort_asc(elements))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "def heap_sort(list_data):\n    \"\"\"\n    Sort a given list of elements in ascending order using heap queue algorithm.\n\n    :param list_data: given list of elements\n    :return: sorted list of elements\n\n    Example:\n    >>> heap_sort([4, 1, 2, 5, 3])\n    [1, 2, 3, 4, 5]\n\n    >>> heap_sort([17, 9, 13, 8, 7, 7, 1, 10, 12, 6, 5, 3, 1, 10, 11, 2, 2, 1, 7, 6])\n    [1, 1, 1, 1, 2, 2, 2, 3, 5, 6, 6, 7, 7, 7, 8, 9, 10, 10, 11, 12, 13, 17]\n    \"\"\"\n    heap_queue = []\n    for element in list_data:\n        heap_queue.append(element)\n        heap_sift_up(heap_queue, len(heap_queue) - 1)\n    for i in range(len(list_data) - 1, 0, -1):\n        heap_queue[0], heap_queue[i] = heap_queue[i], heap_queue[0]\n        heap_sift_down(heap_queue, 0, i - 1)\n    return heap_queue\n\n\ndef heap_sift_up(heap_queue, current_index):\n    \"\"\"\n    Sift up the current node in heap_queue.\n\n    :param heap_queue: heap_queue to be sifted up\n    :param current_index: index of the current node\n    :return: None\n\n    >>> heap_queue = [3, 1, 2, 5, 4]\n    >>> heap_sift_up(heap_queue, 3)\n    >>> heap_queue\n    [4, 1, 2, 5, 3]"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "from collections import deque\n\n\ndef sort_using_heap(arr: list) -> list:\n    if not arr:\n        return []\n\n    heap = deque()\n    for i in range(len(arr)):\n        heap.append(arr[i])\n\n    while len(heap) > 1:\n        heap.appendleft(heap.pop())\n\n        i = len(heap) - 1\n        while i > 0:\n            parent_idx = (i - 1) // 2\n            if heap[i] < heap[parent_idx]:\n                heap[i], heap[parent_idx] = heap[parent_idx], heap[i]\n                i = parent_idx\n            else:\n                break\n\n    return list(heap)\n\n\nif __name__ == \"__main__\":\n    arr = [5, 4, 3, 2, 1]\n    print(sort_using_heap(arr))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def heap_sort(lst):\n    def heapify(lst, idx, heap_size):\n        largest = idx\n        left_idx = 2 * idx + 1\n        right_idx = 2 * idx + 2\n\n        if left_idx < heap_size and lst[left_idx] > lst[largest]:\n            largest = left_idx\n\n        if right_idx < heap_size and lst[right_idx] > lst[largest]:\n            largest = right_idx\n\n        if largest != idx:\n            lst[largest], lst[idx] = lst[idx], lst[largest]\n            heapify(lst, largest, heap_size)\n\n    for i in range(len(lst) // 2 - 1, -1, -1):\n        heapify(lst, i, len(lst))\n\n    for i in range(len(lst) - 1, 0, -1):\n        lst[i], lst[0] = lst[0], lst[i]\n        heapify(lst, 0, i)\n\n    return lst\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\n# Time complexity O(n*log(n))\ndef heap_sort(arr):\n    if len(arr) == 0:\n        return\n    heapify(arr)\n    sorted_list = []\n    while len(arr) > 0:\n        sorted_list.append(heappop(arr))\n    return sorted_list\n\n\ndef main():\n    arr = [34, 5, 2, 1, 4, 0, 6, 2]\n    result = heap_sort(arr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(nums):\n    heapify(nums)\n    sorted_nums = []\n\n    while len(nums) > 0:\n        sorted_nums.append(heappop(nums))\n\n    return sorted_nums\n\n\ndef main():\n    print(heap_sort([4, 1, 2, 10, 5]))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "from heapq import heappop, heappush\n\n\ndef heap_sort(arr):\n    heap = []\n    for num in arr:\n        heappush(heap, num)\n\n    sorted_arr = []\n    while heap:\n        sorted_arr.append(heappop(heap))\n\n    return sorted_arr\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5]))"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "def heap_sort(array):\n    \"\"\"\n    Time complexity: O(n*log(n)).\n    Space complexity: O(1).\n    \"\"\"\n    # Create a min heap.\n    for i in range(len(array) // 2 - 1, -1, -1):\n        _heapify(array, i)\n\n    for i in range(len(array) - 1, 0, -1):\n        array[i], array[0] = array[0], array[i]\n        _heapify(array, 0)\n\n    return array\n\n\ndef _heapify(array, i):\n    left = 2 * i + 1\n    right = 2 * i + 2\n    largest = i\n\n    # If left child is larger than root.\n    if left < len(array) and array[left] > array[largest]:\n        largest = left\n\n    # If right child is larger than root.\n    if right < len(array) and array[right] > array[largest]:\n        largest = right\n\n    # If root is not the largest.\n    if largest != i:\n        array[i], array[largest] = array[largest], array[i]\n        _heapify(array, largest)"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef heap_sort(lst):\n    heap = lst[:]\n    heapify(heap)\n    sorted_list = []\n    for i in range(len(heap)):\n        sorted_list.append(heappop(heap))\n    return sorted_list\n\n\ndef test_heap_sort():\n    assert heap_sort([4, 1, 3, 2, 16, 9, 10, 14, 8, 7]) == [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([4, 1, 3, 2, 16, 9, 10, 14, 8, 7]))"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(input_list):\n    heap = []\n    for item in input_list:\n        heappush(heap, item)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\ndef main():\n    print(heap_sort([1, 2, 3, 4, 5]))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "from gfg.queues.heap import MinHeap\n\n\ndef heap_sort(nums: list) -> list:\n    heap = MinHeap()\n\n    for i in nums:\n        heap.insert(i)\n\n    result = []\n\n    while heap.size != 0:\n        result.append(heap.delete())\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 5, 8, 2, 6, 3, 0, 9, 11, 10, 15]))"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(arr):\n    heapify(arr)\n    sorted_list = []\n\n    while len(arr) > 0:\n        sorted_list.append(heappop(arr))\n\n    return sorted_list\n\n\ndef main():\n    arr = [12, 11, 13, 5, 6, 7]\n    result = heap_sort(arr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(array):\n    heap = []\n    for value in array:\n        heappush(heap, value)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 3, 2, 5, 6, 2, 4, 2, 8]))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(iterable):\n    \"\"\"Heap sort algorithm.\"\"\"\n    h = []\n    for value in iterable:\n        heappush(h, value)\n    return [heappop(h) for _ in range(len(h))]\n\n\nif __name__ == '__main__':\n    import timeit\n\n    setup = 'from __main__ import heap_sort\\n'\n    stmt = 'heap_sort([1, 3, 2, 0, 4, 5])'\n    print(timeit.timeit(setup=setup, stmt=stmt, number=10000))  # 0.05906876599999998"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(nums: list) -> list:\n    heapify(nums)\n\n    sorted_nums = []\n\n    while nums:\n        sorted_nums.append(heappop(nums))\n\n    return sorted_nums\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5]))\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(heap_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))\n    print(heap_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))\n    print(heap_sort([]))\n    print(heap_sort([1]))\n    print(heap_sort([1, 1]))\n    print(heap_sort([1, 2]))\n    print(heap_sort([1, 2, 1]))"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(nums):\n    heap = []\n\n    for num in nums:\n        heappush(heap, num)\n\n    sorted_list = []\n\n    while heap:\n        sorted_list.append(heappop(heap))\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]))"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(arr):\n    heapify(arr)\n\n    return [heappop(arr) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([3, 4, 2, 1, 5]))"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "from heap_queue import HeapQueue\n\n\ndef heap_sort(elements: list) -> list:\n    \"\"\"Heap sort algorithm implementation.\n\n    Args:\n        elements (list): list of elements to be sorted.\n\n    Returns:\n        list: sorted list of elements.\n    \"\"\"\n    heap = HeapQueue()\n    for element in elements:\n        heap.insert(element)\n\n    sorted_list = []\n    while not heap.is_empty():\n        sorted_list.append(heap.remove())\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8]))\n    print(heap_sort([]))\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef heap_sort(nums):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n\n    return [heapq.heappop(heap) for i in range(len(nums))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 3, 5, 2, 4, 6, 8, 7]))"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    # O(nlogn)\n    heap = []\n    for i in arr:\n        heappush(heap, i)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 3, 4, 7, 5, 6, 2]))"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(nums: list) -> list:\n    \"\"\"\n    Heap sort uses the heap data structure to sort a list of elements.\n    Heap sort is an in-place sorting algorithm, which means that the function does not return a new list,\n    but rather sorts the list in-place.\n    It has an average time complexity of O(n log n).\n    Heap sort is also stable.\n    :param nums: The list of elements to sort\n    :return: A new list with the sorted elements in ascending order\n    >>> heap_sort([3, 1, 2, 5, 4, 6, 8, 7])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> heap_sort([4, 1, 3, 2, 5, 6, 8, 7])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> heap_sort([1, 2, 3, 4, 5, 6, 7, 8])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> heap_sort([4, 1, 3, 2, 5, 6, 8, 7])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> heap_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    >>> heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> heap_sort([])\n    []\n    \"\"\"\n\n    if not nums:\n        return []\n\n    heap = nums[:]\n    heapify(he"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def heap_sort(a):\n    \"\"\"\n    Time complexity: O(nlogn).\n    Space complexity: O(1).\n    \"\"\"\n    def heapify(a, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and a[i] < a[left]:\n            largest = left\n\n        if right < n and a[largest] < a[right]:\n            largest = right\n\n        if largest != i:\n            a[i], a[largest] = a[largest], a[i]\n            heapify(a, largest)\n\n    n = len(a)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(a, i)\n\n    for i in range(n - 1, 0, -1):\n        a[0], a[i] = a[i], a[0]\n        heapify(a, 0)\n\n\nif __name__ == \"__main__\":\n    arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    heap_sort(arr)\n    print(arr)"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef sort_heap(arr: list) -> list:\n    \"\"\"\n    Time Complexity: O(n*log(n))\n    \"\"\"\n    heap = arr[:]\n    heapify(heap)\n\n    sorted_list = []\n\n    while heap:\n        sorted_list.append(heappop(heap))\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    unsorted_list = [5, 6, 8, 3, 4, 2, 1, 9, 7, 6]\n    print(f\"Sorted list: {sort_heap(unsorted_list)}\")"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "def sort_ascending_heap(arr):\n    \"\"\"\n    Time Complexity: O(nlogn)\n    Space Complexity: O(1)\n    \"\"\"\n    heap = MaxHeap(arr)\n    return heap.get_sorted_array()\n\n\nclass MaxHeap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.heap_size = len(self.arr)\n\n    def get_sorted_array(self):\n        for i in range(self.heap_size // 2, -1, -1):\n            self.max_heapify(i)\n        for i in range(self.heap_size - 1, 0, -1):\n            self.arr[i], self.arr[0] = self.arr[0], self.arr[i]\n            self.heap_size -= 1\n            self.max_heapify(0)\n        return self.arr\n\n    def max_heapify(self, i):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        largest = i\n\n        if left_child < self.heap_size and self.arr[left_child] > self.arr[largest]:\n            largest = left_child\n        if right_child < self.heap_size and self.arr[right_child] > self.arr[largest]:\n            largest = right_child\n\n        if largest != i:\n            self.arr[i], self.arr[largest] = self.arr[largest], self.arr[i]\n            self.max_heapify(largest)\n\n\nif __name__ == \"__main__\":\n    print(sort_ascending_heap([1, 5, 3, 2, 4]))"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    \"\"\"\n    Using heapq library.\n    \"\"\"\n    heap = []\n    for item in arr:\n        heappush(heap, item)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([5, 3, 2, 1, 6]))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(l: list) -> list:\n    heap = []\n\n    for i in l:\n        heappush(heap, i)\n\n    return [heappop(heap) for i in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([12, 11, 13, 5, 6, 7]))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "from heap_priority_queue import HeapPriorityQueue\n\n\ndef heap_sort(elements):\n    if not isinstance(elements, list):\n        raise TypeError(\"`elements` is not of type list\")\n\n    hpq = HeapPriorityQueue()\n    for element in elements:\n        hpq.insert(element)\n    return [hpq.remove() for _ in range(hpq.size())]\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    elements = [int(e) for e in sys.argv[1].split(\",\")]\n    print(f\"List before sorting: {elements}\")\n    elements = heap_sort(elements)\n    print(f\"List after sorting: {elements}\")"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef sort_list_heap(l):\n    heapify(l)\n\n    return l\n\n\ndef sort_list_heap_inplace(l):\n    \"\"\"\n    In-place heap sort algorithm.\n    \"\"\"\n    for i in range(len(l) - 1):\n        heappush(l, l[i])\n        l[i] = heappop(l)\n\n    return l\n\n\nprint(sort_list_heap([1, 2, 3, 4, 5, 6]))\nprint(sort_list_heap_inplace([1, 2, 3, 4, 5, 6]))"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    heap_size = len(arr)\n    build_heap(arr, heap_size)\n    print(arr)\n    for i in range(heap_size-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n    print(arr)\n\n\ndef heapify(arr, heap_size, root_index):\n    parent_index = root_index\n    left_index = 2 * parent_index + 1\n    right_index = 2 * parent_index + 2\n\n    if left_index < heap_size and arr[left_index] > arr[parent_index]:\n        parent_index = left_index\n\n    if right_index < heap_size and arr[right_index] > arr[parent_index]:\n        parent_index = right_index\n\n    if parent_index != root_index:\n        arr[root_index], arr[parent_index] = arr[parent_index], arr[root_index]\n        heapify(arr, heap_size, parent_index)\n\n\ndef build_heap(arr, heap_size):\n    for i in range(heap_size//2, -1, -1):\n        heapify(arr, heap_size, i)\n\n\narr = [3, 1, 2, 4, 7, 5, 8, 9, 6]\nheap_sort(arr)"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    for elem in arr:\n        heappush(heap, elem)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]))"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(elements: list):\n    \"\"\"Heap sort.\n\n    Time Complex: O(nlogn)\n    Space Complex: O(1)\n    \"\"\"\n    # create a min heap\n    heap = []\n\n    # insert all elements into the heap\n    for element in elements:\n        heappush(heap, element)\n\n    # remove the root and add it to the result list\n    # repeat until the heap becomes empty\n    result = []\n    while heap:\n        result.append(heappop(heap))\n\n    return result\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([5, 3, 6, 2, 10]))"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "from heap_queue import Queue\n\n\ndef heap_sort(nums: list) -> list:\n    \"\"\"\n    Given a list of elements, return a new list with the elements sorted in ascending order.\n\n    :param nums: List[int]\n    :return: List[int]\n    \"\"\"\n    heap = Queue()\n\n    for num in nums:\n        heap.enqueue(num)\n\n    sorted_list = []\n    while not heap.is_empty():\n        sorted_list.append(heap.dequeue())\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([1, 3, 2, 4, 5]) == [1, 2, 3, 4, 5]"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(lst):\n    heap = []\n    for i in lst:\n        heappush(heap, i)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7]))"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def heap_sort(list):\n    pass\n\n\nif __name__ == \"__main__\":\n    list = [5, 9, 1, 4, 3, 7, 8, 6, 2]\n    heap_sort(list)\n    print(list)"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(array):\n    heapify(array)\n    return [heappop(array) for _ in range(len(array))]\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([3, 2, 1]) == [1, 2, 3]"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(items):\n    \"\"\"\n    :param items: list of items\n    :return: sorted list\n    \"\"\"\n    heap = []\n    heapify(heap)\n    for item in items:\n        heappush(heap, item)\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef sort_ascending_heap(data: list) -> list:\n    \"\"\"\n    Use heap queue algorithm to sort a given list of elements in ascending order\n    :param data: list of elements\n    :return: list of elements in ascending order\n    >>> sort_ascending_heap([1, 3, 2, 4])\n    [1, 2, 3, 4]\n    \"\"\"\n    heap = []\n    for element in data:\n        heappush(heap, element)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(sort_ascending_heap([1, 3, 2, 4]))"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    \"\"\"\n    >>> arr = [5, 3, 4, 2, 1, 6, 8, 7]\n    >>> heap_sort(arr)\n    >>> print(arr)\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    \"\"\"\n    heap_size = len(arr)\n    build_max_heap(arr, heap_size)\n    for i in range(heap_size - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heap_size -= 1\n        heapify(arr, heap_size, 0)\n\n\ndef build_max_heap(arr, heap_size):\n    \"\"\"\n    >>> arr = [5, 3, 4, 2, 1, 6, 8, 7]\n    >>> heap_size = len(arr)\n    >>> build_max_heap(arr, heap_size)\n    >>> print(arr)\n    [8, 7, 6, 5, 3, 4, 2, 1]\n    \"\"\"\n    start = heap_size // 2\n    for i in range(start, -1, -1):\n        heapify(arr, heap_size, i)\n\n\ndef heapify(arr, heap_size, i):\n    \"\"\"\n    >>> arr = [8, 7, 6, 5, 3, 4, 2, 1]\n    >>> heap_size = len(arr)\n    >>> heapify(arr, heap_size, 0)\n    >>> print(arr)\n    [8, 7, 6, 5, 3, 4, 2, 1]\n    \"\"\"\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n    if largest !="
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(arr):\n    heapify(arr)\n    return [heappop(arr) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    arr = [2, 5, 1, 8, 4]\n    arr_sorted = heap_sort(arr)\n    print(arr_sorted)"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(elements):\n\n    heap = []\n\n    for element in elements:\n        heappush(heap, element)\n\n    return [heappop(heap) for _ in range(len(heap))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5]))\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def heap_sort(nums):\n    def heapify(nums, heap_size, root_index):\n        largest = root_index\n        left_child = (2 * root_index) + 1\n        right_child = (2 * root_index) + 2\n\n        if left_child < heap_size and nums[left_child] > nums[largest]:\n            largest = left_child\n\n        if right_child < heap_size and nums[right_child] > nums[largest]:\n            largest = right_child\n\n        if largest != root_index:\n            nums[root_index], nums[largest] = nums[largest], nums[root_index]\n            heapify(nums, heap_size, largest)\n\n    n = len(nums)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(nums, n, i)\n\n    for i in range(n - 1, 0, -1):\n        nums[i], nums[0] = nums[0], nums[i]\n        heapify(nums, i, 0)\n\n\nif __name__ == \"__main__\":\n    nums = [3, 7, 4, 6, 1, 0, 9, 8, 9, 4, 3, 5]\n    heap_sort(nums)\n    print(nums)"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef sort_list(input_list):\n    heap = []\n    for i in range(len(input_list)):\n        heappush(heap, input_list[i])\n\n    sorted_list = []\n    for i in range(len(input_list)):\n        sorted_list.append(heappop(heap))\n\n    return sorted_list\n\n\nif __name__ == \"__main__\":\n    print(sort_list([1, 2, 3, 4, 5, 6, 7, 8, 9]))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop\n\n\ndef heap_sort(arr):\n    heapify(arr)\n    return [heappop(arr) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([2, 1, 3, 4, 5, 6]))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "def heap_sort(a):\n    for i in range(len(a)-1):\n        for j in range(i+1, 0, -1):\n            if a[j] < a[j-1]:\n                a[j], a[j-1] = a[j-1], a[j]\n\n\nif __name__ == \"__main__\":\n    a = [3, 5, 2, 1, 7, 0, 10]\n    heap_sort(a)\n    print(a)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heap_sort(items):\n    \"\"\"Sorts the given list using heap queue algorithm.\n\n    Args:\n        items: list of items to be sorted\n\n    Returns:\n        list of sorted items\n    \"\"\"\n\n    heap = []\n    heapify(items)\n\n    while items:\n        heappush(heap, heappop(items))\n\n    return heap\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([2, 7, 4, 1, 5, 3]))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from Heap import Heap\n\ndef heap_sort(l):\n    heap = Heap()\n    for item in l:\n        heap.push(item)\n    return [heap.pop() for _ in range(heap.size())]\n\nif __name__ == \"__main__\":\n    l = [3, 4, 1, 2, 9, 7, 8, 6, 5]\n    print(heap_sort(l))"
    }
  ]
}