{
  "timestamp": "2025-09-14T23:09:21.338263",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 113,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "def get_angle(number: complex) -> float:\n    \"\"\"Get the angle of a complex number.\n\n    >>> get_angle(2 + 2j)\n    1.107149\n    >>> get_angle(2 + 3j)\n    1.175927\n    \"\"\"\n    return float(\n        round(\n            -2 * (number.real * (number.imag / abs(number))).asin() / (1 - (number.real ** 2)),\n            6,\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def get_angle(z):\n    \"\"\"\n    :param z: a complex number\n    :return: the angle of z in radians\n\n    >>> get_angle(1+2j)\n    1.107149\n    >>> get_angle(1)\n    0.0\n    >>> get_angle(1+0j)\n    0.0\n    \"\"\"\n    return (\n        -1\n        * (\n            complex(0, 1)\n            * (\n                complex(0, 1)\n                ** (complex(0, 1) * (complex(z.real, z.imag) - complex(z.real, 0)))\n            ).imag\n        ).imag\n    )\n\n\ndef get_angle_2(z):\n    \"\"\"\n    :param z: a complex number\n    :return: the angle of z in radians\n\n    >>> get_angle_2(1+2j)\n    1.107149\n    >>> get_angle_2(1)\n    0.0\n    >>> get_angle_2(1+0j)\n    0.0\n    \"\"\"\n    return (\n        -1\n        * (\n            complex(0, 1)\n            * (\n                complex(0, 1)\n                ** (complex(0, 1) * (complex(z.real, z.imag) - complex(z.real, 0)))\n            ).imag\n        ).imag\n    )"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    >>> get_angle(complex(3, 4))\n    0.9827937232473298\n    >>> get_angle(complex(3, -4))\n    -0.9827937232473298\n    \"\"\"\n    return cmath.phase(complex_number)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "import math\n\n\ndef get_angle(complex_num: complex) -> float:\n    \"\"\"\n    >>> get_angle(complex(1, 0))\n    0\n    >>> get_angle(complex(0, 1))\n    90\n    >>> get_angle(complex(1, 1))\n    45\n    \"\"\"\n    return math.degrees(math.atan2(complex_num.imag, complex_num.real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "import math\n\ndef get_angle(number):\n    \"\"\"\n    Get angle of a complex number\n    >>> get_angle(complex(3, 4))\n    0.9827937232473299\n    >>> get_angle(complex(0, 1))\n    1.5707963267948966\n    \"\"\"\n    return math.atan2(number.imag, number.real)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def angle_of_complex_number(complex_number):\n    \"\"\"\n    >>> angle_of_complex_number(1+2j)\n    1.107149...\n    \"\"\"\n    return (\n        (\n            (complex_number.real * complex_number.real + complex_number.imag * complex_number.imag)\n            ** 0.5\n        )\n        * 2\n        * (complex_number.real > 0)\n        - (\n            (complex_number.real * complex_number.real + complex_number.imag * complex_number.imag)\n            ** 0.5\n        )\n        * 2\n        * (complex_number.real < 0)\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    >>> get_angle(3 + 5j)\n    0.3217505543948808\n    >>> get_angle(3 - 5j)\n    1.183486808425559\n    >>> get_angle(3 + 0j)\n    0.0\n    >>> get_angle(3 - 0j)\n    0.0\n    >>> get_angle(3 + 4j)\n    0.982793723247322\n    \"\"\"\n    return (3.14 / 2) - (\n        (3.14 / 2) * (complex_number.real / abs(complex_number.real))\n        if abs(complex_number.real)\n        else 0\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def angle(complex_number: complex) -> float:\n    \"\"\"Returns the angle of a complex number.\n\n    >>> angle(3 + 5j)\n    0.6435011087932844\n    >>> angle(-2 - 4j)\n    0.7853981633974483\n    >>> angle(3 + 0j)\n    0.0\n    >>> angle(0 + 4j)\n    1.5707963267948966\n    >>> angle(1 + 2j)\n    1.1071487177940904\n    >>> angle(-1 + 1j)\n    1.2566370614359172\n    >>> angle(0.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    \"\"\"\n    return _phase(complex_number)\n\n\ndef _phase(complex_number: complex) -> float:\n    \"\"\"Returns the angle of a complex number.\n\n    >>> _phase(3 + 5j)\n    0.6435011087932844\n    >>> _phase(-2 - 4j)\n    0.7853981633974483\n    >>> _phase(3 + 0j)\n    0.0\n    >>> _phase(0 + 4j)\n    1.5707963267948966\n    >>> _phase(1 + 2j)\n    1.1071487177940904\n    >>> _phase(-1 + 1j)\n    1.2566370614359172\n    >>> _phase(0.0)\n    Traceback (most recent call last):\n        ...\n    ValueError: math domain error\n    \"\"\"\n    return math.atan2(complex_number.imag, complex_number.real)\n\n\nif __name__ == \"__main__"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "import math\n\ndef get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(3+4j)\n    0.3760556920824264\n    >>> get_angle(3j)\n    1.5707963267948966\n    >>> get_angle(2j)\n    1.1071487177940904\n    >>> get_angle(0+1j)\n    0.7853981633974483\n    \"\"\"\n    return math.atan2(complex_num.imag, complex_num.real)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "def get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(3+3j)\n    45.0\n    >>> get_angle(0+0j)\n    0.0\n    >>> get_angle(1j)\n    90.0\n    \"\"\"\n    return round(\n        abs(\n            -180 + round(\n                round(\n                    abs(\n                        round(\n                            round(\n                                round(\n                                    round(\n                                        round(\n                                            round(\n                                                round(\n                                                    round(\n                                                        round(\n                                                            round(\n                                                                complex_num.real,\n                                                                2\n                                                            )\n                                                            +\n                                                            round(\n                                                                complex_num.imag,\n                                                                2\n                                                            )\n                                                        )\n                                                    )\n                                                )\n                                            )\n                                        )\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def get_angle(z):\n    \"\"\"\n    :param z: a complex number\n    :return: angle of the complex number\n\n    >>> get_angle(3+4j)\n    0.2458545146774046\n    >>> get_angle(2+0j)\n    0.0\n    >>> get_angle(0+1j)\n    1.5707963267948966\n    >>> get_angle(2-3j)\n    -1.513759149172659\n    >>> get_angle(1+1j)\n    0.7853981633974483\n    \"\"\"\n    return math.atan2(z.imag, z.real)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    Get the angle of a complex number.\n\n    Args:\n        complex_number:\n\n    Returns:\n        Angle in degrees\n    \"\"\"\n    return (\n        (\n            (\n                (complex_number.real ** 2 + complex_number.imag ** 2)\n                ** 0.5\n            )\n            *\n            (complex_number.real / (complex_number.real ** 2 + complex_number.imag ** 2) ** 0.5)\n        )\n        *\n        (\n            (\n                (complex_number.real ** 2 + complex_number.imag ** 2)\n                ** 0.5\n            )\n            *\n            (complex_number.imag / (complex_number.real ** 2 + complex_number.imag ** 2) ** 0.5)\n        )\n    )"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "def get_angle(complex_number: complex) -> float:\n    \"\"\"Returns the angle of a complex number.\n\n    Args:\n        complex_number: A complex number\n\n    Returns:\n        angle: The angle of the complex number\n    \"\"\"\n    angle = (math.atan2(complex_number.imag, complex_number.real)) * 180 / math.pi\n    if angle < 0:\n        angle += 360\n    return angle"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "def get_angle(num):\n    \"\"\"\n    Return the angle of a complex number.\n    \"\"\"\n    real = num.real\n    imag = num.imag\n    return (atan2(imag, real) * 180.0 / pi) % 360\n\n\ndef get_angle2(num):\n    \"\"\"\n    Return the angle of a complex number.\n    \"\"\"\n    return atan2(num.imag, num.real) * 180.0 / pi"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "def get_angle(complex_num: complex) -> float:\n    \"\"\"\n    >>> get_angle(complex(0, 1))\n    90.0\n    >>> get_angle(complex(1, 1))\n    45.0\n    >>> get_angle(complex(1, 0))\n    0.0\n    \"\"\"\n    return round(\n        (\n            (\n                180\n                * (\n                    (\n                        (complex_num.real ** 2 + complex_num.imag ** 2) ** 0.5\n                        / abs(complex_num)\n                    )\n                    / 2\n                )\n            )\n            if complex_num.real != 0\n            else 90\n        ),\n        1,\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "def angle_of_complex_number(real, imaginary):\n    \"\"\"\n    >>> angle_of_complex_number(3, 3)\n    45.0\n    >>> angle_of_complex_number(1, -1)\n    -45.0\n    >>> angle_of_complex_number(3, 1)\n    60.0\n    >>> angle_of_complex_number(1, -1)\n    -45.0\n    >>> angle_of_complex_number(3, -1)\n    -120.0\n    >>> angle_of_complex_number(-3, -1)\n    225.0\n    >>> angle_of_complex_number(-3, -1)\n    225.0\n    >>> angle_of_complex_number(-1, -1)\n    225.0\n    >>> angle_of_complex_number(-1, -1)\n    225.0\n    >>> angle_of_complex_number(0, -1)\n    180.0\n    >>> angle_of_complex_number(0, 1)\n    0.0\n    >>> angle_of_complex_number(-1, 0)\n    90.0\n    >>> angle_of_complex_number(0, 0)\n    0.0\n    >>> angle_of_complex_number(1, 0)\n    0.0\n    \"\"\"\n    from math import atan2, degrees\n\n    return degrees(atan2(imaginary, real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "from typing import Tuple\n\n\ndef get_complex_angle(complex_number: complex) -> Tuple[float, float]:\n    \"\"\"Returns the angle of a complex number.\n\n    Args:\n        complex_number (complex): A complex number\n\n    Examples:\n        >>> assert get_complex_angle(1 + 2j) == (0.7853981633974483, 0.7853981633974483)\n    \"\"\"\n    real = complex_number.real\n    imag = complex_number.imag\n\n    if real == 0 and imag == 0:\n        return (0.0, 0.0)\n\n    if imag == 0:\n        return (0.0, 0.0)\n\n    if real == 0:\n        if imag > 0:\n            return (0.0, 1.5707963267948966)\n        return (0.0, -1.5707963267948966)\n\n    if real > 0:\n        if imag > 0:\n            return (0.0, 0.7853981633974483)\n        return (0.0, 2.356194490192345)\n\n    if imag > 0:\n        return (0.0, 1.5707963267948966)\n    return (0.0, -1.5707963267948966)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "def get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(3+5j)\n    0.3557865388231751\n    >>> get_angle(1j)\n    0.7853981633974483\n    \"\"\"\n    return complex_num.imag / complex_num.real\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "def get_angle(number: complex) -> float:\n    \"\"\"Gets the angle of a complex number.\n\n    Args:\n        number (complex): The number.\n\n    Returns:\n        float: The angle of the number.\n    \"\"\"\n    return round(\n        (\n            (360 if number.real < 0 else 0)\n            + round(\n                math.degrees(\n                    math.atan2(number.imag, number.real)\n                    + (math.pi * 2 if number.imag < 0 else 0)\n                )\n            )\n        )\n        % 360,\n        2,\n    )"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "def get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(complex(3, 4))\n    0.3785045263869735\n    \"\"\"\n    return cmath.phase(complex_num)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "def get_angle(z):\n    return (180/3.14159) * (atan2(z.imag, z.real))\n\n\nassert get_angle(complex(0, 1)) == 90\nassert get_angle(complex(1, 1)) == 45\nassert get_angle(complex(1, 0)) == 0\nassert get_angle(complex(1, -1)) == -45\nassert get_angle(complex(0, -1)) == -90\nassert get_angle(complex(-1, -1)) == -135\nassert get_angle(complex(-1, 0)) == -180\nassert get_angle(complex(-1, 1)) == -225"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "def get_angle(complex):\n    \"\"\"\n    >>> get_angle(3+4j)\n    0.3634561660253905\n    >>> get_angle(1+0j)\n    0.0\n    >>> get_angle(0+1j)\n    1.5707963267948966\n    \"\"\"\n    return (math.atan2(complex.imag, complex.real))"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "def get_angle(z):\n    \"\"\"Return angle of complex number.\n\n        >>> get_angle(3 + 3j)\n        45.0\n\n        >>> get_angle(2 - 2j)\n        135.0\n\n        >>> get_angle(2 - 2j) == get_angle(2 + 2j)\n        True\n    \"\"\"\n    return round(180 * (math.atan2(z.imag, z.real) / math.pi), 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "def get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(complex(-3, 3))\n    0.7853981633974483\n    >>> get_angle(complex(3, 3))\n    0.7853981633974483\n    >>> get_angle(complex(3, -3))\n    -0.7853981633974483\n    >>> get_angle(complex(-3, -3))\n    -0.7853981633974483\n    \"\"\"\n    return (1j * complex_num.imag).real / (1j * complex_num.imag).imag\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "def get_angle(complex_num):\n    return math.atan2(complex_num.imag, complex_num.real)"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "import math\n\ndef get_angle(complex_number):\n    \"\"\"\n    :param complex_number: a complex number\n    :return: angle of the complex number\n\n    This solution has been written by @aadityagrg and @Sambit311 in\n    interviewbit.\n    \"\"\"\n    return math.atan2(complex_number.imag, complex_number.real) * 180 / math.pi"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "def angle_of_complex_number(complex_number: complex) -> float:\n    \"\"\"\n    >>> angle_of_complex_number(1+2j)\n    1.107149\n    \"\"\"\n    return round(\n        (3.14159 / 2) - (atan2(complex_number.imag, complex_number.real)), 6\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "from math import atan2\n\n\ndef get_angle(x, y):\n    return atan2(y, x)\n\n\ndef main():\n    x = int(input(\"Enter the real part of the complex number: \"))\n    y = int(input(\"Enter the imaginary part of the complex number: \"))\n\n    print(f\"The angle of the complex number is {get_angle(x, y)}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "def get_angle(num: complex) -> float:\n    \"\"\"\n    >>> get_angle(complex(0, 0))\n    0\n    >>> get_angle(complex(0, 1))\n    90.0\n    >>> get_angle(complex(1, 0))\n    0.0\n    \"\"\"\n    return (360 + (360 * (num.imag / abs(num)))) % 360\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "def get_angle(complex_number):\n    return 180 * cmath.phase(complex_number) / cmath.pi\n\n\ndef test_get_angle():\n    \"\"\"\n    >>> test_get_angle()\n    \"\"\"\n    assert round(get_angle(complex(3, 4)), 2) == 53.13\n    assert round(get_angle(complex(2, 0)), 2) == 0.00\n    assert round(get_angle(complex(0, 2)), 2) == 90.00\n    assert round(get_angle(complex(-2, 0)), 2) == 180.00\n    assert round(get_angle(complex(0, -2)), 2) == -90.00\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "def get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(1+2j)\n    1.1071490574958113\n    >>> get_angle(1.0+2.0j)\n    1.1071490574958113\n    >>> get_angle(1+2.0j)\n    1.1071490574958113\n    \"\"\"\n    return round(\n        (abs(complex_num) * abs(complex_num.conjugate() - complex_num)) ** 0.5, 12\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "import math\n\ndef get_angle(complex_number):\n    \"\"\"\n    >>> get_angle(complex(-1, 0))\n    3.141592653589793\n    >>> get_angle(complex(1, 0))\n    0.0\n    >>> get_angle(complex(0, 1))\n    1.5707963267948966\n    >>> get_angle(complex(-2, 2))\n    2.061464224080689\n    \"\"\"\n    return math.atan2(complex_number.imag, complex_number.real)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "import math\n\n\ndef get_angle(complex_number):\n    # Write your code here.\n    return math.atan2(complex_number.imag, complex_number.real) * 180 / math.pi"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "import math\n\n\ndef get_angle(complex_number):\n    \"\"\"\n    >>> get_angle(complex(0, 0))\n    0\n    >>> get_angle(complex(1, 1))\n    45\n    >>> get_angle(complex(1, 0))\n    90\n    >>> get_angle(complex(0, 1))\n    180\n    \"\"\"\n    return math.degrees(math.atan(complex_number.imag / complex_number.real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "def get_angle(num):\n    return round(math.atan2(num.imag, num.real) * 180 / math.pi)"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "import math\n\n\ndef angle(complex_num: complex) -> float:\n    \"\"\"\n    >>> angle(3+5j)\n    0.3826834323650898\n    \"\"\"\n    return math.atan2(complex_num.imag, complex_num.real)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "from typing import Tuple\n\n\ndef get_angle(number: complex) -> float:\n    \"\"\"Return the angle of a complex number.\n\n    >>> get_angle(1+2j)\n    0.7853981633974483\n    >>> get_angle(1+1j)\n    0.7853981633974483\n    >>> get_angle(-1+1j)\n    1.5707963267948966\n    >>> get_angle(1-1j)\n    1.5707963267948966\n    >>> get_angle(0+0j)\n    0.0\n    \"\"\"\n    return float(\n        round(\n            (3.14 / 2)\n            - (float(round(abs(number.imag) / abs(number.real))) * 3.14 / 2),\n            15,\n        )\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "import math\n\n\ndef get_angle(complex_number):\n    \"\"\"\n    :param complex_number: a complex number\n    :return: angle of the complex number\n\n    >>> get_angle(complex(1, 1))\n    45.0\n    >>> get_angle(complex(1, -1))\n    -45.0\n    >>> get_angle(complex(1, 0))\n    90.0\n    \"\"\"\n    return math.degrees(math.atan2(complex_number.imag, complex_number.real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "def get_angle(complex_num: complex) -> float:\n    \"\"\"\n    >>> get_angle(3 + 4j)\n    0.374712\n    >>> get_angle(3 - 4j)\n    -0.374712\n    >>> get_angle(3 + 0j)\n    0\n    >>> get_angle(3 - 0j)\n    0\n    \"\"\"\n    return (\n        (\n            (complex_num.real ** 2 + complex_num.imag ** 2)\n            if complex_num.real < 0\n            else 0\n        )\n        + (complex_num.imag ** 2 if complex_num.imag > 0 else 0)\n    ) ** 0.5\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "def angle(z):\n    \"\"\"\n    >>> angle(3 + 4j)\n    1.3004918556681515\n    >>> angle(0)\n    0\n    >>> angle(1j)\n    0.7853981633974483\n    \"\"\"\n    if z == 0:\n        return 0\n    return atan2(z.imag, z.real)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "import math\n\n\ndef get_angle(complex_number):\n    \"\"\"\n    >>> get_angle(complex(1, 1))\n    45.0\n    >>> get_angle(complex(1, -1))\n    -45.0\n    >>> get_angle(complex(1, 0))\n    90.0\n    >>> get_angle(complex(-1, 0))\n    -90.0\n    \"\"\"\n    return math.degrees(math.atan2(complex_number.imag, complex_number.real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 42,
      "score": 9.0,
      "candidate": "from math import atan2\n\ndef angle(complex_num):\n    \"\"\"\n    :param complex_num: complex number\n    :return: angle of the complex number\n    \"\"\"\n    return atan2(complex_num.imag, complex_num.real)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 43,
      "score": 9.0,
      "candidate": "def get_angle(complex_number):\n    return (\n        (360 + (360 + (360 + (360 + (180 - 180 * (complex_number.real + complex_number.imag).as_triple()[2])) // 2)) // 2)\n        % 360\n    )\n\n\n# pylint: disable=wrong-import-position,wrong-import-order\nimport sys\nfrom qiskit import BasicAer\nfrom qiskit.utils import QuantumInstance\nfrom qiskit.circuit.library import QuantumVolume\nfrom qiskit.algorithms import QAOA\nfrom qiskit.optimization.applications.ising.max_cut import get_operator as maxcut_get_operator\nfrom qiskit.optimization.applications.ising.tsp import get_operator as tsp_get_operator\nfrom qiskit.optimization.applications.ising.graph_coloring import get_operator as graph_coloring_get_operator\nfrom qiskit.optimization.applications.ising.hamiltonian import get_operator as hamiltonian_get_operator\nfrom qiskit.optimization.applications.ising.set_packing import get_operator as set_packing_get_operator\nfrom qiskit.optimization.applications.ising.knapsack import get_operator as knapsack_get_operator\n\nsys.path.append(\"../../../../qiskit-optimization\")\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver\nfrom qiskit.optimization.algorithms import MinimumEigenOptimizer\nfrom qiskit.aqua.algorithms.adaptive import VQE\nfrom qiskit.aqua.components.optimizers import SPSA\nfrom qiskit.aqua.components.optimizers import COBYLA\nfrom qiskit.aqua.components.optimizers import L_BFGS_B\nfrom qiskit.aqua.components.optimizers import SLSQP\nfrom qiskit.aqua.components.optimizers import QNSPSA\nfrom qiskit.aqua.components."
    },
    {
      "rank": 44,
      "score": 9.0,
      "candidate": "def get_angle(complex_num):\n    return np.angle(complex_num)"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "def get_angle(c):\n    \"\"\"\n    :param c: int or float or complex\n    :return: angle in radians\n    \"\"\"\n    return c.__abs__() * c.__arg__()\n\n\nif __name__ == '__main__':\n    c = 1 + 2j\n    print(get_angle(c))"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "def get_angle(c):\n    \"\"\"\n    c is a complex number\n    returns the angle of c\n    \"\"\"\n    return cmath.atan(c.imag/c.real)\n\n\n\nprint(get_angle(complex(-1.0, 0.0)))\nprint(get_angle(complex(-1.0, 1.0)))\nprint(get_angle(complex(-1.0, -1.0)))\nprint(get_angle(complex(1.0, 0.0)))\nprint(get_angle(complex(1.0, 1.0)))\nprint(get_angle(complex(1.0, -1.0)))\nprint(get_angle(complex(0.0, 0.0)))\nprint(get_angle(complex(0.0, 1.0)))\nprint(get_angle(complex(0.0, -1.0)))"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "from typing import Union\n\nfrom gfg.maths.complex_numbers.ComplexNumbers import Complex\n\n\ndef get_angle(z: Complex) -> Union[float, str]:\n    \"\"\"\n    Angle between positive real axis and positive imaginary axis.\n    \"\"\"\n    if z.real == 0 and z.imag == 0:\n        return \"undefined\"\n\n    if z.imag < 0:\n        return 360 - (abs(z.imag) / z.real) * 90\n\n    return (abs(z.imag) / z.real) * 90\n\n\nif __name__ == \"__main__\":\n    z = Complex(0, 4)\n    print(get_angle(z))"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "def angle_of_complex(complex_number):\n    # If the number is real, return 0.\n    if complex_number.real == 0:\n        return 0\n    # If the number is purely imaginary, return 90 degrees.\n    if complex_number.real == 0 and complex_number.imag != 0:\n        return 90\n    # If the number is purely real, return 0.\n    if complex_number.imag == 0:\n        return 0\n    # If the number is purely imaginary, return 90 degrees.\n    if complex_number.real == 0 and complex_number.imag != 0:\n        return 90\n    # If the number is purely real, return 0.\n    if complex_number.imag == 0:\n        return 0\n    # If the number is purely imaginary, return 90 degrees.\n    if complex_number.real == 0 and complex_number.imag != 0:\n        return 90\n    # If the number is purely real, return 0.\n    if complex_number.imag == 0:\n        return 0\n    # If the number is purely imaginary, return 90 degrees.\n    if complex_number.real == 0 and complex_number.imag != 0:\n        return 90\n\n    # If the number is purely real, return 0.\n    if complex_number.imag == 0:\n        return 0\n\n    # If the number is purely imaginary, return 90 degrees.\n    if complex_number.real == 0 and complex_number.imag != 0:\n        return 90\n\n    # If the number is purely real, return 0.\n    if complex_number.imag == 0:\n        return 0\n\n    # If the number is purely imaginary, return 90 degrees.\n    if complex_number.real == 0 and complex_number.imag != 0:\n        return 90\n\n    # If the number is purely real, return 0.\n    if complex_number.imag == 0:\n        return 0"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def get_angle(number):\n    if number.real == 0:\n        if number.imag > 0:\n            return 90\n        elif number.imag < 0:\n            return 270\n        else:\n            return 0\n    elif number.real > 0:\n        if number.imag > 0:\n            return 180 - (90 * (number.real / abs(number.real)))\n        elif number.imag < 0:\n            return 180 + (90 * (number.real / abs(number.real)))\n        else:\n            return 90 * (number.real / abs(number.real))\n    elif number.real < 0:\n        if number.imag > 0:\n            return 90 - (180 * (abs(number.real) / abs(number.real)))\n        elif number.imag < 0:\n            return 270 + (180 * (abs(number.real) / abs(number.real)))\n        else:\n            return 270 * (abs(number.real) / abs(number.real))\n    else:\n        return 0\n\n\nprint(get_angle(complex(0, 1)))\nprint(get_angle(complex(1, 1)))\nprint(get_angle(complex(-1, 1)))\nprint(get_angle(complex(1, 0)))\nprint(get_angle(complex(0, 0)))\nprint(get_angle(complex(-1, 0)))\nprint(get_angle(complex(1, -1)))\nprint(get_angle(complex(-1, -1)))\nprint(get_angle(complex(0, -1)))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "def get_angle(number):\n    if number == 0:\n        return 0\n    return math.atan(number.imag / number.real)"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    :param complex_number:\n    :return: angle in degree\n    \"\"\"\n    angle = 0\n    if complex_number.real > 0:\n        angle = math.atan(complex_number.imag / complex_number.real)\n    elif complex_number.real < 0:\n        angle = math.atan(complex_number.imag / complex_number.real)\n        angle += math.pi\n    elif complex_number.real == 0:\n        if complex_number.imag > 0:\n            angle = math.pi / 2\n        else:\n            angle = -1 * math.pi / 2\n\n    return math.degrees(angle)\n\n\nprint(get_angle(complex(0, 1)))\nprint(get_angle(complex(1, 0)))\nprint(get_angle(complex(1, 1)))\nprint(get_angle(complex(1, -1)))\nprint(get_angle(complex(2, 2)))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    complex_number: a complex number\n\n    returns: angle in degrees\n    \"\"\"\n    angle = math.degrees(math.atan2(complex_number.imag, complex_number.real))\n    if angle < 0:\n        angle = 360 + angle\n    return angle\n\n\nif __name__ == '__main__':\n    import math\n    print get_angle(complex(3, 4))\n    print get_angle(complex(2, 0))\n    print get_angle(complex(1, -1))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "def angle_of_complex(complex_number):\n    \"\"\"\n    :param complex_number: complex number\n    :return: angle in degree\n    \"\"\"\n    return round(math.degrees(cmath.phase(complex_number)), 2)"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "def get_angle(real, imag):\n    angle = 0\n    if real == 0 and imag > 0:\n        return 90\n    elif real == 0 and imag < 0:\n        return -90\n    elif real > 0 and imag == 0:\n        return 0\n    elif real < 0 and imag == 0:\n        return 180\n    elif real > 0 and imag > 0:\n        angle = math.atan(imag / real) * 180 / math.pi\n    elif real < 0 and imag > 0:\n        angle = 180 + (math.atan(imag / real) * 180 / math.pi)\n    elif real < 0 and imag < 0:\n        angle = 180 + (math.atan(imag / real) * 180 / math.pi)\n    elif real > 0 and imag < 0:\n        angle = 360 + (math.atan(imag / real) * 180 / math.pi)\n    return angle"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    Return the angle of a complex number.\n    \"\"\"\n    return (math.atan2(complex_number.imag, complex_number.real)) * (180 / math.pi)"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "def get_angle(c):\n    \"\"\"\n    :param c: complex\n    :return: angle in degrees\n    \"\"\"\n    return round(math.degrees(math.atan(c.imag/c.real)))"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "def get_angle(num):\n    \"\"\"\n    num: int or float\n    return: float\n    \"\"\"\n    return round(atan(num.imag / num.real), 2)\n\n\nif __name__ == '__main__':\n    print(get_angle(complex(1, 1)))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "def angle_of_complex(a_complex):\n    \"\"\"\n    >>> angle_of_complex(3+3j)\n    45\n    >>> angle_of_complex(1+2j)\n    45\n    \"\"\"\n    return round(abs(a_complex.imag/a_complex.real), 2)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "import math\n\ndef get_angle(z):\n    return math.atan2(z.imag, z.real)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "def get_angle(z):\n    return math.atan2(z.imag, z.real)\n\n# Additional Implementation\n\nimport cmath\n\ndef get_angle(z):\n    return cmath.phase(z)"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "def get_angle(number):\n    \"\"\"\n    >>> get_angle(1 + 2j)\n    1.107149\n    >>> get_angle(2 + 3j)\n    1.244047\n    \"\"\"\n    return float(atan2(number.imag, number.real))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "def angle(a: complex) -> float:\n    return float(cmath.phase(a))\n\n\nif __name__ == \"__main__\":\n    print(angle(complex(1, 1)))"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "from math import atan2\n\n\ndef get_angle(number):\n    \"\"\"\n    :param number: complex number\n    :return: angle of the number\n    \"\"\"\n    return atan2(number.imag, number.real)\n\n\nif __name__ == '__main__':\n    print(get_angle(complex(1, 1)))\n    print(get_angle(complex(1, 0)))\n    print(get_angle(complex(0, 1)))\n    print(get_angle(complex(-1, 1)))\n    print(get_angle(complex(-1, 0)))\n    print(get_angle(complex(0, -1)))"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "import math\n\n\ndef get_angle(complex_num):\n    return math.degrees(math.atan(complex_num.imag/complex_num.real))\n\n\nif __name__ == \"__main__\":\n    from complex import ComplexNumber\n\n    num1 = ComplexNumber(3, 1)\n    num2 = ComplexNumber(3, -1)\n    print(f\"The angle of {num1} is {get_angle(num1)}\")\n    print(f\"The angle of {num2} is {get_angle(num2)}\")"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "def get_angle(real, imag):\n    \"\"\"\n    >>> get_angle(3, 3)\n    45\n    >>> get_angle(1, -1)\n    -45\n    >>> get_angle(3, -3)\n    135\n    >>> get_angle(-1, -1)\n    180\n    >>> get_angle(0, 1)\n    90\n    >>> get_angle(-1, 0)\n    180\n    >>> get_angle(0, -1)\n    -90\n    >>> get_angle(0, 0)\n    0\n    \"\"\"\n    if imag == 0:\n        if real > 0:\n            return 0\n        elif real < 0:\n            return 180\n        else:\n            return 90 if real == 0 else 0\n    if imag > 0:\n        return (math.degrees(math.atan(real/imag)) + 360) % 360\n    return (math.degrees(math.atan(real/imag))) % 360\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "def get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(3+5j)\n    0.7853981633974483\n    >>> get_angle(0+5j)\n    1.5707963267948966\n    >>> get_angle(1+0j)\n    0.0\n    >>> get_angle(1j)\n    1.5707963267948966\n    \"\"\"\n    return (360 * (atan(complex_num.imag / complex_num.real) / 2 / pi))"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "# Solution\ndef get_angle(complex_number):\n    return ((complex_number.real**2 + complex_number.imag**2)**0.5).atan2(complex_number.real)\n\n# Test\ncomplex_num = complex(3, 3)\nangle = get_angle(complex_num)\nprint(angle)"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "import math\n\n\ndef get_angle(x, y):\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += math.pi * 2\n    return math.degrees(angle)"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "from math import atan2\n\n\ndef get_angle(complex_number):\n    \"\"\"\n    Returns the angle of the complex number.\n    \"\"\"\n    return atan2(complex_number.imag, complex_number.real)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "import math\n\ndef get_angle(z):\n    \"\"\"Returns the angle of a complex number.\n\n    Parameters\n    ----------\n    z : complex\n        A complex number\n\n    Returns\n    -------\n    float\n        The angle of the complex number\n    \"\"\"\n    return math.degrees(math.atan(z.imag/z.real))\n\nprint(get_angle(complex(1, 1)))\nprint(get_angle(complex(1, 2)))\nprint(get_angle(complex(2, 3)))\nprint(get_angle(complex(3, 4)))"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "from math import atan2\n\n\ndef get_angle(real, imag):\n    return atan2(imag, real)\n\n\ndef main():\n    print(get_angle(3, 3))\n    print(get_angle(0, 3))\n    print(get_angle(3, 0))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "def get_angle(number):\n    return (number.imag / number.real)"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "import math\n\n\ndef get_angle(number):\n    return math.atan2(number.imag, number.real)\n\n\nif __name__ == '__main__':\n    print(get_angle(complex(0, 1)))"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "import math\n\ndef get_angle(x):\n    \"\"\"\n    >>> get_angle(complex(-1, 0))\n    3.141592653589793\n    >>> get_angle(complex(-1, 1))\n    2.356194490192345\n    >>> get_angle(complex(1, 1))\n    0.7853981633974483\n    \"\"\"\n    return math.atan2(x.imag, x.real)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "def get_angle(complex_num: complex) -> float:\n    \"\"\"\n    >>> get_angle(3+5j)\n    0.3217505543966445\n    \"\"\"\n    return float(atan2(complex_num.imag, complex_num.real))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "def angle(complex_number):\n    return (\n        (\n            (complex_number.real ** 2 + complex_number.imag ** 2)\n            ** 0.5\n        )\n        * (\n            (complex_number.real ** 2 + complex_number.imag ** 2)\n            ** 0.5\n        )\n        * (\n            complex_number.real\n            / (complex_number.real ** 2 + complex_number.imag ** 2) ** 0.5\n            * complex_number.imag\n            / (complex_number.real ** 2 + complex_number.imag ** 2) ** 0.5\n        )\n    )"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "def get_angle(z):\n    \"\"\"\n    >>> get_angle(3 + 3j)\n    45\n    >>> get_angle(1 - 1j)\n    -45\n    \"\"\"\n    return round(math.degrees(cmath.phase(z)), 0)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "def get_angle(complex):\n    angle = 0\n    if complex[0] != 0:\n        angle = math.atan(complex[1] / complex[0])\n    elif complex[1] > 0:\n        angle = math.pi / 2\n    elif complex[1] < 0:\n        angle = -math.pi / 2\n    return angle"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "import math\n\ndef get_angle(number):\n    return math.degrees(math.atan(number.imag/number.real))\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "def get_angle(c):\n    \"\"\"\n    :param c: complex number\n    :type c: float\n    :return: angle in radians\n    :rtype: float\n    \"\"\"\n    return cmath.phase(c)\n\n\nif __name__ == '__main__':\n    print(get_angle(complex(1, 1)))"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "def angle(complex_num):\n    return atan2(complex_num.imag, complex_num.real)\n\n\nif __name__ == '__main__':\n    print(angle(complex(-4, 3)))"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "from math import atan2\n\n\ndef get_angle(real, imag):\n    return atan2(imag, real) * 180 / 3.14159\n\n\ndef main():\n    real = float(input(\"Enter the real part: \"))\n    imag = float(input(\"Enter the imaginary part: \"))\n\n    print(f\"The angle is {get_angle(real, imag)} degrees\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "import math\nimport unittest\n\n\ndef get_angle(complex_number):\n    \"\"\"\n    Return the angle of a complex number.\n    :param complex_number: a complex number\n    :return: angle in degrees\n    \"\"\"\n    real = complex_number.real\n    imag = complex_number.imag\n\n    angle = math.atan2(imag, real) * (180 / math.pi)\n\n    if angle < 0:\n        angle = 360 + angle\n\n    return angle\n\n\nclass TestGetAngle(unittest.TestCase):\n    def test_get_angle(self):\n        self.assertEqual(get_angle(complex(1, 0)), 0)\n        self.assertEqual(get_angle(complex(0, 1)), 90)\n        self.assertEqual(get_angle(complex(1, 1)), 45)\n        self.assertEqual(get_angle(complex(-1, 1)), 135)\n        self.assertEqual(get_angle(complex(-1, -1)), 225)\n        self.assertEqual(get_angle(complex(-1, 0)), 180)\n\n\nif __name__ == \"__main__\":\n    unittest.main()"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "from math import atan2\n\ndef get_angle(z):\n    \"\"\"\n    Return the angle of a complex number.\n    \"\"\"\n    return atan2(z.imag, z.real)"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "def get_angle(num):\n    return 0 if num == 0 else atan2(num.imag, num.real)\n\ndef main():\n    print(get_angle(complex(2, 0)))\n    print(get_angle(complex(0, 2)))\n    print(get_angle(complex(1, 1)))\n    print(get_angle(complex(2, 1)))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 86,
      "score": 8.0,
      "candidate": "def angle_of_complex_number(complex_number):\n    return (atan2(complex_number.imag, complex_number.real)) * (180 / pi)\n\n\ndef atan2(y, x):\n    if x > 0:\n        return atan(y / x)\n    elif x < 0:\n        if y >= 0:\n            return atan(y / x) + pi\n        else:\n            return atan(y / x) - pi\n    elif x == 0:\n        if y > 0:\n            return pi / 2\n        elif y < 0:\n            return -pi / 2\n        elif y == 0:\n            return 0\n    return 0\n\n\ndef atan(y):\n    return pi / 2 - 2 * atan(y / (1 + sqrt(1 + y ** 2)))\n\n\ndef pi():\n    return 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
    },
    {
      "rank": 87,
      "score": 8.0,
      "candidate": "def get_angle(num):\n    return math.atan2(num.imag, num.real)\n\n\"\"\"\nWrite a function to get the area of a circle given its radius.\n\"\"\"\n\ndef get_area(radius):\n    return math.pi * radius ** 2\n\n\"\"\"\nWrite a function to get the circumference of a circle given its radius.\n\"\"\"\n\ndef get_circumference(radius):\n    return 2 * math.pi * radius\n\n\"\"\"\nWrite a function to get the length of a vector given its coordinates.\n\"\"\"\n\ndef get_vector_length(x, y):\n    return math.sqrt(x ** 2 + y ** 2)\n\n\"\"\"\nWrite a function to get the distance between two points.\n\"\"\"\n\ndef get_distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n\"\"\"\nWrite a function to get the distance between two points given their coordinates.\n\"\"\"\n\ndef get_distance_between_points(p1, p2):\n    return math.sqrt((p1.real - p2.real) ** 2 + (p1.imag - p2.imag) ** 2)\n\n\"\"\"\nWrite a function to get the distance between two points given their coordinates.\n\"\"\"\n\ndef get_distance_between_points(p1, p2):\n    return math.sqrt((p1.real - p2.real) ** 2 + (p1.imag - p2.imag) ** 2)\n\n\"\"\"\nWrite a function to get the midpoint of two points given their coordinates.\n\"\"\"\n\ndef get_midpoint(p1, p2):\n    return (p1 + p2) / 2\n\n\"\"\"\nWrite a function to get the midpoint of a line given two points.\n\"\"\"\n\ndef get_midpoint_of_line(p1, p2):\n    return get_midpoint(p1, p2)\n\n\"\"\"\nWrite a function to get the midpoint of a line given its two endpoints."
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "def get_angle(complex_number):\n    return round(math.degrees(math.atan(complex_number.imag/complex_number.real)))\n\n\n# Simple Tests\nassert get_angle(complex(-3, 3)) == 120\nassert get_angle(complex(0, 1)) == 90\nassert get_angle(complex(0, -1)) == -90\nassert get_angle(complex(1, 0)) == 0\nassert get_angle(complex(-1, 0)) == 180\nassert get_angle(complex(1, 1)) == 45\nassert get_angle(complex(-1, -1)) == -135\nassert get_angle(complex(-1, 1)) == -135\nassert get_angle(complex(1, -1)) == 135"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def angle_of_complex(complex_number):\n    return (\n        (math.atan2(complex_number.imag, complex_number.real) * 180) / math.pi\n    )\n\n\nif __name__ == \"__main__\":\n    import unittest\n    from random import randint\n\n    class SolutionTestCase(unittest.TestCase):\n        def test_angle_of_complex_number(self):\n            for _ in range(1000):\n                real = randint(-100, 100)\n                imag = randint(-100, 100)\n                complex_number = complex(real, imag)\n                self.assertAlmostEqual(\n                    angle_of_complex(complex_number),\n                    cmath.phase(complex_number),\n                    delta=0.0001,\n                )\n\n    unittest.main()"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# Solution 1\n# def get_angle(complex_number):\n#     angle = 0\n#     if complex_number[0] != 0:\n#         if complex_number[0] > 0:\n#             angle = math.atan(complex_number[1] / complex_number[0])\n#         else:\n#             angle = math.atan(complex_number[1] / complex_number[0]) + math.pi\n#     return angle\n\n\n# Solution 2\ndef get_angle(complex_number):\n    return cmath.phase(complex_number)\n\n\nprint(get_angle((2 + 2j)))\nprint(get_angle((-1 + -1j)))\nprint(get_angle((1 + 1j)))\nprint(get_angle((-1 + 1j)))\nprint(get_angle((1 + -1j)))\nprint(get_angle((-1 + -1j)))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def get_angle(complex_num):\n    return math.atan2(complex_num.imag, complex_num.real)\n\n\nclass ComplexNumber:\n    def __init__(self, real, imaginary):\n        self.real = real\n        self.imaginary = imaginary\n\n\nclass Solution:\n    def complexNumberMultiply(self, a, b):\n        real = (a.real * b.real - a.imaginary * b.imaginary)\n        imaginary = (a.real * b.imaginary + a.imaginary * b.real)\n\n        return ComplexNumber(real, imaginary)\n\n\nclass Solution2:\n    def complexNumberMultiply(self, a, b):\n        return complex(a.real, a.imaginary) * complex(b.real, b.imaginary)"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def get_angle(complex_num):\n    return 0\n\n\nprint(get_angle(complex(-2, 3)))\nprint(get_angle(complex(1, -1)))\nprint(get_angle(complex(1, 1)))\nprint(get_angle(complex(1, 0)))\nprint(get_angle(complex(1, 3)))\nprint(get_angle(complex(1, -3)))\nprint(get_angle(complex(-1, 3)))\nprint(get_angle(complex(-1, -3)))\nprint(get_angle(complex(0, 1)))\nprint(get_angle(complex(0, -1)))\nprint(get_angle(complex(0, 0)))\nprint(get_angle(complex(0, 4)))\nprint(get_angle(complex(0, -4)))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "def angle_of_complex(complex_number):\n    \"\"\"\n    >>> angle_of_complex(complex(-1, 0))\n    3.141592653589793\n    >>> angle_of_complex(complex(0, 1))\n    1.5707963267948966\n    >>> angle_of_complex(complex(1, 1))\n    0.7853981633974483\n    >>> angle_of_complex(complex(-1, 1))\n    2.356194490192345\n    \"\"\"\n    return abs(complex_number)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def get_angle(z):\n    return -math.atan2(z.imag, z.real)\n\n\nif __name__ == '__main__':\n    import math\n    import unittest\n\n    class Test(unittest.TestCase):\n        def test(self):\n            z = complex(1, 1)\n            self.assertEqual(get_angle(z), math.pi/4)\n            z = complex(1, -1)\n            self.assertEqual(get_angle(z), math.pi*3/4)\n\n    unittest.main()"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "def get_angle(complex_number):\n    \"\"\"\n    >>> get_angle(1+2j)\n    1.107149\n    >>> get_angle(-1+2j)\n    2.356194\n    \"\"\"\n    x, y = complex_number.real, complex_number.imag\n    return round(\n        ((x * x + y * y) ** 0.5) * ((x * y) / ((x * x + y * y) ** 0.5)), 6\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from typing import Tuple\n\n\ndef get_angle(complex_num: complex) -> Tuple[float, str]:\n    \"\"\"Gets the angle of a complex number.\n\n    Args:\n        complex_num (complex): the complex number\n\n    Returns:\n        Tuple[float, str]: the angle and its sign\n    \"\"\"\n    angle = float(atan2(complex_num.imag, complex_num.real))\n    if angle < 0:\n        return (abs(angle) * -1, \"\u00b0\",)\n    return (angle, \"\u00b0\",)"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "def get_angle(complex_num: complex) -> float:\n    \"\"\"Get angle of a complex number.\n\n    Args:\n        complex_num (complex): Complex number.\n\n    Returns:\n        float: angle of the complex number in degrees.\n\n    Examples:\n        >>> assert get_angle(complex(1, 1)) == 45\n        >>> assert get_angle(complex(1, -1)) == -45\n        >>> assert get_angle(complex(-1, -1)) == -135\n        >>> assert get_angle(complex(-1, 1)) == 135\n    \"\"\"\n    return round(\n        (\n            round(\n                abs(\n                    complex_num.real / complex_num.imag\n                ) * 180 / 3.14159265359, 2\n            )\n        ), 2\n    )\n\n\nif __name__ == \"__main__\":\n    print(get_angle(complex(1, 1)))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# Solution\ndef get_angle(complex_num):\n    \"\"\"\n    >>> get_angle(complex(1, 0))\n    0\n    >>> get_angle(complex(0, 1))\n    pi / 2\n    >>> get_angle(complex(-1, 0))\n    pi\n    >>> get_angle(complex(0, -1))\n    -pi / 2\n    \"\"\"\n    return abs(complex_num) * (complex_num.imag / abs(complex_num.imag))\n\n\n# Tests\nclass TestGetAngle(unittest.TestCase):\n\n    def test_get_angle(self):\n        self.assertEqual(get_angle(complex(1, 0)), 0)\n        self.assertEqual(get_angle(complex(0, 1)), math.pi / 2)\n        self.assertEqual(get_angle(complex(-1, 0)), math.pi)\n        self.assertEqual(get_angle(complex(0, -1)), -math.pi / 2)\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def get_angle(c):\n    return (c.imag / c.real) * 180 / 3.14\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from typing import Tuple\n\n\ndef get_angle(complex_num: Tuple[int, int]) -> float:\n    \"\"\"Returns the angle of a complex number.\n\n    Args:\n        complex_num (Tuple[int, int]): A complex number.\n\n    Examples:\n        >>> assert get_angle((5, 0)) == 0\n        >>> assert get_angle((5, 5)) == 45\n    \"\"\"\n    return round(\n        (180 / 3.14159) * (3.14159 / 2 + (complex_num[1] / complex_num[0])),\n        2,\n    )\n\n\nif __name__ == \"__main__\":\n    print(get_angle((5, 0)))\n    print(get_angle((5, 5)))"
    }
  ]
}