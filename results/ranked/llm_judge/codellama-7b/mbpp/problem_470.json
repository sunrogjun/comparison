{
  "timestamp": "2025-09-15T01:52:01.670122",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "mbpp",
  "problem_number": 470,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from typing import List, Set, Tuple\n\n\ndef can_partition_rec(nums: List[int], target: int, idx: int) -> bool:\n    if target == 0:\n        return True\n    if target < 0 or idx >= len(nums):\n        return False\n\n    return can_partition_rec(nums, target, idx + 1) or can_partition_rec(\n        nums, target - nums[idx], idx + 1\n    )\n\n\ndef can_partition_dp(nums: List[int], target: int) -> bool:\n    n = len(nums)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j] or (\n                j >= nums[i - 1] and dp[i - 1][j - nums[i - 1]]\n            )\n\n    return dp[-1][-1]\n\n\ndef can_partition_memo(nums: List[int], target: int) -> bool:\n    n = len(nums)\n    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]\n    memo: Set[Tuple[int, int]] = set()\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if (i - 1, j) in memo:\n                dp[i][j] = True\n            else:\n                dp[i][j] = dp[i - 1][j] or (\n                    j >= nums[i - 1] and dp[i - 1][j - nums[i - 1]]"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "def subset_sum(arr, s):\n    \"\"\"\n    Time Complexity: O(n * s)\n    Space Complexity: O(s)\n    \"\"\"\n    n = len(arr)\n\n    # dp[i][j] : True if there is a subset of arr[:i] with sum equal to j\n    dp = [[False for j in range(s+1)] for i in range(n+1)]\n\n    # if sum is 0 then there is a subset with sum 0\n    for i in range(1, n+1):\n        dp[i][0] = True\n\n    # if sum is not 0 and arr[i-1] is 0 then there is no subset with sum != 0\n    for j in range(1, s+1):\n        dp[0][j] = False\n\n    # Fill dp table in bottom up manner\n    for i in range(1, n+1):\n        for j in range(1, s+1):\n            # if arr[i-1] > j then there is no way to get sum j using arr[:i]\n            # if arr[i-1] == j then there is a way to get sum j using arr[:i]\n            # else check if there is a way using arr[:i-1]\n            dp[i][j] = (arr[i-1] > j) or (arr[i-1] == j) or dp[i-1][j]\n\n    return dp[n][s]\n\n\ndef subset_sum_optimized(arr, s):\n    \"\"\"\n    Time Complexity: O(n * s)\n    Space Complexity: O(s)\n    \"\"\"\n    n = len(arr)\n\n    # dp[j] : True if there is a subset of arr with sum equal to j\n    dp = [False] * (s+1)\n    dp[0] = True\n\n    # Fill dp table in bottom up manner\n    for i in range(1, n+1):\n        for j in range(s, -1, -1):\n            if dp[j] or (arr[i-1] <= j and"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "from typing import List\n\n\n# O(2^n) time | O(n) space\ndef subset_sum_exists(array: List[int], k: int) -> bool:\n    return subset_sum_helper(array, k, set())\n\n\ndef subset_sum_helper(array: List[int], k: int, subset: set) -> bool:\n    if k == 0:\n        return True\n    for index, num in enumerate(array):\n        if num > k:\n            continue\n        if num in subset:\n            continue\n        if subset_sum_helper(array[index + 1:], k - num, subset | {num}):\n            return True\n    return False\n\n\n# O(n) time | O(n) space\ndef subset_sum_exists2(array: List[int], k: int) -> bool:\n    possible_sums = {0}\n    for num in array:\n        possible_sums = possible_sums | {possible_sum + num for possible_sum in possible_sums}\n    return k in possible_sums\n\n\nif __name__ == \"__main__\":\n    print(subset_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 13))\n    print(subset_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 10))\n    print(subset_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 2))\n    print(subset_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 9))\n    print(subset_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 11))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef is_subset_sum(arr, n, s):\n    dp = defaultdict(bool)\n    dp[0] = True\n    for i in range(n):\n        for j in range(s, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n    return dp[s]\n\n\ndef main():\n  print(\"Is there a subset with sum equal to the given sum? \" +\n        str(is_subset_sum([2, 3, 7, 8, 10], 5, 12)))\n  print(\"Is there a subset with sum equal to the given sum? \" +\n        str(is_subset_sum([2, 3, 7, 8, 10], 5, 11)))\n\n\nmain()\n\n\n\"\"\"\nTime O(N*S)\nSpace O(S)\n\"\"\""
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef subset_sum(arr, s):\n    \"\"\"\n    Returns True if there is a subset of arr that sums up to s.\n    \"\"\"\n    n = len(arr)\n\n    # Calculate all the possible sums of subarrays of the given array.\n    sum_arr = [0] * (n + 1)\n    for i in range(1, n + 1):\n        sum_arr[i] = sum_arr[i - 1] + arr[i - 1]\n\n    # Use a dictionary to store the sum as the key and the index of the last\n    # element as the value.\n    d = defaultdict(int)\n    for i in range(n):\n        # If the current sum is equal to s, return True.\n        if sum_arr[i] == s:\n            return True\n        # If the current sum is less than s, store it in the dictionary.\n        elif sum_arr[i] < s:\n            d[sum_arr[i]] = i\n\n    # For all the sums greater than s, check if the difference is present in the dictionary.\n    for i in range(n + 1):\n        if sum_arr[i] > s:\n            if s - sum_arr[i] in d:\n                return True\n\n    return False\n\n\ndef test_subset_sum():\n    \"\"\"\n    >>> test_subset_sum()\n    True\n    True\n    True\n    True\n    True\n    True\n    False\n    \"\"\"\n    assert subset_sum([1, 2, 3], 0)\n    assert subset_sum([1, 2, 3], 1)\n    assert subset_sum([1, 2, 3], 2)\n    assert subset_sum([1, 2, 3], 3)\n    assert subset_sum([1, 2, 3], 4)\n    assert subset_sum([1, 2, 3], 5)\n    assert subset_sum([1, 2, 3], 6) is False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest."
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "def can_sum(target_sum: int, numbers: list) -> bool:\n    \"\"\"\n    The most naive solution is to recursively call the function for each element in the list.\n    Time Complexity: O(n^m)\n    Space Complexity: O(n)\n    \"\"\"\n    if target_sum == 0:\n        return True\n    if target_sum < 0:\n        return False\n\n    for number in numbers:\n        remainder = target_sum - number\n        if can_sum(remainder, numbers):\n            return True\n    return False\n\n\ndef can_sum_dp(target_sum: int, numbers: list) -> bool:\n    \"\"\"\n    The solution is based on the concept of Dynamic Programming.\n    Time Complexity: O(n*m)\n    Space Complexity: O(n*m)\n    \"\"\"\n    dp_table = [[False for _ in range(target_sum + 1)] for _ in range(len(numbers))]\n\n    # Fill the first row with True\n    for j in range(target_sum + 1):\n        if j == 0:\n            dp_table[0][j] = True\n\n    # Fill the first column with False\n    for i in range(len(numbers)):\n        dp_table[i][0] = False\n\n    for i in range(1, len(numbers)):\n        for j in range(1, target_sum + 1):\n            if j >= numbers[i]:\n                dp_table[i][j] = dp_table[i - 1][j] or dp_table[i - 1][j - numbers[i]]\n            else:\n                dp_table[i][j] = dp_table[i - 1][j]\n\n    return dp_table[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert can_sum(7, [2, 3]) == True\n    assert can_sum(7, [5, 3, 4, 7]) == True\n    assert can_sum(7, [2, 4]) == False\n    assert can_sum("
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef subset_sum(arr, target):\n    if not arr:\n        return False\n\n    dp = defaultdict(bool)\n    dp[0] = True\n\n    for i in range(len(arr)):\n        for j in range(target, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n\n    return dp[target]\n\n\nif __name__ == \"__main__\":\n    print(subset_sum([2, 3, 5, 5, 6], 10))\n    print(subset_sum([2, 3, 5, 5, 6], 11))\n    print(subset_sum([2, 3, 5, 5, 6], 8))\n    print(subset_sum([2, 3, 5, 5, 6], 2))"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "def subset_sum(numbers: list, target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    Space Complexity: O(sum)\n    \"\"\"\n    cache = [False] * (target + 1)\n    cache[0] = True\n\n    for num in numbers:\n        for idx in range(target, num - 1, -1):\n            cache[idx] = cache[idx] or cache[idx - num]\n\n    return cache[target]\n\n\nif __name__ == \"__main__\":\n    print(subset_sum([3, 34, 4, 12, 5, 2], 9))"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef find_sum_subset(given_set, sum):\n    \"\"\"\n    :param given_set: list of integers\n    :param sum: integer\n    :return: True if there is a subset with sum equal to the given sum\n    \"\"\"\n    if sum == 0:\n        return True\n    elif len(given_set) == 0:\n        return False\n    elif sum < 0:\n        return False\n    else:\n        return find_sum_subset(given_set[1:], sum) or find_sum_subset(given_set[1:], sum - given_set[0])\n\n\ndef find_sum_subset_rec(given_set, sum):\n    \"\"\"\n    :param given_set: list of integers\n    :param sum: integer\n    :return: True if there is a subset with sum equal to the given sum\n    \"\"\"\n    return find_sum_subset_rec_util(given_set, sum, 0, 0, set())\n\n\ndef find_sum_subset_rec_util(given_set, sum, current_sum, index, result):\n    \"\"\"\n    :param given_set: list of integers\n    :param sum: integer\n    :param current_sum: integer\n    :param index: integer\n    :param result: set\n    :return: True if there is a subset with sum equal to the given sum\n    \"\"\"\n    if current_sum == sum:\n        result.add(tuple(sorted(given_set[:index])))\n        return True\n    if index == len(given_set):\n        return False\n\n    find_sum_subset_rec_util(given_set, sum, current_sum + given_set[index], index + 1, result)\n    find_sum_subset_rec_util(given_set, sum, current_sum, index + 1, result)\n\n    return False\n\n\ndef find_sum_subset_rec_memo(given_set, sum):\n    \"\"\"\n    :param given_set: list of integers\n    :param sum: integer\n    :return: True if there is a subset with sum equal"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from typing import List, Dict\n\n\ndef can_subset_sum(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*s)\n    Space Complexity: O(s)\n    \"\"\"\n    if target == 0:\n        return True\n\n    subset: Dict[int, bool] = {0: True}\n\n    for num in arr:\n        for subset_sum in subset:\n            if subset[subset_sum] and num + subset_sum <= target:\n                subset[num + subset_sum] = True\n            elif num + subset_sum > target:\n                break\n\n    return subset.get(target, False)\n\n\nif __name__ == \"__main__\":\n    print(can_subset_sum([1, 2, 3, 3], 6))\n    print(can_subset_sum([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                         1, 1, 1, 1"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "from typing import List\n\n\ndef is_subset_with_sum(set_: List[int], sum_: int) -> bool:\n    \"\"\"\n    Return true if there is a subset of the given set with sum equal to the given sum.\n    >>> is_subset_with_sum([1, 2, 3, 3], 6)\n    True\n    >>> is_subset_with_sum([1, 2, 3, 4], 6)\n    False\n    >>> is_subset_with_sum([1, 2, 3, 4], 8)\n    True\n    >>> is_subset_with_sum([1, 2, 3, 4], 7)\n    False\n    \"\"\"\n    if sum_ == 0:\n        return True\n    elif sum_ < 0:\n        return False\n    elif len(set_) == 0:\n        return sum_ == 0\n\n    if set_[0] > sum_:\n        return is_subset_with_sum(set_[1:], sum_)\n    else:\n        return (\n            is_subset_with_sum(set_[1:], sum_ - set_[0])\n            or is_subset_with_sum(set_[1:], sum_)\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "from collections import defaultdict\n\n\ndef is_subset_sum(arr, s):\n    if not arr:\n        return False\n    sum_arr = sum(arr)\n    if sum_arr < s:\n        return False\n\n    dp = defaultdict(bool)\n    dp[0] = True\n\n    for i in range(len(arr)):\n        for j in range(s, arr[i] - 1, -1):\n            if dp[j - arr[i]]:\n                dp[j] = True\n\n    return dp[s]\n\n\nprint(is_subset_sum([1, 2, 3, 3], 6))\nprint(is_subset_sum([1, 2, 7, 1, 5], 10))\nprint(is_subset_sum([1, 3, 10, 4, 7], 17))\nprint(is_subset_sum([1, 5, 11, 5], 10))"
    },
    {
      "rank": 13,
      "score": 8.0,
      "candidate": "from typing import List, Set\n\n\ndef is_subset_with_sum(given_set: Set, given_sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    if not given_set:\n        return False\n\n    for subset in powerset(given_set):\n        if sum(subset) == given_sum:\n            return True\n\n    return False\n\n\ndef powerset(given_set: Set) -> Set:\n    \"\"\"\n    Time Complexity: O(2^n)\n    \"\"\"\n    if not given_set:\n        return {frozenset()}\n\n    first_element = next(iter(given_set))\n    smaller_set = given_set.difference(frozenset({first_element}))\n\n    subsets = powerset(smaller_set)\n\n    subsets.update([subset.union(frozenset({first_element})) for subset in subsets])\n\n    return subsets\n\n\nif __name__ == \"__main__\":\n    assert is_subset_with_sum(given_set={1, 2, 3, 4}, given_sum=6) is True\n    assert is_subset_with_sum(given_set={1, 2, 3, 4}, given_sum=7) is False\n    assert is_subset_with_sum(given_set={1, 2, 3, 4}, given_sum=8) is False\n    assert is_subset_with_sum(given_set={1, 2, 3, 4}, given_sum=9) is False\n    assert is_subset_with_sum(given_set={1, 2, 3, 4}, given_sum=10) is False\n\n    assert is_subset_with_sum(given_set={1, 1, 2, 3, 4}, given_sum=6) is True\n    assert is_subset_with_sum(given_set={1, 1, 2, 3, 4}, given_sum=7) is True\n    assert is_subset_with_sum(given_"
    },
    {
      "rank": 14,
      "score": 8.0,
      "candidate": "from typing import Set\n\n\ndef subset_with_given_sum(arr: list, s: int) -> bool:\n    \"\"\"\n    Use Dynamic Programming.\n    Let us consider the array to be of size n.\n    Let us consider the array to be of size n+1.\n    Let us consider the array to be of size n+2.\n    ...\n    ...\n    Let us consider the array to be of size n+s.\n\n    If we consider the array to be of size n,\n    we can get the sum of the elements in the subset\n    by adding the elements of the subset of the array of size n+1.\n    If we consider the array to be of size n+1,\n    we can get the sum of the elements in the subset\n    by adding the elements of the subset of the array of size n+2.\n    ...\n    ...\n    If we consider the array to be of size n+s,\n    we can get the sum of the elements in the subset\n    by adding the elements of the subset of the array of size n+s+1.\n\n    So, we can use the result of subset_with_given_sum()\n    for n+1 to n+s to solve the problem.\n    \"\"\"\n\n    def subset_sum(arr, s, n, sum_arr):\n        # Base case\n        if n == 0:\n            return sum_arr[n]\n\n        # If the sum of the elements in the subset\n        # is equal to the given sum, return True.\n        if sum_arr[n] == s:\n            return True\n\n        # If the sum of the elements in the subset\n        # is not equal to the given sum, return False.\n        if sum_arr[n] != s:\n            return False\n\n        # If the sum of the elements in the subset\n        # is not equal to the given sum, return False.\n        for i in range(1, n + 1):\n            if subset_sum(arr, s, n - i, sum_arr):\n                return True\n\n        return False\n\n    # The array is of size n.\n    n = len(arr)\n    # The array is of size n+1."
    },
    {
      "rank": 15,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef subset_sum(data: List[int], sum_: int) -> bool:\n    \"\"\"\n    Backtracking solution.\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not data:\n        return False\n\n    if sum(data) < sum_:\n        return False\n\n    if sum(data) == sum_:\n        return True\n\n    data = sorted(data)\n    return backtracking(data, 0, sum_)\n\n\ndef backtracking(data: List[int], index: int, sum_: int) -> bool:\n    if sum(data[index:]) == sum_:\n        return True\n\n    if sum(data[index:]) < sum_:\n        return False\n\n    for i in range(index, len(data)):\n        if i != index and data[i] == data[i - 1]:\n            continue\n        if backtracking(data, i + 1, sum_):\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    assert subset_sum([1, 2, 3, 6], 6) is True\n    assert subset_sum([1, 2, 3, 6], 7) is False"
    },
    {
      "rank": 16,
      "score": 8.0,
      "candidate": "def find_sum(arr, sum):\n    arr.sort()\n    size = len(arr)\n    for i in range(size):\n        curr_sum = arr[i]\n        if curr_sum > sum:\n            break\n        elif curr_sum == sum:\n            return True\n        elif curr_sum < sum:\n            right = size - 1\n            while right > i:\n                curr_sum += arr[right]\n                if curr_sum == sum:\n                    return True\n                elif curr_sum > sum:\n                    break\n                right -= 1\n    return False\n\n\ndef main():\n    print(\"Sum found: \" + str(find_sum([1, 2, 3, 7, 5], 12)))\n    print(\"Sum found: \" + str(find_sum([1, 2, 3, 7, 5], 8)))\n    print(\"Sum found: \" + str(find_sum([1, 2, 3, 7, 5], 11)))\n\n\nmain()"
    },
    {
      "rank": 17,
      "score": 8.0,
      "candidate": "def subset_with_sum(arr, target):\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[-1][-1]\n\n\ndef main():\n    print(\"Can form subset: \" + str(subset_with_sum([3, 34, 4, 12, 5, 2], 9)))\n    print(\"Can form subset: \" + str(subset_with_sum([2, 3, 10, 1, 1, 1, 1, 1, 1, 1], 12)))\n\n\nmain()"
    },
    {
      "rank": 18,
      "score": 8.0,
      "candidate": "from itertools import combinations\n\n\ndef subset_sum(set_of_numbers, target_sum):\n    for i in range(1, len(set_of_numbers) + 1):\n        for combination in combinations(set_of_numbers, i):\n            if sum(combination) == target_sum:\n                return True\n    return False\n\n\nprint(subset_sum([1, 2, 3, 4, 5, 6, 7], 7))\nprint(subset_sum([1, 2, 3, 4, 5, 6, 7], 10))"
    },
    {
      "rank": 19,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef is_subset_sum_exists(arr: List[int], sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n\n    # Memoize the subproblems\n    memo = {}\n\n    def is_subset_sum_exists_recursive(arr, sum):\n        if sum == 0:\n            return True\n\n        if sum < 0:\n            return False\n\n        if sum in memo:\n            return memo[sum]\n\n        for el in arr:\n            if is_subset_sum_exists_recursive(arr, sum - el):\n                return True\n\n        memo[sum] = False\n        return False\n\n    return is_subset_sum_exists_recursive(arr, sum)\n\n\nif __name__ == \"__main__\":\n    assert is_subset_sum_exists([1, 2, 3, 3], 6)\n    assert not is_subset_sum_exists([1, 2, 3, 3], 5)\n    assert is_subset_sum_exists([1, 2, 3, 3], 4)\n    assert is_subset_sum_exists([1, 2, 3, 3], 5)"
    },
    {
      "rank": 20,
      "score": 8.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef subset_sum_exists(nums, total):\n    if total == 0:\n        return True\n    if not nums or total < 0:\n        return False\n\n    return subset_sum_exists(nums[:-1], total) or subset_sum_exists(nums[:-1], total - nums[-1])\n\n\nif __name__ == \"__main__\":\n    print(subset_sum_exists([3, 5, 2, 2, 5, 1, 1, 2], 7))"
    },
    {
      "rank": 21,
      "score": 8.0,
      "candidate": "from typing import Set, Dict\n\n\ndef subset_sum(numbers: Set[int], sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    def subset_sum_rec(numbers: Set[int], sum: int, cache: Dict[int, bool]):\n        if sum in cache:\n            return cache[sum]\n\n        if sum == 0:\n            return True\n\n        cache[sum] = False\n\n        for number in numbers:\n            if number <= sum:\n                cache[sum] = subset_sum_rec(numbers, sum - number, cache) or cache[sum]\n            if cache[sum]:\n                break\n\n        return cache[sum]\n\n    return subset_sum_rec(numbers, sum, {})\n\n\nif __name__ == \"__main__\":\n    assert subset_sum({1, 2, 3, 4, 5}, 7) is True"
    },
    {
      "rank": 22,
      "score": 8.0,
      "candidate": "from itertools import combinations\n\n\ndef has_subset_with_given_sum(arr, target):\n    \"\"\"\n    :param arr: list of integers\n    :param target: sum we want to find in arr\n    :return: bool\n    \"\"\"\n    arr_combinations = combinations(arr, 2)\n    for combination in list(arr_combinations):\n        if sum(combination) == target:\n            return True\n    return False"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "from collections import Counter\n\n\ndef subset_sum(arr, k):\n    \"\"\"\n    :param arr: list\n    :param k: int\n    :return: bool\n    \"\"\"\n    # Create a counter of the input array\n    c = Counter(arr)\n    # Iterate through the array\n    for i in c:\n        # Check if the difference between the target sum and the current value is in the counter\n        if k - i in c:\n            return True\n    return False\n\n\ndef main():\n    print(subset_sum([1, 2, 3, 6, 7], 10))\n    print(subset_sum([1, 2, 3, 6, 7], 11))\n    print(subset_sum([1, 2, 3, 6, 7], 7))\n    print(subset_sum([1, 2, 3, 6, 7], 1))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "from itertools import combinations\n\n\ndef subset_with_sum(arr, target):\n    \"\"\"\n    :param arr: list[int]\n    :param target: int\n    :return: bool\n    \"\"\"\n    for subset_size in range(len(arr)):\n        for subset in combinations(arr, subset_size):\n            if sum(subset) == target:\n                return True\n    return False\n\n\nif __name__ == \"__main__\":\n    assert subset_with_sum([1, 2, 3, 7], 7)\n    assert not subset_with_sum([1, 2, 3, 4], 7)\n    assert subset_with_sum([1, 2, 3, 4], 6)"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "def is_subset_sum(nums, target_sum):\n    nums_len = len(nums)\n    if nums_len == 1:\n        if nums[0] == target_sum:\n            return True\n        else:\n            return False\n    nums.sort()\n    min_sum = nums[0]\n    max_sum = nums[-1]\n    if target_sum < min_sum or target_sum > max_sum:\n        return False\n    elif target_sum == min_sum:\n        return True\n    elif target_sum == max_sum:\n        return True\n\n    subset = [False] * (target_sum - min_sum + 1)\n    subset[0] = True\n\n    for i in range(1, target_sum - min_sum + 1):\n        subset[i] = subset[i - 1]\n\n    for i in range(nums_len):\n        for j in range(target_sum - min_sum, nums[i] - 1, -1):\n            if nums[i] <= j:\n                subset[j] = subset[j] or subset[j - nums[i]]\n            else:\n                break\n\n    return subset[-1]\n\n\nif __name__ == \"__main__\":\n    print(is_subset_sum([1, 2, 3, 4, 5], 6))\n    print(is_subset_sum([1, 2, 3, 4, 5], 7))\n    print(is_subset_sum([1, 2, 3, 4, 5], 10))\n    print(is_subset_sum([1, 2, 3, 4, 5], 1))\n    print(is_subset_sum([1, 2, 3, 4, 5], 5))\n    print(is_subset_sum([1, 2, 3, 4, 5], 11))\n    print(is_subset_sum([1], 1))"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef is_subset_sum(arr: List[int], sum: int) -> bool:\n    \"\"\"\n    Let's say our input array has n elements.\n    So, we can have 2^n subsets.\n\n    Let's say our sum is s.\n    If s is greater than or equal to 0 and less than or equal to n-1, then there is a subset that sums up to s.\n    If s is greater than n-1, then there is no subset that sums up to s.\n\n    Now, let's say our input array has n elements and the sum is s.\n    So, we can have 2^n subsets.\n\n    Now, let's say our sum is s.\n    If s is greater than or equal to 0 and less than or equal to n-1, then there is a subset that sums up to s.\n    If s is greater than n-1, then there is no subset that sums up to s.\n\n    So, we can have 2^n subsets.\n\n    Let's say our input array has n elements and the sum is s.\n    So, we can have 2^n subsets.\n\n    Now, let's say our sum is s.\n    If s is greater than or equal to 0 and less than or equal to n-1, then there is a subset that sums up to s.\n    If s is greater than n-1, then there is no subset that sums up to s.\n\n    So, we can have 2^n subsets.\n\n    Let's say our input array has n elements and the sum is s.\n    So, we can have 2^n subsets.\n\n    Now, let's say our sum is s.\n    If s is greater than or equal to 0 and less than or equal to n-1, then there is a subset that sums up to s.\n    If s is greater than n-1, then there is no subset that sums up to s.\n\n    So, we can have 2^n subsets.\n\n    Let's say our input array has n elements and the sum is s.\n    So, we can have 2^n subsets.\n\n    Now, let's say our"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef subset_sum(arr: List[int], sum_val: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    n = len(arr)\n    dp = [[0 for _ in range(sum_val + 1)] for _ in range(n + 1)]\n\n    # sum = 0\n    for i in range(1, n + 1):\n        dp[i][0] = True\n\n    # sum != 0\n    for i in range(1, sum_val + 1):\n        dp[0][i] = False\n\n    # sum = sum_val\n    for i in range(1, n + 1):\n        for j in range(1, sum_val + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            elif arr[i - 1] == j:\n                dp[i][j] = True\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][sum_val]\n\n\nif __name__ == \"__main__\":\n    assert subset_sum([1, 2, 3, 4, 5], 5) is True\n    assert subset_sum([1, 2, 3, 4, 5], 6) is False"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "def subset_sum(arr, target_sum):\n    arr.sort()\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == target_sum:\n            return True\n        elif arr[i] > target_sum:\n            return False\n        else:\n            for j in range(i + 1, n):\n                if arr[i] + arr[j] == target_sum:\n                    return True\n    return False\n\n\nif __name__ == \"__main__\":\n    print(subset_sum([1, 2, 3, 4, 5], 5))"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "from itertools import combinations\n\n\ndef is_subset_sum(arr, target):\n    arr = sorted(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return True\n    return False\n\n\ndef is_subset_sum_dp(arr, target):\n    n = len(arr)\n    dp = [[False for x in range(target + 1)] for y in range(n + 1)]\n\n    # If target is 0, then there is a subset with sum 0\n    for i in range(0, n + 1):\n        dp[i][0] = True\n\n    # If target is not 0 and set is empty, then there is no\n    # subset with sum not 0\n    for i in range(1, target + 1):\n        dp[0][i] = False\n\n    # Fill the dp table in bottom up manner\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j]\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][target]\n\n\ndef is_subset_sum_dp_memo(arr, target):\n    n = len(arr)\n    dp = [[-1 for x in range(target + 1)] for y in range(n + 1)]\n\n    # If target is 0, then there is a subset with sum 0\n    for i in range(0, n + 1):\n        dp[i][0] = True\n\n    # If target is not 0 and set is empty, then there is no\n    # subset with sum not 0\n    for i in range(1, target + 1):\n        dp[0][i] = False\n\n    # Fill the dp table in bottom up"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "def subset_sum(given_set: set, given_sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    if len(given_set) == 0:\n        return False\n\n    given_set = list(given_set)\n    return _subset_sum(given_set, given_sum, 0, {})\n\n\ndef _subset_sum(given_set: list, given_sum: int, index: int, memo: dict) -> bool:\n    if given_sum == 0:\n        return True\n\n    if given_sum < 0:\n        return False\n\n    if index == len(given_set):\n        return False\n\n    if given_sum - given_set[index] in memo:\n        return memo[given_sum - given_set[index]]\n\n    result_from_here = _subset_sum(given_set, given_sum, index + 1, memo)\n\n    memo[given_sum - given_set[index]] = result_from_here\n\n    return result_from_here or _subset_sum(given_set, given_sum - given_set[index], index + 1, memo)\n\n\nif __name__ == \"__main__\":\n    assert subset_sum({1, 2, 3, 7}, 6) is True\n    assert subset_sum({1, 2, 3, 7}, 10) is False\n    assert subset_sum({1, 2, 3, 4, 5, 6}, 10) is True\n    assert subset_sum({1, 2, 3, 4, 5, 6}, 11) is False"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "def subset_with_sum(s, sum_):\n    \"\"\"\n    :param s: list of integers\n    :param sum_: sum to find subset of s with\n    :return: True if a subset of s with sum sum_ exists, False otherwise\n    \"\"\"\n    n = len(s)\n    if n == 1:\n        return s[0] == sum_\n\n    s = sorted(s)\n    i = 0\n    j = n - 1\n    while i < j:\n        if s[i] + s[j] == sum_:\n            return True\n        elif s[i] + s[j] < sum_:\n            i += 1\n        else:\n            j -= 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    print(subset_with_sum([1, 2, 3], 5))\n    print(subset_with_sum([1, 2, 3], 6))\n    print(subset_with_sum([1, 2, 3], 7))\n    print(subset_with_sum([1, 2, 3], 8))"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def is_sub_sum(given_set, given_sum):\n    if not given_set:\n        return False\n    if sum(given_set) < given_sum:\n        return False\n    if sum(given_set) == given_sum:\n        return True\n\n    given_set = sorted(given_set)\n\n    left = 0\n    right = len(given_set) - 1\n    while left < right:\n        current_sum = given_set[left] + given_set[right]\n        if current_sum == given_sum:\n            return True\n        elif current_sum < given_sum:\n            left += 1\n        else:\n            right -= 1\n\n    return False\n\n\nprint(is_sub_sum([1, 2, 3, 7], 6))\nprint(is_sub_sum([1, 2, 3, 4], 6))\nprint(is_sub_sum([1, 2, 3, 4], 100))\nprint(is_sub_sum([1, 2, 3, 4], 4))\nprint(is_sub_sum([1, 2, 3, 4], 5))\nprint(is_sub_sum([1, 2, 3, 4], 3))\nprint(is_sub_sum([1, 2, 3, 4], 0))"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from typing import List\n\n\n# Time Complexity: O(2^n), Space Complexity: O(n)\ndef subset_sum(arr: List[int], sum_: int) -> bool:\n    if not arr:\n        return False\n\n    if sum(arr) < sum_:\n        return False\n\n    if sum(arr) == sum_:\n        return True\n\n    return subset_sum(arr[1:], sum_) or subset_sum(arr[1:], sum_ - arr[0])\n\n\nif __name__ == \"__main__\":\n    print(subset_sum([1, 3, 4, 7, 10], 10))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "from functools import lru_cache\n\n\n@lru_cache(maxsize=None)\ndef is_subset_sum(arr, target, index):\n    if target == 0:\n        return True\n    elif index == 0:\n        return False\n    elif arr[index - 1] > target:\n        return is_subset_sum(arr, target, index - 1)\n    else:\n        return is_subset_sum(arr, target, index - 1) or is_subset_sum(arr, target - arr[index - 1], index - 1)\n\n\ndef main():\n    arr = [3, 34, 4, 12, 5, 2]\n    target = 9\n    print(is_subset_sum(arr, target, len(arr)))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\n\ndef is_subset_sum(data, sum_value):\n    # Create a cache to store the result of subproblems.\n    # Note: the default value is 0 and not False.\n    cache = defaultdict(int)\n\n    # Base case: if the sum_value is 0, then there is a subset with sum 0, which is the empty set.\n    cache[0] = True\n\n    # For each element in the given set\n    for element in data:\n        # For each value in the cache\n        for cache_value in cache.keys():\n            # Check if there is a subset with the sum of the cache value and the current element\n            if cache_value + element == sum_value:\n                # There is a subset with the sum of the cache value and the current element.\n                # Add the current element to the cache.\n                cache[cache_value + element] = True\n            elif cache_value + element < sum_value:\n                # There is no subset with the sum of the cache value and the current element.\n                # Add the current element to the cache.\n                cache[cache_value + element] = False\n\n    # Check if there is a subset with the sum of the cache value and the current element.\n    return cache[sum_value]\n\n\ndef main():\n\n    data = [1, 2, 3, 4, 5, 6, 7, 8]\n    sum_value = 8\n    print(\"Is there a subset of {} with sum equal to {}? {}\".format(data, sum_value, is_subset_sum(data, sum_value)))\n\n    data = [1, 2, 3, 4, 5, 6, 7, 8]\n    sum_value = 10\n    print(\"Is there a subset of {} with sum equal to {}? {}\".format(data, sum_value, is_subset_sum(data, sum_value)))\n\n    data = [1, 2, 3, 4, 5, 6, 7, 8]\n    sum_value = 14\n    print(\"Is there a subset of {} with sum equal to {}? {}"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from collections import defaultdict\n\ndef is_subset_sum(nums, target):\n    if len(nums) == 0:\n        return False\n    elif len(nums) == 1:\n        return nums[0] == target\n\n    # sum_to_index_map[x] stores all the indices with sum x\n    sum_to_index_map = defaultdict(list)\n    sum_to_index_map[0].append(-1)\n    curr_sum = 0\n    for i in range(len(nums)):\n        curr_sum += nums[i]\n        diff = curr_sum - target\n        if diff in sum_to_index_map:\n            for j in sum_to_index_map[diff]:\n                yield (i, j)\n        sum_to_index_map[curr_sum].append(i)\n\ndef subset_sum(nums, target):\n    for i, j in is_subset_sum(nums, target):\n        return True\n    return False\n\ndef main():\n    print(\"Sum of subsets: \" + str(subset_sum([3, 34, 4, 12, 5, 2], 9)))\n    print(\"Sum of subsets: \" + str(subset_sum([3, 34, 4, 12, 5, 2], 30)))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "def find_subset_with_given_sum(arr, n, sum_val):\n    \"\"\"\n    :param arr: list of integers\n    :param n: length of list\n    :param sum_val: sum required\n    :return: True or False\n    \"\"\"\n    if n == 1 and sum_val == arr[0]:\n        return True\n    if sum_val == 0:\n        return True\n    if n == 0 or sum_val < 0:\n        return False\n    return find_subset_with_given_sum(arr, n - 1, sum_val) or find_subset_with_given_sum(arr, n - 1, sum_val - arr[n - 1])\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 3]\n    n = len(arr)\n    sum_val = 6\n    print(find_subset_with_given_sum(arr, n, sum_val))"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "def subset_sum(arr, s):\n    n = len(arr)\n    dp = [False for x in range(s + 1)]\n    dp[0] = True\n\n    for i in range(n):\n        for j in range(s, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n    return dp[s]\n\n\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    s = 9\n    print(subset_sum(arr, s))"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "from typing import List\n\n\ndef subset_sum_exists(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*s), where n is the number of elements in arr and s is the sum of the elements in arr\n    Space Complexity: O(s), where s is the sum of the elements in arr\n    \"\"\"\n    subset_sum_exists.memo = {}\n\n    def helper(arr: List[int], target: int) -> bool:\n        if target == 0:\n            return True\n\n        if target < 0:\n            return False\n\n        if target in subset_sum_exists.memo:\n            return subset_sum_exists.memo[target]\n\n        for i in range(len(arr)):\n            if helper(arr[i + 1 :], target - arr[i]):\n                subset_sum_exists.memo[target] = True\n                return True\n\n        subset_sum_exists.memo[target] = False\n        return False\n\n    return helper(arr, target)\n\n\nif __name__ == \"__main__\":\n    print(subset_sum_exists([1, 2, 3, 4, 5], 9))"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "def is_subset_with_sum(arr, n, sum):\n    \"\"\"\n    :param arr: list of numbers\n    :param n: length of list\n    :param sum: sum to be found\n    :return: boolean\n    \"\"\"\n    if sum < 0:\n        return False\n    if n == 1 and sum == arr[0]:\n        return True\n\n    return is_subset_with_sum(arr, n-1, sum) or is_subset_with_sum(arr, n-1, sum - arr[n-1])\n\n\nif __name__ == \"__main__\":\n    print(is_subset_with_sum([1, 2, 3, 4, 5], 5, 5))\n    print(is_subset_with_sum([1, 2, 3, 4, 5], 5, 6))\n    print(is_subset_with_sum([1, 2, 3, 4, 5], 5, 1))\n    print(is_subset_with_sum([1, 2, 3, 4, 5], 5, 7))\n    print(is_subset_with_sum([1, 2, 3, 4, 5], 5, 0))"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "from itertools import combinations\n\n\ndef find_subset(given_set, given_sum):\n    \"\"\"\n    :param given_set: list, set of numbers\n    :param given_sum: int\n    :return: bool\n    \"\"\"\n    if not given_set:\n        return False\n\n    for i in range(len(given_set) + 1):\n        for subset in combinations(given_set, i):\n            if sum(subset) == given_sum:\n                return True\n    return False\n\n\nif __name__ == '__main__':\n    print(find_subset([1, 2, 3, 4, 5], 7))"
    },
    {
      "rank": 42,
      "score": 4.0,
      "candidate": "def can_partition(nums, s):\n    # Base Cases\n    # if sum of the array is less than the sum, then it is not possible\n    if s < sum(nums):\n        return False\n    if s == sum(nums):\n        return True\n\n    # Memoize table\n    memo = {}\n\n    # Recursive function\n    def helper(nums, s):\n        # Base Cases\n        # if sum is 0 then the subset is found\n        if s == 0:\n            return True\n\n        # if sum is less than 0 then the subset is not found\n        if s < 0:\n            return False\n\n        # Check if the subset is already found\n        if (s, len(nums)) in memo:\n            return memo[(s, len(nums))]\n\n        # Recursive Case\n        # Check the last element\n        if nums[-1] <= s:\n            memo[(s, len(nums))] = helper(nums[:-1], s - nums[-1])\n            if memo[(s, len(nums))]:\n                return True\n\n        # Exclude the last element\n        memo[(s, len(nums))] = helper(nums[:-1], s)\n        return memo[(s, len(nums))]\n\n    return helper(nums, s)\n\n\ndef main():\n  print(\"Can partition: \" + str(can_partition([1, 5, 11, 5], 16)))\n  print(\"Can partition: \" + str(can_partition([1, 5, 11, 5], 17)))\n  print(\"Can partition: \" + str(can_partition([1, 2, 3, 5], 10)))\n\n\nmain()\n\n\n\"\"\"\nTime O(2^N)\nSpace O(N)\n\"\"\""
    },
    {
      "rank": 43,
      "score": 1.0,
      "candidate": "def check_subset_sum(set, sum):\n\t\"\"\"\n\t:param set: list of integers\n\t:param sum: integer\n\t:return: True if there is a subset with sum equal to sum, False otherwise\n\t\"\"\"\n\n\tif len(set) == 0:\n\t\treturn False\n\tif sum == 0:\n\t\treturn True\n\tif sum < 0:\n\t\treturn False\n\n\treturn check_subset_sum(set[1:], sum) or check_subset_sum(set[1:], sum - set[0])\n\ndef test_check_subset_sum():\n\n\tassert check_subset_sum([1, 2, 3, 4, 5], 7) == True\n\tassert check_subset_sum([1, 2, 3, 4, 5], 8) == False\n\ntest_check_subset_sum()"
    },
    {
      "rank": 44,
      "score": 1.0,
      "candidate": "def is_subset_with_given_sum(arr, n, sum):\n    \"\"\"\n    :param arr: list of numbers\n    :param n: length of array\n    :param sum: sum of subset\n    :return: bool\n    \"\"\"\n    # Base Case\n    if n == 0:\n        return False\n\n    # If sum is 0, then there exists empty subset\n    if sum == 0:\n        return True\n\n    # If the first element is greater than the sum, then ignore it\n    if arr[0] > sum:\n        return is_subset_with_given_sum(arr[1:], n - 1, sum)\n\n    # Check if there is subset with sum equals to sum - arr[0]\n    return is_subset_with_given_sum(\n        arr, n - 1, sum - arr[0]\n    ) or is_subset_with_given_sum(arr[1:], n - 1, sum)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    n = len(arr)\n    sum = 10\n    if is_subset_with_given_sum(arr, n, sum):\n        print(\"Found a subset with given sum\")\n    else:\n        print(\"No subset with given sum\")"
    },
    {
      "rank": 45,
      "score": 1.0,
      "candidate": "def subset_sum(arr, sum):\n    if not arr or sum < 0:\n        return False\n\n    if sum == 0:\n        return True\n\n    if sum > 0 and not arr:\n        return False\n\n    return subset_sum(arr[:-1], sum) or subset_sum(arr[:-1], sum - arr[-1])\n\n\ndef subset_sum_dp(arr, sum):\n    # create a dp array of size sum + 1\n    # first row is False\n    dp = [False] * (sum + 1)\n\n    # first column is True\n    for i in range(1, len(dp)):\n        dp[i] = True\n\n    for i in range(1, len(dp)):\n        for j in range(1, len(dp)):\n            if i < arr[j]:\n                dp[i] = dp[i] or dp[i - arr[j]]\n\n    return dp[sum]\n\n\n# Tests\nassert subset_sum([1, 2, 3, 7], 7)\nassert subset_sum([1, 2, 7, 1, 5], 10)\nassert subset_sum([1, 3, 10, 4, 7], 12)\nassert subset_sum([1, 5, 11, 5], 10)\nassert not subset_sum([1, 3, 11, 5], 12)\nassert subset_sum([1, 2, 7, 1, 5], 10)\nassert subset_sum([1, 2, 15, 2, 20, 21, 30], 55)\nassert not subset_sum([1, 2, 15, 2, 20, 21, 30], 56)\nassert not subset_sum([1, 2, 15, 2, 20, 21, 30], 54)\nassert subset_sum([1, 2, 15, 2, 20, 21, 30],"
    },
    {
      "rank": 46,
      "score": 1.0,
      "candidate": "from itertools import combinations\n\n\ndef has_subset_with_sum(nums, s):\n    if s == 0:\n        return True\n\n    for r in range(len(nums) + 1):\n        for comb in combinations(nums, r):\n            if sum(comb) == s:\n                return True\n\n    return False\n\n\n# test\nnums = [1, 2, 3, 4, 5, 6]\nprint(has_subset_with_sum(nums, 7))\nprint(has_subset_with_sum(nums, 10))\nprint(has_subset_with_sum(nums, 11))"
    },
    {
      "rank": 47,
      "score": 1.0,
      "candidate": "def can_sum(target_sum, nums):\n    if target_sum == 0:\n        return True\n    if target_sum < 0:\n        return False\n\n    for num in nums:\n        remainder = target_sum - num\n        if can_sum(remainder, nums):\n            return True\n\n    return False\n\n\ndef can_sum_tabulated(target_sum, nums):\n    table = [False] * (target_sum + 1)\n    table[0] = True\n\n    for i in range(target_sum):\n        if table[i]:\n            for num in nums:\n                table[i + num] = True\n\n    return table[target_sum]\n\n\n# Test cases:\nprint(can_sum(7, [2, 3]))  # True\nprint(can_sum(7, [5, 3, 4, 7]))  # True\nprint(can_sum(7, [2, 4]))  # False\nprint(can_sum(8, [2, 3, 5]))  # True"
    },
    {
      "rank": 48,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef subset_with_sum(arr: List[int], total: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    if not arr:\n        return False\n\n    n = len(arr)\n    dp = [[False for _ in range(total + 1)] for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, total + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][total]\n\n\nif __name__ == \"__main__\":\n    assert subset_with_sum([1, 2, 3, 3], 6)\n    assert subset_with_sum([1, 2, 3, 4], 6) is False\n    assert subset_with_sum([1, 2, 3, 4], 7) is False\n    assert subset_with_sum([1, 2, 3, 4, 5], 7)\n    assert subset_with_sum([1, 2, 3, 4, 5], 8) is False"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "def is_subset_sum_exists(arr, n, sum):\n    \"\"\"\n    :param: arr - input integer array\n    :param: n - size of array\n    :param: sum - integer\n    TODO: complete this method and return a boolean\n    \"\"\"\n    # Base Case\n    if sum == 0:\n        return True\n\n    # If array is empty, then no way to get sum\n    if n == 0:\n        return False\n\n    # If last element is greater than sum, then ignore it\n    if arr[n - 1] > sum:\n        return is_subset_sum_exists(arr, n - 1, sum)\n\n    # Else check if sum can be obtained by any of the following\n    # (a) including the last element\n    # (b) excluding the last element\n\n    return is_subset_sum_exists(arr, n - 1, sum) or is_subset_sum_exists(arr, n - 1, sum - arr[n - 1])\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    sum = test_case[1]\n    solution = test_case[2]\n    output = is_subset_sum_exists(arr, len(arr), sum)\n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\narr = [3, 7, 1, 5, 8]\nsum = 11\nsolution = True\ntest_case = [arr, sum, solution]\ntest_function(test_case)\n\narr = [3, 7, 1, 5, 8]\nsum = 12\nsolution = False\ntest_case = [arr, sum, solution]\ntest_function(test_case)\n\narr = [3, 7, 1, 5, 8]\nsum = 8\nsolution = True\ntest_case = [arr, sum, solution]\ntest_function(test_case)\n\narr = [3, 7, 1, 5, 8]\nsum = 10\nsolution = True\ntest_case = [arr"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "def subset_sum(arr, s):\n    \"\"\"\n    The idea is to use Dynamic Programming with a 2D table.\n    The first row and column is set to False.\n    For every index i, j, we check if the sum of the elements from 0 to i-1 is equal to j.\n    If yes, then there is a subset with sum equal to j.\n    \"\"\"\n    n = len(arr)\n\n    # Create a 2D table to store solutions of subproblems\n    dp = [[False for x in range(s + 1)] for y in range(n + 1)]\n\n    # If sum is 0, then answer is true\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # If sum is not 0 and set is empty, then answer is false\n    for j in range(1, s + 1):\n        dp[0][j] = False\n\n    # Fill the dp table in bottom up manner\n    for i in range(1, n + 1):\n        for j in range(1, s + 1):\n            # If i'th element is excluded\n            dp[i][j] = dp[i - 1][j]\n\n            # If i'th element is included\n            if arr[i - 1] <= j:\n                dp[i][j] |= dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][s]\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 7]\n    s = 6\n    print(subset_sum(arr, s))"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_sum(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    Space Complexity: O(sum)\n    \"\"\"\n\n    def helper(idx: int, sum: int) -> bool:\n        if sum == 0:\n            return True\n        if idx == len(arr) or sum < 0:\n            return False\n\n        return helper(idx + 1, sum) or helper(idx + 1, sum - arr[idx])\n\n    return helper(0, target)\n\n\nif __name__ == \"__main__\":\n    assert is_subset_sum([1, 2, 3, 4, 5], 5) is True\n    assert is_subset_sum([1, 2, 3, 4, 5], 6) is False\n    assert is_subset_sum([1, 2, 3, 4, 5], 7) is False\n    assert is_subset_sum([1, 2, 3, 4, 5], 0) is True\n    assert is_subset_sum([1, 2, 3, 4, 5], 1) is True\n    assert is_subset_sum([1, 2, 3, 4, 5], 2) is True\n    assert is_subset_sum([1, 2, 3, 4, 5], 3) is True\n    assert is_subset_sum([1, 2, 3, 4, 5], 4) is True\n    assert is_subset_sum([1, 2, 3, 4, 5], 10) is False"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef has_subset_sum(nums: List[int], target: int) -> bool:\n    \"\"\"\n    Use Dynamic Programming.\n    Time Complexity: O(n*s) where n is the length of nums and s is the sum.\n    Space Complexity: O(s).\n    \"\"\"\n    dp = [False for _ in range(target + 1)]\n    dp[0] = True\n\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    assert has_subset_sum([1, 2, 3, 7], 6)\n    assert has_subset_sum([1, 2, 7, 1, 5], 10)\n    assert not has_subset_sum([1, 3, 15, 3, 7], 14)"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "def is_subset_sum(nums, target_sum):\n    \"\"\"\n    :param nums: list[int]\n    :param target_sum: int\n    :return: bool\n    \"\"\"\n    # base case\n    if not nums:\n        return False\n\n    if sum(nums) < target_sum:\n        return False\n\n    if sum(nums) == target_sum:\n        return True\n\n    # recursive case\n    if nums[-1] > target_sum:\n        return is_subset_sum(nums[:-1], target_sum)\n\n    return is_subset_sum(nums[:-1], target_sum - nums[-1]) or is_subset_sum(nums[:-1], target_sum)\n\n\ndef is_subset_sum_dp(nums, target_sum):\n    \"\"\"\n    :param nums: list[int]\n    :param target_sum: int\n    :return: bool\n    \"\"\"\n    # base case\n    if not nums:\n        return False\n\n    if sum(nums) < target_sum:\n        return False\n\n    if sum(nums) == target_sum:\n        return True\n\n    # recursive case\n    # dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n    dp = [[False for _ in range(target_sum + 1)] for _ in range(len(nums) + 1)]\n    for i in range(len(nums) + 1):\n        dp[i][0] = True\n\n    for i in range(1, len(nums) + 1):\n        for j in range(1, target_sum + 1):\n            dp[i][j] = dp[i - 1][j] or (j >= nums[i - 1] and dp[i - 1][j - nums[i - 1]])\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    print(is_subset_sum([3,"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n\ndef can_partition_subsets(nums, sum_subset):\n    counter = Counter(nums)\n    total_sum = sum(counter.keys())\n    if total_sum < sum_subset:\n        return False\n\n    if sum_subset in counter.keys():\n        return True\n\n    return can_partition_subsets_recursive(counter, sum_subset)\n\n\ndef can_partition_subsets_recursive(counter, sum_subset):\n    for num in counter.keys():\n        if num < sum_subset:\n            counter[num] -= 1\n            if can_partition_subsets_recursive(counter, sum_subset - num):\n                return True\n            counter[num] += 1\n        elif num == sum_subset:\n            return True\n\n    return False"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "def subset_sum(nums, target):\n    \"\"\"\n    Time Complexity: O(n*target)\n    Space Complexity: O(target)\n    \"\"\"\n    if target == 0:\n        return True\n\n    memo = [0] * (target + 1)\n    for num in nums:\n        for i in range(target, num - 1, -1):\n            if num <= i:\n                memo[i] = 1 or memo[i - num]\n\n    return memo[target]\n\n\nprint(subset_sum([3, 34, 4, 12, 5, 2], 9))"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef subset_with_given_sum(arr: List[int], n: int, sum_given: int) -> bool:\n    \"\"\"\n    O(n*n)\n    \"\"\"\n    if sum_given == 0:\n        return True\n\n    for i in range(n):\n        if arr[i] == sum_given:\n            return True\n\n        if arr[i] < sum_given:\n            if subset_with_given_sum(arr, n, sum_given - arr[i]):\n                return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert subset_with_given_sum([1, 2, 3, 7], 4, 7)"
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_sub_sum(arr: List[int], n: int) -> bool:\n    \"\"\"\n    :param arr: List of numbers\n    :param n: sum\n    :return: True if there is a subset with sum equal to n, else False\n\n    >>> is_sub_sum([1, 2, 3, 7], 7)\n    True\n    >>> is_sub_sum([1, 2, 3, 4], 7)\n    False\n    >>> is_sub_sum([1, 2, 3, 4], 5)\n    True\n    >>> is_sub_sum([1, 2, 3, 4], 8)\n    True\n    >>> is_sub_sum([1, 2, 3, 4], 10)\n    False\n    >>> is_sub_sum([1, 2, 3, 4], 9)\n    False\n    >>> is_sub_sum([1, 2, 3, 4], 6)\n    True\n    >>> is_sub_sum([1, 2, 3, 4], 11)\n    False\n    \"\"\"\n    if n < 0:\n        return False\n\n    if n == 0:\n        return True\n\n    if len(arr) == 0:\n        return False\n\n    return is_sub_sum(arr[:-1], n) or is_sub_sum(arr[:-1], n - arr[-1])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "def has_subset_with_sum(arr, sum):\n    if not arr:\n        return False\n\n    if sum < 0:\n        return False\n\n    if sum == 0:\n        return True\n\n    if len(arr) == 1:\n        return arr[0] == sum\n\n    return has_subset_with_sum(arr[1:], sum) or has_subset_with_sum(arr[1:], sum - arr[0])\n\n\nif __name__ == \"__main__\":\n    assert has_subset_with_sum([1, 2, 3, 4, 5], 5) is True\n    assert has_subset_with_sum([1, 2, 3, 4, 5], 11) is False\n    assert has_subset_with_sum([1, 2, 3, 4, 5], 7) is True"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n\ndef can_partition_rec(arr, target, idx):\n    if target < 0:\n        return False\n    if target == 0:\n        return True\n    if idx >= len(arr):\n        return False\n\n    return can_partition_rec(arr, target, idx + 1) or can_partition_rec(arr, target - arr[idx], idx + 1)\n\n\ndef can_partition_dp(arr, target):\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j] or (j >= arr[i - 1] and dp[i - 1][j - arr[i - 1]])\n\n    return dp[n][target]\n\n\ndef can_partition_dp_memo(arr, target):\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            dp[i][j] = dp[i - 1][j] or (j >= arr[i - 1] and dp[i - 1][j - arr[i - 1]])\n\n    return dp[n][target]\n\n\ndef can_partition_dp_counter(arr, target):\n    c = Counter(arr)\n    n = len(arr)\n    dp = [[False] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1,"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef can_sum(target_sum: int, nums: List[int]) -> bool:\n    \"\"\"\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    if target_sum == 0:\n        return True\n    if target_sum < 0:\n        return False\n\n    for num in nums:\n        remainder = target_sum - num\n        if can_sum(remainder, nums):\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert can_sum(7, [2, 3])\n    assert not can_sum(7, [5, 3, 4, 7])\n    assert can_sum(8, [2, 3, 5])"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n\ndef has_subset_with_given_sum(arr, sum_):\n    \"\"\"\n    :param arr: list[int]\n    :param sum_: int\n    :return: bool\n    \"\"\"\n    # return has_subset_with_given_sum_v1(arr, sum_)\n    return has_subset_with_given_sum_v2(arr, sum_)\n\n\ndef has_subset_with_given_sum_v1(arr, sum_):\n    if len(arr) < 1:\n        return False\n    elif len(arr) == 1:\n        return arr[0] == sum_\n\n    for i in range(len(arr)):\n        if arr[i] == sum_:\n            return True\n        if arr[i] > sum_:\n            continue\n        if has_subset_with_given_sum_v1(arr[i + 1 :], sum_ - arr[i]):\n            return True\n    return False\n\n\ndef has_subset_with_given_sum_v2(arr, sum_):\n    if len(arr) < 1:\n        return False\n    elif len(arr) == 1:\n        return arr[0] == sum_\n\n    counter = Counter(arr)\n    for item, count in counter.items():\n        if item == sum_:\n            return True\n        if item > sum_:\n            continue\n        if has_subset_with_given_sum_v2(arr[1:], sum_ - item):\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    assert has_subset_with_given_sum([1, 2, 3, 7], 7) is True\n    assert has_subset_with_given_sum([1, 2, 3, 7], 12) is False\n    assert has_subset_with_given_sum([1, 2, 3, 4, 5], 12) is False\n    assert has_subset_with_given_sum([1, 2, 3, 4, 5"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "def subset_sum(set_list, target_sum):\n    \"\"\"\n    Time Complexity: O(n*target_sum)\n    Space Complexity: O(target_sum)\n    \"\"\"\n    memo = [0] * (target_sum + 1)\n    memo[0] = True\n    for i in range(len(set_list)):\n        for j in range(target_sum, 0, -1):\n            if j >= set_list[i]:\n                memo[j] = memo[j] or memo[j - set_list[i]]\n    return memo[target_sum]\n\n\ndef subset_sum_memo_table(set_list, target_sum):\n    \"\"\"\n    Time Complexity: O(n*target_sum)\n    Space Complexity: O(target_sum)\n    \"\"\"\n    memo = [0] * (target_sum + 1)\n    for i in range(len(set_list)):\n        for j in range(target_sum, set_list[i] - 1, -1):\n            memo[j] = memo[j] or memo[j - set_list[i]]\n    return memo[target_sum]\n\n\ndef subset_sum_optimized(set_list, target_sum):\n    \"\"\"\n    Time Complexity: O(n*target_sum)\n    Space Complexity: O(target_sum)\n    \"\"\"\n    memo = [0] * (target_sum + 1)\n    for i in range(len(set_list)):\n        for j in range(target_sum, set_list[i] - 1, -1):\n            memo[j] = memo[j] or memo[j - set_list[i]]\n    return memo[target_sum]\n\n\nif __name__ == \"__main__\":\n    print(subset_sum_optimized([1, 2, 3, 3], 6))"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef has_subset_sum(arr: List[int], sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    Space Complexity: O(sum)\n    \"\"\"\n    n = len(arr)\n\n    dp = [False for _ in range(sum + 1)]\n    dp[0] = True\n\n    for i in range(n):\n        for j in range(sum, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n\n    return dp[sum]\n\n\nif __name__ == \"__main__\":\n    assert has_subset_sum([1, 2, 3, 7], 7)\n    assert has_subset_sum([1, 2, 7, 1, 5], 10)\n    assert has_subset_sum([1, 3, 10, 5], 7) is False"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "def is_subset_sum_exists(arr, target_sum):\n    \"\"\"\n    :param: arr - input array\n    :param: target_sum - target sum\n    TODO: complete this method and return a boolean value whether the subset is found or not\n    \"\"\"\n    if len(arr) == 0:\n        return False\n\n    if target_sum == 0:\n        return True\n\n    if target_sum < 0:\n        return False\n\n    return is_subset_sum_exists(arr[1:], target_sum - arr[0]) or is_subset_sum_exists(arr[1:], target_sum)\n\n\ndef test_function(test_case):\n    arr = test_case[0]\n    target_sum = test_case[1]\n    if is_subset_sum_exists(arr, target_sum) == test_case[2]:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n\nif __name__ == '__main__':\n    test_case_1 = [[1, 2, 3, 7], 9, True]\n    test_function(test_case_1)\n\n    test_case_2 = [[1, 2, 7], 9, False]\n    test_function(test_case_2)\n\n    test_case_3 = [[1, 2, 3], 6, True]\n    test_function(test_case_3)\n\n    test_case_4 = [[1, 3, 4], 6, False]\n    test_function(test_case_4)"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_sum(arr: List[int], sum_: int) -> bool:\n    \"\"\"\n    Backtracking solution.\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    if not arr:\n        return False\n\n    if sum(arr) < sum_:\n        return False\n\n    if sum(arr) == sum_:\n        return True\n\n    return is_subset_sum(arr[1:], sum_) or is_subset_sum(arr[1:], sum_ - arr[0])\n\n\ndef is_subset_sum_dp(arr: List[int], sum_: int) -> bool:\n    \"\"\"\n    DP solution.\n    Time Complexity: O(n * sum)\n    Space Complexity: O(n * sum)\n    \"\"\"\n    length = len(arr)\n    dp = [[False for _ in range(sum_ + 1)] for _ in range(length + 1)]\n\n    for i in range(length + 1):\n        dp[i][0] = True\n\n    for i in range(1, length + 1):\n        for j in range(1, sum_ + 1):\n            if j < arr[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[-1][-1]\n\n\nif __name__ == \"__main__\":\n    assert is_subset_sum([1, 2, 3, 3], 6) is True\n    assert is_subset_sum([1, 2, 3, 3], 5) is False\n    assert is_subset_sum([1, 1, 1, 1, 1], 1) is True\n    assert is_subset_sum([1, 1, 1, 1, 1], 5) is False\n    assert is_subset_sum([1], 1)"
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "from itertools import combinations\n\ndef is_subset_sum(s, sum):\n    s = sorted(s)\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[j] + s[i] == sum:\n                return True\n    return False\n\n\ndef is_subset_sum_dp(s, sum):\n    s = sorted(s)\n    n = len(s)\n    dp = [[False for _ in range(sum+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = True\n\n    for i in range(1, n+1):\n        for j in range(1, sum+1):\n            if j >= s[i-1]:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-s[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    return dp[n][sum]\n\n\ndef is_subset_sum_dp_tab(s, sum):\n    s = sorted(s)\n    n = len(s)\n    dp = [[False for _ in range(sum+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, sum+1):\n            if j >= s[i-1]:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j-s[i-1]]\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    return dp[n][sum]\n\n\ndef is_subset_sum_dp_tab_opt(s, sum):\n    s = sorted(s)\n    n = len(s)\n    dp = [False for _ in range(sum+1)]\n    dp[0] = True\n    for i in range(1, n+1):\n        for j in range(sum, s["
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_exists(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*n)\n    \"\"\"\n    for i in range(len(arr)):\n        temp = target - arr[i]\n        if temp == arr[i]:\n            return True\n        elif temp > 0 and temp in arr:\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert is_subset_exists([3, 34, 4, 12, 5, 2], 9)\n    assert not is_subset_exists([3, 34, 4, 12, 5, 2], 12)"
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\ndef subset_sum(arr, n, sum):\n    dp = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][sum]\n\n\ndef subset_sum_dp(arr, n, sum):\n    dp = defaultdict(lambda: defaultdict(bool))\n\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[n][sum]\n\n\ndef subset_sum_dp_2(arr, n, sum):\n    dp = defaultdict(bool)\n\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(sum, -1, -1):\n            if dp[j]:\n                dp[j + arr[i - 1]] = True\n\n    return dp[sum]\n\n\nif __name__ == \"__main__\":\n    print(subset_sum([1, 2, 3, 3], 4, 7))\n    print(subset_sum_dp([1, 2, 3,"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_sum(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum(arr))\n    Space Complexity: O(sum(arr))\n    \"\"\"\n\n    def subset_sum(arr: List[int], target: int) -> bool:\n        if target == 0:\n            return True\n\n        if target < 0:\n            return False\n\n        for i in range(len(arr)):\n            if subset_sum(arr[i + 1 :], target - arr[i]):\n                return True\n\n        return False\n\n    return subset_sum(arr, target)\n\n\nif __name__ == \"__main__\":\n    print(is_subset_sum([1, 2, 3, 3], 6))"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "from typing import List, Set\n\n\ndef find_subset_sum(numbers: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*s)\n    Space Complexity: O(s)\n    \"\"\"\n    if not numbers:\n        return False\n\n    subset_sums: Set[int] = {0}\n\n    for number in numbers:\n        for subset_sum in list(subset_sums):\n            subset_sums.add(subset_sum + number)\n\n    return target in subset_sums\n\n\nif __name__ == \"__main__\":\n    assert find_subset_sum([1, 2, 3, 7], 7) is True\n    assert find_subset_sum([1, 2, 7, 1, 5], 10) is True\n    assert find_subset_sum([1, 3, 10, 5], 12) is False"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "from typing import Set\n\n\ndef subset_with_given_sum(arr: Set[int], sum_: int) -> bool:\n    \"\"\"\n    This solution works in O(n * sum) time and O(sum) space.\n    \"\"\"\n    dp = [False] * (sum_ + 1)\n    dp[0] = True\n\n    for elem in arr:\n        for index in range(sum_, elem - 1, -1):\n            dp[index] = dp[index] or dp[index - elem]\n\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    assert subset_with_given_sum({1, 2, 3}, 5) is True\n    assert subset_with_given_sum({1, 2, 3}, 6) is False"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "def is_subset_with_sum(arr, sum_):\n    n = len(arr)\n    dp = [[0] * (sum_ + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, sum_ + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - arr[i - 1]] + arr[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][sum_] == sum_\n\n\nprint(is_subset_with_sum([1, 2, 3, 7], 6))\nprint(is_subset_with_sum([1, 1, 3, 4], 6))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_with_sum_exists(set_input: List[int], sum_input: int) -> bool:\n    \"\"\"\n    This is a recursive solution.\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n\n    def _is_subset_with_sum_exists(\n        set_input: List[int], sum_input: int, current_sum: int, index: int\n    ) -> bool:\n        if current_sum == sum_input:\n            return True\n\n        if index >= len(set_input):\n            return False\n\n        return (\n            _is_subset_with_sum_exists(\n                set_input, sum_input, current_sum + set_input[index], index + 1\n            )\n            or _is_subset_with_sum_exists(\n                set_input, sum_input, current_sum, index + 1\n            )\n        )\n\n    return _is_subset_with_sum_exists(set_input, sum_input, 0, 0)\n\n\nif __name__ == \"__main__\":\n    assert is_subset_with_sum_exists([1, 2, 3, 7], 7) == True\n    assert is_subset_with_sum_exists([1, 2, 7], 7) == True\n    assert is_subset_with_sum_exists([1, 2, 3, 7], 8) == False\n    assert is_subset_with_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 8) == True\n    assert is_subset_with_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 9) == True\n    assert is_subset_with_sum_exists([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == False"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "from typing import List, Set\n\n\ndef is_sub_sum_exists(input_list: List[int], input_sum: int) -> bool:\n    \"\"\"\n    :param input_list: list of integers\n    :param input_sum: target sum\n    :return: True if subset with sum equal to input_sum is present in input_list\n    >>> is_sub_sum_exists([1, 2, 3, 7], 6)\n    True\n    >>> is_sub_sum_exists([1, 2, 3, 4], 6)\n    True\n    >>> is_sub_sum_exists([1, 2, 3, 4], 5)\n    False\n    >>> is_sub_sum_exists([1, 2, 3, 4], 7)\n    True\n    >>> is_sub_sum_exists([1, 2, 3, 4], 11)\n    False\n    >>> is_sub_sum_exists([1, 2, 3, 4], 1)\n    True\n    >>> is_sub_sum_exists([], 1)\n    False\n    >>> is_sub_sum_exists([1], 1)\n    True\n    \"\"\"\n    if input_sum == 0:\n        return True\n    if not input_list or input_sum < 0:\n        return False\n    return (\n        is_sub_sum_exists(input_list[:-1], input_sum)\n        or is_sub_sum_exists(input_list[:-1], input_sum - input_list[-1])\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "from typing import List, Tuple\n\n\ndef is_subset_with_sum(input_list: List[int], sum_: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    if not input_list or len(input_list) == 0:\n        return False\n\n    for i in range(len(input_list)):\n        for j in range(i + 1, len(input_list)):\n            if sum_ == input_list[i] + input_list[j]:\n                return True\n\n    return False\n\n\ndef is_subset_with_sum_dp(input_list: List[int], sum_: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    if not input_list or len(input_list) == 0:\n        return False\n\n    n = len(input_list)\n    dp = [[False for i in range(sum_ + 1)] for j in range(n)]\n\n    for i in range(n):\n        dp[i][0] = True\n\n    for i in range(1, sum_ + 1):\n        if input_list[0] == i:\n            dp[0][i] = True\n        elif input_list[0] < i:\n            dp[0][i] = False\n\n    for i in range(1, n):\n        for j in range(1, sum_ + 1):\n            if j < input_list[i]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - input_list[i]]\n\n    return dp[-1][-1]\n\n\ndef is_subset_with_sum_recursive(input_list: List[int], sum_: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    if not input_list or len(input_list) == 0:\n        return False\n\n    return _is"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def can_reach_sum(arr, target):\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if target < 0:\n        return False\n    if target == 0:\n        return True\n\n    for i in range(len(arr)):\n        if can_reach_sum(arr[i + 1 :], target - arr[i]):\n            return True\n\n    return False\n\n\nif __name__ == \"__main__\":\n    print(can_reach_sum([1, 2, 3, 4], 5))\n    print(can_reach_sum([1, 2, 7, 1, 5], 9))"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\ndef subset_with_given_sum(arr, n, sum):\n    if sum == 0:\n        return True\n    if n == 0:\n        return False\n\n    if arr[n - 1] > sum:\n        return subset_with_given_sum(arr, n - 1, sum)\n\n    return subset_with_given_sum(arr, n - 1, sum) or subset_with_given_sum(arr, n - 1, sum - arr[n - 1])\n\n\ndef subset_with_given_sum_dp(arr, n, sum):\n    dp = defaultdict(bool)\n\n    for i in range(n + 1):\n        dp[i] = False\n\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(sum, arr[i - 1] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i - 1]]\n\n    return dp[sum]\n\n\ndef main():\n\n    arr = [3, 34, 4, 12, 5, 2]\n    sum = 9\n    print(subset_with_given_sum(arr, len(arr), sum))\n    print(subset_with_given_sum_dp(arr, len(arr), sum))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef can_partition_rec(remaining_sum: int, subset: List[int],\n                      subset_sum: int, nums: List[int]) -> bool:\n    if remaining_sum < 0:\n        return False\n    if remaining_sum == 0:\n        return True\n    if len(subset) == len(nums):\n        return False\n    for num in nums[len(subset):]:\n        if can_partition_rec(remaining_sum - num, subset + [num], subset_sum, nums):\n            return True\n    return False\n\n\ndef can_partition_memo(subset: List[int], subset_sum: int, nums: List[int],\n                       memo: List[List[bool]]) -> bool:\n    if len(subset) == len(nums):\n        return False\n    if memo[len(subset)][subset_sum] is not None:\n        return memo[len(subset)][subset_sum]\n    for num in nums[len(subset):]:\n        if can_partition_memo(subset + [num], subset_sum - num, nums, memo):\n            memo[len(subset)][subset_sum] = True\n            return True\n    memo[len(subset)][subset_sum] = False\n    return False\n\n\ndef can_partition_tab(nums: List[int], target: int) -> bool:\n    n = len(nums)\n    table = [[False] * (target + 1) for _ in range(n + 1)]\n    table[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(target + 1):\n            curr_num = nums[i - 1]\n            if j >= curr_num:\n                table[i][j] = table[i - 1][j] or table[i - 1][j - curr_num]\n            else:\n                table[i][j] = table[i - 1][j]\n\n    return table[n][target]\n\n\nif __name__ == \"__main__\":"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "from itertools import combinations\n\n\ndef subset_sum(arr, sum):\n    \"\"\"\n    Returns a boolean value.\n    >>> subset_sum([1, 3, 5], 6)\n    True\n    >>> subset_sum([1, 3, 5], 7)\n    False\n    >>> subset_sum([1, 3, 5], 8)\n    True\n    >>> subset_sum([1, 3, 5], 9)\n    False\n    >>> subset_sum([1, 3, 5], 1)\n    True\n    >>> subset_sum([1, 3, 5], 0)\n    True\n    >>> subset_sum([1, 3, 5], -1)\n    False\n    >>> subset_sum([1, 3, 5], 100)\n    False\n    \"\"\"\n    if sum < 0:\n        return False\n    for subset in combinations(arr, len(arr)):\n        if sum == sum(subset):\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef subset_sum(arr: List[int], sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(2^n)\n    \"\"\"\n\n    def subset_sum_helper(arr, idx, cur_sum, target_sum):\n        if cur_sum == target_sum:\n            return True\n\n        if idx >= len(arr) or cur_sum > target_sum:\n            return False\n\n        return subset_sum_helper(arr, idx + 1, cur_sum + arr[idx], target_sum) or subset_sum_helper(arr, idx + 1, cur_sum, target_sum)\n\n    return subset_sum_helper(arr, 0, 0, sum)\n\n\nif __name__ == \"__main__\":\n    assert subset_sum([1, 2, 3], 5) == True\n    assert subset_sum([1, 2, 3], 6) == True\n    assert subset_sum([1, 2, 3], 7) == False"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\ndef subset_sum(arr, target):\n    \"\"\"\n    :param: arr - input array\n    :param: target - target value\n    return bool - if there exists a subset of arr with sum equal to target\n    TO CONSIDER: What should be the answer when there are negative numbers in arr?\n    \"\"\"\n    # A hash map to store the sums\n    hash_map = defaultdict(int)\n\n    # if the target is 0 then return True\n    if target == 0:\n        return True\n\n    # if the target is negative then return False\n    if target < 0:\n        return False\n\n    # traverse the array\n    for element in arr:\n        # if the target is equal to the element then return True\n        if element == target:\n            return True\n        # if the target is greater than the element\n        if element < target:\n            # add the element to the hash map\n            hash_map[element] += 1\n\n    # traverse the array\n    for element in arr:\n        # if the target is greater than the element\n        if element < target:\n            # get the value from the hash map\n            value = hash_map[target - element]\n            # if the value is greater than 0\n            if value > 0:\n                # return True\n                return True\n\n    # return False\n    return False\n\ndef test_function(test_case):\n    arr = test_case[0]\n    target = test_case[1]\n    solution = test_case[2]\n    output = subset_sum(arr, target)\n    \n    if output == solution:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\narr = [3, 5, 2, 1, 6]\ntarget = 10\nsolution = True\ntest_case = [arr, target, solution]\ntest_function(test_case)\n\narr = [3, 5, 2, 1, 6]\ntarget = 11\nsolution = False\ntest_case = [arr, target, solution]\ntest_function(test_case)\n\narr = [3, 5, 2,"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "def is_subset_sum(arr, sum):\n    if not arr:\n        return False\n    if sum == 0:\n        return True\n\n    if arr[0] > sum:\n        return False\n\n    if is_subset_sum(arr[1:], sum):\n        return True\n\n    return is_subset_sum(arr[1:], sum - arr[0])\n\n\nassert is_subset_sum([1, 2, 3, 7], 7) == True\nassert is_subset_sum([1, 2, 7, 1, 0], 7) == True\nassert is_subset_sum([1, 3, 10, 5], 7) == False\nassert is_subset_sum([1, 5, 11, 5], 10) == True\nassert is_subset_sum([1, 2, 7, 1, 0], 10) == False"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_sum(arr: List[int], s: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*s)\n    Space Complexity: O(s)\n    \"\"\"\n    if not arr:\n        return False\n\n    # To store results of subproblems\n    dp = [False] * (s + 1)\n\n    # If the sum is 0, then answer is true\n    dp[0] = True\n\n    # Recur for all smaller sums\n    for i in range(0, len(arr)):\n        for j in range(s, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n\n    return dp[s]\n\n\nif __name__ == \"__main__\":\n    assert is_subset_sum([1, 2, 3, 7], 7) == True\n    assert is_subset_sum([1, 1, 3, 4], 6) == True\n    assert is_subset_sum([1, 2, 7, 1, 5], 10) == True\n    assert is_subset_sum([1, 3, 4, 8], 6) == False"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef _subset_sum_rec(arr: List[int], target: int, index: int, current_sum: int) -> bool:\n    \"\"\"\n    Time Complexity: O(2^n)\n    \"\"\"\n    if current_sum == target:\n        return True\n\n    if index >= len(arr) or current_sum > target:\n        return False\n\n    return (\n        _subset_sum_rec(arr, target, index + 1, current_sum)\n        or _subset_sum_rec(arr, target, index + 1, current_sum + arr[index])\n    )\n\n\ndef subset_sum_dp(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    dp = [[False] * (target + 1) for _ in range(len(arr) + 1)]\n\n    for i in range(len(arr) + 1):\n        dp[i][0] = True\n\n    for i in range(1, len(arr) + 1):\n        for j in range(1, target + 1):\n            if arr[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n\n    return dp[-1][-1]\n\n\ndef subset_sum_rec(arr: List[int], target: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum)\n    \"\"\"\n    return _subset_sum_rec(arr, target, 0, 0)\n\n\nif __name__ == \"__main__\":\n    assert subset_sum_dp([1, 2, 3, 3], 6) is True\n    assert subset_sum_dp([1, 2, 3, 3], 7) is False\n    assert subset_sum_dp([1, 2, 3, 3], 0) is True"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n\ndef is_subset_sum(arr, n, s):\n    \"\"\"\n    :param: arr - input integer array\n    :param: n - size of array\n    :param: s - integer sum\n    chk if there is a subset with sum equal to s\n    \"\"\"\n    # base case\n    if s == 0:\n        return True\n\n    # if s is negative, no way of getting s using\n    # values in arr\n    if s < 0:\n        return False\n\n    # if there are no elements in arr, no way to get s\n    if n == 0:\n        return False\n\n    # if last element is greater than sum, then no way of getting s\n    if arr[n - 1] > s:\n        return False\n\n    # if last element can form the sum, then check for remaining elements\n    if arr[n - 1] == s:\n        return True\n\n    # check if sum can be obtained\n    return (is_subset_sum(arr, n - 1, s) or is_subset_sum(arr, n - 1, s - arr[n - 1]))\n\n\ndef is_subset_sum_dp(arr, n, s):\n    \"\"\"\n    :param: arr - input integer array\n    :param: n - size of array\n    :param: s - integer sum\n    chk if there is a subset of the given set with sum equal to the given sum\n    \"\"\"\n    # base case\n    if s == 0:\n        return True\n\n    # if s is negative, no way of getting s using\n    # values in arr\n    if s < 0:\n        return False\n\n    # if there are no elements in arr, no way to get s\n    if n == 0:\n        return False\n\n    # if last element is greater than sum, then no way of getting s\n    if arr[n - 1] > s:\n        return is_subset_sum_dp(arr, n - 1, s)\n\n    # check if sum can be obtained by either of the below 2 cases\n    # (i) by using the last element as include in sum\n    # (ii"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "from typing import List\n\n\n# Time complexity: O(2^n)\n# Space complexity: O(n)\ndef has_subset_sum(arr: List[int], target: int) -> bool:\n    if not arr:\n        return False\n\n    if sum(arr) < target:\n        return False\n\n    if target == 0:\n        return True\n\n    return has_subset_sum_dp(arr, target, 0, {})\n\n\ndef has_subset_sum_dp(arr: List[int], target: int, idx: int, cache: dict) -> bool:\n    if idx == len(arr):\n        return False\n\n    if target == 0:\n        return True\n\n    if target < 0:\n        return False\n\n    if (idx, target) in cache:\n        return cache[(idx, target)]\n\n    cache[(idx, target)] = has_subset_sum_dp(arr, target, idx + 1, cache) or has_subset_sum_dp(arr, target - arr[idx], idx + 1, cache)\n    return cache[(idx, target)]\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef has_subset_sum_dp_2(arr: List[int], target: int) -> bool:\n    if not arr:\n        return False\n\n    if sum(arr) < target:\n        return False\n\n    if target == 0:\n        return True\n\n    dp = [False for _ in range(target + 1)]\n    dp[0] = True\n\n    for i in range(len(arr)):\n        for j in range(target, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n\n    return dp[-1]\n\n\n# Time complexity: O(n)\n# Space complexity: O(n)\ndef has_subset_sum_recursive(arr: List[int], target: int) -> bool:\n    if not arr:\n        return False\n\n    if sum(arr) < target:\n        return False\n\n    if target =="
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "from itertools import combinations\n\n\ndef is_subset_with_sum(arr, sum):\n    \"\"\"\n    :param: arr - input array\n    :param: sum - sum\n    return: bool - is there a subset of arr with sum equal to sum\n    TODO: Write your solution here\n    \"\"\"\n    # Check for empty array\n    if len(arr) == 0:\n        return False\n\n    # Create a dictionary to store the sum and the number of times it occurs\n    sum_dict = {}\n    for num in arr:\n        if num in sum_dict:\n            sum_dict[num] += 1\n        else:\n            sum_dict[num] = 1\n\n    # Create a dictionary to store the sum and the number of times it occurs\n    # with the remaining sum after the sum of a particular number\n    # For example, {1: {0: 1, 2: 1}, 2: {0: 1, 1: 1, 3: 1}}\n    subset_dict = {}\n    for num in arr:\n        for sum_key in sum_dict:\n            if num == sum_key:\n                if num in subset_dict:\n                    subset_dict[num] = {\n                        0: sum_dict[num]\n                    }\n                else:\n                    subset_dict[num] = {\n                        0: sum_dict[num]\n                    }\n            else:\n                if num > sum_key:\n                    if sum_key in subset_dict:\n                        if num in subset_dict[sum_key]:\n                            subset_dict[sum_key][num] += sum_dict[num]\n                        else:\n                            subset_dict[sum_key][num] = sum_dict[num]\n                    else:\n                        subset_dict[sum_key] = {\n                            num: sum_dict[num]\n                        }\n                else:\n                    if sum_key in subset_dict:\n                        if num in subset_dict[sum_key]:\n                            subset_dict[sum_key][num] += sum_dict[num]\n                        else:\n                            subset_dict[sum"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n\ndef is_subset_with_given_sum(arr, s):\n    \"\"\"\n    :param arr: list of numbers\n    :param s: sum\n    :return: bool\n    \"\"\"\n    if len(arr) == 0:\n        return False\n\n    if s == 0:\n        return True\n\n    if s < 0:\n        return False\n\n    # dp[i][j] = True if arr[0..i] has sum j\n    dp = [[False] * (s + 1) for _ in range(len(arr))]\n\n    # if sum is 0, then all elements has sum 0\n    for i in range(len(arr)):\n        dp[i][0] = True\n\n    for i in range(len(arr)):\n        for j in range(1, s + 1):\n            # exclude current element\n            if j - arr[i] >= 0:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[-1][s]\n\n\ndef is_subset_with_given_sum_eff(arr, s):\n    \"\"\"\n    :param arr: list of numbers\n    :param s: sum\n    :return: bool\n    \"\"\"\n    if len(arr) == 0:\n        return False\n\n    if s == 0:\n        return True\n\n    if s < 0:\n        return False\n\n    # dp[i] = True if arr[0..i] has sum s\n    dp = [False] * len(arr)\n    # dp[i] = sum of elements upto arr[i]\n    sums = [0] * len(arr)\n\n    # initialize sums\n    for i in range(len(arr)):\n        sums[i] = arr[i]\n\n    # for each element, check if there is a subset with sum s-arr[i]\n    for i in range(len(arr)):"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def subset_sum(arr, n, sum):\n    # Initialize the DP table\n    dp = [[False for x in range(sum + 1)] for y in range(n + 1)]\n\n    # If the sum is 0, then there is a subset with sum 0\n    for i in range(n + 1):\n        dp[i][0] = True\n\n    # If the sum is not 0 and the set is empty, then there is no subset with sum not 0\n    for i in range(1, sum + 1):\n        dp[0][i] = False\n\n    # Fill the DP table in bottom up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if arr[i - 1] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[n][sum]\n\n\nif __name__ == \"__main__\":\n    arr = [3, 34, 4, 12, 5, 2]\n    n = len(arr)\n    sum = 9\n    if subset_sum(arr, n, sum):\n        print(\"There is a subset with given sum.\")\n    else:\n        print(\"There is not a subset with given sum.\")"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "def find_subset(arr, s):\n    n = len(arr)\n\n    # Base case\n    if n == 0:\n        return False\n\n    # If sum of the first element is greater than the required sum then we can't find a subset with the given sum\n    if arr[0] > s:\n        return False\n\n    # If the first element is equal to the required sum then we can return true\n    if arr[0] == s:\n        return True\n\n    # If the first element is less than the required sum then we can find a subset with the given sum\n    return find_subset(arr[1:], s) or find_subset(arr[1:], s - arr[0])\n\n\ndef main():\n    print(\"Can we find a subset with sum 5: \" + str(find_subset([1, 2, 3, 7], 5)))\n    print(\"Can we find a subset with sum 8: \" + str(find_subset([1, 2, 3, 4, 7], 8)))\n\n\nmain()\n\n\n\"\"\"\nTime complexity: O(2^N)\nSpace complexity: O(N)\n\nCan we find a subset with sum 5: False\nCan we find a subset with sum 8: True\n\"\"\""
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def subset_sum(arr, target):\n    def helper(arr, target, index, curr_sum):\n        if target == curr_sum:\n            return True\n        if curr_sum > target or index >= len(arr):\n            return False\n\n        return helper(arr, target, index + 1, curr_sum) or helper(arr, target, index + 1, curr_sum + arr[index])\n\n    return helper(arr, target, 0, 0)\n\n\nassert subset_sum([1, 2, 3, 4], 6) is True\nassert subset_sum([1, 2, 3, 4], 5) is True\nassert subset_sum([1, 2, 3, 4], 10) is False"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "from collections import Counter\n\n\ndef can_sum_subset(target_sum, nums):\n    if target_sum == 0:\n        return True\n    if target_sum < 0:\n        return False\n\n    for num in nums:\n        remainder = target_sum - num\n        if can_sum_subset(remainder, nums):\n            return True\n\n    return False\n\n\ndef can_sum_subset_2(target_sum, nums):\n    counter = Counter(nums)\n    return can_sum_subset_recursive(target_sum, nums, counter, 0)\n\n\ndef can_sum_subset_recursive(target_sum, nums, counter, current_sum):\n    if current_sum == target_sum:\n        return True\n    if current_sum > target_sum:\n        return False\n\n    for num in nums:\n        if counter[num] > 0:\n            counter[num] -= 1\n            if can_sum_subset_recursive(target_sum, nums, counter, current_sum + num):\n                return True\n            counter[num] += 1\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert can_sum_subset(7, [2, 3]) is True\n    assert can_sum_subset(7, [5, 3, 4, 7]) is True\n    assert can_sum_subset(7, [2, 4]) is False\n    assert can_sum_subset(8, [2, 3, 5]) is True\n    assert can_sum_subset(300, [7, 14]) is False\n\n    assert can_sum_subset_2(7, [2, 3]) is True\n    assert can_sum_subset_2(7, [5, 3, 4, 7]) is True\n    assert can_sum_subset_2(7, [2, 4]) is False\n    assert can_sum_subset_2(8, [2, 3, 5]) is True\n    assert can_sum_subset_2(300, [7, 14"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_subset_with_sum(given_set: List[int], sum_val: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*m)\n    Space Complexity: O(n)\n    \"\"\"\n    subset = [False] * (sum_val + 1)\n    subset[0] = True\n\n    for num in given_set:\n        for i in range(sum_val, num - 1, -1):\n            subset[i] = subset[i] or subset[i - num]\n\n    return subset[-1]\n\n\nif __name__ == \"__main__\":\n    assert is_subset_with_sum([1, 2, 3, 4, 5, 6], 10) is True\n    assert is_subset_with_sum([1, 2, 3, 4, 5, 6], 15) is False\n    assert is_subset_with_sum([1, 2, 3, 4, 5, 6], 2) is False\n    assert is_subset_with_sum([1, 2, 3, 4, 5, 6], 5) is True\n    assert is_subset_with_sum([1, 2, 3, 4, 5, 6], 1) is False\n    assert is_subset_with_sum([1, 2, 3, 4, 5, 6], 3) is True"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef is_sub_sum(arr: List[int], sum_: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n * s)\n    \"\"\"\n    if not arr:\n        return False\n\n    sum_table = [False] * (sum_ + 1)\n    sum_table[0] = True\n\n    for i in range(len(arr)):\n        for j in range(sum_ + 1):\n            if arr[i] > j:\n                sum_table[j] = False\n            elif arr[i] == j:\n                sum_table[j] = True\n            elif arr[i] < j:\n                sum_table[j] = sum_table[j - arr[i]] or sum_table[j]\n\n    return sum_table[sum_]\n\n\nif __name__ == \"__main__\":\n    assert is_sub_sum([1, 2, 3, 7], 7) is True\n    assert is_sub_sum([1, 2, 7, 1, 5], 10) is True\n    assert is_sub_sum([1, 3, 15, 3, 2, 5, 8, 5, 10, 2, 3, 1, 1, 3], 10) is True\n    assert is_sub_sum([1, 3, 15, 3, 2, 5, 8, 5, 10, 2, 3, 1, 1, 3], 11) is False"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef subset_sum(arr: List[int], sum: int) -> bool:\n    \"\"\"\n    Backtracking approach.\n    Time Complexity: O(2^n)\n    Space Complexity: O(n)\n    \"\"\"\n    if sum == 0:\n        return True\n\n    if not arr or sum < 0:\n        return False\n\n    if arr[0] <= sum:\n        if subset_sum(arr[1:], sum - arr[0]):\n            return True\n\n    return subset_sum(arr[1:], sum)\n\n\ndef subset_sum_dp(arr: List[int], sum: int) -> bool:\n    \"\"\"\n    Dynamic Programming approach.\n    Time Complexity: O(n * s)\n    Space Complexity: O(n * s)\n    \"\"\"\n    rows = len(arr)\n    cols = sum + 1\n\n    # dp[i][j] = true if there is a subset of arr[:i + 1] with sum j\n    dp = [[False] * cols for _ in range(rows)]\n\n    # if the sum is 0, then there is a subset\n    for i in range(rows):\n        dp[i][0] = True\n\n    # if the array sum is 0, then there is a subset with empty array\n    for j in range(1, cols):\n        dp[0][j] = False\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            # if the current element is less than the sum\n            # then we can either include it or not\n            if arr[i] <= j:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[rows - 1][sum]\n\n\nif __name__ == \"__main__\":\n    assert subset_sum([1, 2, 3, 3], 6) is True\n    assert subset_sum([1,"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "def subset_with_sum(arr, n, s):\n    if s == 0:\n        return True\n    if n == 0:\n        return False\n    if arr[n - 1] > s:\n        return subset_with_sum(arr, n - 1, s)\n\n    return subset_with_sum(arr, n - 1, s) or subset_with_sum(arr, n - 1, s - arr[n - 1])\n\n\ndef main():\n    arr = [3, 34, 4, 12, 5, 2]\n    n = len(arr)\n    s = 9\n    print(subset_with_sum(arr, n, s))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "def is_subset_sum(arr, sum):\n    def helper(arr, curr_sum, idx):\n        if curr_sum == sum:\n            return True\n        if curr_sum > sum:\n            return False\n\n        if idx >= len(arr):\n            return False\n\n        return helper(arr, curr_sum, idx + 1) or helper(arr, curr_sum + arr[idx], idx + 1)\n\n    return helper(arr, 0, 0)\n\n\nprint(is_subset_sum([3, 34, 4, 12, 5, 2], 9))\nprint(is_subset_sum([3, 34, 4, 12, 5, 2], 30))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef subset_sum(arr: List[int], sum_: int) -> bool:\n    \"\"\"\n    Time Complexity: O(n*sum_), where 'n' is the size of the array.\n    Space Complexity: O(sum_).\n    \"\"\"\n\n    # Initialize the array to store the sum_ values.\n    dp = [False for _ in range(sum_ + 1)]\n\n    # The value of the first element is True.\n    dp[0] = True\n\n    for el in arr:\n\n        for i in range(sum_, el - 1, -1):\n\n            if el <= i:\n                dp[i] = dp[i] or dp[i - el]\n\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    assert subset_sum([1, 2, 3, 3], 6) is True\n    assert subset_sum([1, 2, 7, 1, 5], 10) is True\n    assert subset_sum([1, 3, 10, 4, 7], 14) is False"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "from functools import lru_cache\n\n\ndef can_sum(target, nums):\n    if target == 0:\n        return True\n    if target < 0:\n        return False\n\n    for num in nums:\n        remainder = target - num\n        if can_sum(remainder, nums):\n            return True\n    return False\n\n\ndef can_sum_tab(target, nums):\n    if target == 0:\n        return True\n    if target < 0:\n        return False\n\n    @lru_cache(maxsize=None)\n    def helper(target, nums):\n        if target == 0:\n            return True\n        if target < 0:\n            return False\n\n        for num in nums:\n            remainder = target - num\n            if helper(remainder, nums):\n                return True\n        return False\n\n    return helper(target, nums)\n\n\n# print(can_sum(7, [2, 3]))\nprint(can_sum_tab(7, [2, 3]))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "from collections import defaultdict\n\n\ndef is_subset_sum(arr, n, k):\n    dp = defaultdict(bool)\n    dp[0] = True\n\n    for i in range(n):\n        for j in range(k, arr[i] - 1, -1):\n            dp[j] = dp[j] or dp[j - arr[i]]\n\n    return dp[k]\n\n\nif __name__ == \"__main__\":\n    print(is_subset_sum([1, 2, 3, 7], 4, 6))\n    print(is_subset_sum([1, 2, 7, 1, 5], 5, 10))"
    }
  ]
}