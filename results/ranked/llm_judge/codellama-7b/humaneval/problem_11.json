{
  "timestamp": "2025-09-14T21:09:54.176408",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "humaneval",
  "problem_number": 11,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "assert len(a) == len(b)\n    return \"\".join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: str, b: str) -> List[int]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list('010', '110')\n    [1, 0, 0]\n    \"\"\"\n    return [int(x) ^ int(y) for x, y in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings, consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return string_xor(*strings)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(a: str, b: List[str]) -> str:\n    \"\"\" Input is a string a and list of strings b.\n    Perform binary XOR on a and all strings in b.\n    Return result also as a string.\n    >>> string_xor_all('010', ['110', '111', '100'])\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, map(str, b)))\n\n\ndef string_xor_all_2(a: str, b: List[str]) -> str:\n    \"\"\" Input is a string a and list of strings b.\n    Perform binary XOR on a and all strings in b.\n    Return result also as a string.\n    >>> string_xor_all_2('010', ['110', '111', '100'])\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, map(str, b)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and list of strings b.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list('010', ['110', '100'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a, b_i) for b_i in b]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '001'])\n    '101'\n    \"\"\"\n    if len(strings) == 1:\n        return strings[0]\n    else:\n        return string_xor(strings[0], string_xor_all(strings[1:]))\n\n\ndef string_xor_all_smart(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_smart(['010', '110', '001'])\n    '101'\n    \"\"\"\n    if len(strings) == 1:\n        return strings[0]\n    else:\n        result = strings[0]\n        for string in strings[1:]:\n            result = string_xor(result, string)\n        return result\n\n\ndef string_xor_all_fast(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_fast(['010', '110', '001'])\n    '101'\n    \"\"\"\n    result = ''\n    for i in range(len(strings[0])):\n        result += str(sum(int(s[i]) for s in strings) % 2)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n\ndef string_xor_list(a: str, b: str) -> List[int]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list('010', '110')\n    [1, 0, 0]\n    \"\"\"\n    return [int(i) ^ int(j) for i, j in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "return \"\".join(\n        str(int(a_digit) ^ int(b_digit))\n        for a_digit, b_digit in zip(a, b)\n    )\n\n\ndef string_xor_all(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all strings in the list.\n    >>> string_xor_all(['010', '110', '001'])\n    '111'\n    \"\"\"\n    result = inputs[0]\n    for s in inputs[1:]:\n        result = string_xor(result, s)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "return \"\".join(\n        str(int(a_char) ^ int(b_char))\n        for a_char, b_char in zip(a, b)\n    )\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings, each consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '110'])\n    '000'\n    \"\"\"\n    return string_xor(*strings)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "return ''.join('1' if a_bit == b_bit else '0' for a_bit, b_bit in zip(a, b))\n\n\ndef string_xor_multi(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_multi(['010', '110', '001'])\n    '101'\n    \"\"\"\n    return ''.join('1' if any(a_bit == b_bit for a_bit, b_bit in zip(strings[0], string)) else '0' for string in zip(*strings))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on these inputs and return result as a list of strings.\n    >>> string_xor_list('010', ['110', '101'])\n    ['100', '011']\n    \"\"\"\n    return [string_xor(a, b_i) for b_i in b]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_many(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_many(['010', '110', '001'])\n    '101'\n    \"\"\"\n    return \"\".join(str(int(a_i) ^ sum(int(b_i) for b_i in strings)) for a_i in strings[0])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all the elements in this list and return result also as a string.\n    >>> string_xor_all(['001', '101', '010'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(string_xor(*x))) for x in zip(*strings))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(string_list: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '001'])\n    '101'\n    \"\"\"\n    if not string_list:\n        return \"\"\n    return string_xor(string_list[0], string_xor_all(string_list[1:]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and a list of strings b.\n    Perform binary XOR on each of the strings in b and return the result as a list.\n    >>> string_xor_list('101', ['000', '010', '010'])\n    ['101', '110', '110']\n    \"\"\"\n    return [string_xor(a, b_i) for b_i in b]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '000'], ['110', '010'])\n    ['100', '010']\n    \"\"\"\n    return [string_xor(x, y) for x, y in zip(a, b)]\n\n\ndef string_xor_array(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_array(['010', '000'], ['110', '010'])\n    ['100', '010']\n    \"\"\"\n    return [string_xor(x, y) for x, y in zip(a, b)]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 9.995006026846964,
      "candidate": "result: str = \"\"\n    for x, y in zip(a, b):\n        if x == y:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input is a list of strings a and b.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '110'], ['101', '010'])\n    ['111', '101']\n    \"\"\"\n    result: List[str] = []\n    for x, y in zip(a, b):\n        result.append(string_xor(x, y))\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 9.973356255015277,
      "candidate": "# convert strings to list of integers\n    a = [int(i) for i in a]\n    b = [int(i) for i in b]\n    # perform XOR operation on both lists\n    result = [1 if a[i] == b[i] else 0 for i in range(len(a))]\n    # convert list to string\n    return ''.join(str(i) for i in result)\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '110'], ['101', '011'])\n    ['111', '100']\n    \"\"\"\n    # convert lists to list of lists of integers\n    a = [[int(j) for j in i] for i in a]\n    b = [[int(j) for j in i] for i in b]\n    # perform XOR operation on both lists\n    result = [[1 if a[i][j] == b[i][j] else 0 for j in range(len(a[i]))] for i in range(len(a))]\n    # convert list of lists to list of strings\n    return [''.join(str(j) for j in i) for i in result]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 9.916462768819981,
      "candidate": "return \"\".join(map(lambda x, y: str(int(x) ^ int(y)), a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '011'], ['110', '111'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(x, y) for x, y in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 9.913202760651195,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_all(data: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all strings and return result also as a string.\n    >>> string_xor_all(['001', '101', '010'])\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(data[0])):\n        xor = \"\"\n        for string in data:\n            xor += string[i]\n        result += str(int(xor, 2) ^ int(xor[0], 2))\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 9.892073312576487,
      "candidate": "return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all strings in the list and return result also as a string.\n    >>> string_xor_all(['010', '110', '111'])\n    '101'\n    \"\"\"\n    if len(strings) == 0:\n        return \"\"\n    return string_xor(strings[0], string_xor_all(strings[1:]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 9.88559142093505,
      "candidate": "return \"\".join(\n        [\n            str(int(a_i) ^ int(b_i))\n            for a_i, b_i in zip(a, b)\n        ]\n    )\n\n\ndef string_xor_all(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings each consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return string_xor(*inputs)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 9.878765005758826,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b. Each string consists only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '110'], ['110', '010'])\n    ['100', '100']\n    \"\"\"\n    return list(map(string_xor, a, b))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.854919983341102,
      "candidate": "return ''.join('1' if a[i] != b[i] else '0' for i in range(len(a)))\n\n\ndef string_xor_all(input_list: List[str]) -> str:\n    \"\"\" Input is a list of strings a, b, ..., z consisting only of 1s and 0s.\n    Perform binary XOR on all these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '101'])\n    '101'\n    \"\"\"\n    return string_xor(string_xor(input_list[0], input_list[1]), input_list[2])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 9.827679991179005,
      "candidate": "return \"\".join(\"1\" if a[i] == b[i] else \"0\" for i in range(len(a)))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and list of strings b.\n    Perform binary XOR on each of the strings in b and return list of results also as strings.\n    >>> string_xor_list('010', ['110', '001'])\n    ['100', '000']\n    \"\"\"\n    return [string_xor(a, b_item) for b_item in b]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 9.826294477204067,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on all elements of this list and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(\n        str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(*map(iter, strings))\n    )\n\n\ndef string_xor_all_2(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on all elements of this list and return result also as a string.\n    >>> string_xor_all_2(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(\n        str(int(a_i) ^ b_i)\n        for a_i, *b in zip(*map(iter, strings))\n        for b_i in b\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 9.822705531997244,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all the input strings and return result also as a string.\n    >>> string_xor_all(['010', '110', '001'])\n    '101'\n    \"\"\"\n    return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(*(strings)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 9.814349893873722,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_n(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings. Perform binary XOR on all strings\n    in this list and return result also as a string.\n    >>> string_xor_n(['010', '110'])\n    '100'\n    \"\"\"\n    if len(strings) == 1:\n        return strings[0]\n    return string_xor(strings[0], string_xor_n(strings[1:]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 9.80824001923875,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_n(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings, each consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_n(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(*inputs))\n\n\ndef string_xor_n_optimized(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings, each consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_n_optimized(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(map(str, map(sum, zip(*(map(int, s) for s in inputs)))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 29,
      "score": 9.79195361418084,
      "candidate": "return ''.join(\n        str(int(a_digit) ^ int(b_digit))\n        for a_digit, b_digit in zip(a, b)\n    )\n\n\ndef string_xor_list(xs: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['101', '010', '010'])\n    '111'\n    \"\"\"\n    return ''.join(\n        str(int(a_digit) ^ int(b_digit))\n        for a_digit, b_digit in zip(*xs)\n    )\n\n\ndef string_xor_list_alt(xs: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_alt(['101', '010', '010'])\n    '111'\n    \"\"\"\n    return ''.join(\n        str(int(a_digit) ^ sum(int(b_digit) for b_digit in xs))\n        for a_digit in xs[0]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 9.777763684730042,
      "candidate": "if len(a) != len(b):\n        raise ValueError('Inputs must be of equal length')\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Inputs are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result as a list of strings.\n    >>> string_xor_list(['010', '110'], ['110', '110'])\n    ['000', '000']\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError('Inputs must be of equal length')\n    return [''.join(str(int(x) ^ int(y)) for x, y in zip(a_i, b_i))\n            for a_i, b_i in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 9.777368553475123,
      "candidate": "return \"\".join(map(lambda x, y: str(int(x) ^ int(y)), a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(map(lambda x: str(int(x, 2)), strings))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 9.761305690796105,
      "candidate": "return \"\".join(str(int(a_digit) ^ int(b_digit)) for a_digit, b_digit in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input is two lists of strings a and b, each of which contains only 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '100'], ['110', '010'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a_digit, b_digit) for a_digit, b_digit in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 33,
      "score": 9.74024035526538,
      "candidate": "return \"\".join(\n        str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)\n    )\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['001', '101', '010'])\n    '100'\n    \"\"\"\n    return \"\".join(\n        str(sum(int(x_i) for x_i in x) % 2) for x in zip(*strings)\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 34,
      "score": 9.608646956286316,
      "candidate": "return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)])\n\n\ndef xor_encrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    Take a message and a key, and perform XOR encryption on the message\n    using the key.\n    >>> xor_encrypt_message('test', 'key')\n    '10100011'\n    \"\"\"\n    return string_xor(message, key)\n\n\ndef xor_decrypt_message(message: str, key: str) -> str:\n    \"\"\"\n    Take a message and a key, and perform XOR decryption on the message\n    using the key.\n    >>> xor_decrypt_message('10100011', 'key')\n    'test'\n    \"\"\"\n    return string_xor(message, key)\n\n\ndef xor_encrypt_messages(messages: List[str], key: str) -> List[str]:\n    \"\"\"\n    Take a list of messages and a key, and perform XOR encryption on the\n    messages using the key.\n    >>> xor_encrypt_messages(['test1', 'test2'], 'key')\n    ['10100011', '10100011']\n    \"\"\"\n    return [xor_encrypt_message(message, key) for message in messages]\n\n\ndef xor_decrypt_messages(messages: List[str], key: str) -> List[str]:\n    \"\"\"\n    Take a list of messages and a key, and perform XOR decryption on the\n    messages using the key.\n    >>> xor_decrypt_messages(['10100011', '10100011'], 'key')\n    ['test1', 'test2']\n    \"\"\"\n    return [xor_decrypt_message(message, key) for message in messages]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 9.477447630505942,
      "candidate": "return \"\".join(\n        str(int(a_digit) ^ int(b_digit))\n        for a_digit, b_digit in zip(a, b)\n    )\n\n\ndef string_xor_all(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(\n        str(int(digit_list[0]) ^ int(digit_list[1]))\n        for digit_list in zip(*inputs)\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 9.47284317110102,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and a list of strings b.\n    Perform binary XOR on these inputs and return result as a list of strings.\n    >>> string_xor_list('010', ['010', '110'])\n    ['000', '100']\n    \"\"\"\n    return [string_xor(a, b_i) for b_i in b]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 9.458499469191116,
      "candidate": "return \"\".join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n\ndef string_xor_list(a: str, b: str) -> List[int]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list('010', '110')\n    [1, 0, 0]\n    \"\"\"\n    return [int(i) ^ int(j) for i, j in zip(a, b)]\n\n\ndef string_xor_int(a: str, b: str) -> int:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_int('010', '110')\n    100\n    \"\"\"\n    return int(\"\".join(str(int(i) ^ int(j)) for i, j in zip(a, b)), 2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 38,
      "score": 3.926139092254469,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    return \"\".join(str(int(a_i) & int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) | int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n    \"\"\"\n    return \"\".join(str(1 - int(a_i)) for a_i in a)\n\n\ndef get_bit(num: int, bit: int) -> int:\n    \"\"\"\n    Get the bit of a number at a given position.\n    >>> get_bit(13, 0)\n    1\n    >>> get_bit(13, 1)\n    1\n    >>> get_bit(13, 2)\n    0\n    >>> get_bit(13, 3)\n    0\n    >>> get_bit(13, 4)\n    0\n    >>> get_bit(13, 5)\n    1\n    >>> get_bit(13, 6"
    },
    {
      "rank": 39,
      "score": 3.7896064077536957,
      "candidate": "return \"\".join(\"1\" if a_i == b_i else \"0\" for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on all strings and return result also as a string.\n    >>> string_xor_all(['010', '110', '001'])\n    '101'\n    \"\"\"\n    return \"\".join(\"1\" if any(a_i != b_i for a_i, b_i in zip(a, b)) else \"0\" for a, b in zip(*(strings,) * 2))\n\n\ndef string_xor_all_naive(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on all strings and return result also as a string.\n    >>> string_xor_all_naive(['010', '110', '001'])\n    '101'\n    \"\"\"\n    result = \"\"\n    for i in range(len(strings[0])):\n        for j in range(len(strings)):\n            if strings[j][i] == '0':\n                result += '1'\n            else:\n                result += '0'\n    return result\n\n\nif __name__ == \"__main__\":\n    print(string_xor_all(['010', '110', '001']))\n    print(string_xor_all_naive(['010', '110', '001']))"
    },
    {
      "rank": 40,
      "score": 3.761514928204013,
      "candidate": "result = \"\"\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n\n\ndef get_substrings(string: str) -> List[str]:\n    \"\"\" Input is a string consisting only of 1s and 0s.\n    Return a list of all possible substrings of this string.\n    >>> get_substrings('01001001')\n    ['01001001', '0100100', '010010', '01001', '0100', '010', '01', '001001', '00100', '0010', '001', '00', '0', '100100', '10010', '1001', '100', '10', '1', '0010', '001', '00', '0100', '010', '01', '000100', '00010', '0001', '000', '00', '010', '01', '0001', '000', '0', '1001', '100', '10', '1', '001', '001', '00', '010', '01', '0001', '000', '0']\n    \"\"\"\n    if not string:\n        return []\n\n    substrings = []\n    for length in range(len(string)):\n        for i in range(len(string) - length + 1):\n            substrings.append(string[i : i + length])\n\n    return substrings\n\n\ndef get_xor_substrings(string: str) -> List[str]:\n    \"\"\" Input is a string consisting only of 1s and 0s.\n    Return a list of all possible substrings of this string that are the result\n    of XORing two other substrings of the input."
    },
    {
      "rank": 41,
      "score": 3.732824384460777,
      "candidate": "return ''.join('1' if (a_i == b_i) else '0' for a_i, b_i in zip(a, b))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    return ''.join('1' if (a_i == b_i) else '0' for a_i, b_i in zip(a, b))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    return ''.join('1' if (a_i == '1' or b_i == '1') else '0' for a_i, b_i in zip(a, b))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n    \"\"\"\n    return ''.join('0' if a_i == '1' else '1' for a_i in a)\n\n\ndef string_to_int(a: str) -> int:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Convert this string to an integer and return the integer.\n    >>> string_to_int('010')\n    2\n    \"\"\"\n    return int(a, 2)\n\n\ndef int_to_string(a: int) -> str:\n    \"\"\" Input is an integer a.\n    Convert this integer to a string and return the string.\n    >>> int_to_string(2)"
    },
    {
      "rank": 42,
      "score": 3.501766448946012,
      "candidate": "return ''.join(['1' if a[i] == b[i] else '0' for i in range(len(a))])\n\n\ndef string_xor_list(a: str, b: str) -> List[int]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list('010', '110')\n    [1, 0, 0]\n    \"\"\"\n    return [1 if a[i] == b[i] else 0 for i in range(len(a))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 43,
      "score": 3.4843224952664444,
      "candidate": "return \"\".join([str(int(i) ^ int(j)) for i, j in zip(a, b)])\n\n\ndef string_xor_many(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings containing only 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_many(['001', '010', '110'])\n    '111'\n    \"\"\"\n    return \"\".join([str(int(i) ^ int(j)) for i, j in zip(*strings)])"
    },
    {
      "rank": 44,
      "score": 3.4656400595580994,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists a and b each consisting of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '110'], ['101', '001'])\n    ['111', '100']\n    \"\"\"\n    return list(map(string_xor, a, b))"
    },
    {
      "rank": 45,
      "score": 3.457701058851037,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return string_xor(inputs[0], string_xor(*inputs[1:]))\n\n\ndef string_xor_all_alt(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in zip(*inputs):\n        result += str(sum(map(int, i)) % 2)\n    return result"
    },
    {
      "rank": 46,
      "score": 3.4112724560515946,
      "candidate": "return \"\".join(\n        str(int(a_char) ^ int(b_char))\n        for a_char, b_char in zip(a, b)\n    )\n\n\ndef string_xor_hex(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_hex('010', '110')\n    'b'\n    \"\"\"\n    return \"\".join(\n        hex(int(a_char, 2) ^ int(b_char, 2))[2:]\n        for a_char, b_char in zip(a, b)\n    )\n\n\ndef string_xor_hex_l(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_hex_l('010', '110')\n    '6'\n    \"\"\"\n    return \"\".join(\n        hex(int(a_char, 2) ^ int(b_char, 2))[2:].rjust(2, \"0\")\n        for a_char, b_char in zip(a, b)\n    )\n\n\ndef string_xor_hex_r(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_hex_r('010', '110')\n    '6'\n    \"\"\"\n    return \"\".join(\n        hex(int(a_char, 2) ^ int(b_char, 2))[2:].zfill(2)\n        for a_char, b_char in zip(a, b)\n    )\n\n\ndef string_xor_list(a: str, b: str) -> List[str]:"
    },
    {
      "rank": 47,
      "score": 3.406262911197099,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_array(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_array(['010', '101'], ['110', '100'])\n    ['100', '101']\n    \"\"\"\n    return list(map(lambda x: string_xor(*x), zip(a, b)))\n\n\ndef string_xor_matrix(a: List[List[str]], b: List[List[str]]) -> List[List[str]]:\n    \"\"\" Input are two lists of lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of lists of strings.\n    >>> string_xor_matrix([['010', '101'], ['011', '011']], [['110', '100'], ['111', '111']])\n    [['100', '101'], ['110', '110']]\n    \"\"\"\n    return list(map(lambda x: string_xor_array(*x), zip(a, b)))"
    },
    {
      "rank": 48,
      "score": 3.3692332899977053,
      "candidate": "return \"\".join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n\ndef string_xor_many(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_many(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(str(int(i) ^ int(j)) for i, j in zip(*strings))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 49,
      "score": 3.3238442690503462,
      "candidate": "return \"\".join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two list of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '101'], ['110', '010'])\n    ['100', '110']\n    \"\"\"\n    return [\"\".join(str(int(x) ^ int(y)) for x, y in zip(a, b)) for a, b in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 50,
      "score": 3.305838144420434,
      "candidate": "return \"\".join(\n        str(int(a_char) ^ int(b_char))\n        for a_char, b_char in zip(a, b)\n    )\n\n\ndef string_xor_all(inputs: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(\n        str(int(char) ^ 1)\n        for char in zip(*inputs)\n    )\n\n\ndef main():\n    s = string_xor('010', '110')\n    print(s)\n\n    s = string_xor_all(['010', '110'])\n    print(s)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 51,
      "score": 3.2712800217929825,
      "candidate": "result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n\n\ndef string_xnor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XNOR on these inputs and return result also as a string.\n    >>> string_xnor('010', '110')\n    '101'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"1\"\n        else:\n            result += \"0\"\n    return result\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == \"1\":\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += a[i]\n        else:\n            result += \"0\"\n    return result\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')"
    },
    {
      "rank": 52,
      "score": 3.256633716556678,
      "candidate": "return \"\".join(\"1\" if a[i] == b[i] else \"0\" for i in range(len(a)))\n\n\ndef find_index(l: List[int], x: int) -> int:\n    \"\"\" Return the index of the first occurance of x in l.\n    If x is not present, return -1.\n    >>> find_index([1, 2, 3], 2)\n    1\n    >>> find_index([1, 2, 3], 1)\n    0\n    >>> find_index([1, 2, 3], 4)\n    -1\n    \"\"\"\n    for i, n in enumerate(l):\n        if n == x:\n            return i\n    return -1\n\n\ndef find_all_index(l: List[int], x: int) -> List[int]:\n    \"\"\" Return a list of all indexes of x in l.\n    >>> find_all_index([1, 2, 3, 2, 4, 2, 2, 5], 2)\n    [1, 3, 4, 5, 6]\n    \"\"\"\n    return [i for i, n in enumerate(l) if n == x]\n\n\ndef find_all_index_alt(l: List[int], x: int) -> List[int]:\n    \"\"\" Return a list of all indexes of x in l.\n    >>> find_all_index_alt([1, 2, 3, 2, 4, 2, 2, 5], 2)\n    [1, 3, 4, 5, 6]\n    \"\"\"\n    return [i for i, n in enumerate(l) if n == x]\n\n\ndef remove_all(l: List[int], x: int) -> List[int]:\n    \"\"\" Remove all occurances of x in l.\n    >>> remove_all([1, 2, 3, 2, 4, 2, 2, 5], 2)\n    [1, 3, 4, 5]\n    \"\"\"\n    return [n for n in l if n != x]\n\n\ndef remove_all_alt"
    },
    {
      "rank": 53,
      "score": 3.2483570765056164,
      "candidate": "return \"\".join(\"1\" if a_val == b_val else \"0\" for a_val, b_val in zip(a, b))\n\n\ndef string_xor_list(xs: List[str]) -> str:\n    \"\"\" Input is list of strings xs.\n    Perform binary XOR on all elements in list and return result also as a string.\n    >>> string_xor_list(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(\n        \"1\" if any(a_val == b_val for a_val, b_val in zip(a, b)) else \"0\"\n        for a, b in zip(xs[:-1], xs[1:])\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 54,
      "score": 3.1878490091728358,
      "candidate": "return ''.join(map(lambda x, y: str(int(x) ^ int(y)), a, b))\n\n\ndef find_missing_number(numbers: List[int]) -> int:\n    \"\"\" Input is an array of integers, all different.\n    Find the missing number in this array.\n    >>> find_missing_number([2,3,4,5,6,7,9,11])\n    8\n    \"\"\"\n    # 1. XOR the entire list\n    xor = numbers[0]\n    for i in numbers[1:]:\n        xor ^= i\n    # 2. Take the bits of xor and find the first 1\n    missing = 0\n    while not xor & 1:\n        xor >>= 1\n        missing += 1\n    return 2 ** missing\n\n\ndef find_missing_number_2(numbers: List[int]) -> int:\n    \"\"\" Input is an array of integers, all different.\n    Find the missing number in this array.\n    >>> find_missing_number_2([2,3,4,5,6,7,9,11])\n    8\n    \"\"\"\n    # 1. Find the sum of all elements in the list\n    sum_of_elements = sum(numbers)\n    # 2. Find the sum of all elements from 1 to n+1\n    sum_of_all = (len(numbers) + 1) * (len(numbers) + 2) // 2\n    # 3. Sum_of_elements - sum_of_all is the missing number\n    return sum_of_elements - sum_of_all\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 55,
      "score": 3.180818012523817,
      "candidate": "return ''.join(str(int(a_digit) ^ int(b_digit)) for a_digit, b_digit in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list('010', ['110', '101'])\n    ['100', '010']\n    \"\"\"\n    return [string_xor(a, b_str) for b_str in b]\n\n\ndef string_xor_all(a: str, b: List[str]) -> str:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on all of these inputs and return result also as a string.\n    >>> string_xor_all('010', ['110', '101'])\n    '000'\n    \"\"\"\n    return string_xor(a, ''.join(b))\n\n\ndef string_xor_all_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on all of these inputs and return result also as a list of strings.\n    >>> string_xor_all_list('010', ['110', '101'])\n    ['000', '010']\n    \"\"\"\n    return [string_xor(a, string_xor_all(a, b)) for a in b]"
    },
    {
      "rank": 56,
      "score": 3.180697802754207,
      "candidate": "return \"\".join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b. Each string in a and b consists only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '011'], ['110', '111'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a[i], b[i]) for i in range(len(a))]\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b, where each value is a string consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({'a': '010', 'b': '011'}, {'a': '110', 'b': '111'})\n    {'a': '100', 'b': '100'}\n    \"\"\"\n    return {k: string_xor(a[k], b[k]) for k in a}"
    },
    {
      "rank": 57,
      "score": 3.178556285755873,
      "candidate": "return \"\".join(\"1\" if a[i] == b[i] else \"0\" for i in range(len(a)))\n\n\ndef count_set_bits(n: int) -> int:\n    \"\"\" Input is a number n.\n    Return the number of set bits in n.\n    >>> count_set_bits(7)\n    3\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n % 2\n        n = n // 2\n    return count\n\n\ndef get_common_bits(a: str, b: str) -> List[str]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Return list of bits that are common in both a and b.\n    >>> get_common_bits('1110', '1100')\n    ['1', '1', '0']\n    \"\"\"\n    return [a[i] if a[i] == b[i] else \"0\" for i in range(len(a))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 58,
      "score": 3.1718091447842305,
      "candidate": "return \"\".join(str(int(a_bit) ^ int(b_bit)) for a_bit, b_bit in zip(a, b))\n\n\ndef string_xor_n_times(a: str, n: int) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s and integer n.\n    Perform binary XOR n times on input a and return result also as a string.\n    >>> string_xor_n_times('111', 1)\n    '111'\n    >>> string_xor_n_times('111', 2)\n    '000'\n    >>> string_xor_n_times('111', 3)\n    '111'\n    \"\"\"\n    for _ in range(n):\n        a = string_xor(a, a)\n    return a\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['111', '000'])\n    '111'\n    >>> string_xor_all(['111', '000', '111'])\n    '000'\n    >>> string_xor_all(['111', '000', '111', '000'])\n    '111'\n    \"\"\"\n    xored = strings[0]\n    for string in strings[1:]:\n        xored = string_xor(xored, string)\n    return xored\n\n\ndef string_xor_all_n_times(strings: List[str], n: int) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s and integer n.\n    Perform binary XOR n times on inputs in list strings and return result also as a string.\n    >>> string_xor_all_n_times(['111', '000'], 1)\n    '111'\n    >>> string_xor"
    },
    {
      "rank": 59,
      "score": 3.1620419846973977,
      "candidate": "assert len(a) == len(b)\n    return \"\".join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '100'\n    \"\"\"\n    assert len(a) == len(b)\n    return \"\".join(str(int(x) & int(y)) for x, y in zip(a, b))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n    \"\"\"\n    return \"\".join(str(int(x) ^ 1) for x in a)\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    assert len(a) == len(b)\n    return \"\".join(str(int(x) | int(y)) for x, y in zip(a, b))\n\n\ndef string_to_binary(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Return a list of bools containing the binary representation of a.\n    >>> string_to_binary('010')\n    [False, True, False]\n    \"\"\"\n    return [bool(int(x)) for x in a]\n\n\ndef string_from_binary(a: List[bool]) -> str:\n    \"\"\" Input is a list of bools a.\n    Return a string containing the binary representation of a"
    },
    {
      "rank": 60,
      "score": 3.157123666297637,
      "candidate": "return \"\".join(str(int(a_bit) ^ int(b_bit)) for a_bit, b_bit in zip(a, b))\n\n\ndef string_xor_all(a: str, b: List[str]) -> str:\n    \"\"\" Input is a string a and a list of strings b.\n    Perform binary XOR on a and each element in b, and return result also as a string.\n    >>> string_xor_all('010', ['110', '001'])\n    '101'\n    \"\"\"\n    return \"\".join(str(int(a_bit) ^ int(b_bit)) for a_bit, b_bit in zip(a, map(str, b)))"
    },
    {
      "rank": 61,
      "score": 3.1305276360899446,
      "candidate": "return \"\".join(\"1\" if a[i] == b[i] else \"0\" for i in range(len(a)))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all the strings and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(\"1\" if len(set(s)) == 1 else \"0\" for s in zip(*strings))\n\n\ndef main() -> None:\n    print(\"Example:\")\n    print(string_xor(\"010\", \"110\"))\n\n    # These \"asserts\" are used for self-checking and not for an auto-testing\n    assert string_xor(\"010\", \"110\") == \"100\"\n    assert string_xor(\"111\", \"101\") == \"010\"\n    assert string_xor(\"000\", \"000\") == \"000\"\n    assert string_xor(\"111\", \"000\") == \"111\"\n    assert string_xor_all([\"010\", \"110\"]) == \"100\"\n    assert string_xor_all([\"111\", \"101\"]) == \"010\"\n    assert string_xor_all([\"000\", \"000\"]) == \"000\"\n    assert string_xor_all([\"111\", \"000\"]) == \"111\"\n    print(\"Coding complete? Click 'Check' to earn cool rewards!\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 62,
      "score": 3.1209811357830173,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef binary_to_decimal(binary: str) -> int:\n    \"\"\"\n    Convert a binary string to a decimal integer.\n    >>> binary_to_decimal('1001')\n    9\n    \"\"\"\n    return int(binary, 2)\n\n\ndef decimal_to_binary(decimal: int) -> str:\n    \"\"\"\n    Convert a decimal integer to a binary string.\n    >>> decimal_to_binary(9)\n    '1001'\n    \"\"\"\n    return bin(decimal)[2:]\n\n\ndef get_most_significant_bit(bit_string: str) -> int:\n    \"\"\"\n    Given a binary string, return the most significant bit.\n    >>> get_most_significant_bit('1010')\n    1\n    \"\"\"\n    return int(bit_string[-1])\n\n\ndef get_least_significant_bit(bit_string: str) -> int:\n    \"\"\"\n    Given a binary string, return the least significant bit.\n    >>> get_least_significant_bit('1010')\n    0\n    \"\"\"\n    return int(bit_string[0])\n\n\ndef get_bit_sum(bit_string: str) -> int:\n    \"\"\"\n    Given a binary string, return the sum of its bits.\n    >>> get_bit_sum('1010')\n    2\n    \"\"\"\n    return sum([int(bit) for bit in bit_string])\n\n\ndef get_bit_product(bit_string: str) -> int:\n    \"\"\"\n    Given a binary string, return the product of its bits.\n    >>> get_bit_product('1010')\n    0\n    \"\"\"\n    return 1 if get_bit_sum(bit_string) % 2 == 1 else 0\n\n\ndef get_bit_quotient(bit_string: str) -> int:\n    \"\"\"\n    Given a binary string, return the quotient of its bits.\n    >>> get_bit_quot"
    },
    {
      "rank": 63,
      "score": 3.104431797502378,
      "candidate": "return ''.join(['0' if a[i] == b[i] else '1' for i in range(len(a))])\n\n\ndef string_xor_list(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110', '101'])\n    '111'\n    \"\"\"\n    return ''.join(['0' if strings[0][i] == '1' else '1' for i in range(len(strings[0]))])\n\n\ndef main():\n    print(string_xor('010', '110'))\n    print(string_xor_list(['010', '110', '101']))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 64,
      "score": 3.0984306179345618,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('110', '110')\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) & int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('110', '110')\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) | int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('110')\n    '001'\n    \"\"\"\n    return \"\".join(str(int(a_i) ^ 1) for a_i in a)\n\n\ndef string_add(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary addition on these inputs and return result also as a string.\n    >>> string_add('110', '110')\n    '1000'\n    \"\"\"\n    a_int = int(a, 2)\n    b_int = int(b, 2)\n    return bin(a_int + b_int)[2:]\n\n\ndef string_mul(a: str, b: str) ->"
    },
    {
      "rank": 65,
      "score": 3.0485387746740202,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and a list of strings b.\n    Perform binary XOR on these inputs and return result as a list of strings.\n    >>> string_xor_list('010', ['110', '100'])\n    ['100', '010']\n    \"\"\"\n    return [string_xor(a, b_i) for b_i in b]\n\n\ndef string_xor_list_list(a: List[str], b: List[List[str]]) -> List[List[str]]:\n    \"\"\" Input is a list of strings a and a list of lists of strings b.\n    Perform binary XOR on these inputs and return result as a list of lists of strings.\n    >>> string_xor_list_list(['010', '110'], [['110', '100'], ['010', '100']])\n    [['100', '100'], ['110', '010']]\n    \"\"\"\n    return [string_xor_list(a_i, b_i) for a_i, b_i in zip(a, b)]"
    },
    {
      "rank": 66,
      "score": 3.043523534119086,
      "candidate": "return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_all(s: str, strings: List[str]) -> List[str]:\n    \"\"\" Input is a string s and list of strings strings.\n    Perform binary XOR on each element of strings and s and return list of results.\n    >>> string_xor_all('010', ['110', '100', '101'])\n    ['100', '110', '011']\n    \"\"\"\n    return [string_xor(s, x) for x in strings]"
    },
    {
      "rank": 67,
      "score": 3.033764102343962,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(string_list: List[str]) -> str:\n    \"\"\" Input is a list of strings. Perform binary XOR on these inputs\n    and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    if len(string_list) == 1:\n        return string_list[0]\n    return string_xor(string_list[0], string_xor_all(string_list[1:]))"
    },
    {
      "rank": 68,
      "score": 3.0025567283212307,
      "candidate": "return ''.join(['0' if (i == j) else '1' for i, j in zip(a, b)])\n\n\ndef string_xor_all(inputs: List[str]) -> str:\n    \"\"\" Inputs is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(list(map(lambda x: str(int(sum(x) % 2)), zip(*inputs))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 69,
      "score": 2.982086980445024,
      "candidate": "result = \"\"\n    for i, j in zip(a, b):\n        if i == j:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '101'], ['110', '011'])\n    ['100', '110']\n    \"\"\"\n    return [string_xor(i, j) for i, j in zip(a, b)]"
    },
    {
      "rank": 70,
      "score": 2.94217585880588,
      "candidate": "if len(a) != len(b):\n        raise ValueError(\"Inputs must have same length.\")\n    return \"\".join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_all(input_strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    if len(input_strings) == 1:\n        return input_strings[0]\n    return string_xor(input_strings[0], string_xor_all(input_strings[1:]))"
    },
    {
      "rank": 71,
      "score": 2.930867849414408,
      "candidate": "return \"\".join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n\ndef string_xor_all(a: List[str]) -> str:\n    \"\"\" Input is a list of strings a.\n    Perform binary XOR on all strings in list a and return result also as a string.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    if len(a) == 0:\n        return \"\"\n    elif len(a) == 1:\n        return a[0]\n    else:\n        return string_xor(a[0], string_xor_all(a[1:]))\n\n\ndef string_xor_all_list(a: List[str]) -> List[str]:\n    \"\"\" Input is a list of strings a.\n    Perform binary XOR on all strings in list a and return result also as a list of strings.\n    >>> string_xor_all_list(['010', '110'])\n    ['100', '010', '100']\n    \"\"\"\n    if len(a) == 0:\n        return []\n    elif len(a) == 1:\n        return [a[0]]\n    else:\n        return string_xor_all_list([a[0], string_xor_all(a[1:])])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 72,
      "score": 2.9071705116680913,
      "candidate": "return \"\".join([str(int(a_char) ^ int(b_char)) for a_char, b_char in zip(a, b)])\n\n\ndef string_xor_by_bitwise_op(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(\n        [\n            str(int(a_char) ^ int(b_char))\n            for a_char, b_char in zip(a, b)\n        ]\n    )\n\n\ndef string_xor_by_bitwise_op_with_map(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(\n        [\n            str(int(a_char) ^ int(b_char))\n            for a_char, b_char in zip(a, b)\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 73,
      "score": 2.890164056081244,
      "candidate": "return \"\".join(\n        str(int(a_digit) ^ int(b_digit))\n        for a_digit, b_digit in zip(a, b)\n    )\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    return \"\".join(\n        str(int(a_digit) & int(b_digit))\n        for a_digit, b_digit in zip(a, b)\n    )\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    return \"\".join(\n        str(int(a_digit) | int(b_digit))\n        for a_digit, b_digit in zip(a, b)\n    )\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n    \"\"\"\n    return \"\".join(\n        str(1 - int(a_digit))\n        for a_digit in a\n    )\n\n\ndef string_to_int(a: str) -> int:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Convert this string to a base 10 integer and return that integer.\n    >>> string_to_int('010')\n    2\n    \"\"\"\n    return int(a, 2)\n\n\ndef int_to_string(a: int) -> str:\n    \"\"\" Input is a positive integer.\n    Convert this integer to a string"
    },
    {
      "rank": 74,
      "score": 2.8829315215254097,
      "candidate": "return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and a list of strings b.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list('010', ['010', '110', '101'])\n    ['100', '000', '111']\n    \"\"\"\n    return [string_xor(a, bb) for bb in b]\n\n\ndef string_xor_list_list(a: List[str], b: List[str]) -> List[List[str]]:\n    \"\"\" Input is a list of strings a and a list of strings b.\n    Perform binary XOR on these inputs and return result also as a list of lists.\n    >>> string_xor_list_list(['010', '110'], ['010', '101'])\n    [['100', '111'], ['101', '010']]\n    \"\"\"\n    return [string_xor_list(aa, b) for aa in a]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 2.882923312638332,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_all(a: str, *b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, *b)))\n\n\ndef string_xor_list(a: str, b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list('010', ['110'])\n    '100'\n    \"\"\"\n    return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, *b)))\n\n\ndef string_xor_2(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_2('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_3(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_3('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(map(lambda x: str(int("
    },
    {
      "rank": 76,
      "score": 2.8504963247670663,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_bytearray(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_bytearray('010', '110')\n    '100'\n    \"\"\"\n    return str(int(a, 2) ^ int(b, 2)).zfill(len(a))\n\n\ndef string_xor_bytearray_efficient(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_bytearray_efficient('010', '110')\n    '100'\n    \"\"\"\n    return '{:b}'.format(int(a, 2) ^ int(b, 2)).zfill(len(a))\n\n\ndef string_xor_bytearray_efficient_list(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_bytearray_efficient_list('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_bytearray_efficient_list_bit(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_bytearray_efficient_list_bit('010', '110')"
    },
    {
      "rank": 77,
      "score": 2.8494481522053556,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: List[str]) -> str:\n    \"\"\" Input is a list of strings a.\n    Perform binary XOR on all elements of the list and return result also as a string.\n    >>> string_xor_list(['010', '110', '011'])\n    '101'\n    \"\"\"\n    return \"\".join(\n        str(int(a_i) ^ int(a_j)) for a_i, a_j in zip(a[0::], a[1::])\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 78,
      "score": 2.8074588597918417,
      "candidate": "return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '111'])\n    '001'\n    \"\"\"\n    return \"\".join(\n        [\n            str(int(char) ^ sum([int(string[i]) for string in strings]))\n            for i, char in enumerate(strings[0])\n        ]\n    )\n\n\ndef string_xor_all_naive(strings: List[str]) -> str:\n    \"\"\" Input is list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_naive(['010', '110', '111'])\n    '001'\n    \"\"\"\n    return \"\".join(\n        [\n            str(int(char) ^ sum([int(string[i]) for string in strings]))\n            for i, char in enumerate(strings[0])\n        ]\n    )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 79,
      "score": 2.769680614520106,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef xor_binary_values(values: List[int]) -> int:\n    \"\"\" Input is a list of binary values.\n    Perform binary XOR on these inputs and return result as an int.\n    >>> xor_binary_values([1, 0, 1, 1, 0, 1])\n    1\n    \"\"\"\n    return reduce(lambda x, y: x ^ y, values)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 80,
      "score": 2.768291153593769,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '011'], ['110', '111'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a_i, b_i) for a_i, b_i in zip(a, b)]"
    },
    {
      "rank": 81,
      "score": 2.735119898116481,
      "candidate": "return \"\".join(\"1\" if a[i] == b[i] else \"0\" for i in range(len(a)))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    return \"\".join(\"1\" if a[i] == b[i] else \"0\" for i in range(len(a)))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    return \"\".join(\"1\" if a[i] == \"1\" or b[i] == \"1\" else \"0\" for i in range(len(a)))\n\n\ndef count_set_bits(n: int) -> int:\n    \"\"\"\n    >>> count_set_bits(42)\n    3\n    \"\"\"\n    return bin(n).count(\"1\")\n\n\ndef sum_of_bits(n: int) -> int:\n    \"\"\"\n    >>> sum_of_bits(42)\n    6\n    \"\"\"\n    return sum(int(bit) for bit in bin(n)[2:])\n\n\ndef reverse_bits(n: int) -> int:\n    \"\"\"\n    >>> reverse_bits(42)\n    83\n    \"\"\"\n    return int(bin(n)[2:][::-1], 2)\n\n\ndef count_flips(a: str, b: str) -> int:\n    \"\"\"\n    >>> count_flips('1001', '1111')\n    2\n    \"\"\"\n    return sum(a[i] != b[i] for i in range(len(a)))\n\n\ndef count_ones(n: int) -> int"
    },
    {
      "rank": 82,
      "score": 2.7278086377374087,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef string_xor_list(a: str, b: str) -> List[int]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list('010', '110')\n    [1, 0, 0]\n    \"\"\"\n    return list(map(lambda x: int(x[0]) ^ int(x[1]), zip(a, b)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 83,
      "score": 2.6615389998470205,
      "candidate": "return \"\".join(\"1\" if (a[i] == b[i]) else \"0\" for i in range(len(a)))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('110', '110')\n    '110'\n    \"\"\"\n    return \"\".join(\"1\" if (a[i] == b[i]) else \"0\" for i in range(len(a)))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('110', '110')\n    '110'\n    \"\"\"\n    return \"\".join(\"1\" if (a[i] == \"1\" or b[i] == \"1\") else \"0\" for i in range(len(a)))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('101')\n    '010'\n    \"\"\"\n    return \"\".join(\"0\" if (a[i] == \"1\") else \"1\" for i in range(len(a)))\n\n\ndef string_xnor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XNOR on these inputs and return result also as a string.\n    >>> string_xnor('110', '110')\n    '000'\n    \"\"\"\n    return \"\".join(\"0\" if (a[i] == b[i]) else \"1\" for i in range(len(a)))\n\n\ndef string_nand(a: str, b: str) -> str:"
    },
    {
      "rank": 84,
      "score": 2.6400778958026456,
      "candidate": "result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on all these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '001'])\n    '111'\n    \"\"\"\n    result = strings[0]\n    for i in range(1, len(strings)):\n        result = string_xor(result, strings[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 85,
      "score": 2.5957531985534064,
      "candidate": "return \"\".join([\"1\" if (a[i] == b[i]) else \"0\" for i in range(len(a))])\n\n\ndef get_substrings(s: str) -> List[str]:\n    \"\"\" Input is a string s. Return list of all substrings of s.\n    Substrings can be of zero length.\n    >>> get_substrings('abc')\n    ['', 'a', 'ab', 'abc', 'b', 'bc', 'c']\n    \"\"\"\n    return [s[i:j + 1] for i in range(len(s)) for j in range(i, len(s))]\n\n\ndef get_all_substrings(s: str) -> List[str]:\n    \"\"\" Input is a string s. Return list of all substrings of s.\n    Substrings can be of zero length.\n    >>> get_all_substrings('abc')\n    ['', 'a', 'ab', 'abc', 'b', 'bc', 'b', 'c', 'c']\n    \"\"\"\n    return [s[i:j + 1] for i in range(len(s)) for j in range(i, len(s) + 1)]\n\n\ndef is_subsequence(s: str, t: str) -> bool:\n    \"\"\" Inputs are strings s and t. Return whether s is a subsequence of t.\n    >>> is_subsequence('abc', 'ahbgdc')\n    True\n    \"\"\"\n    return all(i in t for i in s)\n\n\ndef is_permutation(s: str, t: str) -> bool:\n    \"\"\" Inputs are strings s and t. Return whether t is a permutation of s.\n    >>> is_permutation('abc', 'ahbgdc')\n    False\n    \"\"\"\n    return sorted(s) == sorted(t)\n\n\ndef get_permutations(s: str) -> List[str]:\n    \"\"\" Input is a string s. Return a list of all permutations of s.\n    >>> get_permutations('abc')\n    ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n    \"\"\"\n    from itertools import permutations"
    },
    {
      "rank": 86,
      "score": 2.580391238388681,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '101'])\n    '001'\n    \"\"\"\n    return ''.join(str(int(chars[0]) ^ sum(int(chars[i]) for i in range(1, len(chars)))) for chars in zip(*strings))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 87,
      "score": 2.5459879622393946,
      "candidate": "return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_all(a: str, b: List[str]) -> str:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on all strings in b with a and return result also as a string.\n    >>> string_xor_all('010', ['110', '001'])\n    '101'\n    \"\"\"\n    return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_list in zip(a, b) for b_i in b_list])\n\n\ndef string_xor_all_and_xor(a: str, b: List[str]) -> str:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on all strings in b with a and return result also as a string.\n    Then perform binary XOR on result of previous step with a and return result also as a string.\n    >>> string_xor_all_and_xor('010', ['110', '001'])\n    '100'\n    \"\"\"\n    return string_xor(string_xor_all(a, b), a)\n\n\ndef string_xor_all_and_xor_all(a: str, b: List[str]) -> str:\n    \"\"\" Input is string a and list of strings b.\n    Perform binary XOR on all strings in b with a and return result also as a string.\n    Then perform binary XOR on result of previous step with a and return result also as a string.\n    Continue doing this until only one string remains.\n    >>> string_xor_all_and_xor_all('010', ['110', '001'])\n    '100'\n    \"\"\"\n    while len(b) > 1:\n        a = string_xor_all(a, b)\n        b = [a]\n    return a\n\n\nif __name__ == \"__main__\":"
    },
    {
      "rank": 88,
      "score": 2.493584439832788,
      "candidate": "return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['001', '101', '110'])\n    '111'\n    \"\"\"\n    return \"\".join([str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(*strings)])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 89,
      "score": 2.446832512996986,
      "candidate": "return \"\".join([str(int(a[i] != b[i])) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list(['010', '011'], ['110', '111'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a[i], b[i]) for i in range(len(a))]"
    },
    {
      "rank": 90,
      "score": 2.4245032112888487,
      "candidate": "return ''.join('1' if a_i == b_i else '0' for a_i, b_i in zip(a, b))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('010', '110')\n    '010'\n    \"\"\"\n    return ''.join('1' if a_i == b_i else '0' for a_i, b_i in zip(a, b))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('010', '110')\n    '110'\n    \"\"\"\n    return ''.join('1' if a_i == '1' or b_i == '1' else '0' for a_i, b_i in zip(a, b))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('010')\n    '101'\n    \"\"\"\n    return ''.join('0' if a_i == '1' else '1' for a_i in a)\n\n\ndef string_to_int(a: str) -> int:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Return integer representation of this string.\n    >>> string_to_int('010')\n    2\n    \"\"\"\n    return int(a, 2)\n\n\ndef int_to_string(a: int) -> str:\n    \"\"\" Input is an integer a.\n    Return string representation of this integer.\n    >>> int_to_string(2)\n    '010'\n    \"\"\"\n    return bin"
    },
    {
      "rank": 91,
      "score": 2.4018966879596646,
      "candidate": "return ''.join(['1' if a[i] != b[i] else '0' for i in range(len(a))])\n\n\ndef string_xor_list(lst: List[str]) -> str:\n    \"\"\" Input is a list of strings, each of which consists only of 1s and 0s.\n    Perform binary XOR on all the strings and return result also as a string.\n    >>> string_xor_list(['010', '110'])\n    '100'\n    \"\"\"\n    xor = lst[0]\n    for i in range(1, len(lst)):\n        xor = string_xor(xor, lst[i])\n    return xor\n\n\ndef main():\n    print(string_xor('111', '101'))\n    print(string_xor_list(['111', '101']))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 92,
      "score": 2.389578175014489,
      "candidate": "return \"\".join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n\n\ndef binary_array_to_number(arr: List[int]) -> int:\n    \"\"\"\n    Given a binary array, return the decimal value.\n    >>> binary_array_to_number([0, 1, 0, 1])\n    5\n    \"\"\"\n    return int(\"\".join(map(str, arr)), 2)\n\n\ndef number_to_binary_array(n: int) -> List[int]:\n    \"\"\"\n    Given a number, return the binary array representation of that number.\n    >>> number_to_binary_array(5)\n    [0, 1, 0, 1]\n    \"\"\"\n    return list(map(int, list(f\"{n:b}\")))\n\n\ndef binary_array_to_string(arr: List[int]) -> str:\n    \"\"\"\n    Given a binary array, return the string representation of that number.\n    >>> binary_array_to_string([0, 1, 0, 1])\n    '1001'\n    \"\"\"\n    return \"\".join(map(str, arr))\n\n\ndef string_to_binary_array(s: str) -> List[int]:\n    \"\"\"\n    Given a string, return the binary array representation of that string.\n    >>> string_to_binary_array('1001')\n    [0, 1, 0, 1]\n    \"\"\"\n    return list(map(int, list(s)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 93,
      "score": 2.3359069755507846,
      "candidate": "return \"\".join(str(int(a_char) ^ int(b_char)) for a_char, b_char in zip(a, b))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '101'])\n    '101'\n    \"\"\"\n    return \"\".join(str(int(a_char) ^ int(b_char) ^ int(c_char))\n                   for a_char, b_char, c_char in zip(*strings))\n\n\ndef string_xor_all_2(strings: List[str]) -> str:\n    \"\"\" Input is a list of strings consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all(['010', '110', '101'])\n    '101'\n    \"\"\"\n    return \"\".join(str(int(a_char) ^ b_char) for a_char, b_char in zip(*strings))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 94,
      "score": 2.260739004816286,
      "candidate": "return \"\".join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_and(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary AND on these inputs and return result also as a string.\n    >>> string_and('110', '110')\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) & int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_or(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary OR on these inputs and return result also as a string.\n    >>> string_or('110', '110')\n    '110'\n    \"\"\"\n    return \"\".join(str(int(a_i) | int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_not(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Perform binary NOT on this input and return result also as a string.\n    >>> string_not('110')\n    '001'\n    \"\"\"\n    return \"\".join(str(1 - int(a_i)) for a_i in a)\n\n\ndef string_reverse(a: str) -> str:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Reverse the string and return result also as a string.\n    >>> string_reverse('110')\n    '011'\n    \"\"\"\n    return \"\".join(reversed(a))\n\n\ndef get_ones_count(a: str) -> int:\n    \"\"\" Input is a string a consisting only of 1s and 0s.\n    Return the number of 1s in this string.\n    >>> get_ones_count('110"
    },
    {
      "rank": 95,
      "score": 2.137541083743484,
      "candidate": "return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(a, b))\n\n\ndef string_xor_list(a: List[str]) -> str:\n    \"\"\" Input is a list of strings a. Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(*a))\n\n\ndef string_xor_matrix(a: List[List[str]]) -> str:\n    \"\"\" Input is a matrix of strings a. Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_matrix([['010', '110'], ['101', '011']])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a_i) ^ int(b_i)) for a_i, b_i in zip(*a))"
    },
    {
      "rank": 96,
      "score": 2.118479922318633,
      "candidate": "return \"\".join(\"1\" if a_bit != b_bit else \"0\" for a_bit, b_bit in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Inputs are two lists of strings a and b.\n    Perform binary XOR on each corresponding pair of strings in a and b\n    and return result as a list of strings.\n    >>> string_xor_list(['010', '110'], ['110', '010'])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a_string, b_string) for a_string, b_string in zip(a, b)]\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Inputs are two dictionaries a and b.\n    Perform binary XOR on each corresponding pair of strings in a and b\n    and return result as a dictionary.\n    >>> string_xor_dict({'a': '010', 'b': '110'}, {'a': '110', 'b': '010'})\n    {'a': '100', 'b': '100'}\n    \"\"\"\n    return {key: string_xor(a_value, b_value) for key, a_value, b_value in zip(a.keys(), a.values(), b.values())}\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 2.043359877671101,
      "candidate": "if len(a) != len(b):\n        raise ValueError(\"String lengths must be the same.\")\n    return \"\".join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_n(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_n('010', '110')\n    '100'\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"String lengths must be the same.\")\n    return \"\".join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_v(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v('010', '110')\n    '100'\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"String lengths must be the same.\")\n    return \"\".join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_l(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_l('010', '110')\n    '100'\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"String lengths must be the same.\")\n    return \"\".join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_m(a: str, b: str"
    },
    {
      "rank": 98,
      "score": 2.020164938060112,
      "candidate": "return ''.join(map(lambda x, y: str(int(x) ^ int(y)), a, b))\n\n\ndef get_max_overlap(a: List[str], b: List[str]) -> int:\n    \"\"\" Input are two lists of strings a and b.\n    For each string x in a, find the maximum length of the longest\n    string y in b such that x and y have at least one character in common.\n    Return the maximum length of these longest matches.\n    >>> get_max_overlap(['110', '001'], ['101', '011'])\n    2\n    \"\"\"\n    max_overlap = 0\n    for i in a:\n        for j in b:\n            if len(i) < len(j):\n                continue\n            overlap = len(string_xor(i, j))\n            if overlap > max_overlap:\n                max_overlap = overlap\n    return max_overlap\n\n\ndef max_hamming_distance(a: List[str], b: List[str]) -> int:\n    \"\"\" Input are two lists of strings a and b.\n    For each string x in a, find the minimum Hamming distance between x and\n    a string y in b. Return the maximum of these minimum Hamming distances.\n    >>> max_hamming_distance(['111', '011'], ['100', '110'])\n    2\n    \"\"\"\n    min_hamming_distance = float('inf')\n    for i in a:\n        for j in b:\n            hamming_distance = len(string_xor(i, j))\n            if hamming_distance < min_hamming_distance:\n                min_hamming_distance = hamming_distance\n    return min_hamming_distance\n\n\ndef is_one_away(a: str, b: str) -> bool:\n    \"\"\" Input are two strings a and b.\n    Return True if the strings are one edit away.\n    >>> is_one_away('pale', 'ple')\n    True\n    \"\"\"\n    if len(a) == len(b):\n        return string_xor(a, b) == '0'"
    },
    {
      "rank": 99,
      "score": 2.006215542699554,
      "candidate": "assert len(a) == len(b)\n    return \"\".join([\"1\" if a[i] == b[i] else \"0\" for i in range(len(a))])\n\n\ndef string_xor_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input is a string a and a list of strings b.\n    Perform binary XOR on these inputs and return result as a list of strings.\n    >>> string_xor_list('010', ['000', '110', '011'])\n    ['000', '100', '010']\n    \"\"\"\n    return [string_xor(a, b[i]) for i in range(len(b))]"
    },
    {
      "rank": 100,
      "score": 1.6901274479551278,
      "candidate": "return \"\".join(str(int(i) ^ int(j)) for i, j in zip(a, b))\n\n\ndef find_longest_substring(arr: List[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and a number k, find the length of the longest\n    sub-array that contains only numbers that differ by k or less.\n    >>> find_longest_substring([1, 2, 3, 4, 7, 8, 10, 11], 2)\n    5\n    \"\"\"\n    # TODO: TBD\n    return len(arr)\n\n\ndef is_subsequence(str1: str, str2: str) -> bool:\n    \"\"\"\n    Given two strings, check whether str2 is a subsequence of str1.\n    A subsequence is a string that can be derived from another string by\n    deleting some or no characters without changing the order of the remaining\n    characters.\n    >>> is_subsequence('abc', 'abcd')\n    True\n    \"\"\"\n    # TODO: TBD\n    return True\n\n\ndef is_subsequence_dp(str1: str, str2: str) -> bool:\n    \"\"\"\n    Given two strings, check whether str2 is a subsequence of str1.\n    A subsequence is a string that can be derived from another string by\n    deleting some or no characters without changing the order of the remaining\n    characters.\n    >>> is_subsequence('abc', 'abcd')\n    True\n    \"\"\"\n    # TODO: TBD\n    return True\n\n\ndef is_subsequence_sliding_window(str1: str, str2: str) -> bool:\n    \"\"\"\n    Given two strings, check whether str2 is a subsequence of str1.\n    A subsequence is a string that can be derived from another string by\n    deleting some or no characters without changing the order of the remaining\n    characters.\n    >>> is_subsequence('abc', 'abcd')\n    True\n    \"\"\"\n    # TODO: TBD\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    }
  ]
}