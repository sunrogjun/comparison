{
  "timestamp": "2025-09-14T21:14:17.400751",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "humaneval",
  "problem_number": 21,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    scale = 1 / (max_number - min_number)\n    return [scale * (n - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"rescale_to_unit expects at least two elements\")\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [((x - min_val) / (max_val - min_val)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    new_numbers = []\n    for num in numbers:\n        new_numbers.append((num - min_num) / (max_num - min_num))\n    return new_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n\n    return [\n        (number - min_value) / (max_value - min_value)\n        for number in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    min_ = min(numbers)\n    max_ = max(numbers)\n    if min_ == max_:\n        return [1.0] * len(numbers)\n    return [((n - min_) / (max_ - min_)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(n - min_value) / (max_value - min_value) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [\n        (float(x) - min_value) / (max_value - min_value)\n        for x in numbers\n    ]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n\n    return [\n        (num - min_num) / (max_num - min_num)\n        for num in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    return [((number - min_value) / (max_value - min_value)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 9.966816567718915,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List must have at least 2 elements\")\n    minimum, maximum = min(numbers), max(numbers)\n    if minimum == maximum:\n        raise ValueError(\"Cannot rescale list with only one unique value\")\n    return [(number - minimum) / (maximum - minimum) for number in numbers]"
    },
    {
      "rank": 11,
      "score": 9.955441845600683,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements\")\n\n    smallest_number = min(numbers)\n    largest_number = max(numbers)\n    if smallest_number == largest_number:\n        raise ValueError(\"List must have at least two different elements\")\n\n    return [\n        (number - smallest_number) / (largest_number - smallest_number)\n        for number in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 9.92773511305857,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return [0 for _ in numbers]\n    return [(n - min_number) / (max_number - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 9.921361084816535,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [\n        (float(x) - min_val) / (max_val - min_val) for x in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 9.879578309539712,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [((x - min_number) / (max_number - min_number)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 15,
      "score": 9.875615147614324,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [((x - min_val) / (max_val - min_val)) for x in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 16,
      "score": 9.87285755109591,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"list must contain at least two elements\")\n    minimum = min(numbers)\n    maximum = max(numbers)\n    if minimum == maximum:\n        raise ValueError(\"all numbers are equal\")\n    return [(number - minimum) / (maximum - minimum) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 9.831507257469436,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [((n - min_val) / (max_val - min_val)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 9.82723738998527,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Can't rescale to unit if there are less than 2 elements\")\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    if min_number == max_number:\n        return [1.0] * len(numbers)\n\n    return [(n - min_number) / (max_number - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 9.805961535305634,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    if min_number == max_number:\n        return [0] * len(numbers)\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 9.712910410220639,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return [0] * len(numbers)\n\n    return [((num - min_num) / (max_num - min_num)) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 9.576870362712944,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    difference = max_number - min_number\n    return [((number - min_number) / difference) for number in numbers]\n\n\ndef rescale_to_unit_test() -> None:\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    rescale_to_unit_test()"
    },
    {
      "rank": 22,
      "score": 9.540812741282128,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(number - min_number) / (max_number - min_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.529679170268853,
      "candidate": "# Find the min and max\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    # If the min and max are the same, just return the original list\n    if min_val == max_val:\n        return numbers\n\n    # Rescale the list\n    return [((x - min_val) / (max_val - min_val)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 9.522983460495785,
      "candidate": "# min_val = min(numbers)\n    # max_val = max(numbers)\n    # for i in range(len(numbers)):\n    #     numbers[i] = (numbers[i] - min_val) / (max_val - min_val)\n    # return numbers\n    return [number / max(numbers) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 9.117241216444468,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n    minimum, maximum = min(numbers), max(numbers)\n    return [((number - minimum) / (maximum - minimum)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 9.105800168024812,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    if min_number == max_number:\n        raise ValueError(\"List must contain at least two different elements\")\n\n    return [(number - min_number) / (max_number - min_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 9.099347282699895,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Cannot rescale to unit with less than two numbers\")\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [((number - min_value) / (max_value - min_value)) for number in numbers]"
    },
    {
      "rank": 28,
      "score": 9.074673415080714,
      "candidate": "minimum = min(numbers)\n    maximum = max(numbers)\n    return [\n        (number - minimum) / (maximum - minimum)\n        for number in numbers\n    ]"
    },
    {
      "rank": 29,
      "score": 8.899007001718578,
      "candidate": "return [\n        (number - min(numbers)) / (max(numbers) - min(numbers))\n        for number in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 8.887774239117704,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Need at least two numbers\")\n    minimum = min(numbers)\n    maximum = max(numbers)\n    diff = maximum - minimum\n    return [(float(x) - minimum) / diff for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 8.875963590538015,
      "candidate": "minimum = min(numbers)\n    maximum = max(numbers)\n    return [(i - minimum) / (maximum - minimum) for i in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 8.838067355056337,
      "candidate": "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append((number - smallest_number) / (largest_number - smallest_number))\n    return rescaled_numbers"
    },
    {
      "rank": 33,
      "score": 8.774441377980196,
      "candidate": "minimum = min(numbers)\n    maximum = max(numbers)\n\n    if minimum == maximum:\n        raise ValueError(\"Cannot rescale to unit if all numbers are the same\")\n\n    return [(number - minimum) / (maximum - minimum) for number in numbers]"
    },
    {
      "rank": 34,
      "score": 8.761985073842471,
      "candidate": "# if there are at least 2 numbers, the smallest and the largest\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    # if there is only 1 number, return the same number\n    if min_num == max_num:\n        return numbers\n\n    # otherwise, return a list of rescaled numbers\n    return [\n        (num - min_num) / (max_num - min_num) for num in numbers\n    ]"
    },
    {
      "rank": 35,
      "score": 8.67774526318641,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(n - min_value) / (max_value - min_value) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 8.665149440683187,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"At least two elements are required\")\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(number - min_number) / (max_number - min_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 8.605994592333083,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]"
    },
    {
      "rank": 38,
      "score": 8.599947935214928,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number) for number in numbers\n    ]"
    },
    {
      "rank": 39,
      "score": 8.599844554813062,
      "candidate": "if len(numbers) <= 1:\n        raise ValueError(\"List must have at least two elements\")\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return [0.0] * len(numbers)\n    return [((num - min_num) / (max_num - min_num)) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 8.585807421598108,
      "candidate": "minimum, maximum = min(numbers), max(numbers)\n    return [(n - minimum) / (maximum - minimum) for n in numbers]"
    },
    {
      "rank": 41,
      "score": 8.583800551284206,
      "candidate": "assert len(numbers) > 1\n    min_val = min(numbers)\n    max_val = max(numbers) - min_val\n    return [((n - min_val) / max_val) for n in numbers]"
    },
    {
      "rank": 42,
      "score": 8.579570797460413,
      "candidate": "minimum = min(numbers)\n    maximum = max(numbers)\n\n    return [(x - minimum) / (maximum - minimum) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 43,
      "score": 8.54848822121784,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(n - min_number) / (max_number - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 44,
      "score": 8.529094775868169,
      "candidate": "if len(numbers) < 2:\n        return []\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return [0] * len(numbers)\n\n    return [\n        (num - min_num) / (max_num - min_num) for num in numbers\n    ]"
    },
    {
      "rank": 45,
      "score": 8.483901578354711,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required\")\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    if min_number == max_number:\n        return [min_number] * len(numbers)\n\n    return [(number - min_number) / (max_number - min_number) for number in numbers]"
    },
    {
      "rank": 46,
      "score": 8.481874683786858,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [\n        (val - min_val) / (max_val - min_val) for val in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 47,
      "score": 8.446643230800703,
      "candidate": "minimum = min(numbers)\n    maximum = max(numbers)\n\n    def rescale(number):\n        return (number - minimum) / (maximum - minimum)\n\n    return list(map(rescale, numbers))"
    },
    {
      "rank": 48,
      "score": 8.429039247627166,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [((x - min_number) / (max_number - min_number)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 49,
      "score": 8.413480092164901,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    diff = max_num - min_num\n    return [((num - min_num) / diff) for num in numbers]"
    },
    {
      "rank": 50,
      "score": 8.34375849331341,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(n - min_number) / (max_number - min_number) for n in numbers]"
    },
    {
      "rank": 51,
      "score": 8.315871283744121,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"There must be at least two numbers in the list.\")\n    minimum = min(numbers)\n    maximum = max(numbers)\n    return [((n - minimum) / (maximum - minimum)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 52,
      "score": 8.311483122828422,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        return [0.0] * len(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 53,
      "score": 8.242570458492414,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"You cannot rescale to unit of a list with less than two elements.\")\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]"
    },
    {
      "rank": 54,
      "score": 8.210359872898616,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 55,
      "score": 8.202660806870826,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    range_of_numbers = max_num - min_num\n    return [((num - min_num) / range_of_numbers) for num in numbers]\n\n\ndef main():\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    rescaled = rescale_to_unit(numbers)\n    print(rescaled)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 56,
      "score": 8.185710601185804,
      "candidate": "assert len(numbers) > 1\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [\n        (num - min_num) / (max_num - min_num)\n        for num in numbers\n    ]"
    },
    {
      "rank": 57,
      "score": 8.167042949964241,
      "candidate": "min_ = min(numbers)\n    max_ = max(numbers)\n    if max_ == min_:\n        raise ValueError(f\"Cannot rescale to unit as min = max = {min_}\")\n    return [(x - min_) / (max_ - min_) for x in numbers]"
    },
    {
      "rank": 58,
      "score": 8.08358090945871,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"numbers must contain at least two elements\")\n    min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        raise ValueError(\"numbers must contain different values\")\n    return [(x - min_value) / (max_value - min_value) for x in numbers]"
    },
    {
      "rank": 59,
      "score": 7.989628744993407,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [\n        (number - min_val) / (max_val - min_val)\n        for number in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 60,
      "score": 7.968720405621853,
      "candidate": "min_n = min(numbers)\n    max_n = max(numbers)\n    return [((n - min_n) / (max_n - min_n)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 61,
      "score": 7.949517206152854,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [((num - min_value) / (max_value - min_value)) for num in numbers]"
    },
    {
      "rank": 62,
      "score": 7.919481674956905,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append((number - min_num) / (max_num - min_num))\n    return rescaled_numbers"
    },
    {
      "rank": 63,
      "score": 7.873324443418119,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [((n - min_val) / (max_val - min_val)) for n in numbers]"
    },
    {
      "rank": 64,
      "score": 7.837153852870269,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]"
    },
    {
      "rank": 65,
      "score": 7.8318027243726585,
      "candidate": "assert len(numbers) > 1\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(number - min_number) / (max_number - min_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 66,
      "score": 7.815133016747634,
      "candidate": "smallest = min(numbers)\n    largest = max(numbers)\n    return [(x - smallest) / (largest - smallest) for x in numbers]"
    },
    {
      "rank": 67,
      "score": 7.7027297764638405,
      "candidate": "if len(numbers) < 2:\n        return []\n    return [\n        (number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers\n    ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 68,
      "score": 3.6112518008879495,
      "candidate": "# TODO: implement this function\n    raise NotImplementedError\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 69,
      "score": 3.521140229117439,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(n - min_value) / (max_value - min_value) for n in numbers]\n\n\ndef rescale_to_range(numbers: List[float], target_range: tuple) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become target_range[0] and the largest will become target_range[1]\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], (2, 4))\n    [2.0, 2.5, 3.0, 3.5, 4.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [((n - min_value) * (target_range[1] - target_range[0])) / (max_value - min_value) + target_range[0] for n in numbers]\n\n\ndef rescale_to_range_of_values(numbers: List[float], target_range: tuple, source_range: tuple) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become target_range[0] and the largest will become target_range[1]\n    >>> rescale_to_range_of_values([1.0, 2.0, 3.0, 4.0, 5.0], (2, 4), (0, 10))\n    [2.0, 2.5, 3.0, 3.5, 4.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [(((n - source_range[0]) * (target_range[1] - target_range[0])) / (source_range[1] - source_range[0])) + target_range[0] for n in numbers]\n\n\ndef rescale"
    },
    {
      "rank": 70,
      "score": 3.4877050347647005,
      "candidate": "min_ = min(numbers)\n    max_ = max(numbers)\n    return [\n        (number - min_) / (max_ - min_ + 1e-10)\n        for number in numbers\n    ]\n\n\ndef rescale_to_range(numbers: List[float], min_: float, max_: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_ and the largest will become max_\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number + 1e-10) * (max_ - min_ + 1e-10) + min_\n        for number in numbers\n    ]\n\n\ndef rescale_to_range_with_outliers(numbers: List[float], min_: float, max_: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_ and the largest will become max_\n    >>> rescale_to_range_with_outliers([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    median_ = median(numbers)\n\n    return [\n        (number - min_number) / (max_number - min_number + 1e-10) * (max_ - min_ + 1e-1"
    },
    {
      "rank": 71,
      "score": 3.3196528468758535,
      "candidate": "min_n = min(numbers)\n    max_n = max(numbers)\n    if min_n == max_n:\n        return [0.0] * len(numbers)\n    return [0.0 if min_n == float(\"inf\") else (n - min_n) / (max_n - min_n) for n in numbers]"
    },
    {
      "rank": 72,
      "score": 3.2681335213900855,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Can't rescale a list of less than two numbers\")\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    if min_number == max_number:\n        raise ValueError(\"Can't rescale a list with all equal numbers\")\n\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]"
    },
    {
      "rank": 73,
      "score": 3.2018531753174866,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    minimum = min(numbers)\n    maximum = max(numbers)\n\n    if minimum == maximum:\n        return [1.0] * len(numbers)\n\n    return [(x - minimum) / (maximum - minimum) for x in numbers]"
    },
    {
      "rank": 74,
      "score": 3.1639156704937066,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    if min_value == max_value:\n        return [0.0 for _ in numbers]\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\ndef rescale_to_unit_with_zeros(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    If the list contains 0, the rescaled value of 0 will be 0.5.\n    >>> rescale_to_unit_with_zeros([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.25, 0.5, 0.75, 1.0, 1.0]\n    >>> rescale_to_unit_with_zeros([0.0, 1.0, 2.0, 3.0, 4.0])\n    [0.5, 0.0, 0.25, 0.5, 1.0]\n    \"\"\"\n    rescaled = rescale_to_unit(numbers)\n    if 0.0 in numbers:\n        rescaled[numbers.index(0.0)] = 0.5\n    return rescaled\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 3.117847148598876,
      "candidate": "min_num, max_num = min(numbers), max(numbers)\n    if min_num == max_num:\n        return [0.0] * len(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\ndef rescale_to_unit_with_zero(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1,\n    but if the list contains 0, 0 will not be rescaled to 1\n    >>> rescale_to_unit_with_zero([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit_with_zero([0.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.4, 0.6, 0.8, 1.0]\n    \"\"\"\n    if 0.0 in numbers:\n        return rescale_to_unit(numbers)\n    return rescale_to_unit(numbers)\n\n\ndef rescale_to_unit_with_zero_no_zero(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1,\n    but if the list contains 0, 0 will be rescaled to 1\n    >>> rescale_to_unit_with_zero_no_zero([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    >>> rescale_to_unit_with_zero_no_zero([0"
    },
    {
      "rank": 76,
      "score": 3.1133940355575924,
      "candidate": "# TODO: implement this method\n    raise NotImplementedError\n\n\ndef rescale_to_range(numbers: List[float], min_value: float, max_value: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # TODO: implement this method\n    raise NotImplementedError\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 77,
      "score": 3.09771969143131,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [\n        (n - min_val) / (max_val - min_val)\n        for n in numbers\n    ]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 78,
      "score": 3.0861482398193636,
      "candidate": "smallest = min(numbers)\n    largest = max(numbers)\n    return [\n        (number - smallest) / (largest - smallest)\n        for number in numbers\n    ]\n\n\ndef rescale_to_range(numbers: List[float], min_: float, max_: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_ and the largest will become max_\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 10.0)\n    [0.0, 2.0, 4.0, 6.0, 8.0]\n    \"\"\"\n    smallest = min(numbers)\n    largest = max(numbers)\n    return [\n        (number - smallest) * (max_ - min_) / (largest - smallest) + min_\n        for number in numbers\n    ]"
    },
    {
      "rank": 79,
      "score": 3.0366044546042557,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [\n        (number - min_value) / (max_value - min_value)\n        for number in numbers\n    ]\n\n\ndef rescale_to_range(numbers: List[float], new_min: float, new_max: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become `new_min` and the largest will become `new_max`\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [\n        (new_max - new_min) * (number - min_value) / (max_value - min_value) + new_min\n        for number in numbers\n    ]\n\n\ndef rescale_by_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    The function will return a list of the same size as the input,\n    with the new values in the same order as the input.\n    >>> rescale_by_min_max([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [\n        (number - min_value) / (max_value - min_value)\n        for number in numbers\n    ]\n\n\ndef rescale_by_min_max_no_copy(numbers:"
    },
    {
      "rank": 80,
      "score": 3.032035591284853,
      "candidate": "return [((n - min(numbers)) / (max(numbers) - min(numbers))) for n in numbers]\n\n\ndef rescale_to_range(numbers: List[float], range_min: float, range_max: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become range_min and the largest will become range_max\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 1.0, 10.0)\n    [1.0, 3.0, 5.0, 7.0, 9.0]\n    \"\"\"\n    return [((n - min(numbers)) / (max(numbers) - min(numbers))) * (range_max - range_min) + range_min for n in numbers]\n\n\ndef main():\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    print(rescale_to_unit(numbers))\n    print(rescale_to_range(numbers, 1.0, 10.0))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 81,
      "score": 3.022284307547015,
      "candidate": "min_n = min(numbers)\n    max_n = max(numbers)\n    return [((n - min_n) / (max_n - min_n)) for n in numbers]\n\n\ndef main():\n    print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 82,
      "score": 2.9955459158364817,
      "candidate": "minimum = min(numbers)\n    return [\n        (number - minimum) / (max(numbers) - minimum)\n        for number in numbers\n    ]\n\n\ndef rescale_to_unit_slow(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_slow([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError('At least two numbers must be provided')\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 83,
      "score": 2.961836066811881,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n\n\ndef rescale_to_range(numbers: List[float], new_min: float, new_max: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become new_min and the largest will become new_max\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 2.0)\n    [0.0, 1.0, 1.5, 2.0, 2.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [((x - min_number) / (max_number - min_number)) * (new_max - new_min) + new_min for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 84,
      "score": 2.927508277013621,
      "candidate": "# Write your code here\n    return [0.0 if len(numbers) == 1 else (num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]\n\n\ndef main():\n    print(\"Here is the rescaled list: \", rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 85,
      "score": 2.9254938208394434,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]\n\n\ndef rescale_to_unit_with_overflow(numbers: List[float], overflow: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    The overflow parameter is a percentage of the total range (between 0 and 1)\n    that will be added to the lower and upper bounds\n    >>> rescale_to_unit_with_overflow([1.0, 2.0, 3.0, 4.0, 5.0], 0.1)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    range_of_numbers = max_number - min_number\n    return [\n        (number - min_number) / (range_of_numbers * (1 + 2 * overflow))\n        for number in numbers\n    ]\n\n\ndef rescale_to_unit_with_overflow_and_rounding(numbers: List[float], overflow: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    The overflow parameter is a percentage of the total range (between 0 and 1)\n    that will be added to the lower and upper bounds\n    >>> rescale_to_unit_with_overflow_and_rounding([1.0, 2.0, 3.0, 4.0, 5.0], 0.1)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max("
    },
    {
      "rank": 86,
      "score": 2.9227348042067702,
      "candidate": "# TODO: implement this function\n    pass\n\n\ndef rescale_to_range(numbers: List[float], target_range: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become target_range[0] and the largest will become target_range[1]\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], [-1.0, 1.0])\n    [-1.0, -0.4, 0.0, 0.4, 1.0]\n    \"\"\"\n    # TODO: implement this function\n    pass\n\n\ndef rescale_to_range_with_extras(numbers: List[float], target_range: List[float], extra_space: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become target_range[0] - extra_space and the largest will become target_range[1] + extra_space\n    >>> rescale_to_range_with_extras([1.0, 2.0, 3.0, 4.0, 5.0], [-1.0, 1.0], 0.2)\n    [-1.2, -0.8, -0.4, 0.4, 1.2]\n    \"\"\"\n    # TODO: implement this function\n    pass\n\n\ndef rescale_to_range_with_extras_and_outliers(\n    numbers: List[float], target_range: List[float], extra_space: float, outlier_fraction: float\n) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become target_range[0] - extra_space and the largest will become target_range[1] + extra_space\n    but with a small number of outliers, which are clipped to the target range\n    >>> rescale_to_range"
    },
    {
      "rank": 87,
      "score": 2.9225862459862015,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    scale = 1.0 / (max_num - min_num)\n    return [((n - min_num) * scale) for n in numbers]\n\n\ndef rescale_to_unit_with_extremes(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0, the largest will become 1 and the two extreme numbers\n    will become -1 and 1\n    >>> rescale_to_unit_with_extremes([1.0, 2.0, 3.0, 4.0, 5.0])\n    [-1.0, -0.25, 0.0, 0.25, 1.0]\n    \"\"\"\n    min_num = min(numbers)\n    max_num = max(numbers)\n    scale = 2.0 / (max_num - min_num)\n    return [((n - min_num) * scale) - 1 for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 88,
      "score": 2.9037410625682187,
      "candidate": "assert len(numbers) > 1\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [((n - min_number) / (max_number - min_number)) for n in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    >>> [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) > 1\n    min_number = min(numbers)\n    max_number = max(numbers)\n    for i in range(len(numbers)):\n        numbers[i] = ((numbers[i] - min_number) / (max_number - min_number))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 89,
      "score": 2.8729228474626156,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    scale_factor = 1 / (max_value - min_value)\n    return [(number - min_value) * scale_factor for number in numbers]\n\n\ndef rescale_to_range(numbers: List[float], min_value: float, max_value: float) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value\n    >>> rescale_to_range([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    scale_factor = (max_value - min_value) / (max_number - min_number)\n    return [((number - min_number) * scale_factor) + min_value for number in numbers]\n\n\ndef rescale_to_range_with_outliers(\n    numbers: List[float], min_value: float, max_value: float, outlier_percentage: float\n) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become min_value and the largest will become max_value,\n    but with outliers that exceed the range by a factor of outlier_percentage\n    >>> rescale_to_range_with_outliers([1.0, 2.0, 3.0, 4.0, 5.0], 0.0, 1.0, 0.1)\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers = sorted(numbers)\n    outlier_length = int(len(numbers) * outlier_percentage)\n    return res"
    },
    {
      "rank": 90,
      "score": 2.870604309466388,
      "candidate": "# TODO: implement this method\n    raise NotImplementedError"
    },
    {
      "rank": 91,
      "score": 2.84798920558327,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    diff = max_num - min_num\n    return [(num - min_num) / diff for num in numbers]\n\n\ndef main():\n    numbers = [float(x) for x in input(\"Enter numbers separated by commas: \").split(\",\")]\n    print(rescale_to_unit(numbers))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 92,
      "score": 2.8470721613718872,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Cannot rescale to unit with less than two elements\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        return [1.0] * len(numbers)\n\n    return [(number - min_val) / (max_val - min_val) for number in numbers]\n\n\ndef rescale_to_unit_and_add_to_one(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0, the largest will become 1 and all others will be\n    between 0 and 1\n    >>> rescale_to_unit_and_add_to_one([1.0, 2.0, 3.0, 4.0, 5.0])\n    [1.0, 1.25, 1.5, 1.75, 2.0]\n    \"\"\"\n\n    if len(numbers) < 2:\n        raise ValueError(\"Cannot rescale to unit with less than two elements\")\n\n    rescaled_numbers = rescale_to_unit(numbers)\n    max_val = max(rescaled_numbers)\n    return [1.0 + number - max_val for number in rescaled_numbers]"
    },
    {
      "rank": 93,
      "score": 2.846309181321815,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\ndef rescale_to_unit_slow(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_slow([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_value = min(numbers)\n    max_value = max(numbers)\n    return [x / (max_value - min_value) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 94,
      "score": 2.8418725015110544,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [\n        (number - min_number) / (max_number - min_number)\n        for number in numbers\n    ]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_inplace([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n    for index, number in enumerate(numbers):\n        numbers[index] = (number - min_number) / (max_number - min_number)\n    return numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 95,
      "score": 2.8017892323267946,
      "candidate": "if len(numbers) < 2:\n        return numbers\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n    if min_val == max_val:\n        return [1.0] * len(numbers)\n\n    return [(number - min_val) / (max_val - min_val) for number in numbers]\n\n\ndef rescale_to_unit_capped(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_capped([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n    if min_val == max_val:\n        return [1.0] * len(numbers)\n\n    return [min((number - min_val) / (max_val - min_val), 1.0) for number in numbers]"
    },
    {
      "rank": 96,
      "score": 2.7766157398990337,
      "candidate": "# Check that the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements\")\n\n    # Find the minimum and the maximum\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    # Check if the difference between min and max is 0\n    if max_num - min_num == 0:\n        return [0.0] * len(numbers)\n\n    # Transform the numbers\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 2.7003520550780005,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Cannot rescale to unit with less than two numbers\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        return [0.0 for _ in numbers]\n\n    return [((n - min_val) / (max_val - min_val)) for n in numbers]"
    },
    {
      "rank": 98,
      "score": 2.6657657302896403,
      "candidate": "# min_num = min(numbers)\n    # max_num = max(numbers)\n    # return [((num - min_num) / (max_num - min_num)) for num in numbers]\n    return [num / max(numbers) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))"
    },
    {
      "rank": 99,
      "score": 2.512087743178749,
      "candidate": "assert len(numbers) > 1, \"Cannot rescale to unit with a single number\"\n    minimum = min(numbers)\n    maximum = max(numbers)\n\n    if maximum == minimum:\n        return [0.0] * len(numbers)\n\n    return [(x - minimum) / (maximum - minimum) for x in numbers]"
    },
    {
      "rank": 100,
      "score": 2.1354841156503843,
      "candidate": "# 1. find the min and max values\n    min_value = min(numbers)\n    max_value = max(numbers)\n    # 2. find the difference between the min and max values\n    difference = max_value - min_value\n    # 3. divide all values by the difference\n    return [((number - min_value) / difference) for number in numbers]\n\n\ndef rescale_to_unit_inplace(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    >>> rescale_to_unit_inplace(numbers)\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # 1. find the min and max values\n    min_value = min(numbers)\n    max_value = max(numbers)\n    # 2. find the difference between the min and max values\n    difference = max_value - min_value\n    # 3. divide all values by the difference\n    for i in range(len(numbers)):\n        numbers[i] = ((numbers[i] - min_value) / difference)\n\n\ndef rescale_to_unit_inplace_no_return(numbers: List[float]) -> None:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    >>> rescale_to_unit_inplace_no_return(numbers)\n    >>> numbers\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    # 1. find the min and max values\n    min_value = min(numbers)"
    }
  ]
}