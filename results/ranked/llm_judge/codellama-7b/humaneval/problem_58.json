{
  "timestamp": "2025-09-14T21:30:45.507294",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "humaneval",
  "problem_number": 58,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "set_1 = set(l1)\n    set_2 = set(l2)\n    return sorted(set_1 & set_2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\nif __name__ == \"__main__\":\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input is a list\n    # TODO: Check if the input"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1 & s2)\n\n\ndef main():\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "l1 = set(l1)\n    l2 = set(l2)\n\n    return sorted(l1 & l2)\n\n\ndef common_sort(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1.sort()\n    l2.sort()\n\n    l1 = set(l1)\n    l2 = set(l2)\n\n    return sorted(l1 & l2)"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# convert to dict\n    d1 = {}\n    d2 = {}\n    for i in l1:\n        d1[i] = 1\n    for i in l2:\n        d2[i] = 1\n    # find intersection\n    ret = []\n    for i in d1:\n        if i in d2:\n            ret.append(i)\n    return sorted(ret)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "return sorted(list(set(l1).intersection(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "# Set-based approach\n    return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\ndef main():\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1.intersection(s2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "return sorted(list(set(l1).intersection(set(l2))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "if len(l1) > len(l2):\n        l1, l2 = l2, l1\n    return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 30,
      "score": 9.993251387631034,
      "candidate": "l3 = set(l1) & set(l2)\n    l3 = sorted(l3)\n    return l3\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 9.963994939209833,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 9.930867849414408,
      "candidate": "# Set Union\n    # return sorted(set(l1).intersection(set(l2)))\n\n    # List Union\n    # return sorted(list(set(l1) | set(l2)))\n\n    # List Comprehension\n    return sorted([val for val in l1 if val in l2])"
    },
    {
      "rank": 33,
      "score": 9.907170511668092,
      "candidate": "if len(l1) < len(l2):\n        return common(l2, l1)\n    l1 = set(l1)\n    l2 = set(l2)\n    return sorted(l1 & l2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 34,
      "score": 9.890164056081243,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\ndef common_recursive(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_recursive([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_recursive([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    if l1 and l2:\n        if l1[0] == l2[0]:\n            return [l1[0]] + common_recursive(l1[1:], l2[1:])\n        else:\n            return common_recursive(l1[1:], l2) or common_recursive(l1, l2[1:])\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 9.882923312638333,
      "candidate": "# O(n)\n    return sorted(set(l1).intersection(set(l2)))\n\n\ndef common_sorted(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # O(n*log(n))\n    return sorted(set(l1).intersection(set(l2)))\n\n\ndef common_fast(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_fast([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_fast([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # O(n)\n    s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1.intersection(s2))\n\n\ndef common_fastest(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_fastest([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_fastest([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # O(n)\n    s1 = set"
    },
    {
      "rank": 36,
      "score": 9.854153125103362,
      "candidate": "return sorted(list(set(l1).intersection(l2)))"
    },
    {
      "rank": 37,
      "score": 9.845393812074393,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 38,
      "score": 9.807458859791842,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 9.803945923433922,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 9.769680614520107,
      "candidate": "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 41,
      "score": 9.76713512321487,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 42,
      "score": 9.765262807032524,
      "candidate": "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 43,
      "score": 9.740864890863175,
      "candidate": "return sorted(set(l1).intersection(set(l2)))"
    },
    {
      "rank": 44,
      "score": 9.73511989811648,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\ndef main():\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 45,
      "score": 9.72780863773741,
      "candidate": "# We don't need to sort the lists because they are sorted\n    # anyway.\n    # We need to make a copy of the lists because otherwise we\n    # will modify the original lists.\n    l1 = l1[:]\n    l2 = l2[:]\n    # We need to make a copy of the lists because otherwise we\n    # will modify the original lists.\n    l1 = l1[:]\n    l2 = l2[:]\n    # Remove duplicates from the lists.\n    l1 = list(set(l1))\n    l2 = list(set(l2))\n    # Find the common elements.\n    common = []\n    for el in l1:\n        if el in l2:\n            common.append(el)\n    # Sort the common elements.\n    common.sort()\n    return common\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 46,
      "score": 9.699680655040597,
      "candidate": "# Create a dictionary that counts the number of times a value\n    # occurs in l1.\n    d1 = {}\n    for i in l1:\n        if i in d1:\n            d1[i] += 1\n        else:\n            d1[i] = 1\n\n    # Create a dictionary that counts the number of times a value\n    # occurs in l2.\n    d2 = {}\n    for i in l2:\n        if i in d2:\n            d2[i] += 1\n        else:\n            d2[i] = 1\n\n    # Create a dictionary that counts the number of times a value\n    # occurs in the intersection of the two lists.\n    d3 = {}\n    for i in l1:\n        if i in d2:\n            if i in d3:\n                d3[i] += 1\n            else:\n                d3[i] = 1\n\n    # Create a list of common values.\n    common = []\n    for i in d3:\n        if d1[i] == d2[i]:\n            common.append(i)\n\n    # Return the sorted unique common values.\n    return sorted(common)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    print(common(l1, l2))  # [1, 5, 653]\n    l1 = [5, 3, 2, 8]\n    l2 = [3, 2]\n    print(common(l1, l2))  # [2, 3]\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 47,
      "score": 9.699146693885302,
      "candidate": "l1.sort()\n    l2.sort()\n    i = 0\n    j = 0\n    common_elements = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            common_elements.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return common_elements\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 48,
      "score": 9.677440122697439,
      "candidate": "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1 & s2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 49,
      "score": 9.661538999847021,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 50,
      "score": 9.545987962239394,
      "candidate": "s1 = set(l1)\n    s2 = set(l2)\n    return sorted(s1 & s2)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 51,
      "score": 9.493584439832787,
      "candidate": "set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1.intersection(set2))\n\n\ndef unique_common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> unique_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> unique_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 52,
      "score": 9.47114453552205,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 53,
      "score": 9.446832512996986,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 54,
      "score": 9.42450321128885,
      "candidate": "l3 = sorted(set(l1) & set(l2))\n    return l3\n\n\ndef difference(l1: list, l2: list):\n    \"\"\"Return sorted unique elements in first list not present in second.\n    >>> difference([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [2, 3, 4]\n    >>> difference([5, 3, 2, 8], [3, 2])\n    [5, 8]\n\n    \"\"\"\n    l3 = sorted(set(l1) - set(l2))\n    return l3\n\n\ndef union(l1: list, l2: list):\n    \"\"\"Return sorted unique elements in first or second list.\n    >>> union([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 2, 3, 4, 5, 653, 7, 9, 121]\n    >>> union([5, 3, 2, 8], [3, 2])\n    [2, 3, 5, 8]\n\n    \"\"\"\n    l3 = sorted(set(l1) | set(l2))\n    return l3\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 55,
      "score": 9.389578175014488,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 56,
      "score": 9.335906975550785,
      "candidate": "return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 57,
      "score": 9.293848149332355,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 58,
      "score": 9.287625906893272,
      "candidate": "set1 = set(l1)\n    set2 = set(l2)\n    common = set1 & set2\n    return sorted(common)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 59,
      "score": 9.260739004816287,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 60,
      "score": 9.14831015455784,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 61,
      "score": 9.044545314337253,
      "candidate": "l1.sort()\n    l2.sort()\n    result = []\n    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            result.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 62,
      "score": 9.0433598776711,
      "candidate": "if len(l1) > len(l2):\n        return common(l2, l1)\n\n    # build a set of elements in list 1\n    s = set(l1)\n\n    # check for intersection with list 2\n    result = []\n    for x in l2:\n        if x in s:\n            result.append(x)\n\n    return sorted(result)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 63,
      "score": 9.006215542699554,
      "candidate": "return sorted(list(set(l1).intersection(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 64,
      "score": 9.001390976634635,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 65,
      "score": 8.959815655301357,
      "candidate": "if not l1 or not l2:\n        return []\n    return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 66,
      "score": 8.825786945643413,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 67,
      "score": 8.815151592750942,
      "candidate": "return sorted(set(l1).intersection(set(l2)))"
    },
    {
      "rank": 68,
      "score": 8.812529540846942,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 69,
      "score": 8.7983308897086,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 70,
      "score": 8.757011511043656,
      "candidate": "# Set operations are O(n), so we can use them to get the unique values of\n    # each list in O(n) time.\n    l1_set = set(l1)\n    l2_set = set(l2)\n\n    # Find the intersection of the sets in O(n) time using set.intersection().\n    # This will return a set of common elements, but we want a list.\n    common_elements = l1_set.intersection(l2_set)\n\n    # Sort the common elements in O(n log n) time.\n    return sorted(common_elements)"
    },
    {
      "rank": 71,
      "score": 8.75320425695424,
      "candidate": "return sorted(list(set(l1).intersection(l2)))\n\n\nif __name__ == \"__main__\":\n    print(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    print(common([5, 3, 2, 8], [3, 2]))"
    },
    {
      "rank": 72,
      "score": 8.725061744842701,
      "candidate": "# TODO: complete this local function\n    return []\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 73,
      "score": 8.633195822588712,
      "candidate": "l3 = [i for i in l1 if i in l2]\n    l3.sort()\n    return l3"
    },
    {
      "rank": 74,
      "score": 8.543645447872803,
      "candidate": "return sorted(list(set(l1).intersection(set(l2))))"
    },
    {
      "rank": 75,
      "score": 8.536390107639537,
      "candidate": "return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 76,
      "score": 8.519251714074711,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 77,
      "score": 8.486595028534193,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 78,
      "score": 8.479313539527935,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 79,
      "score": 8.430830549582662,
      "candidate": "return sorted(set(l1).intersection(set(l2)))"
    },
    {
      "rank": 80,
      "score": 8.400498097136913,
      "candidate": "return sorted(set(l1).intersection(l2))"
    },
    {
      "rank": 81,
      "score": 8.358649450259561,
      "candidate": "if len(l1) < len(l2):\n        return sorted(set(l1) & set(l2))\n    else:\n        return sorted(set(l2) & set(l1))"
    },
    {
      "rank": 82,
      "score": 8.355472400803755,
      "candidate": "return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 83,
      "score": 8.330821651267415,
      "candidate": "return sorted(set(l1).intersection(l2))"
    },
    {
      "rank": 84,
      "score": 8.330025040120514,
      "candidate": "l1.sort()\n    l2.sort()\n    i, j = 0, 0\n    res = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            res.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 85,
      "score": 8.319932828737294,
      "candidate": "if len(l1) > len(l2):\n        l1, l2 = l2, l1\n    seen = set(l1)\n    return sorted(set(l2) & seen)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 86,
      "score": 8.26834572117571,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 87,
      "score": 8.262358234063235,
      "candidate": "l1.sort()\n    l2.sort()\n\n    common_list = []\n\n    i = j = 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            common_list.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] > l2[j]:\n            j += 1\n        else:\n            i += 1\n\n    return common_list"
    },
    {
      "rank": 88,
      "score": 8.253776767882322,
      "candidate": "return sorted(set(l1).intersection(l2))"
    },
    {
      "rank": 89,
      "score": 8.230775183332875,
      "candidate": "return sorted(list(set(l1).intersection(set(l2))))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 90,
      "score": 8.17766426877105,
      "candidate": "if len(l1) > len(l2):\n        return common(l2, l1)\n\n    l1 = sorted(l1)\n    l2 = sorted(l2)\n\n    i, j = 0, 0\n    result = []\n    while i < len(l1) and j < len(l2):\n        if l1[i] == l2[j]:\n            result.append(l1[i])\n            i += 1\n            j += 1\n        elif l1[i] < l2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 91,
      "score": 8.170903645254455,
      "candidate": "return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 92,
      "score": 8.137216875345032,
      "candidate": "return sorted(set(l1).intersection(set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 93,
      "score": 8.125541785619841,
      "candidate": "l1.sort()\n    l2.sort()\n    l1_p = l1[0]\n    l2_p = l2[0]\n    result = []\n    while True:\n        if l1_p == l2_p:\n            result.append(l1_p)\n        if l1_p < l2_p:\n            l1_p = l1[l1.index(l1_p) + 1]\n        else:\n            l2_p = l2[l2.index(l2_p) + 1]\n        if l1_p == len(l1):\n            break\n        if l2_p == len(l2):\n            break\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 94,
      "score": 7.989885927293789,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 95,
      "score": 7.88830876415424,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 96,
      "score": 7.788975668089492,
      "candidate": "return sorted(set(l1).intersection(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 7.774489185406606,
      "candidate": "return sorted(list(set(l1) & set(l2)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 98,
      "score": 7.69976979737013,
      "candidate": "return sorted(set(l1) & set(l2))"
    },
    {
      "rank": 99,
      "score": 7.448941304890342,
      "candidate": "return sorted(set(l1) & set(l2))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "return sorted(list(set(l1).intersection(l2)))\n\n\ndef common_sorted(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common_sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1).intersection(l2)))"
    }
  ]
}