{
  "timestamp": "2025-09-14T21:58:23.462971",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "humaneval",
  "problem_number": 120,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "# sorted(arr, reverse=True)[:k]\n    # sorted(arr, reverse=True)[:k]\n    # arr = sorted(arr, reverse=True)\n    # return arr[:k]\n    # arr.sort(reverse=True)\n    # return arr[:k]\n    # return sorted(arr, reverse=True)[:k]\n    return sorted(arr, reverse=True)[:k]\n\n\ndef maximum_v2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # arr = sorted(arr, reverse=True)\n    # return arr[:k]\n    # return sorted(arr, reverse=True)[:k]\n    return sorted(arr, reverse=True)[:k]\n\n\ndef maximum_v3(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4,"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "# Time Complexity: O(nlogn)\n    # Space Complexity: O(n)\n    arr.sort()\n    return arr[len(arr) - k:]\n\n\ndef maximum_two_pointer(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Time Complexity: O(n)\n    # Space Complexity: O(n)\n    max_heap = []\n    for num in arr:\n        if len(max_heap) < k:\n            heapq.heappush(max_heap, num)\n        elif num > max_heap[0]:\n            heapq.heappushpop(max_heap, num)\n    return sorted(max_heap)\n\n\ndef maximum_heapq(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "if k == 0:\n        return []\n\n    import heapq\n    heap = []\n    for num in arr:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, num)\n\n    return list(heap)\n\n\ndef main():\n    print('Please enter the array:')\n    arr = list(map(int, input().split()))\n    print('Please enter the k:')\n    k = int(input())\n    result = maximum(arr, k)\n    print(result)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "# sorted_arr = sorted(arr)\n    # return sorted_arr[-k:]\n\n    # 1. \u6392\u5e8f\n    # 2. \u622a\u53d6\u6700\u540ek\u4e2a\u5143\u7d20\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(nlogn)\n\n    # 3. \u4f7f\u7528\u5806\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(nlogk)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\n    # \u8f85\u52a9\u7a7a\u95f4: O(k)\n\n    # 4. \u5206\u6cbb\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(k)\n    # \u8f85\u52a9\u7a7a\u95f4: O(k)\n\n    # 5. \u5feb\u901f\u6392\u5e8f\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(logn)\n    # \u8f85\u52a9\u7a7a\u95f4: O(logn)\n\n    # 6. \u6876\u6392\u5e8f\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u8f85\u52a9\u7a7a\u95f4: O(n)\n\n    # 7. \u6876\u6392\u5e8f\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u8f85\u52a9\u7a7a\u95f4: O(n)\n\n    # 8. \u8ba1\u6570\u6392\u5e8f\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u8f85\u52a9\u7a7a\u95f4: O(n)\n\n    # 9. \u8ba1\u6570\u6392\u5e8f\n    # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n    # \u8f85\u52a9\u7a7a\u95f4: O(n)\n\n    # 10. \u8ba1\u6570\u6392\u5e8f"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "if k > len(arr):\n        return arr\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k > len(arr):\n        return arr\n\n    arr.sort()\n    return arr[:k]\n\n\ndef maximum_2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "heap = []\n    for i in range(k):\n        heapq.heappush(heap, arr[i])\n\n    for i in range(k, len(arr)):\n        if arr[i] > heap[0]:\n            heapq.heappushpop(heap, arr[i])\n\n    return sorted(heap)\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 3\n        Output: [0, 1, 2]\n\n    Example 2:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 2\n        Output: [0, 1]\n\n    Example 3:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 2\n        Output: [2, 4]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [0, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, -arr[i])\n\n    for i in range(k, len(arr)):\n        if -arr[i] > -heap[0]:\n            heapq.heappushpop(heap, -arr[i])\n\n    return sorted(heap)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "from collections import deque\n\n    if k == 0:\n        return []\n\n    queue = deque()\n    for n in arr:\n        while queue and n > queue[-1]:\n            queue.pop()\n        queue.append(n)\n        if len(queue) > k:\n            queue.popleft()\n\n    return list(queue)\n\n\ndef maximum2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n\n    max_heap = MaxHeap(k)\n    for n in arr:\n        if k == len(max_heap):\n            max_heap.heapify(n)\n        else:\n            max_heap.insert(n)\n\n    return max_heap.heap\n\n\nclass MaxHeap:\n    def __init__(self, capacity):\n        self.heap = []\n        self.capacity = capacity\n\n    def heapify(self, n):\n        for i in range(len(self.heap)):\n            self.heap[i] = n\n            self.sift_down(i)\n\n    def insert(self, n):\n        if len(self.heap) < self"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "arr.sort()\n    return arr[-k:]"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "if k == 0: return []\n\n    import heapq\n    heap = []\n    for num in arr:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            heapq.heappushpop(heap, num)\n\n    return sorted(heap)\n\n\ndef main():\n    # [4, -4, 4], 2\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    # [-3, 2, 1, 2, -1, -2, 1], 1\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "return sorted(heapq.nlargest(k, arr))\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(heapq.nsmallest(k, arr))"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "if not arr or k == 0:\n        return []\n\n    if k == 1:\n        return [max(arr)]\n\n    if k >= len(arr):\n        return sorted(arr)\n\n    # use a min heap\n    h = []\n    for num in arr:\n        heapq.heappush(h, num)\n\n    # get the top k\n    return sorted(heapq.nlargest(k, h))\n\n\ndef maximum_2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or k == 0:\n        return []\n\n    if k == 1:\n        return [max(arr)]\n\n    if k >= len(arr):\n        return sorted(arr)\n\n    # use a max heap\n    h = []\n    for num in arr:\n        heapq.heappush(h, -num)\n\n    # get the top k\n    return [-heapq.heappop(h) for _ in range(k)]\n\n\ndef maximum_3(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "arr.sort()\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 4\n        Output: [0, 1, 2, 3]\n\n    Example 2:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 3\n        Output: [0, 1, 2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[:k]"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "# sort and get the first k elements\n    arr.sort()\n    return arr[-k:]\n\n\ndef main():\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "return sorted(arr, reverse=True)[:k]\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 3\n        Output: [0, 1, 2]\n\n    Example 2:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 2\n        Output: [0, 1]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [0, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(arr)[:k]\n\ndef maximum_subarray(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, find a contiguous \n    subarray of arr of length at least k that contains the maximum number of \n    distinct integers.\n\n    Example 1:\n\n        Input: arr = [2, 1, 2, 3, 2, 3, 4, 2, 3, 1], k = 3\n        Output: 4\n\n    Example 2:\n\n        Input: arr = [5, 1, 3, 5, 2, 4, 3, 2, 4, 2], k = 3\n        Output: 6\n\n    Note:\n        1. The length of the array will be in the range of [1, 10000].\n        2. The elements in the array will be in the range of [0, 10000].\n        3. 1 <= k <= arr.length\n    \"\"\"\n    return len(set(arr[:k]))\n\ndef minimum_subarray(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# sort the array in ascending order\n    arr.sort()\n    # create an empty list to store the maximum k numbers\n    max_k_nums = []\n    # traverse the array and append the maximum k numbers to the list\n    for i in range(len(arr)):\n        if len(max_k_nums) < k:\n            max_k_nums.append(arr[i])\n        else:\n            # when the list already contains k numbers\n            # replace the minimum number in the list if the current number is larger than it\n            if arr[i] > max_k_nums[0]:\n                max_k_nums[0] = arr[i]\n    return max_k_nums\n\n\ndef main():\n    arr = [-3, -4, 5]\n    k = 3\n    print(f'Array: {arr}')\n    print(f'K: {k}')\n    print(maximum(arr, k))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# exceptions\n    assert isinstance(arr, list) and len(arr) >= 1 and len(arr) <= 1000\n    assert isinstance(k, int) and 0 <= k <= len(arr)\n    # main method: (heap or quick selection)\n    #     first, sort the array\n    #     then, find the largest k elements, O(n log n)\n    #     finally, return the k elements\n    return max_k_nums(arr, k)\n\n\ndef max_k_nums(arr, k):\n    import heapq\n    heap = []\n    for num in arr:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heappushpop(heap, num)\n    return heap\n\n\ndef max_k_nums_quick_select(arr, k):\n    from random import randint\n\n    def partition(left, right, pivot_idx):\n        # partition the sub-array around the pivot\n        pivot = arr[pivot_idx]\n        arr[pivot_idx], arr[right] = arr[right], arr[pivot_idx]\n\n        # partition point\n        i = left\n        for j in range(left, right):\n            if arr[j] <= pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n\n        arr[i], arr[right] = arr[right], arr[i]\n        return i\n\n    def quick_select(left, right, k_smallest):\n        if left == right:\n            return arr[left]\n        pivot_idx = randint(left, right)\n        pivot_idx = partition(left, right, pivot_idx)\n\n        if k_smallest == pivot_idx:\n            return arr[k_smallest]\n        if k_smallest < pivot_idx:\n            return quick_select(left, pivot_idx - 1, k_smallest)\n        if k_smallest > pivot_idx:\n            return quick_select(pivot_idx"
    },
    {
      "rank": 17,
      "score": 9.988893927875916,
      "candidate": "# Time complexity: O(nlogk)\n    # Space complexity: O(k)\n    arr.sort()\n    return arr[-k:]\n\n\ndef maximum_2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Time complexity: O(k)\n    # Space complexity: O(k)\n    from collections import deque\n    deq = deque()\n    for num in arr:\n        if len(deq) < k:\n            deq.append(num)\n        else:\n            if num > deq[0]:\n                deq.popleft()\n                deq.append(num)\n    return list(deq)\n\n\ndef main():\n    import random\n    import time\n\n    arr = list(range(1000))\n    random.shuffle(arr)\n\n    start_time = time.time()\n    print(maximum(arr, 5))\n    print(\"Time: \", time.time() - start_time)\n\n    start_time = time.time()\n    print(maximum_2(arr, 5))\n    print(\"Time: \", time.time() - start_time)\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 18,
      "score": 9.93190171477037,
      "candidate": "if k == 0:\n        return []\n\n    # Sort the array\n    arr.sort()\n\n    # Return the last k elements\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n\n    # Sort the array\n    arr.sort()\n\n    # Return the first k elements\n    return arr[:k]\n\n\ndef maximum_subarray(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, find the maximum \n    sub-array of arr. Note that the length of the sub-array must be k.\n\n    Example 1:\n\n        Input: arr = [1, -1, 4, 3, -3, -4], k = 3\n        Output: [4, 3, -3]\n\n    Example 2:\n\n        Input: arr = [-4, 4, -3, 3, -3, -2, 2, 1, -1], k = 3\n        Output: [4, 3, -3]\n\n    Example 3:\n\n        Input: arr = [1, 2, 3, 4, 5],"
    },
    {
      "rank": 19,
      "score": 9.930009346849173,
      "candidate": "if not arr or len(arr) == 0 or k == 0 or k > len(arr):\n        return []\n    \n    arr.sort()\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or len(arr) == 0 or k == 0 or k > len(arr):\n        return []\n    \n    arr.sort()\n    return arr[:k]\n\n\ndef maximum_without_sort(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be"
    },
    {
      "rank": 20,
      "score": 9.927412453835766,
      "candidate": "# Time Complexity: O(nlogk)\n    # Space Complexity: O(k)\n    from collections import deque\n    queue = deque()\n    for i in range(k):\n        while queue and arr[i] >= queue[-1]:\n            queue.pop()\n        queue.append(arr[i])\n\n    return list(queue)\n\n\ndef maximum_2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Time Complexity: O(nlogk)\n    # Space Complexity: O(k)\n    import heapq\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, -arr[i])\n\n    return list(map(lambda x: -x, heap))\n\n\ndef maximum_3(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4],"
    },
    {
      "rank": 21,
      "score": 9.927277988653705,
      "candidate": "if k >= len(arr):\n        return sorted(arr)\n\n    return sorted(arr[:k])\n\n\ndef maximum_fast(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k >= len(arr):\n        return sorted(arr)\n\n    return sorted(arr[:k])\n\n\n# Test cases:\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 3))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 4))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 5))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1],"
    },
    {
      "rank": 22,
      "score": 9.909574937564084,
      "candidate": "# sort the array\n    arr.sort()\n\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # sort the array\n    arr.sort()\n\n    return arr[:k]\n\n\ndef maximum_with_dup(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [5, -4, -3]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3."
    },
    {
      "rank": 23,
      "score": 9.878446472529031,
      "candidate": "heap = []\n    for i, num in enumerate(arr):\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heappushpop(heap, num)\n\n    return sorted(heap)\n\n\ndef maximum_v2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    max_heap = []\n    min_heap = []\n    for i, num in enumerate(arr):\n        if len(max_heap) < k:\n            heapq.heappush(max_heap, num)\n        elif len(min_heap) < k:\n            heapq.heappush(min_heap, -num)\n        else:\n            if num > -min_heap[0]:\n                heapq.heappushpop(max_heap, num)\n                heapq.heappushpop(min_heap, -num)\n            else:\n                heapq.heappushpop(max_heap, num)\n\n    return sorted(max_heap)\n\n\nprint(maximum([-3, -4, 5], 3))\nprint"
    },
    {
      "rank": 24,
      "score": 9.856340515228137,
      "candidate": "if k == 0:\n        return []\n\n    # Find the k-th largest element\n    # and put it into the k-th position.\n    arr = [-float('inf')] * k + arr\n    for i in range(k, len(arr)):\n        if arr[i] > arr[k - 1]:\n            arr[k - 1], arr[i] = arr[i], arr[k - 1]\n            i -= 1\n    return arr[k:]"
    },
    {
      "rank": 25,
      "score": 9.85145598626796,
      "candidate": "return sorted(max_k_numbers(arr, k))\n\n\ndef max_k_numbers(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if len(arr) <= k:\n        return arr\n\n    max_heap = []\n    for n in arr:\n        if len(max_heap) < k:\n            heapq.heappush(max_heap, n)\n        else:\n            heapq.heappushpop(max_heap, n)\n\n    return max_heap\n\n\ndef main():\n    print('Please run this solution on LeetCode.')\n    print('https://leetcode.com/problems/find-the-maximum-of-element-after-removing-every-k-elements/')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 26,
      "score": 9.844455316488794,
      "candidate": "if not arr or not k:\n        return []\n\n    # sort the array\n    arr.sort()\n\n    # return the last k elements\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or not k:\n        return []\n\n    # sort the array\n    arr.sort()\n\n    # return the first k elements\n    return arr[:k]\n\n\ndef maximum_with_count(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return an integer \n    p such that the absolute difference between p and the element at index k is \n    less than or equal to the absolute difference between any two other elements.\n\n    Example 1:\n\n        Input: arr = [4, 2, 3], k = 1\n        Output: 2\n\n    Example 2:\n\n        Input: arr = [1, 4, 3, 2], k = 3\n        Output: 2\n\n    Note:\n        1. 0 <= arr.length <= 10000\n        2. 0 <= arr[i] <= 100000\n        3. 0 <= k <= arr"
    },
    {
      "rank": 27,
      "score": 9.825690865935298,
      "candidate": "arr.sort()\n    return arr[-k:]\n\n\ndef main():\n    print('Please run this solution on LeetCode.')\n    print('https://leetcode.com/problems/find-the-highest-altitude/')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 28,
      "score": 9.77684829539764,
      "candidate": "# Time Complexity: O(nlogn)\n    # Space Complexity: O(n)\n    arr.sort()\n    return arr[-k:]\n\n\ndef maximum_v2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Time Complexity: O(n)\n    # Space Complexity: O(k)\n    if not arr:\n        return []\n\n    max_heap = []\n    for num in arr:\n        if len(max_heap) < k:\n            heapq.heappush(max_heap, num)\n        else:\n            if num > max_heap[0]:\n                heapq.heapreplace(max_heap, num)\n\n    return sorted(max_heap)\n\n\ndef maximum_v3(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k ="
    },
    {
      "rank": 29,
      "score": 9.643191990999085,
      "candidate": "if len(arr) == k:\n        return sorted(arr)\n\n    max_heap = arr[:k]\n    heapify(max_heap)\n\n    for i in range(k, len(arr)):\n        if arr[i] > max_heap[0]:\n            heappop(max_heap)\n            heappush(max_heap, arr[i])\n\n    return sorted(max_heap)\n\n\ndef maximum_optimized(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if len(arr) == k:\n        return sorted(arr)\n\n    max_heap = arr[:k]\n    heapify(max_heap)\n\n    for i in range(k, len(arr)):\n        if arr[i] > max_heap[0]:\n            max_heap[0] = arr[i]\n            max_heap[0], max_heap[-1] = max_heap[-1], max_heap[0]\n            max_heap.sort()\n\n    return max_heap"
    },
    {
      "rank": 30,
      "score": 9.629175946534993,
      "candidate": "if k == 0:\n        return []\n    if k == 1:\n        return [max(arr)]\n    if k == len(arr):\n        return sorted(arr)\n\n    mx = max(arr)\n    max_idxs = [i for i, v in enumerate(arr) if v == mx]\n    if len(max_idxs) > k:\n        return sorted([mx] * k)\n    elif len(max_idxs) == k:\n        return sorted(arr)\n    else:\n        return sorted(arr)[:k]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 2:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    if k == 1:\n        return [min(arr)]\n    if k == len(arr):\n        return sorted(arr)\n\n    mn = min(arr)\n    min_idxs = [i for i, v in enumerate(arr) if v == mn]\n    if len(min_idxs) > k:\n        return sorted([mn] * k)\n    elif len(min_idxs) == k:\n        return sorted(arr)\n    else:\n        return sorted(arr)[:k]\n\n\ndef maximum_of_subarrays(arr, k, n):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, find the maximum \n    values of each sub"
    },
    {
      "rank": 31,
      "score": 9.588262324841487,
      "candidate": "# \u8d2a\u5fc3\u7b97\u6cd5\n    arr.sort()\n    return arr[-k:]\n\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))"
    },
    {
      "rank": 32,
      "score": 9.222401281938199,
      "candidate": "if not arr:\n        return []\n\n    heap = []\n    for num in arr:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            heapq.heappushpop(heap, num)\n\n    return heap\n\n\ndef maximum_fast(arr, k):\n    \"\"\"\n    Same as above, but using Python's built-in heapq module.\n    \"\"\"\n    if not arr:\n        return []\n\n    heap = arr[:k]\n    heapq.heapify(heap)\n    for num in arr[k:]:\n        heapq.heappushpop(heap, num)\n\n    return heap\n\n\ndef main():\n    import time\n    import random\n\n    arr = [random.randint(-1000, 1000) for _ in range(1000)]\n    k = random.randint(1, 100)\n\n    start_time = time.time()\n    print(maximum(arr, k))\n    print(\"Elapsed time without heapq: {}\".format(time.time() - start_time))\n\n    start_time = time.time()\n    print(maximum_fast(arr, k))\n    print(\"Elapsed time with heapq: {}\".format(time.time() - start_time))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 33,
      "score": 9.101594779886327,
      "candidate": "if not arr or k < 1 or k > len(arr): return []\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nmain()"
    },
    {
      "rank": 34,
      "score": 9.090419802360152,
      "candidate": "arr = sorted(arr)\n    return arr[len(arr)-k:len(arr)]\n\n\nif __name__ == \"__main__\":\n    # arr = [-3, -4, 5]\n    # k = 3\n    # print(maximum(arr, k))\n    # arr = [4, -4, 4]\n    # k = 2\n    # print(maximum(arr, k))\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 35,
      "score": 9.084116984135814,
      "candidate": "return sorted(arr, reverse=True)[:k]\n\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 36,
      "score": 9.060016927391498,
      "candidate": "if not arr or k <= 0:\n        return []\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nmain()\n\n\n\"\"\"\nTime O(NlogN)\nSpace O(N)\n\"\"\""
    },
    {
      "rank": 37,
      "score": 8.888435779456389,
      "candidate": "# sort and then slice\n    return sorted(arr)[-k:]\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 38,
      "score": 8.877464243892744,
      "candidate": "if k == 0:\n        return []\n    if k == 1:\n        return [max(arr)]\n    if k == len(arr):\n        return sorted(arr)\n    return sorted(max(arr[:k]), arr[-k:])\n\n\ndef test_maximum():\n    assert maximum([-3, -4, 5], 3) == [-4, -3, 5]\n    assert maximum([4, -4, 4], 2) == [4, 4]\n    assert maximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert maximum([-3, 2, 1, 2, -1, -2, 1], 2) == [2, 2]\n    assert maximum([-3, 2, 1, 2, -1, -2, 1], 3) == [-2, 1, 2]\n    assert maximum([-3, 2, 1, 2, -1, -2, 1], 4) == [-2, 1, 2, 2]\n    assert maximum([-3, 2, 1, 2, -1, -2, 1], 5) == [-3, 1, 2, 2, 2]"
    },
    {
      "rank": 39,
      "score": 8.851275340468257,
      "candidate": "if k == 0: return []\n    if k == 1: return [max(arr)]\n    if k == len(arr): return sorted(arr)\n\n    arr.sort()\n    return arr[-k:]"
    },
    {
      "rank": 40,
      "score": 8.835582094473247,
      "candidate": "if k == 0:\n        return []\n\n    arr.sort(reverse=True)\n    return arr[:k]\n\n\ndef main():\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 41,
      "score": 8.766767030688666,
      "candidate": "# sort the input array\n    arr.sort()\n\n    # get the length of the input array\n    n = len(arr)\n\n    # initialize a list to store the result\n    res = []\n\n    # iterate through the input array\n    for i in range(n):\n        # if the length of the result list is less than k\n        if len(res) < k:\n            # append the current element to the result list\n            res.append(arr[i])\n        # if the length of the result list is greater than or equal to k\n        elif arr[i] > res[-1]:\n            # replace the last element with the current element\n            res[-1] = arr[i]\n    \n    return res\n\nif __name__ == \"__main__\":\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 42,
      "score": 8.716473630446735,
      "candidate": "if not arr or k < 1 or k > len(arr):\n        return []\n    \n    arr.sort()\n    return arr[-k:]"
    },
    {
      "rank": 43,
      "score": 8.70134848575761,
      "candidate": "# sort the array\n    arr.sort()\n\n    # return the last k elements\n    return arr[-k:]\n\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 44,
      "score": 8.660016766352054,
      "candidate": "arr = sorted(arr)\n    return arr[len(arr)-k:len(arr)]\n\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 45,
      "score": 8.59633157496445,
      "candidate": "def partition(arr, left, right):\n        \"\"\"\n        return the position of the pivot\n        \"\"\"\n        pivot = arr[right]\n        i = left\n        for j in range(left, right):\n            if arr[j] < pivot:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[right] = arr[right], arr[i]\n        return i\n\n    def find_kth_largest(arr, left, right, k):\n        if left == right:\n            return arr[left]\n        pos = partition(arr, left, right)\n        if pos == k:\n            return arr[pos]\n        elif pos < k:\n            return find_kth_largest(arr, pos + 1, right, k)\n        else:\n            return find_kth_largest(arr, left, pos - 1, k)\n\n    return find_kth_largest(arr, 0, len(arr) - 1, len(arr) - k)\n\nif __name__ == '__main__':\n    # Test 1\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    # Test 2\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    # Test 3\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 46,
      "score": 8.596230598757979,
      "candidate": "arr.sort(reverse=True)\n    return arr[:k]\n\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 47,
      "score": 8.568814960811567,
      "candidate": "# initialize variables\n    max_nums = []\n    # max_nums = [None] * k\n\n    # traverse the list\n    for num in arr:\n        # if the list is not full, append the number to the list\n        if len(max_nums) < k:\n            max_nums.append(num)\n        # if the list is full and the number is bigger than the smallest number\n        # in the list, replace the smallest number with the new number\n        elif num > max_nums[0]:\n            max_nums[0] = num\n        # if the number is smaller than the smallest number in the list, do nothing\n        else:\n            pass\n\n    # sort the list\n    max_nums.sort()\n\n    # return the list\n    return max_nums\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 48,
      "score": 8.554087658759999,
      "candidate": "arr.sort()\n    return arr[-k:]"
    },
    {
      "rank": 49,
      "score": 8.482983970589355,
      "candidate": "if not arr or len(arr) < k:\n        return []\n\n    if k == 1:\n        return [max(arr)]\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef test_maximum():\n    assert maximum([-3, -4, 5], 3) == [-4, -3, 5]\n    assert maximum([4, -4, 4], 2) == [4, 4]\n    assert maximum([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n\n\nif __name__ == '__main__':\n    test_maximum()"
    },
    {
      "rank": 50,
      "score": 8.481004213104477,
      "candidate": "if len(arr) <= k:\n        return sorted(arr)\n\n    min_heap = []\n    max_heap = []\n    for i in range(k):\n        if len(min_heap) == 0 or arr[i] < min_heap[0]:\n            heapq.heappush(min_heap, arr[i])\n        else:\n            heapq.heappush(max_heap, -arr[i])\n\n    for i in range(k, len(arr)):\n        if arr[i] > -min_heap[0]:\n            heapq.heappush(max_heap, -arr[i])\n        elif arr[i] < min_heap[0]:\n            heapq.heappush(min_heap, arr[i])\n        else:\n            pass\n\n        if len(max_heap) > 0 and len(min_heap) > 0:\n            if -max_heap[0] < min_heap[0]:\n                small = heapq.heappop(max_heap)\n                heapq.heappush(min_heap, -small)\n            else:\n                large = heapq.heappop(min_heap)\n                heapq.heappush(max_heap, -large)\n\n    return [-max_heap[0]] + min_heap\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nmain()"
    },
    {
      "rank": 51,
      "score": 8.446592096234278,
      "candidate": "if k == 0:\n        return []\n\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, arr[i])\n\n    for i in range(k, len(arr)):\n        if arr[i] > heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, arr[i])\n\n    heap.sort()\n    return heap"
    },
    {
      "rank": 52,
      "score": 8.438775610054513,
      "candidate": "# Time Complexity: O(nlogn)\n    # Space Complexity: O(n)\n    arr.sort()\n    return arr[-k:]\n\n\n    # Time Complexity: O(n)\n    # Space Complexity: O(n)\n    # import heapq\n    # heap = []\n    # for num in arr:\n    #     heapq.heappush(heap, num)\n    #     if len(heap) > k:\n    #         heapq.heappop(heap)\n    # return list(reversed(heap))"
    },
    {
      "rank": 53,
      "score": 8.414200193380704,
      "candidate": "# \u6392\u5e8f\n    arr.sort()\n    return arr[-k:]\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))"
    },
    {
      "rank": 54,
      "score": 8.36646767424564,
      "candidate": "# sort the array\n    arr.sort()\n    # return the last k elements\n    return arr[-k:]"
    },
    {
      "rank": 55,
      "score": 8.346106922525788,
      "candidate": "# sort the array\n    arr.sort()\n\n    # return the last k elements\n    return arr[-k:]\n\n\nif __name__ == '__main__':\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 56,
      "score": 8.31886135724878,
      "candidate": "arr.sort()\n    return arr[-k:]\n\n\nif __name__ == '__main__':\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 57,
      "score": 8.317980892296942,
      "candidate": "return sorted(max(arr, key=lambda x:arr.count(x)) for _ in range(k))\n\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 58,
      "score": 8.314575246586935,
      "candidate": "from collections import deque\n\n    d = deque()\n    for x in arr:\n        if len(d) < k:\n            d.append(x)\n        else:\n            if x > d[0]:\n                d.popleft()\n                d.append(x)\n\n    return list(d)\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nmain()"
    },
    {
      "rank": 59,
      "score": 8.282709886669592,
      "candidate": "if k > len(arr):\n        return arr\n\n    arr.sort()\n\n    return arr[-k:]\n\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 60,
      "score": 8.250976160641335,
      "candidate": "# Time Complexity: O(nlog(n) + klog(k))\n    # Space Complexity: O(n)\n    return sorted(max(arr[:k]))\n\n    # Time Complexity: O(n)\n    # Space Complexity: O(n)\n    # def maximum(arr, k):\n    #     res = []\n    #     for i in range(k):\n    #         max_num = -float(\"inf\")\n    #         for j in range(i, len(arr)):\n    #             max_num = max(max_num, arr[j])\n    #         res.append(max_num)\n    #     return res\n\n    # Time Complexity: O(n)\n    # Space Complexity: O(n)\n    # def maximum(arr, k):\n    #     res = []\n    #     for i in range(k):\n    #         max_num = -float(\"inf\")\n    #         for j in range(i, len(arr)):\n    #             max_num = max(max_num, arr[j])\n    #         res.append(max_num)\n    #     return res\n\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 61,
      "score": 8.248837947944937,
      "candidate": "from queue import PriorityQueue\n\n    if k == 0:\n        return []\n\n    # use max heap to keep k largest elements\n    pq = PriorityQueue()\n    for num in arr[:k]:\n        pq.put(-num)\n    for num in arr[k:]:\n        if not pq.empty():\n            if num > -pq.queue[0]:\n                pq.get()\n                pq.put(-num)\n    return [-pq.get() for _ in range(pq.qsize())]"
    },
    {
      "rank": 62,
      "score": 8.247265202351764,
      "candidate": "if k == 0: return []\n    if k == 1: return [max(arr)]\n\n    return sorted(arr, reverse=True)[:k]\n\n\ndef main():\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 63,
      "score": 8.191727667308099,
      "candidate": "arr = sorted(arr)\n    return arr[-k:]\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 64,
      "score": 8.173494147510292,
      "candidate": "if k == 0: return []\n\n    # get the max k numbers from the start\n    arr_max = [None] * k\n    for i in range(k):\n        arr_max[i] = max(arr)\n        arr.remove(arr_max[i])\n\n    # sort the max k numbers\n    arr_max.sort()\n\n    return arr_max\n\n\ndef main():\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 65,
      "score": 8.091973084690936,
      "candidate": "if k > len(arr): return arr\n    if k <= 0: return []\n    arr.sort()\n    return arr[-k:]\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 66,
      "score": 8.063074332725536,
      "candidate": "if not arr or not k or k > len(arr):\n        return []\n\n    # find the kth max element in arr\n    # k = 1 -> find the max\n    # k = len(arr) -> find the min\n    # k = len(arr) // 2 -> find the median\n    def find_kth_max(arr, k):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            pivot_idx = random.randint(left, right)\n            new_pivot_idx = partition(arr, left, right, pivot_idx)\n            if new_pivot_idx == k - 1:\n                return arr[new_pivot_idx]\n            elif new_pivot_idx > k - 1:\n                right = new_pivot_idx - 1\n            else:\n                left = new_pivot_idx + 1\n\n    # find the kth min element in arr\n    # k = 1 -> find the min\n    # k = len(arr) -> find the max\n    # k = len(arr) // 2 -> find the median\n    def find_kth_min(arr, k):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            pivot_idx = random.randint(left, right)\n            new_pivot_idx = partition(arr, left, right, pivot_idx)\n            if new_pivot_idx == k - 1:\n                return arr[new_pivot_idx]\n            elif new_pivot_idx < k - 1:\n                left = new_pivot_idx + 1\n            else:\n                right = new_pivot_idx - 1\n\n    # find the kth max element in arr\n    # k = 1 -> find the max\n    # k = len(arr) -> find the min\n    # k = len(arr) // 2 -> find the median\n    def find_kth_max_using_builtin(arr, k):\n        return heapq.nlargest(k, arr)[-1]\n\n    def find_kth_min_using"
    },
    {
      "rank": 67,
      "score": 8.019055373903987,
      "candidate": "# Time Complexity: O(nlogk)\n    # Space Complexity: O(k)\n\n    # heapq.nlargest(k, arr)\n    # heapq.nsmallest(k, arr)\n\n    # Time Complexity: O(nlogn)\n    # Space Complexity: O(1)\n\n    # return sorted(arr, reverse=True)[:k]\n\n    # Time Complexity: O(nlogk)\n    # Space Complexity: O(1)\n\n    # return sorted(arr, reverse=True)[:k]\n\n    # Time Complexity: O(k + (n - k)logk)\n    # Space Complexity: O(k)\n\n    # heap = []\n    # for num in arr:\n    #     if len(heap) < k:\n    #         heapq.heappush(heap, num)\n    #     elif num > heap[0]:\n    #         heapq.heapreplace(heap, num)\n\n    # return heap\n\n    # Time Complexity: O(k + (n - k)logk)\n    # Space Complexity: O(1)\n\n    # heap = []\n    # for num in arr:\n    #     if len(heap) < k:\n    #         heapq.heappush(heap, num)\n    #     elif num > heap[0]:\n    #         heapq.heapreplace(heap, num)\n    #     else:\n    #         heapq.heappush(heap, num)\n\n    # return heap\n\n    # Time Complexity: O(nlogk)\n    # Space Complexity: O(k)\n\n    # heap = []\n    # for num in arr:\n    #     heapq.heappush(heap, num)\n    #     if len(heap) > k:\n    #         heapq.heappop(heap)\n\n    # return heap\n\n    # Time Complexity: O(nlogk)\n    # Space Complexity: O(k)\n\n    # heap = []\n    # for num in arr:\n    #     heapq.heappush"
    },
    {
      "rank": 68,
      "score": 7.931690111456615,
      "candidate": "# Initialization\n    max_heap = []\n    max_heapq.heapify(max_heap)\n    result = []\n\n    for num in arr:\n        if len(max_heap) < k:\n            max_heapq.heappush(max_heap, num)\n        else:\n            if num > max_heap[0]:\n                max_heapq.heappop(max_heap)\n                max_heapq.heappush(max_heap, num)\n\n    while max_heap:\n        result.append(max_heapq.heappop(max_heap))\n\n    return result\n\n\ndef main():\n    # call maximum() function with a list of integer input and a positive integer k\n    print(maximum([-3, -4, 5], 3))  # [-4, -3, 5]\n    print(maximum([4, -4, 4], 2))  # [4, 4]\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))  # [2]\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 69,
      "score": 7.829768166228955,
      "candidate": "# Time Complexity: O(n)\n    # Space Complexity: O(1)\n    arr.sort()\n    return arr[-k:]\n\n    # Time Complexity: O(nlogn)\n    # Space Complexity: O(1)\n    # arr.sort(reverse=True)\n    # return arr[:k]\n\n\nif __name__ == '__main__':\n    # Test 1\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    # Test 2\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    # Test 3\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 70,
      "score": 7.6408667416881695,
      "candidate": "return sorted(arr, reverse=True)[:k]\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))"
    },
    {
      "rank": 71,
      "score": 7.621382992414939,
      "candidate": "arr.sort()\n    return arr[-k:]\n\nif __name__ == \"__main__\":\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 72,
      "score": 7.60966550031207,
      "candidate": "# sort the list\n    arr.sort()\n\n    # return the last k elements\n    return arr[-k:]\n\nif __name__ == \"__main__\":\n    print(maximum([-3, -4, 5], 3))\n    print(maximum([4, -4, 4], 2))\n    print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 73,
      "score": 7.344151500726753,
      "candidate": "# Time Complexity: O(nlogk)\n    # Space Complexity: O(k)\n    arr.sort()\n    return arr[-k:]\n\n\ndef main():\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 74,
      "score": 3.2219136761813103,
      "candidate": "# initialize the window\n    window = sorted(arr[:k])\n    # loop through the rest of the array\n    for i in range(k, len(arr)):\n        # check if the current value is smaller than the smallest value in the window\n        if arr[i] >= window[0]:\n            # pop the smallest value in the window\n            window.pop(0)\n            # insert the current value at the end of the window\n            window.append(arr[i])\n        # sort the window\n        window.sort()\n        # append the current window to the answer array\n        yield window[:k]\n\n\n# test cases\ntest = [-3, -4, 5]\nk = 3\n\nexpected = [[-4, -3, 5], [-4, -3, 5], [-4, -3, 5]]\n\nprint(list(maximum(test, k)))"
    },
    {
      "rank": 75,
      "score": 3.2193819720464334,
      "candidate": "if not arr or k == 0: return []\n\n    _max = arr[0]\n    _max_idx = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] > _max:\n            _max = arr[i]\n            _max_idx = i\n\n    # swap the maximum element to the first position\n    arr[0], arr[_max_idx] = arr[_max_idx], arr[0]\n\n    return arr[:k]\n\n\nif __name__ == '__main__':\n    # Example 1:\n    #     Input: arr = [-3, -4, 5], k = 3\n    #     Output: [-4, -3, 5]\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    # Example 2:\n    #     Input: arr = [4, -4, 4], k = 2\n    #     Output: [4, 4]\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    # Example 3:\n    #     Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    #     Output: [2]\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 76,
      "score": 3.199385976598761,
      "candidate": "# sort the array in place\n    arr.sort()\n\n    # get the max k numbers in the array\n    return arr[-k:]\n\n\ndef main():\n    print('Please run this solution on LeetCode.')\n    print('https://leetcode.com/problems/find-k-closest-elements/')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 77,
      "score": 3.1464912117682107,
      "candidate": "arr.sort()\n    return arr[-k:]\n\n\ndef maximum_2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort()\n    return arr[-k:]\n\n\nprint(maximum_2([-3, -4, 5], 3))\nprint(maximum_2([4, -4, 4], 2))\nprint(maximum_2([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 78,
      "score": 3.0964203943081716,
      "candidate": "if k == 0:\n        return []\n\n    if k == 1:\n        return [max(arr)]\n\n    # 1. find max number in the arr\n    max_num = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > max_num:\n            max_num = arr[i]\n\n    # 2. move all max numbers to the end of arr\n    i = 0\n    for j in range(len(arr)):\n        if arr[j] == max_num:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n\n    # 3. return the first k numbers\n    return arr[:k]\n\n\ndef main():\n    # [4, -4, 4]\n    # print(maximum([4, -4, 4], 2))\n\n    # [2]\n    # print(maximum([-3, 2, 1, 2, -1, -2, 1], 1))\n\n    # [-4, -3, 5]\n    print(maximum([-3, -4, 5], 3))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 79,
      "score": 3.088762799608115,
      "candidate": "if not arr or len(arr) == 0: return []\n\n    arr = sorted(arr)\n    return arr[-k:] if k <= len(arr) else arr\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or len(arr) == 0: return []\n\n    arr = sorted(arr)\n    return arr[:k] if k <= len(arr) else arr\n\n\ndef maximum_without_sort(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range"
    },
    {
      "rank": 80,
      "score": 3.0848467798007237,
      "candidate": "if k == 0: return []\n    if k == 1: return [max(arr)]\n    if k == len(arr): return sorted(arr)\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, 4, 2, 2, 1, 1], k = 3\n        Output: [1, 1, 2]\n\n    Example 2:\n\n        Input: arr = [4, 4, 2, 2, 1, 1], k = 2\n        Output: [1, 2]\n\n    Example 3:\n\n        Input: arr = [4, 4, 2, 2, 1, 1], k = 1\n        Output: [1]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [1, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0: return []\n    if k == 1: return [min(arr)]\n    if k == len(arr): return sorted(arr)\n\n    arr.sort()\n    return arr[:k]"
    },
    {
      "rank": 81,
      "score": 3.0531525336846634,
      "candidate": "# sort the array\n    arr.sort()\n\n    # return the last k elements\n    return arr[-k:]\n\n\ndef main():\n    arr = [-3, -4, 5]\n    print(maximum(arr, 3))\n\n    arr = [4, -4, 4]\n    print(maximum(arr, 2))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    print(maximum(arr, 1))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 82,
      "score": 3.029949099221664,
      "candidate": "arr = sorted(arr)\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr = sorted(arr)\n    return arr[:k]\n\n\ndef minimum_index(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return an array of \n    length k with the k minimum numbers from arr.\n\n    Example 1:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 3\n        Output: [0, 1, 2]\n\n    Example 2:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 4\n        Output: [0, 1, 2, 3]\n\n    Example 3:\n\n        Input: arr = [4, 5, 6, 7, 0, 1, 2], k = 5\n        Output: [0, 1, 2, 3, 4]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2"
    },
    {
      "rank": 83,
      "score": 3.0182326152657395,
      "candidate": "# sort the array\n    arr.sort()\n    # return the last k elements\n    return arr[len(arr) - k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 2:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 3:\n\n        Input: arr = [3, 1, 2, 3, 3, 3, 3, 3, 3, 3], k = 2\n        Output: [1, 2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # sort the array\n    arr.sort()\n    # return the first k elements\n    return arr[:k]\n\n\ndef maximum_absolute_difference(arr):\n    \"\"\"\n    Given an array arr of integers, find the maximum difference between any two \n    elements in the array. Return the difference between the largest and smallest \n    values in the array.\n\n    Example 1:\n\n        Input: arr = [7, 9, 3, 4, 8, -10]\n        Output: 23\n\n    Example 2:\n\n        Input: arr = [5, 6, 2, 1]\n        Output: 4\n\n    Note:\n        1. 0 <= arr.length <= 10^5\n        2. -10^9 <= arr[i] <= 10^9\n    \"\"\"\n    # sort the array\n    arr.sort()\n    # return the difference between the largest and smallest values in the array\n    return"
    },
    {
      "rank": 84,
      "score": 2.968774963755175,
      "candidate": "# initialize local variables\n    len_arr = len(arr)\n    len_k = k\n    max_arr = []\n\n    # check if array is empty\n    if len_arr == 0:\n        return max_arr\n\n    # check if array is smaller than k\n    if len_arr < len_k:\n        return arr\n\n    # check if array is not empty and k is not larger than array\n    # select first k elements in array\n    for i in range(len_k):\n        max_arr.append(arr[i])\n\n    # sort the list\n    max_arr.sort()\n\n    return max_arr\n\n\nprint(maximum([-3, -4, 5], 3))\nprint(maximum([4, -4, 4], 2))\nprint(maximum([-3, 2, 1, 2, -1, -2, 1], 1))"
    },
    {
      "rank": 85,
      "score": 2.96266863868378,
      "candidate": "if not arr or k < 1 or k > len(arr):\n        return []\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, -4, 5], k = 3\n        Output: [-4, 4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or k < 1 or k > len(arr):\n        return []\n\n    arr.sort()\n    return arr[:k]\n\n\ndef minimum_absolute_difference(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum absolute difference between \n    any two elements in the array.\n\n    Example 1:\n\n        Input: arr = [4, 2, 1, 3]\n        Output: 1\n\n    Example 2:\n\n        Input: arr = [1, 3, 6, 10, 15]\n        Output: 1\n\n    Example 3:\n\n        Input: arr = [3, 8, -10, 23]\n        Output: 1\n\n    Note:\n        1. 1 <= arr.length <= 100000\n        2. -100000 <= arr[i] <= 100000\n    \"\"\"\n    if not arr or len(arr"
    },
    {
      "rank": 86,
      "score": 2.9115312204186026,
      "candidate": "if k == 0:\n        return []\n\n    from collections import deque\n    max_heap = deque(maxlen=k)\n    for num in arr:\n        if len(max_heap) < k:\n            max_heap.append(num)\n        else:\n            if num > max_heap[0]:\n                max_heap.popleft()\n                max_heap.append(num)\n\n    return list(max_heap)\n\n\ndef main():\n    print('Please run this solution on LeetCode.')\n    print('https://leetcode.com/problems/k-largest-elements-in-an-array/')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 87,
      "score": 2.8600670410661153,
      "candidate": "if not arr or len(arr) == 0: return arr\n\n    # O(n)\n    arr.sort()\n\n    # O(k)\n    return arr[-k:]\n\n    # O(n)\n    # return heapq.nlargest(k, arr)\n\n    # O(nlogn)\n    # return sorted(arr, reverse=True)[:k]\n\n    # O(nlogk)\n    # return sorted(arr, reverse=True)[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or len(arr) == 0: return arr\n\n    # O(n)\n    arr.sort()\n\n    # O(k)\n    return arr[:k]\n\n    # O(n)\n    # return heapq.nsmallest(k, arr)\n\n    # O(nlogn)\n    # return sorted(arr, reverse=False)[:k]\n\n    # O(nlogk)\n    # return sorted(arr, reverse=False)[-k:]"
    },
    {
      "rank": 88,
      "score": 2.8569647449828994,
      "candidate": "# # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i in range(k):\n    #     max_num = max(arr)\n    #     res.append(max_num)\n    #     arr.remove(max_num)\n    # return res\n\n    # # Initialization\n    # res = []\n    # # Main algorithm\n    # for i"
    },
    {
      "rank": 89,
      "score": 2.8530166643782007,
      "candidate": "arr.sort()\n    return arr[len(arr) - k:]\n\n\ndef main():\n    print('Please run this solution on LeetCode.')\n    print('https://leetcode.com/problems/find-k-closest-elements/')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 90,
      "score": 2.8378275537219224,
      "candidate": "if k == 0:\n        return []\n\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, -arr[i])\n\n    for i in range(k, len(arr)):\n        if arr[i] > -heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, -arr[i])\n\n    return [-x for x in heap]\n\n\ndef maximum2(arr, k):\n    if k == 0:\n        return []\n\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, -arr[i])\n\n    for i in range(k, len(arr)):\n        if arr[i] > -heap[0]:\n            heapq.heappop(heap)\n            heapq.heappush(heap, -arr[i])\n\n    return [-x for x in heap]"
    },
    {
      "rank": 91,
      "score": 2.817231059917391,
      "candidate": "arr.sort()\n    return arr[-k:]\n\n\ndef minimum_window_substring(s, t):\n    \"\"\"\n    Given a string s and a string t, return the minimum window in the string s \n    which will contain all the characters in t. If there is no such window in s \n    that covers all characters in t, return the empty string \"\".\n\n    Example 1:\n\n        Input: s = \"ADOBECODEBANC\", t = \"ABC\"\n        Output: \"BANC\"\n\n    Example 2:\n\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n\n    Example 3:\n\n        Input: s = \"a\", t = \"aa\"\n        Output: \"\"\n\n    Example 4:\n\n        Input: s = \"a\", t = \"a\"\n        Output: \"a\"\n\n    Note:\n        1. 1 <= s.length <= 105\n        2. 1 <= t.length <= 104\n        3. s and t consist of English letters (lowercase and uppercase).\n        4. At least one letter fits in the window.\n    \"\"\"\n    # Find the first char in t\n    t_char_set = set(t)\n    t_dict = {}\n    for char in t_char_set:\n        t_dict[char] = 0\n    min_length = len(s) + 1\n    start = 0\n    end = 0\n    for i in range(len(s)):\n        if s[i] in t_char_set:\n            t_dict[s[i]] += 1\n            while all(t_dict.values()):\n                if i - start + 1 < min_length:\n                    min_length = i - start + 1\n                    start = max(start - 1, 0)\n                    end = i\n                t_dict[s[start]] -= 1\n                start += 1\n    return s[start: end + 1]\n\n\ndef first_unique_char(s):\n    \"\"\"\n    Given a string, find the first non-repeating character in it and"
    },
    {
      "rank": 92,
      "score": 2.810445664653115,
      "candidate": "if not arr or k < 1 or k > len(arr):\n        return []\n\n    # 1. find the max number in arr\n    # 2. put the max number in a stack\n    # 3. put the max number in the result list\n    # 4. put the max number in the arr\n    # 5. find the max number in the arr\n    # 6. repeat 3-5\n\n    stack = []\n    result = []\n    for i in range(k):\n        num = -2 ** 31\n        for j in range(i, len(arr)):\n            if arr[j] > num:\n                num = arr[j]\n        stack.append(num)\n        result.append(num)\n        arr[i] = num\n        num = -2 ** 31\n\n    while i < len(arr) - 1:\n        i += 1\n        for j in range(i, len(arr)):\n            if arr[j] > num:\n                num = arr[j]\n        stack.pop()\n        stack.append(num)\n        result.append(num)\n        arr[i] = num\n        num = -2 ** 31\n\n    return result\n\n\ndef main():\n    # call the method here\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 93,
      "score": 2.781706727218839,
      "candidate": "# \u6392\u5e8f\n    arr.sort()\n    # \u8fd4\u56de\u6700\u540ek\u4e2a\u5143\u7d20\n    return arr[-k:]\n\n\nif __name__ == '__main__':\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))"
    },
    {
      "rank": 94,
      "score": 2.7144180491819068,
      "candidate": "# sort the array\n    arr.sort()\n    # return the last k elements\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 2:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # sort the array\n    arr.sort()\n    # return the first k elements\n    return arr[:k]\n\n\ndef find_kth_largest(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, find the kth largest \n    element in the array. Note that it is the kth largest element in the sorted \n    order, not the kth distinct element.\n\n    Example 1:\n\n        Input: arr = [3,2,1,5,6,4], k = 2\n        Output: 5\n\n    Example 2:\n\n        Input: arr = [3,2,3,1,2,4,5,5,6], k = 4\n        Output: 4\n\n    Note:\n        1. 1 <= k <= arr.length\n        2. You may assume k is always valid, 1 <= k <= arr.length.\n    \"\"\"\n    # sort the array\n    arr.sort()\n    # return the last kth element\n    return arr[-k]"
    },
    {
      "rank": 95,
      "score": 2.7012895570183724,
      "candidate": "# sort the array\n    arr.sort()\n    return arr[-k:]\n\n\ndef minimum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [-4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # sort the array\n    arr.sort()\n    return arr[:k]\n\n\ndef maximum_with_duplicates(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-3, -4, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [-3]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0"
    },
    {
      "rank": 96,
      "score": 2.618678000639471,
      "candidate": "if k > len(arr):\n        return arr\n\n    res = []\n    for _ in range(k):\n        res.append(max(arr))\n        index = arr.index(max(arr))\n        arr[index] = -float('inf')\n    return res\n\n\ndef main():\n    arr = [-3, -4, 5]\n    k = 3\n    print(maximum(arr, k))\n\n    arr = [4, -4, 4]\n    k = 2\n    print(maximum(arr, k))\n\n    arr = [-3, 2, 1, 2, -1, -2, 1]\n    k = 1\n    print(maximum(arr, k))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 97,
      "score": 2.6153179897223664,
      "candidate": "if not arr or k <= 0:\n        return []\n\n    arr.sort()\n    return arr[-k:]\n\n\ndef minimum_subsequence_sum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return the minimum \n    sum of a subsequence of arr of length k.\n\n    Example 1:\n\n        Input: arr = [4, 10, 1, 8, 7], k = 2\n        Output: 20\n        Explanation: The minimum sum of a subsequence of length 2 is 1 + 8 = 9, \n                     or 4 + 7 = 11, or 4 + 10 = 14.\n\n    Example 2:\n\n        Input: arr = [4, 10, 1, 8, 7], k = 3\n        Output: 12\n        Explanation: The minimum sum of a subsequence of length 3 is 1 + 8 + 7 = 15, \n                     or 4 + 10 + 1 = 15, or 4 + 10 + 8 = 22.\n\n    Example 3:\n\n        Input: arr = [4, 10, 1, 8, 7], k = 4\n        Output: 11\n        Explanation: The minimum sum of a subsequence of length 4 is 1 + 8 + 7 + 4 = 21, \n                     or 4 + 10 + 1 + 8 = 22, or 4 + 10 + 1 + 7 = 22.\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if not arr or k <= 0:\n        return 0\n\n    arr.sort()\n    return sum(arr[:k])"
    },
    {
      "rank": 98,
      "score": 2.6007990626007946,
      "candidate": "if not arr or k == 0:\n        return []\n    if k == 1:\n        return [max(arr)]\n    if k > len(arr):\n        return arr\n\n    # initialize a heap with the first k elements of arr\n    heap = arr[:k]\n    heapq.heapify(heap)\n\n    # add the next element of arr to the heap, and remove the smallest element\n    for i in range(k, len(arr)):\n        heapq.heappushpop(heap, arr[i])\n    return heap\n\n\nclass MaximumTest(unittest.TestCase):\n\n    def test_case_1(self):\n        arr = [-3, -4, 5]\n        k = 3\n        self.assertListEqual(maximum(arr, k), [-4, -3, 5])\n\n    def test_case_2(self):\n        arr = [4, -4, 4]\n        k = 2\n        self.assertListEqual(maximum(arr, k), [4, 4])\n\n    def test_case_3(self):\n        arr = [-3, 2, 1, 2, -1, -2, 1]\n        k = 1\n        self.assertListEqual(maximum(arr, k), [2])\n\n\nif __name__ == \"__main__\":\n\n    unittest.main()"
    },
    {
      "rank": 99,
      "score": 2.5342721852214813,
      "candidate": "def quick_select(arr, k):\n        if not arr or k < 0 or k >= len(arr): return None\n\n        pivot = arr[-1]\n        left, right = [], []\n        for num in arr[:-1]:\n            if num < pivot: left.append(num)\n            elif num > pivot: right.append(num)\n\n        if len(left) == k: return left\n        if len(left) == k - 1: return left + [pivot]\n        if len(left) == k - 2: return left + [pivot] + [right[0]]\n\n        if len(left) > k - 2: return quick_select(left, k - 2)\n        return quick_select(right, k - len(left) - 2) + [pivot] + left\n\n    return quick_select(arr, k)\n\n\ndef main():\n    print('Please run this solution on LeetCode.')\n    print('https://leetcode.com/problems/find-k-pairs-with-smallest-sums/')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 100,
      "score": 2.523979158052062,
      "candidate": "# Time Complexity: O(nlog(k))\n    # Space Complexity: O(k)\n    res = []\n    for i in range(k):\n        max_val = -float('inf')\n        for j in range(i, len(arr)):\n            if arr[j] >= max_val:\n                max_val = arr[j]\n                res.append(max_val)\n                break\n    return res\n\n\ndef maximum_2(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Time Complexity: O(n)\n    # Space Complexity: O(k)\n    res = []\n    max_val = -float('inf')\n    for i in range(k):\n        if arr[i] >= max_val:\n            max_val = arr[i]\n            res.append(max_val)\n    for i in range(k, len(arr)):\n        if arr[i] >= max_val:\n            max_val = arr[i]\n            res.pop(0)\n            res.append(max_val)\n    return res\n\n\nprint(maximum_2([-3, -4, 5], 3))\nprint(maximum_2([4, -"
    }
  ]
}