{
  "timestamp": "2025-09-14T21:32:05.552357",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codellama-7b",
  "dataset": "humaneval",
  "problem_number": 61,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\ndef extract_substring(text: str, start_mark: str, end_mark: str):\n    \"\"\" return the substring of text between the first occurrence\n    of start_mark and the first occurrence of end_mark.\n    If no end_mark is found, return the rest of the text.\n    If no start_mark is found, return an empty string.\n    >>> extract_substring(\"(this is a sentence).\", \"(\", \")\")\n    'this is a sentence'\n    >>> extract_substring(\"(this is a sentence).\", \"(\", \")\"))\n    'this is a sentence'\n    >>> extract_substring(\"(this is a sentence).\", \"=\", \")\")\n    ''\n    >>> extract_substring(\"(this is a sentence).\", \"=\", \")\"))\n    ''\n    >>> extract_substring(\"(this is a sentence).\", \"=\", \".\"))\n    ''\n    >>> extract_substring(\"(this is a sentence).\", \"(\", \"=\")\n    ''\n    >>> extract_substring(\"(this is a sentence).\", \"(\", \"=\"))\n    ''\n    \"\"\"\n    start_index = text.find(start_mark)\n    if start_index == -1:\n        return \"\"\n    start_index += len(start_mark)\n    text = text[start_index:]\n    end_index = text.find(end_mark)\n    if end_index == -1:\n        return \"\"\n    return text[:end_index]\n\n\ndef count_sentences(text: str):\n    \"\"\" return the number of sentences in text,\n    where a sentence is delimited by either a period (.) or exclamation point (!)\n\n    >>> count_sentences(\"This is a sentence. How is it?\")\n    2\n    >>> count_sentences(\"This is a sentence! How is it?\")\n    2\n    >>> count_sentences(\"This is a sentence!? How is it?\")\n    2"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "opening = brackets.count(\"(\")\n    closing = brackets.count(\")\")\n    return opening == closing\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "count = 0\n    for c in brackets:\n        if c == '(':\n            count += 1\n        elif c == ')':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0\n\n\ndef is_balanced_paren(string: str) -> bool:\n    \"\"\"\n    >>> is_balanced_paren('()')\n    True\n    >>> is_balanced_paren('(()')\n    False\n    >>> is_balanced_paren(')(()')\n    False\n    \"\"\"\n    stack = []\n    for c in string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef is_balanced_paren_v2(string: str) -> bool:\n    \"\"\"\n    >>> is_balanced_paren_v2('()')\n    True\n    >>> is_balanced_paren_v2('(()')\n    False\n    >>> is_balanced_paren_v2(')(()')\n    False\n    \"\"\"\n    stack = []\n    for c in string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef is_balanced_paren_v3(string: str) -> bool:\n    \"\"\"\n    >>> is_balanced_paren_v3('()')\n    True\n    >>> is_balanced_paren_v3('(()')\n    False\n    >>> is_balanced_paren_v3(')(()')\n    False\n    \"\"\"\n    stack = []\n    for c in string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == '__"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "openers = 0\n    for b in brackets:\n        if b == '(':\n            openers += 1\n        elif b == ')':\n            openers -= 1\n            if openers < 0:\n                return False\n    return openers == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "depth = 0\n    for b in brackets:\n        if b == '(':\n            depth += 1\n        elif b == ')':\n            depth -= 1\n            if depth < 0:\n                return False\n    return depth == 0\n\n\ndef contains_correct_bracketing(s: str):\n    \"\"\" s is a string that may contain substrings of the form \"()\" and/or \"[]\".\n    Return True if s contains a substring that is a correct use of parentheses\n    and brackets.\n\n    >>> contains_correct_bracketing('abc')\n    True\n    >>> contains_correct_bracketing('(abc)')\n    True\n    >>> contains_correct_bracketing('[abc]')\n    True\n    >>> contains_correct_bracketing('[abc')\n    False\n    >>> contains_correct_bracketing('(abc')\n    False\n    >>> contains_correct_bracketing('(abc]')\n    False\n    \"\"\"\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if correct_bracketing(s[i:j]):\n                return True\n    return False\n\n\ndef remove_incorrect_bracketing(s: str):\n    \"\"\" s is a string that may contain substrings of the form \"()\" and/or \"[]\".\n    Return a version of s with all incorrect bracketings removed.\n    If s does not contain any correct bracketings, return the empty string.\n\n    >>> remove_incorrect_bracketing('abc')\n    'abc'\n    >>> remove_incorrect_bracketing('[abc]')\n    '[abc]'\n    >>> remove_incorrect_bracketing('[abc')\n    ''\n    >>> remove_incorrect_bracketing('(abc')\n    ''\n    >>> remove_incorrect_bracketing('(abc]')\n    ''\n    >>> remove_incorrect_bracketing('abc]')\n    'abc]'\n    >>> remove_incorrect_bracketing('[abc(d)ef]')\n    '[abc(d)ef]'\n    >>> remove_incorrect_bracketing"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "opening_brackets = brackets.count(\"(\")\n    closing_brackets = brackets.count(\")\")\n    return opening_brackets == closing_brackets\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "count = 0\n    for c in brackets:\n        if c == \"(\":\n            count += 1\n        elif c == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\ndef balanced_parens(s: str):\n    \"\"\"s is a string.\n    Return True if the parentheses in s are balanced,\n    False otherwise.\n\n    >>> balanced_parens('')\n    True\n    >>> balanced_parens('()()()')\n    True\n    >>> balanced_parens('(()())')\n    True\n    >>> balanced_parens('())')\n    False\n    >>> balanced_parens('())()')\n    False\n    \"\"\"\n    return correct_bracketing(s) and s.count('(') == s.count(')')\n\n\ndef count_balanced_parens(s: str):\n    \"\"\"s is a string.\n    Return the number of properly balanced (parentheses) substrings in s.\n\n    >>> count_balanced_parens('')\n    1\n    >>> count_balanced_parens('()')\n    2\n    >>> count_balanced_parens('(()())')\n    4\n    >>> count_balanced_parens('()((())())()')\n    6\n    >>> count_balanced_parens('(()(()))(((()))())()')\n    10\n    \"\"\"\n    if len(s) == 0:\n        return 1\n    if s[0] == '(':\n        return 0\n    if s[-1] == ')':\n        return 0\n\n    if balanced_parens(s):\n        return 1\n    else:\n        return 0 + count_balanced_parens(s[1:-1])\n\n\ndef count_balanced_parens_recur(s: str):\n    \"\"\"s is a string.\n    Return the number of properly balanced (parentheses) substrings in s.\n\n    >>> count_balanced_parens_recur('')\n    1\n    >>> count_balanced_parens_recur('()')\n    2"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "# Your code here\n    # stack = []\n    # for b in brackets:\n    #     if b == '(':\n    #         stack.append(b)\n    #     if b == ')':\n    #         if not stack:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return not stack\n\n    # 2nd approach\n    # stack = []\n    # for b in brackets:\n    #     if b == '(':\n    #         stack.append(b)\n    #     if b == ')':\n    #         if not stack:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return not stack\n\n    # 3rd approach\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        if b == ')':\n            if not stack:\n                return False\n            else:\n                stack.pop()\n    return not stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print('all test cases passed!')\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "# your code here\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef remove_outlier(X):\n    \"\"\"assume X is a list of numbers.\n    return the list of numbers without their outlier.\n\n    An outlier is defined as a data point which is more than 2 standard deviations away from the sample mean\n\n    >>> remove_outlier([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> remove_outlier([1, 1, 2, 3, 5])\n    [1, 1, 2, 3, 5]\n    >>> remove_outlier([1, 1, 2, 3, 6])\n    [1, 1, 2, 3]\n    >>> remove_outlier([1, 1, 2, 4, 5])\n    [1, 1, 2, 4, 5]\n    >>> remove_outlier([1, 2, 2, 2, 6])\n    [1, 2, 2, 2]\n    \"\"\"\n    # your code here\n    mean = sum(X) / len(X)\n    std = (sum([(x - mean) ** 2 for x in X]) / len(X)) ** 0.5\n    return [x for x in X if abs(x - mean) < 2 * std]\n\n\ndef remove_outlier_no_loop(X):\n    \"\"\"assume X is a list of numbers.\n    return the list of numbers without their outlier.\n\n    An outlier is defined as a data point which is more than 2 standard deviations away from the sample mean\n\n    >>> remove_outlier([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> remove_outlier([1, 1, 2, 3, 5"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "opening_brackets = brackets.count('(')\n    closing_brackets = brackets.count(')')\n    return opening_brackets == closing_brackets\n\n\ndef balanced_parens(s: str):\n    \"\"\"\n    >>> balanced_parens('()')\n    True\n    >>> balanced_parens('(())')\n    True\n    >>> balanced_parens('(()')\n    False\n    >>> balanced_parens('foo(bar)')\n    True\n    >>> balanced_parens('foo(bar((())))')\n    True\n    >>> balanced_parens('foo(bar((())))((((((()))))))')\n    True\n    \"\"\"\n    return correct_bracketing(s) and balanced_parens_helper(s)\n\n\ndef balanced_parens_helper(s: str):\n    \"\"\"\n    >>> balanced_parens_helper('()')\n    True\n    >>> balanced_parens_helper('(())')\n    True\n    >>> balanced_parens_helper('(()')\n    False\n    >>> balanced_parens_helper('foo(bar)')\n    True\n    >>> balanced_parens_helper('foo(bar((())))')\n    True\n    >>> balanced_parens_helper('foo(bar((())))((((((()))))))')\n    True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    if s[0] == '(':\n        return balanced_parens_helper(s[1:])\n    elif s[0] == ')':\n        return False\n    else:\n        return balanced_parens_helper(s[1:])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "opening = 0\n    for i in range(len(brackets)):\n        if brackets[i] == '(':\n            opening += 1\n        elif brackets[i] == ')':\n            opening -= 1\n        if opening < 0:\n            return False\n    return opening == 0\n\n\ndef balanced_parens(string: str):\n    \"\"\" Return True if the use of parentheses in string is balanced,\n    False otherwise.\n\n    >>> balanced_parens('(a)')\n    True\n    >>> balanced_parens('a)b(')\n    False\n    >>> balanced_parens('a)b(c)d(')\n    False\n    >>> balanced_parens('(a(b)c())')\n    True\n    \"\"\"\n    return correct_bracketing(string) and correct_bracketing(string[::-1])\n\n\ndef extract_quoted_string(line: str):\n    \"\"\" Return the string of characters between matching double quotes from line.\n\n    >>> extract_quoted_string('')\n    ''\n    >>> extract_quoted_string('\"')\n    ''\n    >>> extract_quoted_string('\"abc')\n    'abc'\n    >>> extract_quoted_string('abc\"')\n    ''\n    >>> extract_quoted_string('abc\"def')\n    'abc'\n    >>> extract_quoted_string('\"abc\"def')\n    'abc'\n    >>> extract_quoted_string('\"abc\" \"def\"')\n    'abc'\n    >>> extract_quoted_string('abc\"def\"ghi')\n    'abc'\n    \"\"\"\n    for i in range(len(line)):\n        if line[i] == '\"':\n            return line[i+1:line.find('\"', i+1)]\n    return ''\n\n\ndef extract_quoted_strings(line: str):\n    \"\"\" Return a list of the strings of characters between matching double quotes\n    from line.\n\n    >>> extract_quoted_strings('')\n    []\n    >>> extract_quoted_strings('\"')\n    []\n    >>> extract_quoted_strings('\"abc')\n    ['abc"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "\"*** YOUR CODE HERE ***\"\n    if brackets == '':\n        return True\n    elif brackets[0] == '(':\n        return correct_bracketing(brackets[1:])\n    elif brackets[0] == ')':\n        if brackets[1] == '(':\n            return correct_bracketing(brackets[1:])\n        else:\n            return False\n\n\ndef count_correct_bracketings(brackets: str):\n    \"\"\"Return the number of ways bracket can be correctly bracketed.\n    *** YOUR CODE HERE ***\n    \"\"\"\n    if brackets == '':\n        return 1\n    elif brackets[0] == '(':\n        return count_correct_bracketings(brackets[1:])\n    elif brackets[0] == ')':\n        if brackets[1] == '(':\n            return count_correct_bracketings(brackets[1:])\n        else:\n            return 0\n    else:\n        return count_correct_bracketings(brackets[1:]) + count_correct_bracketings(brackets[1:])\n\n\ndef evaluate_reverse_polish(tokens):\n    \"\"\"\n    >>> evaluate_reverse_polish('1 2 3 4 + +')\n    9\n    >>> evaluate_reverse_polish('1 2 3 4 * *')\n    24\n    >>> evaluate_reverse_polish('4 3 + 5 2 + /')\n    4.0\n    >>> evaluate_reverse_polish('1 2 3 4 5 + -')\n    -2\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    stack = []\n    for token in tokens.split():\n        if token in ['+', '-', '*', '/']:\n            right = stack.pop()\n            left = stack.pop()\n            if token == '+':\n                result = left + right\n            elif token == '-':\n                result = left - right\n            elif token == '*':\n                result = left * right\n            else:\n                result = left / right\n            stack.append(result)\n        else:\n            stack.append("
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "# your code here\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef remove_outer_parentheses(s):\n    \"\"\"\n    >>> remove_outer_parentheses('foo')\n    'foo'\n    >>> remove_outer_parentheses('(foo)')\n    'foo'\n    >>> remove_outer_parentheses('foo(bar)')\n    'foo(bar)'\n    \"\"\"\n    # your code here\n    return s[1:-1] if correct_bracketing(s) else s\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "# Your code here\n    stack = []\n    for i in brackets:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack != []:\n                stack.pop()\n            else:\n                return False\n    if stack == []:\n        return True\n    else:\n        return False\n\n\nprint(correct_bracketing(\"()\"))\nprint(correct_bracketing(\"(()\"))\nprint(correct_bracketing(\"(()()\"))\nprint(correct_bracketing(\"()()()\"))\nprint(correct_bracketing(\")(()\"))\nprint(correct_bracketing(\"(()()()\"))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "# ------------------------------------------------------------------\n    # Bubble sort\n    #\n    # for i in range(len(brackets)-1):\n    #     for j in range(len(brackets)-1-i):\n    #         if brackets[j] == \"(\" and brackets[j+1] == \")\":\n    #             brackets[j], brackets[j+1] = brackets[j+1], brackets[j]\n    #             return True\n    #     return False\n    # ------------------------------------------------------------------\n\n    # ------------------------------------------------------------------\n    # Push and pop\n    #\n    # stack = []\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(\"(\")\n    #     else:\n    #         if len(stack) == 0:\n    #             return False\n    #         stack.pop()\n    # return len(stack) == 0\n    # ------------------------------------------------------------------\n\n    # ------------------------------------------------------------------\n    # Recursive\n    #\n    # if len(brackets) == 0:\n    #     return True\n    # if len(brackets) == 1:\n    #     return False\n    # if brackets[0] == \"(\" and brackets[-1] == \")\":\n    #     return correct_bracketing(brackets[1:-1])\n    # return False\n    # ------------------------------------------------------------------\n\n    # ------------------------------------------------------------------\n    # Stack\n    #\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(\"(\")\n        elif bracket == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n    # ------------------------------------------------------------------\n\n\nprint(correct_bracketing(\"(()())\"))"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "# 1. count opening brackets\n    count_opening = 0\n    for c in brackets:\n        if c == \"(\":\n            count_opening += 1\n\n    # 2. count closing brackets\n    count_closing = 0\n    for c in brackets:\n        if c == \")\":\n            count_closing += 1\n\n    # 3. check equality\n    if count_opening == count_closing:\n        return True\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "# count = brackets.count('(')\n    # if count != brackets.count(')'):\n    #     return False\n    # return True\n\n    # \u65b9\u6cd5\u4e8c\uff1a\n    # stack \u7528\u6765\u5b58\u653e\u5de6\u62ec\u53f7\n    # \u904d\u5386brackets\n    # \u82e5\u5f53\u524d\u5b57\u7b26\u4e3a\u5de6\u62ec\u53f7\uff0c\u5219\u5165\u6808\n    # \u82e5\u5f53\u524d\u5b57\u7b26\u4e3a\u53f3\u62ec\u53f7\uff0c\u5219\u51fa\u6808\n    # \u5f53\u904d\u5386\u5b8c\u6210\u540e\uff0c\u82e5\u6808\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56deTrue\uff0c\u5426\u5219\u8fd4\u56deFalse\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        elif b == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "\"*** YOUR CODE HERE ***\"\n\ndef sum_digits(i: int) -> int:\n    \"\"\"\n    Return the sum of the digits of a non-negative integer.\n\n    >>> sum_digits(10) # 1 + 0 = 1\n    1\n    >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12\n    12\n    >>> sum_digits(1234567890)\n    45\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n\ndef double_e_count(text: str) -> int:\n    \"\"\"Return the number of 'e' chars in text, but any char that follows a 'e' char should not be counted\n\n    >>> double_e_count('apple')\n    0\n    >>> double_e_count('Exercise')\n    2\n    >>> double_e_count('eXamineE')\n    3\n    >>> double_e_count('tExEx')\n    2\n    \"\"\"\n    \"*** YOUR CODE HERE ***\""
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "assert set(brackets).issubset({\"(\", \")\"})\n    # stack is a list of opening brackets that we have not yet closed\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        else:  # b == ')'\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if stack == []:\n                return False\n            else:\n                stack.pop()\n    return stack == []\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "if brackets == \"\":\n        return True\n    elif brackets[0] == \"(\":\n        return correct_bracketing(brackets[1:])\n    elif brackets[0] == \")\":\n        if brackets[1:] == \"\":\n            return False\n        elif brackets[1] == \"(\":\n            return correct_bracketing(brackets[2:])\n        else:\n            return False\n    else:\n        raise ValueError(\"Brackets must be a string of '(' and ')'.\")\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "stack = []\n    for b in brackets:\n        if b == \"(\":\n            stack.append(b)\n        elif b == \")\":\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef count_correct_bracketings(brackets: str):\n    \"\"\"\n    return the number of ways to correctly bracket the expression\n    \"\"\"\n    if len(brackets) == 0:\n        return 1\n    if brackets[0] == \"(\":\n        return 0\n    if brackets[0] == \")\":\n        return count_correct_bracketings(brackets[1:])\n    return count_correct_bracketings(brackets[1:]) + count_correct_bracketings(brackets[2:])\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print(count_correct_bracketings(\"(()())\"))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        elif b == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        elif b == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing_rec(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_rec(\"(\")\n    False\n    >>> correct_bracketing_rec(\"()\")\n    True\n    >>> correct_bracketing_rec(\"(()())\")\n    True\n    >>> correct_bracketing_rec(\")(()\")\n    False\n    \"\"\"\n    if len(brackets) == 0:\n        return True\n    elif brackets[0] == '(':\n        return correct_bracketing_rec(brackets[1:])\n    elif brackets[0] == ')':\n        if len(brackets) >= 2 and brackets[1] == '(':\n            return correct_bracketing_rec(brackets[2:])\n        else:\n            return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "# Your code here\n    pass\n\n\ndef match_parens(s: str):\n    \"\"\"\n    s is a string of parentheses, brackets and/or braces\n    return True if every opening bracket has a corresponding closing bracket\n\n    >>> match_parens(\"(((((((()))))))\")\n    True\n    >>> match_parens(\"(((((((())(((((()))))))))))\")\n    False\n    >>> match_parens(\"(())\")\n    True\n    >>> match_parens(\"()\")\n    True\n    >>> match_parens(\"\")\n    True\n    \"\"\"\n    # Your code here\n    pass\n\n\ndef balanced_parens(s: str):\n    \"\"\"\n    s is a string of parentheses, brackets and/or braces\n    return True if every opening symbol has a corresponding closing symbol\n\n    >>> balanced_parens(\"(((((((()))))))\")\n    True\n    >>> balanced_parens(\"(((((((())(((((()))))))))))\")\n    False\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"\")\n    True\n    \"\"\"\n    # Your code here\n    pass\n\n\ndef balanced_multiple(s: str):\n    \"\"\"\n    s is a string of parentheses, brackets and/or braces\n    return True if every opening symbol has a corresponding closing symbol\n\n    >>> balanced_multiple(\"(((((((()))))))\")\n    True\n    >>> balanced_multiple(\"(((((((())(((((()))))))))))\")\n    False\n    >>> balanced_multiple(\"(())\")\n    True\n    >>> balanced_multiple(\"()\")\n    True\n    >>> balanced_multiple(\"\")\n    True\n    \"\"\"\n    # Your code here\n    pass\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "opening_brackets = brackets.count(\"(\")\n    closing_brackets = brackets.count(\")\")\n    if opening_brackets > closing_brackets:\n        return False\n    else:\n        return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "# count = 0\n    # for b in brackets:\n    #     if b == \"(\":\n    #         count += 1\n    #     else:\n    #         count -= 1\n    # return count == 0\n\n    stack = []\n    for b in brackets:\n        if b == \"(\":\n            stack.append(\"(\")\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_parenthesization(expression: str):\n    \"\"\" expression is a string of the form (op arg)\n    return a tuple of the form (op, arg) if expression\n    is a valid operation in prefix notation, and None otherwise.\n\n    >>> correct_parenthesization(\"- x 3\")\n    ('-', 'x')\n    >>> correct_parenthesization(\"+ x (- y 3)\")\n    ('+', 'x')\n    >>> correct_parenthesization(\"- x (- y 3)\")\n    ('-', 'x')\n    \"\"\"\n    stack = []\n    for t in expression.split():\n        if t in [\"-\", \"+\", \"*\", \"/\"]:\n            stack.append(t)\n        elif t == \"(\":\n            stack.append(t)\n        elif t == \")\":\n            if len(stack) == 0:\n                return None\n            top = stack.pop()\n            while top != \"(\":\n                top = stack.pop()\n            if len(stack) == 0:\n                return None\n            stack.pop()\n        else:\n            if len(stack) == 0:\n                return None\n            top = stack.pop()\n            while top != \"(\":\n                if top in [\"-\", \"+\", \"*\", \"/\"]:\n                    return None\n                top = stack.pop()\n            stack.append(t)\n    if len(stack) == 0:\n        return None\n    return stack.pop()\n\n\ndef prefix_print(t: tuple, indent=0):\n    \"\"\" t is a tuple of the form (op, arg).\n    print the tuple with one indentation level.\n\n    >>> prefix_print("
    },
    {
      "rank": 29,
      "score": 10.0,
      "candidate": "stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if stack == []:\n                return False\n            else:\n                stack.pop()\n    return stack == []\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 10.0,
      "candidate": "# TODO: implement correct_bracketing function\n    return False\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 10.0,
      "candidate": "opening_brackets = 0\n    for bracket in brackets:\n        if bracket == '(':\n            opening_brackets += 1\n        else:\n            if opening_brackets <= 0:\n                return False\n            else:\n                opening_brackets -= 1\n    return opening_brackets == 0\n\n\ndef test_correct_bracketing():\n    assert correct_bracketing(\"()\")\n    assert correct_bracketing(\"()()()()\")\n    assert not correct_bracketing(\"(\")\n    assert not correct_bracketing(\")\")\n    assert not correct_bracketing(\"(()(()\")\n    assert not correct_bracketing(\"())()\")\n\n\nif __name__ == \"__main__\":\n    test_correct_bracketing()\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 10.0,
      "candidate": "if brackets.count(\"(\") != brackets.count(\")\"):\n        return False\n    stack = []\n    for b in brackets:\n        if b == \"(\":\n            stack.append(\"(\")\n        elif b == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\nprint(correct_bracketing(\"(()())\"))\nprint(correct_bracketing(\")(()\"))\nprint(correct_bracketing(\"(\"))\nprint(correct_bracketing(\"()\"))\nprint(correct_bracketing(\"(()())\"))\nprint(correct_bracketing(\")(\"))\nprint(correct_bracketing(\"(()))(\"))\nprint(correct_bracketing(\"(()())(()))(((((()))))))\"))\nprint(correct_bracketing(\"(()())(()))(((((()))))))(\"))"
    },
    {
      "rank": 33,
      "score": 10.0,
      "candidate": "# Your code here\n    \"*** YOUR CODE HERE ***\"\n    count = 0\n    for i in brackets:\n        if i == '(':\n            count += 1\n        elif i == ')':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\nprint(correct_bracketing(\"(()())\"))"
    },
    {
      "rank": 34,
      "score": 10.0,
      "candidate": "if len(brackets) % 2 == 1:\n        return False\n\n    open_brackets = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            open_brackets += 1\n        else:\n            open_brackets -= 1\n            if open_brackets < 0:\n                return False\n    return open_brackets == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 10.0,
      "candidate": "# Your code here\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef is_valid_parenthesization(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if brackets is parenthesis of an expression.\n\n    >>> is_valid_parenthesization(\"(()())\")\n    True\n    >>> is_valid_parenthesization(\"()\")\n    True\n    >>> is_valid_parenthesization(\"())\")\n    False\n    >>> is_valid_parenthesization(\"())(\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef is_valid_parenthesization2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if brackets is parenthesis of an expression.\n\n    >>> is_valid_parenthesization2(\"(()())\")\n    True\n    >>> is_valid_parenthesization2(\"()\")\n    True\n    >>> is_valid_parenthesization2(\"())\")\n    False\n    >>> is_valid_parenthesization2(\"())(\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 10.0,
      "candidate": "# return len(brackets) == 0 or brackets[-1] == ')'\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        elif b == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 10.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef correct_bracketing_re(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_re(\"(\")\n    False\n    >>> correct_bracketing_re(\"()\")\n    True\n    >>> correct_bracketing_re(\"(()())\")\n    True\n    >>> correct_bracketing_re(\")(()\")\n    False\n    \"\"\"\n    return len(re.findall(r\"\\(\", brackets)) == len(re.findall(r\"\\)\", brackets))\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n    print('[1] test:', correct_bracketing('(()())'))\n    print('[2] test:', correct_bracketing('([(])'))\n    print('[3] test:', correct_bracketing('(())'))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 38,
      "score": 10.0,
      "candidate": "open_brackets = 0\n    for c in brackets:\n        if c == \"(\":\n            open_brackets += 1\n        elif c == \")\":\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\ndef correct_parenthesization(prefix: str) -> bool:\n    \"\"\" prefix is a string of \"0\", \"1\", \"+\" and \"(\" characters.\n    return True if and only if every non-empty prefix can be\n    correctly parenthesized, so that the resulting arithmetic expression\n    evaluates to true.\n\n    >>> correct_parenthesization(\"1\")\n    True\n    >>> correct_parenthesization(\"1+1\")\n    True\n    >>> correct_parenthesization(\"+1\")\n    False\n    >>> correct_parenthesization(\"1+1+\")\n    False\n    >>> correct_parenthesization(\"1+(1+1)\")\n    True\n    >>> correct_parenthesization(\"1+1)+1\")\n    False\n    \"\"\"\n    if len(prefix) == 0:\n        return False\n    if prefix[0] == \"(\":\n        return False\n    if prefix[-1] == \")\":\n        return False\n    for i in range(len(prefix)):\n        if prefix[i] == \"(\":\n            return correct_parenthesization(prefix[i + 1:]) and correct_bracketing(prefix[i:])\n    return False\n\n\ndef generate_parenthesizations(parts):\n    \"\"\"\n    parts is a list of strings.\n    generate_parenthesizations returns a list of all ways of parenthesizing\n    the strings in parts so that the resulting arithmetic expression evaluates\n    to true.\n\n    >>> generate_parenthesizations([\"1\"])\n    ['1']\n    >>> generate_parenthesizations([\"1\", \"1\"])\n    ['1+1', '11']\n    >>> generate_parenthesizations([\"1\", \"1\", \"1\"])\n    ['1+1+1', '1+11', '11+1', '111']\n    >>> generate_parenthesizations([\"1\", \"1\", \"0\"])"
    },
    {
      "rank": 39,
      "score": 10.0,
      "candidate": "if len(brackets) % 2 != 0:\n        return False\n    else:\n        return brackets == brackets.replace('()', '')\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 10.0,
      "candidate": "stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        elif b == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 41,
      "score": 10.0,
      "candidate": "open_brackets = 0\n    for c in brackets:\n        if c == \"(\":\n            open_brackets += 1\n        elif c == \")\":\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                return False\n    return open_brackets == 0\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v2(\"(\")\n    False\n    >>> correct_bracketing_v2(\"()\")\n    True\n    >>> correct_bracketing_v2(\"(()())\")\n    True\n    >>> correct_bracketing_v2(\")(()\")\n    False\n    \"\"\"\n    open_brackets = []\n    for c in brackets:\n        if c == \"(\":\n            open_brackets.append(c)\n        elif c == \")\":\n            if len(open_brackets) > 0:\n                open_brackets.pop()\n            else:\n                return False\n    return len(open_brackets) == 0\n\n\ndef correct_bracketing_v3(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v3(\"(\")\n    False\n    >>> correct_bracketing_v3(\"()\")\n    True\n    >>> correct_bracketing_v3(\"(()())\")\n    True\n    >>> correct_bracketing_v3(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for c in brackets:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return False\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 42,
      "score": 10.0,
      "candidate": "open_brackets = 0\n    for c in brackets:\n        if c == '(':\n            open_brackets += 1\n        elif c == ')':\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\ndef correct_parenthesizing(tokens: list, parens: str):\n    \"\"\" tokens is a list of strings.\n    parens is a string of \"(\" and \")\".\n    return True if every string in tokens can be joined together,\n    with each string enclosed in parens, such that the resulting string\n    is well-bracketed.\n\n    >>> correct_parenthesizing([\"(\", \")\"], \"()\")\n    True\n    >>> correct_parenthesizing([\"(\", \"x\"], \"()\")\n    False\n    >>> correct_parenthesizing([\"x\", \")\"], \"()\")\n    False\n    >>> correct_parenthesizing([\"x\", \"x\"], \"()\")\n    False\n    >>> correct_parenthesizing([\"x(\", \")\", \"x\"], \"()\")\n    True\n    >>> correct_parenthesizing([\"x(\", \"y\", \")\", \"x\"], \"()\")\n    True\n    >>> correct_parenthesizing([\"x(\", \"y\", \")\", \"x\"], \"\")\n    False\n    \"\"\"\n    if len(tokens) == 0:\n        return True\n    if parens == \"()\":\n        return correct_bracketing(tokens[0] + tokens[-1])\n    elif parens == \"[]\":\n        return correct_bracketing(tokens[0] + tokens[-1])\n    elif parens == \"{}\":\n        return correct_bracketing(tokens[0] + tokens[-1])\n    else:\n        return False\n\n\ndef get_parenthesized_substrings(string: str, parens: str):\n    \"\"\" return a list of strings, each of which is a substring of string\n    that is surrounded by a parenthesis.\n\n    >>> get_parenthesized_substrings(\"abc\", \"()\")\n    ['abc']\n    >>> get_parenthesized_substrings(\"(abc\", \"()"
    },
    {
      "rank": 43,
      "score": 10.0,
      "candidate": "# your code here\n\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        elif b == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\nprint(correct_bracketing(\"(()())\"))\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" return the number of ways to correctly bracket the expression.\n\n    brackets is a string of \"(\" and \")\".\n\n    >>> count_correct_bracketing(\"()()()\")\n    2\n    >>> count_correct_bracketing(\"(())()\")\n    2\n    >>> count_correct_bracketing(\"((())())\")\n    4\n    \"\"\"\n    # your code here\n    if len(brackets) == 0:\n        return 1\n    elif len(brackets) == 1:\n        return 0\n    elif len(brackets) == 2:\n        if brackets[0] == '(' and brackets[1] == ')':\n            return 1\n        else:\n            return 0\n    else:\n        cnt = 0\n        for i in range(1, len(brackets)):\n            if brackets[i] == ')' and brackets[i - 1] == '(':\n                if correct_bracketing(brackets[:i] + brackets[i + 1:]):\n                    cnt += count_correct_bracketing(brackets[:i] + brackets[i + 1:])\n        return cnt\n\n\nprint(count_correct_bracketing(\"(()())\"))\n\n\ndef balanced_brackets(string):\n    \"\"\"\n    return True if all brackets in string are balanced, i.e. every opening bracket\n    has a corresponding closing bracket and vice versa.\n\n    >>> balanced_brackets('[]()()(((([])))')\n    True\n    >>> balanced_brackets('[()]')\n    True\n    >>> balanced_brackets('[)')\n    False\n    >>> balanced_brackets('[(])')\n    False"
    },
    {
      "rank": 44,
      "score": 10.0,
      "candidate": "stack = []\n    for char in brackets:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "# this is the stack\n    # stack = []\n\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(\"(\")\n    #     elif bracket == \")\":\n    #         if len(stack) == 0:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return len(stack) == 0\n\n    # or\n\n    # if not brackets:\n    #     return True\n\n    # stack = []\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(\"(\")\n    #     elif bracket == \")\":\n    #         if len(stack) == 0:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return len(stack) == 0\n\n    # or\n\n    # stack = []\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(\"(\")\n    #     elif bracket == \")\":\n    #         if len(stack) == 0:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return len(stack) == 0\n\n    # or\n\n    # if not brackets:\n    #     return True\n\n    # stack = []\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(\"(\")\n    #     elif bracket == \")\":\n    #         if len(stack) == 0:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # return len(stack) == 0\n\n    # or\n\n    # if not brackets:\n    #     return True\n\n    # stack = []\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(\"(\")\n    #     elif bracket == \")\":\n    #         if len(stack) == 0:\n    #             return False\n    #         else:\n    #             stack.pop"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "opening_brackets = brackets.count(\"(\")\n    closing_brackets = brackets.count(\")\")\n    return opening_brackets == closing_brackets\n\n\nprint(correct_bracketing(\"()\"))\nprint(correct_bracketing(\"(())\"))\nprint(correct_bracketing(\"(()))\"))"
    },
    {
      "rank": 47,
      "score": 1.5,
      "candidate": "return brackets.count(\"(\") == brackets.count(\")\")\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef match(b1: str, b2: str):\n    \"\"\" return True if b1 and b2 are a pair of brackets that can be matched.\n\n    >>> match('(', ')')\n    True\n    >>> match('(', ']')\n    False\n    >>> match('[', ']')\n    True\n    >>> match('[', '(')\n    False\n    >>> match('(', ')')\n    True\n    \"\"\"\n    return (b1 == '(' and b2 == ')') or (b1 == '[' and b2 == ']')\n\n\ndef is_correct(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> is_correct(\"()\")\n    True\n    >>> is_correct(\"(()())\")\n    True\n    >>> is_correct(\")(()\")\n    False\n    >>> is_correct(\"(]\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(' or bracket == '[':\n            stack.append(bracket)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                if not match(stack.pop(), bracket):\n                    return False\n    return len(stack)"
    },
    {
      "rank": 48,
      "score": 1.5,
      "candidate": "count = 0\n    for b in brackets:\n        if b == \"(\":\n            count += 1\n        else:\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0\n\n\ndef balanced_parens(s: str):\n    \"\"\"\n    return True if s is balanced in parentheses\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    \"\"\"\n    stack = []\n    for c in s:\n        if c == \"(\":\n            stack.append(\"(\")\n        elif c == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef count_correct_bracketings(s: str):\n    \"\"\"\n    return the number of correct bracketings of s.\n\n    >>> count_correct_bracketings(\"()\")\n    1\n    >>> count_correct_bracketings(\"()()()\")\n    2\n    >>> count_correct_bracketings(\"((()))\")\n    1\n    >>> count_correct_bracketings(\"(()())\")\n    2\n    >>> count_correct_bracketings(\"()(()())\")\n    3\n    >>> count_correct_bracketings(\"(((())))\")\n    2\n    >>> count_correct_bracketings(\"((((()))))\")\n    1\n    \"\"\"\n    if len(s) == 0:\n        return 1\n    if len(s) == 1:\n        return 0\n\n    first = s[0]\n    rest = s[1:]\n    if first == \"(\":\n        return count_correct_bracketings(rest)\n\n    num_correct = 0\n    for i in range(len(rest)):\n        if rest[i] == \"(\":\n            num_correct += count_correct_bracketings(rest[:i] + rest[i+1:])\n\n    return num_correct\n\n\ndef test_correct_bracketing():\n    assert correct_bracketing(\"()\")"
    },
    {
      "rank": 49,
      "score": 1.0,
      "candidate": "if not brackets:\n        return True\n    counter = 0\n    for b in brackets:\n        if b == '(':\n            counter += 1\n        elif b == ')':\n            counter -= 1\n        if counter < 0:\n            return False\n    return counter == 0\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of balanced and unbalanced parentheses.\n    return a list of the indices of the balanced parentheses.\n\n    >>> balanced_parens(\"(())\")\n    [0, 1, 2, 3]\n    >>> balanced_parens(\"(()\")\n    [0, 1, 2]\n    >>> balanced_parens(\"()()\")\n    [0, 1, 3, 4]\n    >>> balanced_parens(\"())\")\n    [1, 2, 3]\n    \"\"\"\n    if not parens:\n        return []\n    counter = 0\n    indices = []\n    for i, p in enumerate(parens):\n        if p == '(':\n            counter += 1\n        elif p == ')':\n            counter -= 1\n        if counter == 0:\n            indices.append(i)\n    return indices\n\n\ndef match_paren_index(parens: str, i: int):\n    \"\"\" parens is a string of balanced and unbalanced parentheses.\n    return the index of the matching paren, or None if there is no match.\n\n    >>> match_paren_index(\"(())\", 0)\n    3\n    >>> match_paren_index(\"()\", 0)\n    1\n    >>> match_paren_index(\"(()\", 0)\n    None\n    \"\"\"\n    if not parens:\n        return None\n    counter = 0\n    for j, p in enumerate(parens):\n        if j == i:\n            continue\n        if p == '(':\n            counter += 1\n        elif p == ')':\n            counter -= 1\n        if counter == 0:\n            return j\n    return None\n\n\ndef replace_parens(parens: str, i: int, replacement:"
    },
    {
      "rank": 50,
      "score": 1.0,
      "candidate": "return brackets.count(\"(\") == brackets.count(\")\")\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of parentheses: \"()\", \"()()\", \"(()(()))\"\n    return True if there are the same number of opening and closing parentheses,\n    and if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"(\")\n    False\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"()()\")\n    True\n    >>> balanced_parens(\")(()\")\n    False\n    >>> balanced_parens(\"(()())\")\n    True\n    \"\"\"\n    return correct_bracketing(parens) and parens.count(\"(\") == parens.count(\")\")\n\n\ndef factorial(n):\n    \"\"\"Return n!\n\n    >>> [factorial(n) for n in range(6)]\n    [1, 1, 2, 6, 24, 120]\n    >>> factorial(3) * factorial(2)\n    12\n    >>> 3 * factorial(2) == factorial(3) * 2\n    True\n    >>> factorial(3.3)\n    Traceback (most recent call last):\n    ...\n    ValueError\n    \"\"\"\n    if type(n) != int or n < 0:\n        raise ValueError\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\n\ndef double_eights(n):\n    \"\"\"Return True if n has two eights in a row.\n    >>> double_eights(8)\n    False\n    >>> double_eights(88)\n    True\n    >>> double_eights(2882)\n    True\n    >>> double_eights(880088)\n    True\n    >>> double_eights(12345)\n    False\n    >>> double_eights(80808080)\n    False\n    \"\"\"\n    # Convert n into a string, and check if the length"
    },
    {
      "rank": 51,
      "score": 1.0,
      "candidate": "return brackets.count('(') == brackets.count(')')\n\n\ndef correct_parenthesization(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if this is a correct parenthesization of a mathematical expression.\n\n    >>> correct_parenthesization(\"\")\n    True\n    >>> correct_parenthesization(\"(\")\n    False\n    >>> correct_parenthesization(\"()\")\n    True\n    >>> correct_parenthesization(\"(()())\")\n    True\n    >>> correct_parenthesization(\")(()\")\n    False\n    \"\"\"\n    return correct_bracketing(brackets) and (brackets.count('()') % 2 == 0)\n\n\ndef number_of_correct_parenthesizations(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of possible correct parenthesizations of brackets.\n\n    >>> number_of_correct_parenthesizations(\"\")\n    1\n    >>> number_of_correct_parenthesizations(\"(\")\n    0\n    >>> number_of_correct_parenthesizations(\"()\")\n    1\n    >>> number_of_correct_parenthesizations(\"(()())\")\n    2\n    >>> number_of_correct_parenthesizations(\")(()\")\n    0\n    \"\"\"\n    if brackets.count('(') == 0:\n        return 1\n    elif not correct_bracketing(brackets):\n        return 0\n    else:\n        count = 0\n        for i in range(len(brackets)):\n            if brackets[i] == '(':\n                count += number_of_correct_parenthesizations(brackets[:i] + brackets[i + 1:])\n        return count\n\n\ndef remove_outermost_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return brackets with the outermost brackets removed.\n\n    >>> remove_outermost_brackets(\"(()())\")\n    '(())'\n    >>> remove_outermost_brackets(\"()()()\")\n    '()()'\n    >>> remove_outermost_brackets(\"()\")\n    ''\n    \"\"\"\n    if not brackets:"
    },
    {
      "rank": 52,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append('(')\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of '(', ')' and '*'.\n    return True if every '(' has a corresponding ')',\n    every '*' has a corresponding ')' and there are no unmatched '(' or ')'\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"(*)\")\n    True\n    >>> balanced_parens(\"(*\")\n    False\n    >>> balanced_parens(\"(**\")\n    False\n    >>> balanced_parens(\")(\")\n    False\n    \"\"\"\n    stack = []\n    for c in parens:\n        if c == '(' or c == '*':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            if stack[-1] == '(':\n                stack.pop()\n            elif stack[-1] == '*':\n                stack[-1] = ')'\n            else:\n                return False\n    return len(stack) == 0\n\n\ndef reverse_paren(paren: str):\n    \"\"\" paren is a string of '(' or ')'.\n    return the string with paren and its reverse.\n\n    >>> reverse_paren('(')\n    '()'\n    >>> reverse_paren('*')\n    '*'\n    \"\"\"\n    if paren == '(':\n        return ')'\n    elif paren == ')':\n        return '('\n    else:\n        return paren\n\n\ndef reverse_parens(parens: str):\n    \"\"\" parens is a string of '(', ')', '*' and ')'.\n    return the string with parens and its reverse.\n\n    >>> reverse_parens(\"()\")\n    '()()'\n    >>> reverse_parens(\"(*)\")\n    '*()'\n    >>> reverse_"
    },
    {
      "rank": 53,
      "score": 1.0,
      "candidate": "balance = 0\n    for c in brackets:\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n\n\ndef match_parens(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> match_parens(\"()\")\n    True\n    >>> match_parens(\")(()\")\n    False\n    >>> match_parens(\"(()())\")\n    True\n    \"\"\"\n    # This solution is not as efficient as it could be, but it works.\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef is_balanced_paren(string: str):\n    \"\"\" string is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> is_balanced_paren(\"(()())\")\n    True\n    >>> is_balanced_paren(\"()\")\n    True\n    >>> is_balanced_paren(\")(()\")\n    False\n    \"\"\"\n    # This solution is not as efficient as it could be, but it works.\n    stack = []\n    for c in string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef is_balanced_paren_better(string: str):\n    \"\"\" string is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> is_balanced_paren_better(\"(()())\")\n    True\n    >>> is_balanced_paren_better(\"()\")\n    True\n    >>> is_balanced_paren_"
    },
    {
      "rank": 54,
      "score": 1.0,
      "candidate": "# Your code here\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"(\")\n    False\n    >>> correct_bracketing2(\"()\")\n    True\n    >>> correct_bracketing2(\"(()())\")\n    True\n    >>> correct_bracketing2(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"(\")\n    False\n    >>> correct_bracketing3(\"()\")\n    True\n    >>> correct_bracketing3(\"(()())\")\n    True\n    >>> correct_bracketing3(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    return brackets.count('(') == brackets.count(')')\n\n\ndef correct_bracketing4(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing4(\"(\")\n    False\n    >>> correct_bracketing4(\"()\")\n    True\n    >>> correct_bracketing4(\"(()())\")\n    True\n    >>> correct_bracketing4(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    return brackets.count('('"
    },
    {
      "rank": 55,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef count_correct_bracketings(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways the brackets can be bracketed if they are balanced.\n\n    >>> count_correct_bracketings(\"()\")\n    1\n    >>> count_correct_bracketings(\"(())\")\n    2\n    >>> count_correct_bracketings(\"()()\")\n    2\n    \"\"\"\n    if len(brackets) == 0:\n        return 1\n    if brackets[0] == '(':\n        return 0\n    if correct_bracketing(brackets):\n        return 1 + count_correct_bracketings(brackets[1:])\n    else:\n        return count_correct_bracketings(brackets[1:])\n\n\ndef all_bracketings(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a list of all possible ways the brackets can be bracketed if they are balanced.\n\n    >>> all_bracketings(\"()\")\n    [['()']]\n    >>> all_bracketings(\"(())\")\n    [['(())'], ['()()']]\n    >>> all_bracketings(\"()()\")\n    [['()()'], ['()()']]\n    \"\"\"\n    if len(brackets) == 0:\n        return [[]]\n    if brackets[0] == '(':\n        return []\n    if correct_bracketing(brackets):\n        return [[brackets] + b for b in all_bracketings(brackets[1:])]\n    else:\n        return all_bracketings(brackets[1:])\n\n\ndef bracket_structure(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a list of the indices of the brackets.\n\n    >>> bracket_structure(\"()\")"
    },
    {
      "rank": 56,
      "score": 1.0,
      "candidate": "\"*** YOUR CODE HERE ***\"\n    if not brackets:\n        return True\n    if brackets[0] == '(':\n        return correct_bracketing(brackets[1:])\n    if brackets[0] == ')':\n        if brackets[1:].find('(') == -1:\n            return False\n        else:\n            return correct_bracketing(brackets[1:])\n\n\ndef match_parens(str):\n    \"\"\"Returns True if str has balanced parentheses.\"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not str:\n        return True\n    if str[0] == '(':\n        return match_parens(str[1:])\n    if str[0] == ')':\n        if str[1:].find('(') == -1:\n            return False\n        else:\n            return match_parens(str[1:])\n\n\ndef match_parens(str):\n    \"\"\"Returns True if str has balanced parentheses.\"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not str:\n        return True\n    if str[0] == '(':\n        return match_parens(str[1:])\n    if str[0] == ')':\n        if str[1:].find('(') == -1:\n            return False\n        else:\n            return match_parens(str[1:])\n\n\ndef count_matching_parens(str):\n    \"\"\"Count the number of properly balanced parentheses in str.\n\n    >>> count_matching_parens('')\n    0\n    >>> count_matching_parens('()')\n    1\n    >>> count_matching_parens('foo')\n    0\n    >>> count_matching_parens('((()))')\n    4\n    >>> count_matching_parens('(()')\n    0\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if not str:\n        return 0\n    if str[0] == '(':\n        return count_matching_parens(str[1:]) + 1\n    if str[0] == ')':\n        if str["
    },
    {
      "rank": 57,
      "score": 1.0,
      "candidate": "count = 0\n    for c in brackets:\n        if c == '(':\n            count += 1\n        if c == ')':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of '(' and ')'.\n    return True if there is a valid way to bracket parens such that\n    the resulting string of '(' and ')' is in the form (...)(...)...\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"(\")\n    False\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"()()(())\")\n    True\n    >>> balanced_parens(\"(()())\")\n    True\n    >>> balanced_parens(\")(\")\n    False\n    >>> balanced_parens(\")(()\")\n    False\n    \"\"\"\n    assert len(parens) % 2 == 0\n    if len(parens) == 0:\n        return True\n    if parens[0] == ')':\n        return False\n    for i in range(1, len(parens)):\n        if parens[i] == ')':\n            if parens[i-1] == '(':\n                return balanced_parens(parens[1:i]) and balanced_parens(parens[i+1:])\n            else:\n                return False\n    return False\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways to correctly bracket the expression.\n\n    >>> count_correct_bracketing(\"\")\n    1\n    >>> count_correct_bracketing(\"(\")\n    0\n    >>> count_correct_bracketing(\"()\")\n    1\n    >>> count_correct_bracketing(\"()()(())\")\n    2\n    >>> count_correct_bracketing(\"(()())\")\n    2\n    >>> count_correct_bracketing(\")(\")\n    0\n    >>> count_correct_bracket"
    },
    {
      "rank": 58,
      "score": 1.0,
      "candidate": "open_brackets = 0\n    for c in brackets:\n        if c == '(':\n            open_brackets += 1\n        elif c == ')':\n            open_brackets -= 1\n            if open_brackets < 0:\n                return False\n    return open_brackets == 0\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket\n    and vice versa.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\")(()\")\n    False\n    >>> balanced_brackets(\"(()())\")\n    True\n    \"\"\"\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_brackets_with_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket\n    and vice versa.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\")(()\")\n    False\n    >>> balanced_brackets(\"(()())\")\n    True\n    \"\"\"\n    stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_brackets_with_list(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket\n    and vice versa.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\")(()\")\n    False\n    >>> balanced_brackets(\"(()())\")\n    True\n    \"\"\"\n    stack = []"
    },
    {
      "rank": 59,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append('(')\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef balanced_parens(paren_string):\n    \"\"\"\n    Returns True if paren_string is balanced.\n\n    >>> balanced_parens('')\n    True\n    >>> balanced_parens('()')\n    True\n    >>> balanced_parens(')(()')\n    False\n    >>> balanced_parens('(()())')\n    True\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    return correct_bracketing(paren_string)\n\n\ndef count_balanced_parens(s):\n    \"\"\"\n    Count the number of well-formed parentheses in s.\n\n    >>> count_balanced_parens(\"\")\n    0\n    >>> count_balanced_parens(\"()\")\n    1\n    >>> count_balanced_parens(\")(()\")\n    0\n    >>> count_balanced_parens(\"(()())\")\n    2\n    >>> count_balanced_parens(\"junk(junk())morejunk\")\n    1\n    >>> count_balanced_parens(\"junk(junk(() morejunk\")\n    0\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if s == \"\":\n        return 0\n    elif s[0] == \"(\":\n        return count_balanced_parens(s[1:])\n    elif s[0] == \")\":\n        return count_balanced_parens(s[1:]) + 1\n    else:\n        return count_balanced_parens(s[1:])\n\n\ndef remove_comment(line, marker):\n    \"\"\"\n    Returns a version of the Python code in line with the first instance\n    of the string marker removed.  For example,\n    remove_comment(\"if x: # not a comment\", \"#\") returns \"if x:  \".\n\n    >>> remove_comment(\"x = 1  # This is a"
    },
    {
      "rank": 60,
      "score": 1.0,
      "candidate": "# Your code here\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a list of (i, j) such that brackets[i] and brackets[j] are brackets that match each other,\n    where i < j\n\n    >>> matching_brackets(\"()\")\n    [(0, 1)]\n    >>> matching_brackets(\"(())\")\n    [(0, 3), (1, 2)]\n    >>> matching_brackets(\"(()())\")\n    [(0, 5), (1, 4), (3, 5)]\n    >>> matching_brackets(\")(()\")\n    []\n    \"\"\"\n    # Your code here\n\n\ndef matching_brackets_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a list of (i, j) such that brackets[i] and brackets[j] are brackets that match each other,\n    where i < j\n\n    >>> matching_brackets(\"()\")\n    [(0, 1)]\n    >>> matching_brackets(\"(())\")\n    [(0, 3), (1, 2)]\n    >>> matching_brackets(\"(()())\")\n    [(0, 5), (1, 4), (3, 5)]\n    >>> matching_brackets(\")(()\")\n    []\n    \"\"\"\n    # Your code here\n\n\ndef remove_outer_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a string with the outermost matching brackets removed.\n    if there are no matching brackets, return the string unchanged.\n\n    >>> remove_outer_matching_brackets(\"()abc()\")\n    'abc'\n    >>> remove_outer_matching_brackets(\"abc\")\n    'abc'\n    >>> remove_outer_matching_brackets(\")(abc()\")\n    ')abc()'\n    \"\"\"\n    # Your code here\n\n\ndef remove_inner_matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a string with the innermost matching brackets removed.\n    if there"
    },
    {
      "rank": 61,
      "score": 1.0,
      "candidate": "open_brackets = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            open_brackets += 1\n        elif bracket == \")\":\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n    return open_brackets == 0\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\"())\")\n    False\n    >>> balanced_brackets(\"(()())\")\n    True\n    >>> balanced_brackets(\")(()\")\n    False\n    \"\"\"\n    return correct_bracketing(brackets)\n\n\ndef balanced_parentheses(parentheses: str):\n    \"\"\" parentheses is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_parentheses(\"()\")\n    True\n    >>> balanced_parentheses(\"())\")\n    False\n    >>> balanced_parentheses(\"(()())\")\n    True\n    >>> balanced_parentheses(\")(()\")\n    False\n    \"\"\"\n    return balanced_brackets(parentheses)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 62,
      "score": 1.0,
      "candidate": "return brackets.count('(') == brackets.count(')')\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of balanced and unbalanced parentheses.\n    return True if every nonempty prefix of parens is balanced.\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"(()())\")\n    True\n    >>> balanced_parens(\")(()\")\n    False\n    \"\"\"\n    return parens == '' or (parens[0] == '(' and balanced_parens(parens[1:]))\n\n\ndef brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> brackets(\"[]\")\n    True\n    >>> brackets(\"[]()\")\n    True\n    >>> brackets(\"[\")\n    False\n    \"\"\"\n    return brackets == '' or (brackets[0] == '[' and brackets[1] == ']' and brackets[2:] == brackets[2:])\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of balanced and unbalanced brackets.\n    return True if every nonempty prefix of brackets is balanced.\n\n    >>> balanced_brackets(\"\")\n    True\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"[][]\")\n    True\n    >>> balanced_brackets(\"[][]()\")\n    True\n    >>> balanced_brackets(\"][\")\n    False\n    \"\"\"\n    return brackets == '' or (brackets[0] == '[' and brackets[-1] == ']' and balanced_brackets(brackets[1:-1]))\n\n\ndef brackets_recur(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> brackets_recur(\"[]\")\n    True\n    >>> brackets_recur(\"[]()\")\n    True\n    >>> brackets_recur(\"[\")\n    False"
    },
    {
      "rank": 63,
      "score": 1.0,
      "candidate": "open_brackets = 0\n    for bracket in brackets:\n        if bracket == '(':\n            open_brackets += 1\n        elif bracket == ')':\n            open_brackets -= 1\n            if open_brackets < 0:\n                return False\n    return open_brackets == 0\n\n\ndef balanced_parens(s: str):\n    \"\"\"Return True if s is a string of balanced parens.\n\n    >>> balanced_parens('')\n    True\n    >>> balanced_parens('()')\n    True\n    >>> balanced_parens(')(()')\n    False\n    \"\"\"\n    return correct_bracketing(s)\n\n\ndef count_balanced_parens(s: str):\n    \"\"\"Return the number of strings of balanced parens in s.\n\n    >>> count_balanced_parens('')\n    1\n    >>> count_balanced_parens('()')\n    1\n    >>> count_balanced_parens(')(()')\n    0\n    >>> count_balanced_parens('(())')\n    1\n    >>> count_balanced_parens('(()())')\n    2\n    \"\"\"\n    if s == '':\n        return 1\n    elif s == '(' or s == ')':\n        return 0\n    elif s[0] == '(':\n        return count_balanced_parens(s[1:])\n    elif s[0] == ')':\n        return count_balanced_parens(s[1:])\n    else:\n        return count_balanced_parens(s[1:]) + count_balanced_parens(s[1:])\n\n\ndef remove_outer_parens(s: str):\n    \"\"\"Return s with outer parens removed.\n\n    >>> remove_outer_parens('')\n    ''\n    >>> remove_outer_parens('abc')\n    'abc'\n    >>> remove_outer_parens('(abc)')\n    'abc'\n    \"\"\"\n    if s == '':\n        return ''\n    elif s[0] == '(' and s[-1] == ')':\n        return remove_outer"
    },
    {
      "rank": 64,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append('(')\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef correct_parenthesization(f: str) -> bool:\n    \"\"\" f is a string of variables, '(', ')', and ','.\n    return True if all the variables in f are paired with a closing bracket.\n\n    >>> correct_parenthesization('a,b,(c,d,e),(f,g,h),i')\n    True\n    >>> correct_parenthesization('(a,b,(c,d,e),(f,g,h),i')\n    False\n    >>> correct_parenthesization('a,b,(c,d,e),(f,g,h,)i')\n    False\n    >>> correct_parenthesization('a,b,(c,d,e),(f,g,h),)i')\n    False\n    >>> correct_parenthesization(')a,b,(c,d,e),(f,g,h),i')\n    False\n    \"\"\"\n    stack = []\n    for c in f:\n        if c == '(':\n            stack.append('(')\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef correct_parenthesization_and_bracketing(f: str) -> bool:\n    \"\"\" f is a string of variables, '(', ')', and ','.\n    return True if all the variables in f are paired with a closing bracket.\n\n    >>> correct_parenthesization_and_bracketing('a,b,(c,d,e),(f,g,h),i')\n    True\n    >>> correct_parenthesization_and_bracketing('(a,b,(c,d,e),(f,g,h),i')\n    False\n    >>> correct_parenthesization_and_bracketing('a,b,(c,d,e),(f,g,"
    },
    {
      "rank": 65,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0\n\n\ndef remove_outmost_brackets(s: str):\n    \"\"\"\n    >>> remove_outmost_brackets(\"abc\")\n    'abc'\n    >>> remove_outmost_brackets(\"(abc)\")\n    'abc'\n    >>> remove_outmost_brackets(\"((abc))\")\n    'abc'\n    >>> remove_outmost_brackets(\"(((abc))\")\n    '((abc))'\n    \"\"\"\n    if not s:\n        return s\n    if s[0] == '(':\n        i = 1\n        while i < len(s):\n            if s[i] == '(':\n                i += 1\n            elif s[i] == ')':\n                i += 1\n                break\n            else:\n                return remove_outmost_brackets(s[i:])\n        return remove_outmost_brackets(s[i:])\n    else:\n        i = len(s) - 1\n        while i > 0:\n            if s[i] == ')':\n                i -= 1\n            elif s[i] == '(':\n                i -= 1\n                break\n            else:\n                return remove_outmost_brackets(s[:i])\n        return remove_outmost_brackets(s[:i])\n\n\ndef remove_brackets(s: str):\n    \"\"\"\n    >>> remove_brackets(\"(abc)\")\n    'abc'\n    >>> remove_brackets(\"((abc))\")\n    'abc'\n    >>> remove_brackets(\"(((abc))\")\n    '((abc))'\n    \"\"\"\n    if not s:\n        return s\n    if s[0] == '(':\n        i = 1\n        while i < len(s):\n            if s[i] == '(':\n                i += 1\n            elif s[i] == ')':\n                i +="
    },
    {
      "rank": 66,
      "score": 1.0,
      "candidate": "# Your code here\n    return brackets.count('(') == brackets.count(')')\n\n\ndef nested_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket,\n    and also, if the brackets are nested correctly.\n\n    >>> nested_correct_bracketing(\"(\")\n    False\n    >>> nested_correct_bracketing(\"()\")\n    True\n    >>> nested_correct_bracketing(\"(()())\")\n    True\n    >>> nested_correct_bracketing(\")(()\")\n    False\n    >>> nested_correct_bracketing(\"()()()\")\n    True\n    >>> nested_correct_bracketing(\"(()()())\")\n    True\n    >>> nested_correct_bracketing(\"()(())\")\n    True\n    \"\"\"\n    # Your code here\n    return correct_bracketing(brackets) and len(brackets) % 2 == 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 67,
      "score": 1.0,
      "candidate": "depth = 0\n    for c in brackets:\n        if c == '(':\n            depth += 1\n        else:\n            depth -= 1\n            if depth < 0:\n                return False\n    return depth == 0\n\n\ndef is_valid_parenthesization(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if brackets is a valid way to parenthesize a math expression.\n\n    >>> is_valid_parenthesization(\"(())\")\n    True\n    >>> is_valid_parenthesization(\"())\")\n    False\n    >>> is_valid_parenthesization(\"())()()\")\n    True\n    >>> is_valid_parenthesization(\"(()())\")\n    True\n    \"\"\"\n    # replace each pair of \"(\" and \")\" with \"1\"\n    # validity of the parenthesization is equivalent to the validity of the number\n    # (it must be either 0 or 1)\n    return correct_bracketing(brackets.replace(\"()\", \"1\"))\n\n\ndef parenthesize(exp: str):\n    \"\"\" return a valid parenthesization of the given arithmetic expression\n    (an expression consisting of numbers and addition operators).\n\n    >>> parenthesize(\"1+2+3\")\n    '(1+2+3)'\n    >>> parenthesize(\"1+(2+3)\")\n    '1+(2+3)'\n    >>> parenthesize(\"1+2*(3+4)\")\n    '1+(2*((3+4)))'\n    \"\"\"\n    if '(' in exp:\n        return exp\n    if '+' not in exp:\n        return '(' + exp + ')'\n    i = exp.index('+')\n    return '(' + parenthesize(exp[:i]) + '+' + parenthesize(exp[i + 1:]) + ')'\n\n\ndef parenthesize_all(exp: str):\n    \"\"\" return a list of all valid parenthesizations of the given arithmetic expression.\n\n    >>> parenthesize_all(\"1+2+3\")\n    ['((1+2)+3)', '(1+(2+3))', '(1+2+(3))']\n    \"\"\"\n    if '(' in exp:\n        return ["
    },
    {
      "rank": 68,
      "score": 1.0,
      "candidate": "stack = []\n    for b in brackets:\n        if b == \"(\":\n            stack.append(b)\n        elif b == \")\":\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef balanced_parens(s: str):\n    \"\"\" return True if s is balanced.\n    that is, return True iff for every open paren in s,\n    a closed paren can be found later in the string.\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\")()(\")\n    False\n    \"\"\"\n    stack = []\n    for b in s:\n        if b == \"(\":\n            stack.append(b)\n        elif b == \")\":\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef paren_balance_recur(s: str):\n    \"\"\" return True if s is balanced.\n    that is, return True iff for every open paren in s,\n    a closed paren can be found later in the string.\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\")()(\")\n    False\n    \"\"\"\n    if s == \"\":\n        return True\n    if s[0] == \"(\":\n        return paren_balance_recur(s[1:])\n    if s[0] == \")\":\n        return False\n    return paren_balance_recur(s[1:])\n\n\ndef paren_balance_iter(s: str):\n    \"\"\" return True if s is balanced.\n    that is, return True iff for every open paren in s,\n    a closed paren can be found later in the string.\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\")()(\")\n    False\n    \"\"\"\n    stack = []\n    for b in"
    },
    {
      "rank": 69,
      "score": 1.0,
      "candidate": "# Your code here\n    count = 0\n    for i in brackets:\n        if i == '(':\n            count += 1\n        elif i == ')':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    stack = []\n    for i in brackets:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing_tail_recursive(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_tail_recursive(\"(\")\n    False\n    >>> correct_bracketing_tail_recursive(\"()\")\n    True\n    >>> correct_bracketing_tail_recursive(\"(()())\")\n    True\n    >>> correct_bracketing_tail_recursive(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    def helper(brackets, count, index):\n        if index == len(brackets):\n            return count == 0\n        if brackets[index] == '(':\n            return helper(brackets, count + 1, index + 1)\n        elif brackets[index] == ')':\n            return helper(brackets, count - 1, index + 1)\n    return helper(brackets, 0, 0)\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" brackets is a"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "# Your code here\n    stack = []\n    for c in brackets:\n        if c == \"(\":\n            stack.append(\"(\")\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_bracketing_optimized(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_optimized(\"(\")\n    False\n    >>> correct_bracketing_optimized(\"()\")\n    True\n    >>> correct_bracketing_optimized(\"(()())\")\n    True\n    >>> correct_bracketing_optimized(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    return brackets.count(\"(\") == brackets.count(\")\")\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways to choose a subset of the brackets to be removed\n    so that the remaining brackets are balanced.\n\n    >>> count_correct_bracketing(\"()\")\n    1\n    >>> count_correct_bracketing(\"(())\")\n    2\n    >>> count_correct_bracketing(\"((()))\")\n    6\n    >>> count_correct_bracketing(\"(()())\")\n    2\n    >>> count_correct_bracketing(\")(\")\n    0\n    \"\"\"\n    # Your code here\n    if not correct_bracketing(brackets):\n        return 0\n    if len(brackets) == 0:\n        return 1\n    if brackets[0] == \"(\":\n        return count_correct_bracketing(brackets[1:])\n    else:\n        return count_correct_bracketing(brackets[1:]) + count_correct_bracketing(brackets[2:])\n\n\ndef count_correct_bracketing_optimized(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways to choose a subset of the brackets to be removed"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "opening_brackets = brackets.count('(')\n    closing_brackets = brackets.count(')')\n    return opening_brackets == closing_brackets\n\n\ndef extract_parentheses(s: str):\n    \"\"\"Return a list of strings, one for each pair of parentheses in s,\n    in the order that they appear in s.\n    >>> extract_parentheses('a(b)c(d)')\n    ['(b)', '(d)']\n    >>> extract_parentheses('a((b))c(d)')\n    ['((b))', '(d)']\n    >>> extract_parentheses('(a(b)c)d')\n    ['(b)', '(a(b)c)']\n    \"\"\"\n    result = []\n    parentheses_level = 0\n    parentheses_start = 0\n    for i, c in enumerate(s):\n        if c == '(':\n            if parentheses_level == 0:\n                parentheses_start = i\n            parentheses_level += 1\n        elif c == ')':\n            parentheses_level -= 1\n            if parentheses_level == 0:\n                result.append(s[parentheses_start:i + 1])\n    return result\n\n\ndef find_parentheses(s: str):\n    \"\"\"Return a list of tuples, one for each pair of parentheses in s,\n    in the order that they appear in s.\n    The tuple contains the string contents of the two parentheses,\n    and the index of the first character of the string contents.\n\n    >>> find_parentheses('a(b)c(d)')\n    [('b', 2), ('d', 6)]\n    >>> find_parentheses('a((b))c(d)')\n    [('(b)', 3), ('d', 8)]\n    >>> find_parentheses('(a(b)c)d')\n    [('b', 4), ('a(b)c', 1)]\n    \"\"\"\n    result = []\n    parentheses_level = 0\n    parentheses_start = 0\n    for i, c in enumerate(s):\n        if c == '(':"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "assert set(brackets).issubset({\"(\", \")\"})\n    opening = brackets.count(\"(\")\n    closing = brackets.count(\")\")\n    return opening == closing\n\n\ndef parentheses_balanced(expression: str):\n    \"\"\"\n    Return True if the expression consists of pairs of parentheses, each\n    containing an expression consisting of parentheses in a properly balanced way.\n\n    >>> parentheses_balanced(\"\")\n    True\n    >>> parentheses_balanced(\"(())\")\n    True\n    >>> parentheses_balanced(\"(()\")\n    False\n    >>> parentheses_balanced(\"())\")\n    False\n    >>> parentheses_balanced(\")(())\")\n    False\n    \"\"\"\n\n    assert set(expression).issubset({\"(\", \")\"})\n    if len(expression) < 2:\n        return True\n    if expression[0] == \"(\":\n        return correct_bracketing(expression[1:]) and parentheses_balanced(expression[1:])\n    if expression[-1] == \")\":\n        return correct_bracketing(expression[:-1]) and parentheses_balanced(expression[:-1])\n    return False\n\n\ndef count_matching_pairs(expression: str):\n    \"\"\"\n    Return the number of matching pairs of parentheses in expression.\n\n    >>> count_matching_pairs(\"\")\n    0\n    >>> count_matching_pairs(\"(())\")\n    2\n    >>> count_matching_pairs(\"(()\")\n    1\n    >>> count_matching_pairs(\"())\")\n    1\n    >>> count_matching_pairs(\")(())\")\n    2\n    \"\"\"\n    assert set(expression).issubset({\"(\", \")\"})\n    if len(expression) < 2:\n        return 0\n    if expression[0] == \"(\":\n        return 1 + count_matching_pairs(expression[1:])\n    if expression[-1] == \")\":\n        return 1 + count_matching_pairs(expression[:-1])\n    return 0\n\n\ndef count_mismatched_pairs(expression: str):\n    \"\"\"\n    Return the number of mismatched pairs of parentheses in expression."
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "if len(brackets) == 0:\n        return True\n    if len(brackets) == 1:\n        return False\n    if brackets[0] == ')' or brackets[-1] == '(':\n        return False\n\n    if brackets[0] == '(':\n        return correct_bracketing(brackets[1:])\n    if brackets[-1] == ')':\n        return correct_bracketing(brackets[:-1])\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"(\")\n    False\n    >>> correct_bracketing2(\"()\")\n    True\n    >>> correct_bracketing2(\"(()())\")\n    True\n    >>> correct_bracketing2(\")(()\")\n    False\n    \"\"\"\n    if len(brackets) == 0:\n        return True\n    if len(brackets) == 1:\n        return False\n\n    if brackets[0] == '(':\n        return correct_bracketing2(brackets[1:])\n    if brackets[-1] == ')':\n        return correct_bracketing2(brackets[:-1])\n\n    return correct_bracketing2(brackets[1:]) and correct_bracketing2(brackets[:-1])\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"(\")\n    False\n    >>> correct_bracketing3(\"()\")\n    True\n    >>> correct_bracketing3(\"(()())\")\n    True\n    >>> correct_bracketing3(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        if b == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "# stack = []\n    # for bracket in brackets:\n    #     if bracket == \"(\":\n    #         stack.append(bracket)\n    #     else:\n    #         if not stack:\n    #             return False\n    #         else:\n    #             stack.pop()\n    # if not stack:\n    #     return True\n    # else:\n    #     return False\n\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            else:\n                stack.pop()\n    return not stack\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v2(\"(\")\n    False\n    >>> correct_bracketing_v2(\"()\")\n    True\n    >>> correct_bracketing_v2(\"(()())\")\n    True\n    >>> correct_bracketing_v2(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if stack.pop() != \"(\":\n                return False\n    return not stack\n\n\ndef correct_bracketing_v3(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_v3(\"(\")\n    False\n    >>> correct_bracketing_v3(\"()\")\n    True\n    >>> correct_bracketing_v3(\"(()())\")\n    True\n    >>> correct_bracketing_v3(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            else:\n                stack.pop()\n    return not stack"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "return _correct_bracketing(list(brackets))\n\n\ndef _correct_bracketing(brackets: list):\n    if not brackets:\n        return True\n    if brackets[0] == \"(\":\n        return _correct_bracketing(brackets[1:]) and brackets[-1] == \")\"\n    return _correct_bracketing(brackets[1:]) and brackets[0] == \")\"\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if brackets is of even length and every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\"(()())\")\n    True\n    >>> balanced_brackets(\")(()\")\n    False\n    >>> balanced_brackets(\"(())\")\n    True\n    \"\"\"\n    return _balanced_brackets(list(brackets))\n\n\ndef _balanced_brackets(brackets: list):\n    if not brackets:\n        return True\n    if brackets[0] == \"(\":\n        return _balanced_brackets(brackets[1:]) and brackets[-1] == \")\"\n    return _balanced_brackets(brackets[1:]) and brackets[0] == \")\"\n\n\ndef correct_and_balanced_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if brackets is of even length, every opening bracket has a corresponding closing bracket, and the brackets are correctly bracketed.\n\n    >>> correct_and_balanced_bracketing(\"(()())\")\n    True\n    >>> correct_and_balanced_bracketing(\")(\")\n    False\n    >>> correct_and_balanced_bracketing(\"())\")\n    False\n    >>> correct_and_balanced_bracketing(\"())(\")\n    False\n    >>> correct_and_balanced_bracketing(\"((())\")\n    False\n    \"\"\"\n    return _correct_and_balanced_bracketing(list(brackets))\n\n\ndef _correct_and_balanced_bra"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "# base cases\n    if len(brackets) == 0:\n        return True\n    if len(brackets) == 1:\n        return False\n    # recurrence cases\n    if brackets[0] == '(':\n        return correct_bracketing(brackets[1:])\n    if brackets[0] == ')':\n        return False\n    else:\n        return correct_bracketing(brackets[1:])\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    # base cases\n    if len(brackets) == 0:\n        return True\n    if len(brackets) == 1:\n        return False\n    # recurrence cases\n    if brackets[0] == '(':\n        return correct_bracketing_stack(brackets[1:])\n    if brackets[0] == ')':\n        return correct_bracketing_stack(brackets[1:])\n    else:\n        return correct_bracketing_stack(brackets[1:])\n\n\ndef count_correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways to bracket the expression.\n\n    >>> count_correct_bracketing_stack(\"()\")\n    1\n    >>> count_correct_bracketing_stack(\"(()())\")\n    1\n    >>> count_correct_bracketing_stack(\"(()()())\")\n    2\n    >>> count_correct_bracketing_stack(\"(()()())()\")\n    3\n    \"\"\"\n    if len(brackets) == 0:\n        return 1\n    if len(brackets) == 1:\n        return 0\n    if brackets[0] == '(':\n        return count"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "level = 0\n    for c in brackets:\n        if c == '(':\n            level += 1\n        elif c == ')':\n            if level == 0:\n                return False\n            level -= 1\n    return level == 0\n\n\ndef match_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket\n    and vice versa.\n\n    >>> match_brackets(\"(\")\n    False\n    >>> match_brackets(\"()\")\n    True\n    >>> match_brackets(\"(()())\")\n    True\n    >>> match_brackets(\")(()\")\n    False\n    \"\"\"\n    level = 0\n    for c in brackets:\n        if c == '(':\n            level += 1\n        elif c == ')':\n            if level == 0:\n                return False\n            level -= 1\n    return level == 0\n\n\ndef balanced_brackets(s: str):\n    \"\"\" Return True if all brackets in s are balanced, and False otherwise.\n    Assume that s contains only parentheses, square brackets, and curly brackets.\n\n    >>> balanced_brackets('(())')\n    True\n    >>> balanced_brackets('(()')\n    False\n    >>> balanced_brackets('[()]{}')\n    True\n    >>> balanced_brackets('[(])')\n    False\n    \"\"\"\n    return correct_bracketing(s) and match_brackets(s)\n\n\ndef remove_outer_parentheses(s: str) -> str:\n    \"\"\"\n    >>> remove_outer_parentheses('hello')\n    'hello'\n    >>> remove_outer_parentheses('(hello)')\n    'hello'\n    >>> remove_outer_parentheses('(hello (world))')\n    'hello (world)'\n    >>> remove_outer_parentheses('(((hello))))')\n    'hello'\n    >>> remove_outer_parentheses('((hello (world)))')\n    'hello (world)'\n    \"\"\"\n    if len(s) < 2:\n        return s\n    if s[0] =="
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "opening_brackets = 0\n    for c in brackets:\n        if c == '(':\n            opening_brackets += 1\n        elif c == ')':\n            if opening_brackets <= 0:\n                return False\n            opening_brackets -= 1\n    return opening_brackets == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    opening_brackets = []\n    for c in brackets:\n        if c == '(':\n            opening_brackets.append(c)\n        elif c == ')':\n            if len(opening_brackets) == 0:\n                return False\n            opening_brackets.pop()\n    return len(opening_brackets) == 0\n\n\ndef nesting(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of nesting of brackets.\n\n    >>> nesting(\"()\")\n    1\n    >>> nesting(\"(()())\")\n    2\n    >>> nesting(\"())\")\n    1\n    >>> nesting(\"((((((()))))))\")\n    6\n    \"\"\"\n    opening_brackets = 0\n    for c in brackets:\n        if c == '(':\n            opening_brackets += 1\n        elif c == ')':\n            if opening_brackets <= 0:\n                return 0\n            opening_brackets -= 1\n    return opening_brackets\n\n\ndef nesting_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of nesting of brackets.\n\n    >>> nesting_stack(\"()\")\n    1\n    >>> nesting_stack(\"(()())\")\n    2\n    >>> nesting_stack(\"())\")"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "\"*** YOUR CODE HERE ***\"\n    if brackets == '':\n        return True\n    elif brackets == '(':\n        return False\n    else:\n        return correct_bracketing(brackets[1:]) if brackets[0] == '(' else False or correct_bracketing(brackets[1:])\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways bracketing the string using the first and last character.\n\n    >>> count_correct_bracketing(\"()\")\n    1\n    >>> count_correct_bracketing(\"(()())\")\n    2\n    >>> count_correct_bracketing(\"()()()\")\n    3\n    >>> count_correct_bracketing(\")(()\")\n    0\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if brackets == '':\n        return 1\n    elif brackets == '(':\n        return 0\n    elif correct_bracketing(brackets):\n        return count_correct_bracketing(brackets[1:]) + count_correct_bracketing(brackets[1:])\n    else:\n        return 0\n\n\ndef correct_bracketing_v2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return all ways bracketing the string using the first and last character.\n\n    >>> correct_bracketing_v2(\"()\")\n    ['()']\n    >>> correct_bracketing_v2(\"(()())\")\n    ['()(())', '(()())']\n    >>> correct_bracketing_v2(\"()()()\")\n    ['()()()']\n    >>> correct_bracketing_v2(\")(()\")\n    []\n    \"\"\"\n    \"*** YOUR CODE HERE ***\"\n    if brackets == '':\n        return [brackets]\n    elif brackets == '(':\n        return []\n    elif correct_bracketing(brackets):\n        return correct_bracketing_v2(brackets[1:]) + [brackets[0] + x for x in correct_bracketing_v"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "openers = brackets.count(\"(\")\n    closers = brackets.count(\")\")\n    return openers == closers\n\n\ndef balanced_parens(paren_string: str):\n    \"\"\" paren_string is a string consisting only of '(' and ')'.\n    return True if every opening bracket has a corresponding closing bracket.\n    return False otherwise.\n\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\"())\")\n    False\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"\")\n    True\n    \"\"\"\n    if len(paren_string) % 2 != 0:\n        return False\n    else:\n        return correct_bracketing(paren_string)\n\n\ndef count_balanced(s: str):\n    \"\"\"\n    return the number of non-overlapping substrings of s that are balanced.\n    return -1 if the number of balanced substrings is greater than 1000.\n\n    >>> count_balanced(\"((((((f)))))\")\n    1\n    >>> count_balanced(\"(((((((((((()))))))))))))\")\n    -1\n    >>> count_balanced(\"\")\n    1\n    \"\"\"\n    if not balanced_parens(s):\n        return 0\n    else:\n        if len(s) % 2 == 0:\n            return 1\n        else:\n            left = count_balanced(s[:len(s)//2])\n            right = count_balanced(s[len(s)//2:])\n            if left == -1 or right == -1:\n                return -1\n            else:\n                return left * right\n\n\ndef balanced_parens_helper(paren_string, openers, closers):\n    \"\"\" paren_string is a string consisting only of '(' and ')'.\n    return the number of non-overlapping substrings of s that are balanced.\n\n    >>> balanced_parens_helper(\"(()\", 0, 0)\n    1\n    >>> balanced_parens_helper(\"(()\", 1, 0)\n    0"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "if brackets == \"\":\n        return True\n\n    open_brackets = 0\n\n    for i in brackets:\n        if i == \"(\":\n            open_brackets += 1\n        elif i == \")\":\n            if open_brackets > 0:\n                open_brackets -= 1\n            else:\n                return False\n\n    return open_brackets == 0\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of parentheses.\n    return True if the parentheses in parens are balanced.\n\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\")()\")\n    False\n    \"\"\"\n    if parens == \"\":\n        return True\n\n    open_brackets = 0\n\n    for i in parens:\n        if i == \"(\":\n            open_brackets += 1\n        elif i == \")\":\n            if open_brackets == 0:\n                return False\n            else:\n                open_brackets -= 1\n\n    return open_brackets == 0\n\n\ndef matching_delimiters(delimiters: str):\n    \"\"\" delimiters is a string of delimiter characters,\n    possibly nested by pairs of parentheses, brackets, and braces.\n    return True if every opening delimiter has a corresponding closing delimiter.\n\n    >>> matching_delimiters(\"\")\n    True\n    >>> matching_delimiters(\"(())\")\n    True\n    >>> matching_delimiters(\"(())[]\")\n    True\n    >>> matching_delimiters(\"(())[]}\")\n    True\n    >>> matching_delimiters(\"[(])\")\n    False\n    >>> matching_delimiters(\"[(])}{\")\n    False\n    \"\"\"\n    if delimiters == \"\":\n        return True\n\n    open_delimiters = {\n        \"(\": 0,\n        \"[\": 0,\n        \"{\": 0,\n    }\n\n    for i in delimiters:\n        if i == \"(\":\n            open_delimit"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "# Use a stack to keep track of the opening brackets\n    stack = []\n\n    # Loop through each bracket\n    for bracket in brackets:\n\n        # If the bracket is an opening bracket, push it onto the stack\n        if bracket == \"(\":\n            stack.append(bracket)\n\n        # If the bracket is a closing bracket\n        else:\n            # If the stack is empty, the bracket is unmatched\n            if len(stack) == 0:\n                return False\n\n            # If the top element of the stack is an opening bracket, pop it off\n            elif stack[-1] == \"(\":\n                stack.pop()\n\n            # Otherwise, the bracket is unmatched\n            else:\n                return False\n\n    # If the stack is not empty, then there are still opening brackets that don't have a matching closing bracket\n    if len(stack) != 0:\n        return False\n\n    # Otherwise, all brackets have matching counterparts\n    return True\n\n\n# # Tests\n#\n# >>> correct_bracketing(\"(()())\")\n# True\n# >>> correct_bracketing(\"()()()\")\n# True\n# >>> correct_bracketing(\"()()(()\")\n# False\n# >>> correct_bracketing(\"\")\n# True\n# >>> correct_bracketing(\"(()\")\n# False\n# >>> correct_bracketing(\"())\")\n# False\n# >>> correct_bracketing(\"((())\")\n# False"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef balanced_parens(s: str):\n    \"\"\" s is a string of characters.\n    return True if s is a balanced string of parentheses\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"((()))\")\n    True\n    >>> balanced_parens(\"(())\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\"())\")\n    False\n    >>> balanced_parens(\"((())))\")\n    True\n    >>> balanced_parens(\"((())))(\")\n    False\n    \"\"\"\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n\n\ndef count_correct_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of correctly bracketed substrings\n\n    >>> count_correct_brackets(\"\")\n    1\n    >>> count_correct_brackets(\"(\")\n    0\n    >>> count_correct_brackets(\"()\")\n    1\n    >>> count_correct_brackets(\")(\")\n    0\n    >>> count_correct_brackets(\"(()())\")\n    3\n    >>> count_correct_brackets(\"()((((()))())(()))(\")\n    5\n    \"\"\"\n    if not brackets:\n        return 1\n    if brackets[0] == ')':\n        return 0\n    if brackets[0] == '(':\n        return count_correct_brackets(brackets[1:])\n    return count_correct_brackets(brackets[1:]) + count_correct_brackets(brackets[1:])\n\n\ndef count_correct_brackets_v2(brackets:"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "# Your code here\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) != 0:\n        return False\n    return True\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"(\")\n    False\n    >>> correct_bracketing2(\"()\")\n    True\n    >>> correct_bracketing2(\"(()())\")\n    True\n    >>> correct_bracketing2(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) != 0:\n        return False\n    return True\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"(\")\n    False\n    >>> correct_bracketing3(\"()\")\n    True\n    >>> correct_bracketing3(\"(()())\")\n    True\n    >>> correct_bracketing3(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n    stack = []\n    for b in brackets:\n        if b == '(':\n            stack.append(b)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) != 0:\n        return False\n    return True\n\n\ndef correct_bracketing4(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket."
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "# Your code here\n    # TODO: Count the number of opening brackets\n    # TODO: Count the number of closing brackets\n    # TODO: If both counts are the same, return True\n    # TODO: Otherwise, return False\n\n    return None\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket\n    and if the number of opening brackets and closing brackets is the same.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\")(()\")\n    False\n    >>> balanced_brackets(\"(()())\")\n    True\n    >>> balanced_brackets(\"())\")\n    False\n    >>> balanced_brackets(\"(()\n    ... )\")\n    False\n    \"\"\"\n    # Your code here\n    # TODO: Count the number of opening brackets\n    # TODO: Count the number of closing brackets\n    # TODO: If both counts are the same, return True\n    # TODO: Otherwise, return False\n\n    return None\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "# Your code here\n\n\ndef balanced_parens(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if parens contains a balanced number of ()\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"(\")\n    False\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"(()())\")\n    True\n    >>> balanced_parens(\")(()\")\n    False\n    \"\"\"\n    # Your code here\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"[\" and \"]\".\n    return True if brackets contains a balanced number of []\n\n    >>> balanced_brackets(\"\")\n    True\n    >>> balanced_brackets(\"[\")\n    False\n    >>> balanced_brackets(\"]\")\n    False\n    >>> balanced_brackets(\"[]\")\n    True\n    >>> balanced_brackets(\"[()]\")\n    True\n    >>> balanced_brackets(\"[(])\")\n    False\n    \"\"\"\n    # Your code here\n\n\ndef balanced_braces(braces: str):\n    \"\"\" braces is a string of \"{\" and \"}\".\n    return True if braces contains a balanced number of {}\n\n    >>> balanced_braces(\"\")\n    True\n    >>> balanced_braces(\"{\")\n    False\n    >>> balanced_braces(\"}\")\n    False\n    >>> balanced_braces(\"{}\")\n    True\n    >>> balanced_braces(\"{[()]}\")\n    True\n    >>> balanced_braces(\"{[(])}\")\n    False\n    \"\"\"\n    # Your code here\n\n\ndef balanced_parentheses(parens: str):\n    \"\"\" parens is a string of \"(\" and \")\".\n    return True if parens contains a balanced number of ()\n\n    >>> balanced_parentheses(\"\")\n    True\n    >>> balanced_parentheses(\"(\")\n    False\n    >>> balanced_parentheses(\"()\")\n    True\n    >>> balanced_parentheses(\"(()())\")\n    True"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "# Your code here\n    pass\n\n\ndef count_correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return the number of ways to choose the correct bracketing for the string.\n\n    >>> count_correct_bracketing(\"(\")\n    0\n    >>> count_correct_bracketing(\"()\")\n    1\n    >>> count_correct_bracketing(\"(()())\")\n    2\n    >>> count_correct_bracketing(\"()()()\")\n    3\n    >>> count_correct_bracketing(\")(()\")\n    0\n    \"\"\"\n    # Your code here\n    pass"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "open_count = 0\n    for c in brackets:\n        if c == '(':\n            open_count += 1\n        elif c == ')':\n            if open_count == 0:\n                return False\n            open_count -= 1\n    return open_count == 0\n\n\ndef matching_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> matching_brackets(\"()\")\n    True\n    >>> matching_brackets(\")(()\")\n    False\n    >>> matching_brackets(\"(()())\")\n    True\n    >>> matching_brackets(\"((((())\")\n    False\n    \"\"\"\n    open_count = 0\n    for c in brackets:\n        if c == '(':\n            open_count += 1\n        elif c == ')':\n            if open_count == 0:\n                return False\n            open_count -= 1\n    return open_count == 0\n\n\ndef correct_bracketing_iter(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_iter(\"()\")\n    True\n    >>> correct_bracketing_iter(\")(()\")\n    False\n    >>> correct_bracketing_iter(\"(()())\")\n    True\n    >>> correct_bracketing_iter(\"((((())\")\n    False\n    \"\"\"\n    open_stack = []\n    for c in brackets:\n        if c == '(':\n            open_stack.append(c)\n        elif c == ')':\n            if not open_stack:\n                return False\n            open_stack.pop()\n    return len(open_stack) == 0\n\n\ndef matching_brackets_iter(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> matching_brackets_iter(\"()\")\n    True\n    >>> matching_brackets_iter(\")(()\")\n    False\n    >>> matching_bra"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "# TODO: implement this function.\n    #raise NotImplementedError\n\n    open_brackets = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            open_brackets += 1\n        elif bracket == \")\":\n            open_brackets -= 1\n        if open_brackets < 0:\n            return False\n\n    return open_brackets == 0\n\n\n\ndef parentheses(string: str):\n    \"\"\" Return True if the given string is a valid parenthesis expression.\n\n    >>> parentheses('( ( (  ) ) )')\n    True\n    >>> parentheses('( ( ( ( ) ) ) )')\n    False\n    >>> parentheses(') ( ( ( ) ) )')\n    False\n    >>> parentheses(') ( ( ( ) ) )')\n    False\n    \"\"\"\n    # TODO: implement this function.\n    #raise NotImplementedError\n\n    if not string or len(string) == 0:\n        return False\n\n    open_brackets = 0\n    for bracket in string:\n        if bracket == \"(\":\n            open_brackets += 1\n        elif bracket == \")\":\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1\n\n    return open_brackets == 0\n\n\ndef parentheses_stack(string: str):\n    \"\"\" Return True if the given string is a valid parenthesis expression.\n\n    >>> parentheses_stack('( ( (  ) ) )')\n    True\n    >>> parentheses_stack('( ( ( ( ) ) ) )')\n    False\n    >>> parentheses_stack(') ( ( ( ) ) )')\n    False\n    >>> parentheses_stack(') ( ( ( ) ) )')\n    False\n    \"\"\"\n    # TODO: implement this function.\n    #raise NotImplementedError\n\n    if not string or len(string) == 0:\n        return False\n\n    stack = []\n    for bracket in string:\n        if bracket == \"(\":\n            stack.append(\"(\")\n        elif bracket == \")\":\n            if not stack:\n                return False\n            stack.pop()\n\n    return len"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "# return the number of opening brackets minus the number of closing brackets\n    # if the result is positive, there are more opening brackets, therefore\n    # the string is not correctly bracketed.\n    # if the result is negative, there are more closing brackets, therefore\n    # the string is not correctly bracketed.\n    return brackets.count(\"(\") - brackets.count(\")\")\n\n\ndef remove_outer_parentheses(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a string with the outermost parentheses removed.\n\n    >>> remove_outer_parentheses(\"(()())\")\n    '()()'\n    >>> remove_outer_parentheses(\"())\")\n    ')()'\n    >>> remove_outer_parentheses(\"((asdf))\")\n    '(asdf)'\n    >>> remove_outer_parentheses(\"((asdf))())\")\n    '(asdf))())'\n    \"\"\"\n\n    # if there are no opening brackets, return an empty string.\n    if brackets.find(\"(\") == -1:\n        return \"\"\n\n    # find the index of the first opening bracket, and the last closing bracket.\n    open_index = brackets.find(\"(\")\n    close_index = brackets.rfind(\")\")\n\n    # return the substring between the first opening bracket and the last closing bracket.\n    return brackets[open_index + 1:close_index]\n\n\ndef remove_middle_parentheses(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return a string with all the middle parentheses and their contents removed.\n\n    >>> remove_middle_parentheses(\"(()())\")\n    '()()'\n    >>> remove_middle_parentheses(\"((asdf))\")\n    '()'\n    >>> remove_middle_parentheses(\"((asdf))())\")\n    '()())'\n    \"\"\"\n\n    # if there are no opening brackets, return an empty string.\n    if brackets.find(\"(\") == -1:\n        return \"\"\n\n    # find all the opening brackets\n    open_indices = [i for i, char in enumerate(brackets) if char == \"(\""
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_parenthesization(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every subsequence of length 2*k+1 of brackets has a matching\n    pair of parentheses.\n\n    >>> correct_parenthesization(\"()\")\n    True\n    >>> correct_parenthesization(\"(())\")\n    True\n    >>> correct_parenthesization(\"(()())\")\n    True\n    >>> correct_parenthesization(\"(()\")\n    False\n    >>> correct_parenthesization(\"())\")\n    False\n    >>> correct_parenthesization(\")(\")\n    False\n    >>> correct_parenthesization(\")(\")\n    False\n    \"\"\"\n    stack = []\n    for c in brackets:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n\n\ndef correct_parenthesization_harder(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every subsequence of length 2*k+1 of brackets has a matching\n    pair of parentheses.\n\n    >>> correct_parenthesization_harder(\"()\")\n    True\n    >>> correct_parenthesization_harder(\"(())\")\n    True\n    >>> correct_parenthesization_harder(\"(()())\")\n    True\n    >>> correct_parenthesization_harder(\"(()\")\n    False\n    >>> correct_parenthesization_harder(\"())\")\n    False\n    >>> correct_parenthesization_harder(\")(\")\n    False\n    >>> correct_parenthesization_harder(\")(\")\n    False\n    \"\"\"\n    stack = []\n    for c in brackets:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "# TODO: implement correct_bracketing function\n    return False\n\n\ndef remove_outlier(L: list):\n    \"\"\"Assume that L is a list of integers sorted in increasing order.\n       Return the value of the median of this list, which is the \"middle\" value.\n\n       If the number of elements in L is even, you can return any of the two \"middle\" values.\n\n    >>> remove_outlier([1, 2, 3, 4, 5])\n    3\n    >>> remove_outlier([2, 4, 5, 8, 10, 12, 15])\n    8\n    \"\"\"\n    # TODO: implement remove_outlier function\n    return 0\n\n\ndef sum_of_two_digits(x: int, y: int) -> int:\n    \"\"\"\n    Return the sum of x and y.\n    >>> sum_of_two_digits(2, 3) # 2 + 3\n    5\n    >>> sum_of_two_digits(5, 5) # 5 + 5\n    10\n    >>> sum_of_two_digits(123, 456) # 123 + 456\n    579\n    \"\"\"\n    # TODO: implement sum_of_two_digits function\n    return 0\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    Return whether n is a prime number.\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    >>> is_prime(521)\n    True\n    \"\"\"\n    # TODO: implement is_prime function\n    return True\n\n\ndef is_perfect(n: int) -> bool:\n    \"\"\"\n    Return whether n is a perfect number.\n    A perfect number is a number with the sum of its proper divisors equal to itself.\n    The first perfect number is 6, because 1 + 2 + 3 + 4 + 6 = 6.\n\n    >>> is_perfect(6)\n    True\n    >>> is_perfect(15)\n    False\n    >>> is"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "# Your code here\n    bracket_stack = []\n    for b in brackets:\n        if b == '(':\n            bracket_stack.append(b)\n        elif b == ')':\n            if len(bracket_stack) > 0:\n                bracket_stack.pop()\n            else:\n                return False\n    return len(bracket_stack) == 0\n\n\ndef balanced_parens(s: str):\n    \"\"\" s is a string consisting only of the characters '(', ')', and '*'.\n    return True if it is balanced.\n\n    >>> balanced_parens(\"(((((*(()(((*(())\")\n    True\n    >>> balanced_parens(\"(((((*(*(()(((*(())\")\n    False\n    >>> balanced_parens(\"(((((*(*(((((()\")\n    False\n    \"\"\"\n    # Your code here\n    if len(s) == 0:\n        return True\n    if s[0] == '*':\n        return balanced_parens(s[1:])\n    elif s[0] == ')':\n        return False\n    else:\n        return balanced_parens(s[1:]) and balanced_parens(s[1:])\n\n\ndef balanced_parens_v2(s: str):\n    \"\"\" s is a string consisting only of the characters '(', ')', and '*'.\n    return True if it is balanced.\n\n    >>> balanced_parens_v2(\"(((((*(()(((*(())\")\n    True\n    >>> balanced_parens_v2(\"(((((*(*(()(((*(())\")\n    False\n    >>> balanced_parens_v2(\"(((((*(*(((((()\")\n    False\n    \"\"\"\n    # Your code here\n    if len(s) == 0:\n        return True\n    if s[0] == '*':\n        return balanced_parens_v2(s[1:])\n    elif s[0] == ')':\n        return False\n    else:\n        if len(s) < 2:\n            return False\n        if s[1] == ')' and s[0] =="
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "count = 0\n    for b in brackets:\n        if b == \"(\":\n            count += 1\n        elif b == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    stack = []\n    for b in brackets:\n        if b == \"(\":\n            stack.append(b)\n        elif b == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "open_brackets = []\n    for b in brackets:\n        if b == '(':\n            open_brackets.append('(')\n        elif b == ')':\n            if len(open_brackets) == 0:\n                return False\n            else:\n                open_brackets.pop()\n    return len(open_brackets) == 0\n\n\ndef correct_bracketing_stack(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_stack(\"(\")\n    False\n    >>> correct_bracketing_stack(\"()\")\n    True\n    >>> correct_bracketing_stack(\"(()())\")\n    True\n    >>> correct_bracketing_stack(\")(()\")\n    False\n    \"\"\"\n    open_brackets = []\n    for b in brackets:\n        if b == '(':\n            open_brackets.append('(')\n        elif b == ')':\n            if len(open_brackets) == 0:\n                return False\n            else:\n                open_brackets.pop()\n    return len(open_brackets) == 0\n\n\ndef correct_bracketing_recursive(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_recursive(\"(\")\n    False\n    >>> correct_bracketing_recursive(\"()\")\n    True\n    >>> correct_bracketing_recursive(\"(()())\")\n    True\n    >>> correct_bracketing_recursive(\")(()\")\n    False\n    \"\"\"\n    if len(brackets) == 0:\n        return True\n    elif brackets[0] == '(':\n        return correct_bracketing_recursive(brackets[1:])\n    elif brackets[0] == ')':\n        return False\n\n\ndef remove_outermost_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    assume brackets is a valid expression with balanced bracketing."
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "# your code here\n\n\ndef balanced_parens(s: str):\n    \"\"\"\n    s is a string, containing only '(' and ')'.\n    return True if s is balanced.\n\n    >>> balanced_parens(\"\")\n    True\n    >>> balanced_parens(\"()\")\n    True\n    >>> balanced_parens(\"(()\")\n    False\n    >>> balanced_parens(\")test\")\n    False\n    >>> balanced_parens(\")()()\")\n    True\n    >>> balanced_parens(\"(()(()))\")\n    True\n    >>> balanced_parens(\"(()(()\")\n    False\n    \"\"\"\n    # your code here"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "opening_brackets = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            opening_brackets += 1\n        elif bracket == \")\":\n            opening_brackets -= 1\n        else:\n            raise ValueError(\"bracket must be '(' or ')', not {}\".format(bracket))\n    return opening_brackets == 0\n\n\ndef balanced_brackets(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> balanced_brackets(\"()\")\n    True\n    >>> balanced_brackets(\"()[]{}\")\n    True\n    >>> balanced_brackets(\"([{}])\")\n    True\n    >>> balanced_brackets(\"([{})\")\n    False\n    \"\"\"\n    opening_brackets = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            opening_brackets += 1\n        elif bracket == \")\":\n            opening_brackets -= 1\n        else:\n            raise ValueError(\"bracket must be '(' or ')', not {}\".format(bracket))\n    return opening_brackets == 0\n\n\ndef balanced_parentheses(parentheses: str):\n    \"\"\" parentheses is a string of \"(\" and \")\".\n    return True if every opening parenthesis has a corresponding closing parenthesis.\n\n    >>> balanced_parentheses(\"()\")\n    True\n    >>> balanced_parentheses(\"()[]{}\")\n    True\n    >>> balanced_parentheses(\"([{}])\")\n    True\n    >>> balanced_parentheses(\"([{})\")\n    False\n    \"\"\"\n    opening_parentheses = 0\n    for bracket in parentheses:\n        if bracket == \"(\":\n            opening_parentheses += 1\n        elif bracket == \")\":\n            opening_parentheses -= 1\n        else:\n            raise ValueError(\"bracket must be '(' or ')', not {}\".format(bracket))\n    return opening_parentheses == 0\n\n\ndef balanced_square_brackets(brackets"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "# return True if every opening bracket has a corresponding closing bracket.\n    # return False if not.\n\n    # 1. get the count of opening and closing brackets\n    # 2. return True if they are equal\n    # 3. return False if they are not equal\n\n    opening_count = brackets.count(\"(\")\n    closing_count = brackets.count(\")\")\n    return opening_count == closing_count\n\n\ndef is_matched_up_to(brackets: str):\n    \"\"\"\n    return True if brackets is a matched string of \"(\" and \")\",\n    return False if it is not.\n\n    >>> is_matched_up_to(\"\")\n    True\n    >>> is_matched_up_to(\"(\")\n    False\n    >>> is_matched_up_to(\"()\")\n    True\n    >>> is_matched_up_to(\"()(\")\n    False\n    >>> is_matched_up_to(\"(()())\")\n    True\n    >>> is_matched_up_to(\"()(()())\")\n    True\n    >>> is_matched_up_to(\")(()\")\n    False\n    \"\"\"\n    # 1. check if brackets is a string of \"(\" and \")\"\n    # 2. return True if every opening bracket has a corresponding closing bracket\n    # 3. return False if not\n\n    # 1. check if brackets is a string of \"(\" and \")\"\n    # 2. return True if every opening bracket has a corresponding closing bracket\n    # 3. return False if not\n\n    # 1. get the count of opening and closing brackets\n    # 2. return True if they are equal\n    # 3. return False if they are not equal\n\n    opening_count = brackets.count(\"(\")\n    closing_count = brackets.count(\")\")\n    return opening_count == closing_count\n\n\ndef is_matched_up_to_by_stack(brackets: str):\n    \"\"\"\n    return True if brackets is a matched string of \"(\" and \")\",\n    return False if it is not.\n\n    >>> is_matched_up_to_by_stack(\"\")\n    True"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "stack = []\n    for c in brackets:\n        if c == '(':\n            stack.append('(')\n        elif c == ')':\n            if stack == []:\n                return False\n            stack.pop()\n    return stack == []\n\n\ndef matching_pairs(string: str):\n    \"\"\" string is a string of parentheses, brackets, and braces.\n    return a list of triples (i, j, kind) such that\n        string[i:j] is a matching pair of the indicated kind of bracket.\n\n    >>> matching_pairs('(foo)bar[baz]{quux}')\n    [(0, 4, '('), (5, 9, ')'), (9, 13, '['), (13, 17, ']'), (17, 21, '{'), (21, 25, '}')]\n    \"\"\"\n    stack = []\n    for i, c in enumerate(string):\n        if c in '([{':\n            stack.append((c, i))\n        elif c in ')]}':\n            if stack == []:\n                return None\n            prev_open, j = stack.pop()\n            if prev_open + c not in '()[]{}':\n                return None\n            yield (j, i, prev_open + c)\n    if stack != []:\n        return None\n\n\ndef matching_pairs2(string: str):\n    \"\"\" string is a string of parentheses, brackets, and braces.\n    return a list of pairs (i, j) such that\n        string[i:j] is a matching pair of parentheses, brackets, or braces.\n\n    >>> matching_pairs2('(foo)bar[baz]{quux}')\n    [(0, 4), (5, 9), (9, 13), (13, 17), (17, 21)]\n    \"\"\"\n    stack = []\n    for i, c in enumerate(string):\n        if c in '([{':\n            stack.append(i)\n        elif c in ')]}':\n            if stack == []:\n                return None\n            j = stack.pop()\n            yield (j,"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "level = 0\n    for i, c in enumerate(brackets):\n        if c == \"(\":\n            level += 1\n        elif c == \")\":\n            level -= 1\n        if level < 0:\n            return False\n    return level == 0\n\n\ndef correct_bracketing2(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing2(\"(\")\n    False\n    >>> correct_bracketing2(\"()\")\n    True\n    >>> correct_bracketing2(\"(()())\")\n    True\n    >>> correct_bracketing2(\")(()\")\n    False\n    \"\"\"\n    level = 0\n    for c in brackets:\n        if c == \"(\":\n            level += 1\n        elif c == \")\":\n            level -= 1\n        if level < 0:\n            return False\n    return level == 0\n\n\ndef correct_bracketing3(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing3(\"(\")\n    False\n    >>> correct_bracketing3(\"()\")\n    True\n    >>> correct_bracketing3(\"(()())\")\n    True\n    >>> correct_bracketing3(\")(()\")\n    False\n    \"\"\"\n    return brackets.count(\"(\") == brackets.count(\")\")\n\n\ndef correct_bracketing4(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing4(\"(\")\n    False\n    >>> correct_bracketing4(\"()\")\n    True\n    >>> correct_bracketing4(\"(()())\")\n    True\n    >>> correct_bracketing4(\")(()\")\n    False\n    \"\"\"\n    return brackets.count(\"(\") == brackets.count(\")\")\n\n\ndef correct_bracketing5(brackets: str):\n    \"\"\" brackets is a string of \"(\" and"
    }
  ]
}