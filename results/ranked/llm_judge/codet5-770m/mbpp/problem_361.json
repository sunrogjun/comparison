{
  "timestamp": "2025-09-14T15:07:10.655816",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "mbpp",
  "problem_number": 361,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "class Solution:\n    def sortList(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        if n <= 1:\n            return nums\n        heap = [None] * n\n        for i in range(n):\n            heap[nums[i] - 1] = i\n        for i in range(n - 1, -1, -1):\n            nums[i] = heap[i]\n            heap[heap[i]] = i\n        return nums\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    nums = [4, 7, 1, 2, 3, 6]\n    print(s.sortList(nums))"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    # O(nlogn)\n    # O(n)\n    n = len(arr)\n    for i in range(n//2-1, -1, -1):\n        heappush(arr, heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(heap_sort(arr))"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heap = []\n        for num in nums:\n            if len(heap) == 0:\n                heapq.heappush(heap, num)\n            else:\n                heapq.heappushpop(heap, num)\n        while len(heap)!= 0:\n            nums[0] = heapq.heappop(heap)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        i = 0\n        while i < n:\n            j = i\n            while j < n and nums[i] < nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n                j += 1\n            i += 1\n\n\n\nnums = [3,2,1,5,4]\ns = Solution()\ns.sortArray(nums)\nprint(nums)"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n-1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            for j in range(0, i):\n                if nums[j] > nums[j+1]:\n                    nums[j], nums[j+1] = nums[j+1], nums[j]\n        return nums"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heapSort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heappush(arr, heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [7, 1, 9, 8, 2, 5, 4, 6]\n    print(heapSort(arr))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "class Heap:\n    def __init__(self, array):\n        self.array = array\n        self.heap = []\n        self.size = len(array)\n        for i in range(self.size):\n            self.heap.append(0)\n\n    def insert(self, val):\n        if len(self.heap) == 0 or self.heap[0] >= val:\n            self.heap.append(val)\n            return\n\n        parent = (self.size - 1) // 2\n        while parent >= 0 and self.heap[parent] > self.heap[0]:\n            self.heap[parent], self.heap[0] = self.heap[0], self.heap[parent]\n            parent = parent - 1\n\n    def heap_sort(self):\n        for i in range(self.size // 2, -1, -1):\n            self.heap[i], self.heap[0] = self.heap[0], self.heap[i]\n            self.insert(self.heap[0])\n\n    def __str__(self):\n        return str(self.heap)\n\n\nif __name__ == \"__main__\":\n    h = Heap([10, 7, 8, 9, 2, 5, 4, 6, 1, 3])\n    h.heap_sort()\n    print(h)"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    for i in range(len(arr)):\n        heappush(arr, arr[i])\n\n    while len(arr) > 1:\n        arr[0], arr[1] = heappop(arr), heappop(arr)\n\n\narr = [4, 5, 6, 7, 8, 9, 0, 1, 2]\nheap_sort(arr)\nprint(arr)"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "import heapq\n\ndef heap_sort(list_of_elements):\n    list_of_elements.sort()\n    heapq.heapify(list_of_elements)\n    return list_of_elements\n\nif __name__ == \"__main__\":\n    print(heap_sort([10,9,8,7,6,5,4,3,2,1]))"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "class Solution:\n    def sortArray(self, nums: List[int]) -> None:\n        n = len(nums)\n        heapq.heapify(nums)\n        for i in range(n-1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            heapq.heappop(nums)\n\nnums = [6, 5, 4, 3, 2, 1]\nSolution().sortArray(nums)\nprint(nums)"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "class Solution:\n    def sortArray(self, nums: List[int]) -> None:\n        n = len(nums)\n        if n < 2:\n            return\n        heap = []\n        for i in range(n // 2 - 1, -1, -1):\n            heap.append(nums[i])\n            nums[i], nums[n - i - 1] = nums[n - i - 1], nums[i]\n        while len(heap) > 0:\n            nums[0], nums[n - 1] = nums[n - 1], nums[0]\n            heapq.heappop(heap)\n\n\nif __name__ == \"__main__\":\n    arr = [10, 3, 2, 9, 8, 7]\n    s = Solution()\n    print(s.sortArray(arr))"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "class Solution:\n    def sortList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        size = len(nums)\n        if size <= 1:\n            return\n\n        # create a heap\n        heap = []\n        for num in nums:\n            heap.append((num, -num))\n\n        # insert the first element in the end of the list\n        i = size - 1\n        while i >= 0:\n            num, i = heap[0]\n            nums[i] = num\n            i -= 1\n\n        # find the minimum element in the heap\n        min_num = -heap[0][0]\n\n        # insert the minimum element into the end of the list\n        heap.append((min_num, -min_num))\n\n        # iterate through the heap\n        for i in range(size - 1, 0, -1):\n            num, i = heap[i]\n            nums[i] = num\n\n\nif __name__ == \"__main__\":\n    nums = [2, 4, 1, 3, 5]\n    s = Solution()\n    s.sortList(nums)\n    print(nums)"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass heap:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        if self.root is None:\n            self.root = Node(val)\n        else:\n            temp = self.root\n            while temp.right:\n                temp = temp.right\n            temp.right = Node(val)\n\n    def delete(self):\n        if self.root is None:\n            return None\n\n        temp = self.root\n        self.root = temp.right\n        while temp.left:\n            temp = temp.left\n        return temp.val\n\n    def display(self):\n        if self.root is None:\n            return None\n\n        temp = self.root\n        while temp.left:\n            print(temp.val, end=\" \")\n            temp = temp.left\n\n        print(temp.val)\n\n\nif __name__ == '__main__':\n    heap = heap()\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(8)\n    heap.insert(9)\n    heap.insert(10)\n    heap.insert(7)\n    heap.insert(6)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(4)\n    heap.insert(8)\n    heap.insert(0)\n    heap.insert(5)\n    heap.insert(10)\n    heap.insert(9)\n    heap.insert(7)\n    heap.insert(6)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(4)\n    heap.insert(8)\n    heap.insert(0)\n    heap.insert(5)\n    heap.insert(10)\n    heap.insert(9)\n    heap.insert(7)\n    heap.insert(6)\n    heap.insert(3)\n    heap.insert(2)"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\ndef sort_list(arr):\n    n = len(arr)\n\n    for i in range(n//2-1, -1, -1):\n        heappush(arr, heappop(arr))\n\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print(sort_list(arr))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n//2 - 1, -1, -1):\n            if i == 0:\n                continue\n            if nums[i] > nums[i-1]:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n            else:\n                break\n        i = n - 1\n        while i >= 0:\n            nums[i], nums[0] = nums[0], nums[i]\n            i -= 1"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "class Solution:\n    def sortArrayByHeap(self, nums):\n        n = len(nums)\n        if n < 2:\n            return nums\n\n        nums.sort()\n        heap = [nums[0]]\n        for i in range(1, n):\n            heapq.heappush(heap, nums[i])\n\n        return heap\n\n\nif __name__ == \"__main__\":\n    nums = [1, 2, 3, 4, 5]\n    print(Solution().sortArrayByHeap(nums))"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) < 2:\n            return\n        n = len(nums)\n        for i in range(n//2 - 1, -1, -1):\n            self.heapify(nums, i)\n        for i in range(n-1, 0, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            self.heapify(nums, 0)\n\n    def heapify(self, nums, i):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        largest = i\n        if left < n and nums[i] > nums[left]:\n            largest = left\n        if right < n and nums[largest] > nums[right]:\n            largest = right\n        if largest!= i:\n            nums[i], nums[largest] = nums[largest], nums[i]\n            self.heapify(nums, largest)"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef sort_list_by_heap_queue(arr):\n    # create a heap\n    heap = []\n\n    # populate the heap\n    for element in arr:\n        heappush(heap, element)\n\n    # create a empty list\n    result = []\n\n    # while the heap is not empty\n    while heap:\n        # pop the top element\n        top = heappop(heap)\n        result.append(top)\n\n        # pop the element from the left\n        heappush(heap, top)\n\n    return result\n\n\narr = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(sort_list_by_heap_queue(arr))"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n        nums.sort()\n        i = n // 2\n        while i > 0:\n            if nums[0] > nums[i]:\n                nums[0], nums[i] = nums[i], nums[0]\n                i -= 1"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, -num)\n        result = []\n        while heap:\n            result.append(heapq.heappop(heap))\n        return result\n\n\na = Solution()\nprint(a.sortArray([3, 2, 1, 4, 5]))"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "import heapq\n\n\nclass Solution:\n    def sortList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        heapq.heapify(nums)\n        for i in range(len(nums) - 1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            heapq.heappop(nums)"
    },
    {
      "rank": 22,
      "score": 9.0,
      "candidate": "def heap_sort(arr):\n    n = len(arr)\n    heapify(arr, 0, n-1)\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, 0, i-1)\n\n\ndef heapify(arr, low, high):\n    if low < high:\n        mid = (low+high)//2\n        if arr[mid] > arr[high]:\n            arr[high], arr[mid] = arr[mid], arr[high]\n        heapify(arr, low, mid)\n\n\nif __name__ == \"__main__\":\n    arr = [8, 4, 2, 5, 3, 1, 7, 6]\n    print(\"Sorted array is:\")\n    heap_sort(arr)\n    print(arr)"
    },
    {
      "rank": 23,
      "score": 8.0,
      "candidate": "class Solution:\n    def sortList(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        heap = []\n        for i in range(n):\n            heapq.heappush(heap, nums[i])\n        while heap:\n            nums[i] = heapq.heappop(heap)"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "class Heap:\n\n    def __init__(self, items):\n        self.items = items\n        self.size = len(items)\n        self.heap = [None] * self.size\n\n    def insert(self, item):\n        if self.heap[self.size - 1] is not None:\n            self.heap[self.size - 1] = max(item, self.heap[self.size - 1])\n        else:\n            self.heap.append(item)\n        self.size -= 1\n        self.heapify(self.size)\n\n    def heapify(self, size):\n        while size > 0:\n            parent = (size - 1) // 2\n            if self.heap[parent] is not None:\n                if self.heap[parent] > self.items[size]:\n                    self.items[parent], self.items[size] = self.items[size], self.items[parent]\n                size = parent\n            else:\n                break\n\n    def heap_sort(self):\n        for i in range(self.size - 1, 0, -1):\n            self.items[0], self.items[i] = self.items[i], self.items[0]\n            self.heapify(0)\n\n\ndef heap_sort(items):\n    heap = Heap(items)\n    heap_sort.heap_sort()\n    return heap.items\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([7, 8, 9, 1, 5, 4, 2, 6, 3]))"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef sort_heap(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heappush(arr, heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [3, 5, 2, 4, 6, 1]\n    print(sort_heap(arr))"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    heap = []\n    for i in range(len(arr)):\n        heap.append(arr[i])\n    heap_sort_helper(heap)\n    for i in range(len(arr)-1, 0, -1):\n        arr[i], heap[0] = heap[0], arr[i]\n        heap_sort_helper(heap)\n    return arr\n\n\ndef heap_sort_helper(heap):\n    size = len(heap)\n    for i in range(size//2-1, -1, -1):\n        heap[0], heap[i] = heap[i], heap[0]\n        heapq.heappushpop(heap, heap[0])"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.heapify(self.arr, len(self.arr) - 1)\n\n    def heapify(self, arr, pos):\n        l = pos\n        r = pos * 2 + 1\n        if l < len(arr) and arr[l] > arr[r]:\n            l = r\n        if r < len(arr) and arr[r] > arr[l]:\n            r = l\n        if l < r:\n            arr[l], arr[r] = arr[r], arr[l]\n            self.heapify(arr, l)\n            self.heapify(arr, r)\n\n    def heapSort(self):\n        n = len(self.arr)\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(self.arr, i)\n        for i in range(n - 1, 0, -1):\n            self.heapify(self.arr, i)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    heap = Heap(arr)\n    heap.heapSort()\n    print(arr)"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "def heap_sort(lst):\n    heap = []\n    for i in range(len(lst)):\n        heapq.heappush(heap, lst[i])\n\n    while heap:\n        lst[i] = heapq.heappop(heap)\n    return lst"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    # TODO: implement heap sort\n    if len(arr) < 2:\n        return arr\n    heap = []\n    for i in arr:\n        heapq.heappush(heap, i)\n    return [heapq.heappop(heap) for _ in range(len(arr))]\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([1, 5, 3, 7, 2]) == [1, 2, 3, 4, 5]\n    assert heap_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert heap_sort([]) == []"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n        self.heap = [None for _ in range(len(arr))]\n        self.heapify(0)\n\n    def heapify(self, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < len(self.arr) and self.arr[left] > self.arr[largest]:\n            largest = left\n        if right < len(self.arr) and self.arr[right] > self.arr[largest]:\n            largest = right\n        if largest!= i:\n            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]\n            self.heapify(largest)\n\n    def pop(self):\n        return self.heap[0]\n\n    def push(self, element):\n        self.heap[0] = element\n        self.heapify(0)\n\n    def sort(self):\n        res = []\n        while self.heap:\n            res.append(self.pop())\n        return res\n\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nheap = Heap(arr)\nprint(heap.sort())"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Heap:\n    def __init__(self, nums):\n        self.nums = nums\n        self.size = len(nums)\n        self.root = None\n\n    def insert(self, val):\n        new_node = Node(val)\n        if self.root is None:\n            self.root = new_node\n        else:\n            self.swap(self.root, new_node)\n\n    def swap(self, node_a, node_b):\n        temp = node_a.val\n        node_a.val = node_b.val\n        node_b.val = temp\n\n    def find_min(self):\n        if self.root is None:\n            return -1\n\n        min_val = self.root.val\n        min_node = self.root\n        while min_node.next is not None:\n            min_node = min_node.next\n        return min_val\n\n    def remove_min(self):\n        if self.root is None:\n            return\n\n        temp = self.root.val\n        self.root = self.root.next\n        self.swap(self.root, temp)\n\n    def __repr__(self):\n        return str(self.root.val)\n\n\nif __name__ == \"__main__\":\n    heap = Heap([1,2,3,4,5])\n    heap.insert(5)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    print(heap)\n    print(heap.find_min())\n    print(heap.remove_min())\n    print(heap)\n    print(heap.find_min())\n    print(heap.remove_min())\n    print(heap)\n    print(heap.find_min())"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "def heap_sort(nums):\n    n = len(nums)\n    heapify(nums, 0, n-1)\n    for i in range(n-2, -1, -1):\n        nums[i], nums[0] = nums[0], nums[i]\n        heapify(nums, 0, i)\n\n\ndef heapify(nums, i, j):\n    parent = (i + j) // 2\n    if nums[i] > nums[parent]:\n        nums[i], nums[parent] = nums[parent], nums[i]\n        heapify(nums, i, parent)\n\n\nnums = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nheap_sort(nums)\nprint(nums)"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n//2):\n        heappush(arr, heappop(arr))\n    return arr\n\nif __name__ == '__main__':\n    print(heap_sort([4,2,3,1,5,6,7]))"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef sort_by_heapq(arr):\n    n = len(arr)\n    for i in range(n//2):\n        heappush(arr, -heappop(arr))\n\n    return arr\n\n\narr = [-1, 3, 4, 2, 1, -5, -2, 0, 5, 6]\nprint(sort_by_heapq(arr))"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    heap = []\n    for element in arr:\n        heap.append(element)\n\n    while len(heap) > 1:\n        min_element = heap[0]\n        heap.remove(min_element)\n\n        for element in heap:\n            if element < min_element:\n                min_element = element\n\n        heap.append(min_element)\n\n    return heap"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n//2 - 1, -1, -1):\n        heappush(arr, arr[0])\n    for i in range(n-1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heappush(arr, arr[0])\n    return arr\n\n\nprint(heap_sort([4, 2, 5, 1, 3, 6, 7]))"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n    for i in arr:\n        heappush(heap, i)\n    while len(heap) > 0:\n        print(heap)\n        arr[0], arr[heap[0]] = arr[heap[0]], arr[0]\n        heappop(heap)\n\n\narr = [5, 2, 1, 3, 4, 6, 7]\nheap_sort(arr)\nprint(arr)"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n//2, -1, -1):\n        heapq.heappush(arr, -heapq.heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([4, 2, 1, 3, 5]) == [-1, -2, -3, -5, 4]\n    assert heap_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert heap_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n-1,-1,-1):\n            for j in range(i+1,n):\n                if nums[i] > nums[j]:\n                    temp = nums[i]\n                    nums[i] = nums[j]\n                    nums[j] = temp\n\nnums = [1,5,7,2,4]\nprint(nums)\nsol = Solution()\nsol.sortArray(nums)\nprint(nums)"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "class Heap:\n\n    def __init__(self, array):\n        self.heap = []\n        for num in array:\n            self.insert(num)\n\n    def insert(self, num):\n        self.heap.append(num)\n        self.heapify(len(self.heap) - 1)\n\n    def heapify(self, index):\n        largest = index\n        left = 2 * index + 1\n        right = 2 * index + 2\n        if left < len(self.heap) and self.heap[left] > self.heap[largest]:\n            largest = left\n        if right < len(self.heap) and self.heap[right] > self.heap[largest]:\n            largest = right\n        if largest!= index:\n            self.heap[largest], self.heap[index] = self.heap[index], self.heap[largest]\n            self.heapify(largest)\n\n\nif __name__ == '__main__':\n    a = [3, 2, 1, 5, 4, 6]\n    h = Heap(a)\n    print(h.heap)"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "import heapq\n\ndef heapSort(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    n = len(nums)\n    for i in range(n//2-1, -1, -1):\n        heapq.heappush(nums, -heapq.heappop(nums))\n    for i in range(n-1, 0, -1):\n        heapq.heappush(nums, -heapq.heappop(nums))\n\n\nnums = [5, 6, 3, 2, 1, 8, 4, 7]\nheapSort(nums)\nprint(nums)"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, i)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, 0)\n\n\ndef heapify(arr, i):\n    left = 2 * i + 1\n    right = 2 * i + 2\n    largest = i\n    if left < n and arr[i] > arr[left]:\n        largest = left\n    if right < n and arr[largest] > arr[right]:\n        largest = right\n    if largest!= i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, largest)\n\n\narr = [2, 4, 3, 1, 7, 6]\nheap_sort(arr)\nprint(arr)"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "from heapq import heapify, heappush, heappop\n\n\ndef heapSort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void Do not return anything, modify arr in-place instead.\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return\n\n    # build heap\n    for i in range(n//2 - 1, -1, -1):\n        heappush(arr, arr[i])\n\n    # do sorting\n    for i in range(n-1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heappush(arr, arr[i])\n\n\nif __name__ == \"__main__\":\n    arr = [1, 3, 5, 2, 4, 8, 7, 6, 9, 10]\n    heapSort(arr)\n    print(arr)"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    length = len(arr)\n    for i in range(length//2 - 1, -1, -1):\n        heapify(arr, i)\n    for i in range(length-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, 0)\n\n\ndef heapify(arr, index):\n    left = 2*index + 1\n    right = 2*index + 2\n    if left < len(arr) and arr[left] > arr[index]:\n        left = 2*index + 1\n    if right < len(arr) and arr[right] > arr[index]:\n        right = 2*index + 2\n    if left < len(arr) and arr[left] > arr[right]:\n        arr[index], arr[left] = arr[left], arr[index]\n        heapify(arr, left)\n    if right < len(arr) and arr[right] > arr[index]:\n        arr[index], arr[right] = arr[right], arr[index]\n        heapify(arr, right)\n\n\nif __name__ == \"__main__\":\n    arr = [3, 9, 2, 7, 1, 4, 5, 8, 6]\n    heap_sort(arr)\n    print(arr)"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, values):\n        self.heap = values\n        self.heap_size = len(values)\n        self.heapify()\n\n    def heapify(self):\n        for i in range(self.heap_size // 2 - 1, -1, -1):\n            self.swap(i, self.heap_size - 1)\n            self.heapify_down(i)\n\n    def heapify_down(self, i):\n        while i * 2 + 1 < self.heap_size:\n            if self.heap[i] > self.heap[i * 2 + 1]:\n                self.swap(i, i * 2 + 1)\n                i *= 2\n\n    def swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n\n    def heap_sort(self):\n        for i in range(len(self.heap) - 1, 0, -1):\n            self.swap(i, 0)\n            self.heapify_down(0)\n\n\nif __name__ == '__main__':\n    a = [5, 2, 3, 1, 4, 6]\n    h = Heap(a)\n    h.heap_sort()\n    print(h.heap)"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "def sort_by_heap(arr):\n    n = len(arr)\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, i)\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, 0)\n\n\ndef heapify(arr, index):\n    largest = index\n    left = 2*index + 1\n    right = 2*index + 2\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n    if largest!= index:\n        arr[index], arr[largest] = arr[largest], arr[index]\n        heapify(arr, largest)\n\n\nif __name__ == \"__main__\":\n    arr = [2, 6, 8, 9, 3, 7, 1, 4, 5]\n    print(arr)\n    sort_by_heap(arr)\n    print(arr)"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    heap = []\n    for i in arr:\n        heapq.heappush(heap, i)\n\n    while heap:\n        print(heapq.heappop(heap))\n\n\nif __name__ == \"__main__\":\n    arr = [3, 5, 4, 2, 1]\n    heap_sort(arr)"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, x):\n        heapq.heappush(self.heap, x)\n\n    def delete(self):\n        if self.heap:\n            return heapq.heappop(self.heap)\n        else:\n            return None\n\n    def __len__(self):\n        return len(self.heap)\n\n    def __str__(self):\n        return str(self.heap)\n\n\ndef sort(arr):\n    heap = Heap()\n    for x in arr:\n        heap.insert(x)\n    return heap.__str__()\n\n\nif __name__ == '__main__':\n    print(sort([2, 4, 5, 6, 7, 9]))\n    print(sort([]))"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    n = len(arr)\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, arr[i])\n\n    for i in range(n-1, 0, -1):\n        arr[i], heapq.heappop(heap)\n\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    print(heap_sort(arr))"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, array):\n        self.array = array\n        self.heap = []\n        self.build_heap()\n    \n    def build_heap(self):\n        for i in range(len(self.array)//2-1, -1, -1):\n            self.heap.insert(i, self.array[i])\n    \n    def insert(self, element, position):\n        self.heap.insert(position, element)\n        self.rebalance(position)\n    \n    def rebalance(self, position):\n        parent = (position-1)//2\n        if position > 0:\n            if self.array[position] > self.array[parent]:\n                self.array[position], self.array[parent] = self.array[parent], self.array[position]\n    \n    def get_heap(self):\n        return self.array[0:len(self.heap)]\n    \n    def pop_min(self):\n        return self.heap.pop(0)\n    \n    def pop_max(self):\n        return self.heap.pop()\n    \n    def get_max(self):\n        return self.array[0]\n    \n    def get_min(self):\n        return self.array[len(self.heap):]\n    \n    def get_min_heap(self):\n        return self.array[0:len(self.heap)]\n    \n    def get_max_heap(self):\n        return self.array[len(self.heap):]\n    \n    def get_min_position(self):\n        return 0\n    \n    def get_max_position(self):\n        return len(self.array)-1\n\ndef heap_sort(array):\n    heap = Heap(array)\n    return heap.get_min()\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]))"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heappush(arr, heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([6, 4, 1, 2, 7, 8, 9, 3, 10]))"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heapSort(arr):\n    n = len(arr)\n    for i in range(n//2):\n        heappush(arr, heappop(arr))\n\n    for i in range(n-1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heappush(arr, heappop(arr))\n\n    return arr\n\n\narr = [12, 11, 13, 5, 6, 7]\nprint(heapSort(arr))"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(a):\n    n = len(a)\n    for i in range(n // 2 - 1, -1, -1):\n        heappush(a, a[i])\n    for i in range(n - 1, 0, -1):\n        a[0], a[i] = a[i], a[0]\n        heappush(a, a[0])\n    return a\n\n\nif __name__ == \"__main__\":\n    a = [5, 3, 1, 2, 4, 6]\n    print(heap_sort(a))"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    heap = []\n\n    for element in arr:\n        heappush(heap, element)\n\n    result = []\n\n    while heap:\n        result.append(heappop(heap))\n\n    return result"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "def heap_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    heap_sort_helper(arr, 0, len(arr) - 1)\n    return arr\n\ndef heap_sort_helper(arr, i, j):\n    largest_index = i\n    largest_val = arr[i]\n    while j < j + 2 * i:\n        if arr[j] > largest_val and arr[j] > arr[largest_index]:\n            largest_index = j\n        if arr[j] < largest_val and arr[j] < arr[largest_index]:\n            largest_val = arr[j]\n        if arr[j] > arr[largest_index]:\n            arr[j], arr[largest_index] = arr[largest_index], arr[j]\n        j += 1\n    arr[largest_index], arr[i] = arr[i], arr[largest_index]\n    heap_sort_helper(arr, i, largest_index - 1)\n    return\n\n\narr = [4, 3, 2, 1, 5, 6, 7]\nprint(heap_sort(arr))"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "import heapq\n\ndef heap_sort(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: void Do not return anything, modify arr in-place instead.\n    \"\"\"\n    heapq.heapify(arr)\n    for i in range(len(arr) - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapq.heappop(arr)\n\narr = [1, 4, 3, 2, 5, 6]\nheap_sort(arr)\nprint(arr)"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n-1, -1, -1):\n        heappush(arr, heappop(arr))\n    return arr\n\n\narr = [2, 4, 6, 1, 3]\nprint(heap_sort(arr))"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef heapsort(arr):\n    # heap sort\n    heapq.heapify(arr)\n    # print(arr)\n\n    # while len(arr) > 1:\n    #     # print(arr[0], arr[1], arr[2], arr[3])\n    #     # heapify the first two elements\n    #     # heapq.heappushpop(arr, arr[0])\n    #     # heapq.heappop(arr)\n    #     # heapq.heappushpop(arr, arr[1])\n    #     # heapq.heappop(arr)\n    #     # heapq.heappop(arr)\n    #     # heapq.heappop(arr)\n    #     # heapq.heappop(arr)\n\n    #     # print(arr)\n\n    #     # heapify the first two elements\n    #     # heapq.heappush(arr, arr[0])\n    #     # heapq.heappop(arr)\n    #     # heapq.heappop(arr)\n    #     # heapq.heappop(arr)\n    #     # heapq.heappop(arr)\n\n    #     # print(arr)\n\n    # return arr\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, 3, 4, 5]\n    # arr = [4, 5, 3, 2, 1]\n    print(heapsort(arr))"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "class Solution:\n    def sortList(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        if n == 0:\n            return nums\n        heap = []\n        for i in range(n):\n            heapq.heappush(heap, nums[i])\n        return [heapq.heappop(heap) for i in range(n)]"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "class Solution(object):\n    def sortArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n        n = len(nums)\n        for i in range(n-1, 0, -1):\n            for j in range(i):\n                if nums[j] > nums[j+1]:\n                    temp = nums[j]\n                    nums[j] = nums[j+1]\n                    nums[j+1] = temp"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef sort(arr):\n    heapq.heapify(arr)\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapq.heappop(arr)\n\n\narr = [2, 7, 4, 6, 1, 5, 8]\nsort(arr)\nprint(arr)"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "import heapq\n\n\ndef heap_sort(arr):\n    heap = []\n    for i in range(len(arr)):\n        heapq.heappush(heap, arr[i])\n\n    while len(heap) > 1:\n        heapq.heappushpop(heap, heapq.heappop(heap))\n\n    return heap\n\n\narr = [5, 1, 3, 2, 6, 4, 8, 7, 9, 10]\nprint(heap_sort(arr))"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\ndef sort_list(arr):\n    heap = []\n    for i in range(len(arr)):\n        heappush(heap, arr[i])\n\n    while len(heap) > 0:\n        arr[0] = heappop(heap)\n        print(arr)\n\nif __name__ == '__main__':\n    arr = [3, 4, 5, 2, 1]\n    sort_list(arr)"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n-1, 0, -1):\n        heappush(arr, heappop(arr))\n    return arr\n\n\nif __name__ == '__main__':\n    assert heap_sort([3, 6, 2, 1, 5, 4]) == [1, 2, 3, 4, 5, 6]\n    assert heap_sort([]) == []\n    assert heap_sort([1]) == [1]\n    assert heap_sort([1, 2, 3]) == [1, 2, 3]"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(nums):\n    n = len(nums)\n    if n <= 1:\n        return nums\n    if n > 1:\n        for i in range(n//2):\n            heappush(nums, heappop(nums))\n    return nums\n\n\nif __name__ == '__main__':\n    assert heap_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n    assert heap_sort([]) == []\n    assert heap_sort([1, 2, 3, 4]) == [1, 2, 3, 4]"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef sort_heap(arr):\n    n = len(arr)\n    for i in range(n//2 - 1, -1, -1):\n        heappush(arr, arr[i])\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heappop(arr)\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [4, 2, 7, 1, 5, 6]\n    print(sort_heap(arr))"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heapSort(arr):\n    if len(arr) < 2:\n        return arr\n\n    arr = sorted(arr)\n    res = []\n    for i in range(len(arr)):\n        heappush(res, arr[i])\n\n    return res\n\n\narr = [4, 5, 6, 1, 2]\nprint(heapSort(arr))\n\narr = [4, 5, 6, 1]\nprint(heapSort(arr))\n\narr = [4, 5, 6]\nprint(heapSort(arr))"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "class Heap:\n    def __init__(self, items=None):\n        self.heap = []\n        if items is not None:\n            self.insert(items)\n\n    def insert(self, item):\n        self.heap.append(item)\n        self._heapify_up(len(self.heap) - 1)\n\n    def _heapify_up(self, index):\n        while index > 0 and self.heap[index] > self.heap[index - 1]:\n            self.heap[index], self.heap[index - 1] = self.heap[index - 1], self.heap[index]\n            index -= 1\n\n    def delete(self):\n        if self.heap:\n            item = self.heap[0]\n            self.heap[0] = self.heap[len(self.heap) - 1]\n            self._heapify_down(len(self.heap) - 1)\n            return item\n        else:\n            return None\n\n\nif __name__ == '__main__':\n    items = [3, 6, 9, 7, 1, 8, 2, 5, 4]\n    h = Heap(items)\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "class Solution:\n    def sortList(self, nums: List[int]) -> List[int]:\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, num)\n\n        result = []\n        while heap:\n            result.append(heapq.heappop(heap))\n\n        return result\n\n\nif __name__ == '__main__':\n    print(Solution().sortList([5, 2, 6, 4, 1]))"
    },
    {
      "rank": 70,
      "score": 1.0,
      "candidate": "class Solution:\n    def sortArrayByHeap(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n // 2 - 1, -1, -1):\n            self.heapify(nums, i)\n        for i in range(n - 1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            self.heapify(nums, 0)\n\n    def heapify(self, nums, index):\n        left = 2 * index + 1\n        right = 2 * index + 2\n        if left < n and nums[index] > nums[left]:\n            nums[index], nums[left] = nums[left], nums[index]\n        if right < n and nums[index] > nums[right]:\n            nums[index], nums[right] = nums[right], nums[index]\n        if left < n and nums[index] > nums[left]:\n            nums[index], nums[left] = nums[left], nums[index]"
    },
    {
      "rank": 71,
      "score": 1.0,
      "candidate": "class Solution:\n    def sortArray(self, nums: List[int]) -> None:\n        # write your code here\n        n = len(nums)\n        i = n - 1\n        while i > 0:\n            j = i\n            while j > 0 and nums[j] > nums[i]:\n                nums[j], nums[i] = nums[i], nums[j]\n                j -= 1\n            i -= 1\n\n\ns = Solution()\nnums = [3, 2, 5, 1, 4]\nprint(s.sortArray(nums))"
    },
    {
      "rank": 72,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    n = len(arr)\n    for i in range(n, -1, -1):\n        print(i, arr[i], end=' ')\n        heapq.heappush(arr, -arr[i])\n    return arr\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([4, 5, 6, 7, 1, 2, 3]))"
    },
    {
      "rank": 73,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    \"\"\"\n    Time: O(n^2)\n    Space: O(n)\n    \"\"\"\n    n = len(arr)\n    # create a heap\n    for i in range(n-1, 0, -1):\n        # find minimum element\n        min_index = i\n        for j in range(i):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # swap the element with the minimum\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [2, 4, 1, 3, 5, 6]\n    print(heap_sort(arr))"
    },
    {
      "rank": 74,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef heap_sort(nums):\n    n = len(nums)\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, nums[i])\n    for i in range(n - 1, 0, -1):\n        nums[i], heapq.heappop(heap)\n    return nums\n\n\nprint(heap_sort([5, 3, 7, 2, 1, 4, 6, 8]))"
    },
    {
      "rank": 75,
      "score": 1.0,
      "candidate": "def sort_heap(arr):\n    for i in range(len(arr)//2, -1, -1):\n        # Swap the first and last element of the list\n        temp = arr[i]\n        arr[i] = arr[len(arr)-1]\n        arr[len(arr)-1] = temp\n        # Remove the last element from the heap\n        arr.pop()\n\n\nif __name__ == \"__main__\":\n    print(\"Sorted array is:\")\n    arr = [4, 2, 3, 1, 5, 6]\n    print(arr)\n    sort_heap(arr)\n    print(arr)"
    },
    {
      "rank": 76,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    # Time Complexity: O(nlogn)\n    # Space Complexity: O(n)\n    # Create a max heap\n    max_heap = [0 for _ in range(len(arr))]\n    for num in arr:\n        max_heap[num] = num\n\n    # Iterate over the max heap until it is empty\n    while len(max_heap) > 1:\n        # Move the max heap element to the front of the list\n        left = 0\n        right = len(max_heap) - 1\n\n        while left <= right:\n            if max_heap[left] > max_heap[right]:\n                max_heap[left], max_heap[right] = max_heap[right], max_heap[left]\n                left += 1\n                right -= 1\n            elif max_heap[left] == max_heap[right]:\n                break\n\n        # Move the max heap element to the front of the list\n        left = 0\n        right = len(max_heap) - 1\n\n        while left <= right:\n            if max_heap[left] > max_heap[right]:\n                max_heap[left], max_heap[right] = max_heap[right], max_heap[left]\n                left += 1\n                right -= 1\n            elif max_heap[left] == max_heap[right]:\n                break\n\n    return max_heap\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9]))"
    },
    {
      "rank": 77,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    n = len(arr)\n    heapq.heapify(arr)\n    for i in range(n-1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapq.heappop(arr)\n\n\nif __name__ == '__main__':\n    arr = [12, 11, 13, 5, 6, 7]\n    print(arr)\n    heap_sort(arr)\n    print(arr)"
    },
    {
      "rank": 78,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef sort_arr(arr):\n    heapq.heapify(arr)\n    while len(arr) > 1:\n        heapq.heappushpop(arr, heapq.heappop(arr))\n        heapq.heappushpop(arr, heapq.heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [2, 5, 4, 1, 7, 9]\n    print(sort_arr(arr))"
    },
    {
      "rank": 79,
      "score": 1.0,
      "candidate": "def heapSort(arr):\n    # Sort by heap\n    heap = []\n    for i in range(len(arr)):\n        heap.append(arr[i])\n\n    for i in range(len(heap) - 1, 0, -1):\n        arr[i] = heap[0]\n        heap.pop(0)\n\n\nif __name__ == '__main__':\n    print(heapSort([5, 2, 6, 1, 3, 4]))"
    },
    {
      "rank": 80,
      "score": 1.0,
      "candidate": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, num)\n        \n        sorted_nums = []\n        while heap:\n            sorted_nums.append(heapq.heappop(heap))\n        \n        return sorted_nums\n            \n\nif __name__ == \"__main__\":\n    nums = [2,4,1,5,3]\n    sol = Solution()\n    print(sol.sortArray(nums))"
    },
    {
      "rank": 81,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    # write your code here\n    n = len(arr)\n    heap = [0 for _ in range(n)]\n    for i in range(n):\n        heap[i] = arr[i]\n    while len(heap) > 1:\n        for i in range(n-1, 0, -1):\n            if arr[i] < heap[0]:\n                heap[0], heap[i] = heap[i], heap[0]\n    return heap\n\n\nif __name__ == \"__main__\":\n    arr = [4, 2, 1, 3, 5]\n    print(heap_sort(arr))"
    },
    {
      "rank": 82,
      "score": 1.0,
      "candidate": "class heapq:\n    def __init__(self, arr):\n        self.heap = arr[:]\n        self.heapify(0)\n\n    def heapify(self, pos):\n        while pos * 2 + 1 < len(self.heap):\n            if self.heap[pos] > self.heap[pos * 2]:\n                temp = self.heap[pos]\n                self.heap[pos] = self.heap[pos * 2]\n                self.heap[pos * 2] = temp\n            pos = pos * 2 + 1\n\n    def sort(self):\n        for i in range(len(self.heap) // 2):\n            self.heapify(i)\n        for i in range(len(self.heap) - 1, 0, -1):\n            self.heap[0], self.heap[i] = self.heap[i], self.heap[0]\n            self.heapify(i)\n\n    def print_heap(self):\n        for i in self.heap:\n            print(i, end=\" \")\n        print()\n\n\nif __name__ == '__main__':\n    arr = [5, 8, 2, 1, 7, 9, 4, 6, 6, 2, 9, 8, 5, 1, 6, 7, 4, 3, 8, 5, 9, 2, 8, 9, 4, 6, 7, 6, 9]\n    heapq = heapq(arr)\n    heapq.sort()\n    print(heapq.heap)\n    heapq.print_heap()"
    },
    {
      "rank": 83,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\ndef heapsort(nums):\n    n = len(nums)\n    for i in range(n-1, 0, -1):\n        heappush(nums, heappop(nums))\n\n    return nums\n\nif __name__ == \"__main__\":\n    print(heapsort([1, 3, 5, 2, 4, 6, 7, 8, 9, 10]))\n    print(heapsort([]))"
    },
    {
      "rank": 84,
      "score": 1.0,
      "candidate": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        i = len(nums) // 2\n        while i >= 0:\n            temp = nums[i]\n            j = i\n            while j < len(nums) and nums[j] > temp:\n                nums[j + 1] = nums[j]\n                j += 1\n            nums[i] = temp\n            i -= 1\n        return nums\n\n\nif __name__ == '__main__':\n    nums = [2, 5, 3, 1, 7, 4]\n    result = Solution().sortArray(nums)\n    assert result == sorted(nums)\n\n    nums = [1, 2, 3, 4, 5, 6]\n    result = Solution().sortArray(nums)\n    assert result == sorted(nums)\n\n    nums = [3, 2, 1, 4, 5, 6]\n    result = Solution().sortArray(nums)\n    assert result == sorted(nums)\n\n    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n    result = Solution().sortArray(nums)\n    assert result == sorted(nums)\n\n    nums = []\n    result = Solution().sortArray(nums)\n    assert result == sorted(nums)"
    },
    {
      "rank": 85,
      "score": 1.0,
      "candidate": "from typing import List\n\n\ndef heap_sort(arr: List[int]) -> List[int]:\n    if len(arr) < 2:\n        return arr\n\n    heap = [(arr[0], 0)]\n    while heap:\n        val, index = heap.pop()\n        for i in range(1, len(arr)):\n            if arr[i] > val:\n                heap.append((arr[i], i))\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([3, 5, 1, 2, 6, 4, 8]) == [1, 2, 3, 4, 5, 6, 8]\n    assert heap_sort([3, 5, 1, 2, 6, 4, 8]) == [1, 2, 3, 4, 5, 6, 8]"
    },
    {
      "rank": 86,
      "score": 1.0,
      "candidate": "class Solution:\n    def sortList(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return\n\n        # sort elements\n        # build heap\n        heap = []\n        for i in range(n):\n            heapq.heappush(heap, nums[i])\n\n        # reverse heap\n        while heap:\n            nums[i], heapq.heappop(heap)\n\n\nif __name__ == \"__main__\":\n    nums = [4, 3, 2, 1]\n    print(Solution().sortList(nums))"
    },
    {
      "rank": 87,
      "score": 1.0,
      "candidate": "class heap_sort:\n    def __init__(self, lst):\n        self.lst = lst\n        self.heap_sort_helper()\n\n    def heap_sort_helper(self):\n        n = len(self.lst)\n\n        # create a heap\n        for i in range(n//2-1, -1, -1):\n            self.heapify(i)\n\n        # loop through the rest of the list\n        for i in range(n-1, 0, -1):\n            self.lst[0], self.lst[i] = self.lst[i], self.lst[0]\n            self.heapify(0)\n\n    def heapify(self, index):\n        # swap the element at the index with the element at the right position\n        temp = self.lst[index]\n        self.lst[index] = self.lst[index+1]\n        self.lst[index+1] = temp\n\n        # swap the element at the right position with the element at the left position\n        while index > 0 and self.lst[index] < self.lst[index-1]:\n            self.lst[index], self.lst[index-1] = self.lst[index-1], self.lst[index]\n            index -= 1\n\n\nif __name__ == \"__main__\":\n    lst = [4, 2, 1, 3, 5]\n    print(lst)\n    print(\"heap sort : \")\n    heap_sort(lst)\n    print(lst)"
    },
    {
      "rank": 88,
      "score": 1.0,
      "candidate": "# Solution 1\n# Time complexity O(nlogn)\n# Space complexity O(n)\nclass Solution:\n    def sortArray(self, nums):\n        n = len(nums)\n        heap = []\n\n        for num in nums:\n            heapq.heappush(heap, num)\n\n        for _ in range(n // 2):\n            nums[0], nums[heap[0]] = nums[heap[0]], nums[0]\n            heapq.heappop(heap)\n\n        return nums\n\n\n# Solution 2\n# Time complexity O(nlogn)\n# Space complexity O(n)\nclass Solution:\n    def sortArray(self, nums):\n        n = len(nums)\n        heap = []\n\n        for num in nums:\n            heapq.heappush(heap, num)\n\n        for i in range(n-1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            heapq.heappop(heap)\n\n        return nums\n\n\n# Solution 3\n# Time complexity O(nlogn)\n# Space complexity O(n)\nclass Solution:\n    def sortArray(self, nums):\n        n = len(nums)\n        heap = []\n\n        for num in nums:\n            heapq.heappush(heap, num)\n\n        for i in range(n-1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            heapq.heappop(heap)\n\n        return nums\n\n\n# Solution 4\n# Time complexity O(nlogn)\n# Space complexity O(n)\nclass Solution:\n    def sortArray(self, nums):\n        n = len(nums)\n        heap = []\n\n        for num in nums:\n            heapq.heappush(heap, num)\n\n        for i in range(n-1, 0, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            heapq.heappop(heap)\n\n        return nums\n\n\n# Solution 5\n# Time complexity O(nlogn"
    },
    {
      "rank": 89,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    # create a heap with the elements in the list\n    heap = [(x, x) for x in arr]\n    heapq.heapify(heap)\n\n    # run until the heap is empty\n    while len(heap) > 0:\n        # pop the element from the heap and push it to the list\n        x, y = heapq.heappop(heap)\n        arr.append(y)\n        # pop the element from the heap and push it to the list\n        heapq.heappush(heap, (y, y))\n\n    return arr\n\n\nif __name__ == '__main__':\n    print(heap_sort([5, 2, 1, 3, 4]))"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "def heap_sort(lst):\n    n = len(lst)\n    # creating a heap\n    for i in range(n//2 - 1, -1, -1):\n        heapify(lst, i)\n    # iterating through the list\n    for i in range(n-1, 0, -1):\n        # swapping the elements\n        lst[i], lst[0] = lst[0], lst[i]\n        # updating the heap\n        heapify(lst, 0)\n    return lst\n\n\ndef heapify(lst, i):\n    # swapping the elements\n    tmp = lst[i]\n    j = i\n    while j > 0 and lst[j] > tmp:\n        lst[j], lst[i] = lst[i], lst[j]\n        j -= 1\n    lst[i], lst[j] = tmp, lst[i]\n\n\nif __name__ == '__main__':\n    lst = [5, 1, 2, 3, 4, 6, 7]\n    print(heap_sort(lst))"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    for i in range(len(arr)//2-1, -1, -1):\n        swap(arr, i)\n    return arr\n\n\ndef swap(arr, i):\n    temp = arr[i]\n    arr[i] = arr[len(arr)-1-i]\n    arr[len(arr)-1-i] = temp\n\n\narr = [5, 3, 2, 6, 1, 8, 4]\nprint(heap_sort(arr))"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    n = len(arr)\n    i = n//2\n    while i >= 0:\n        heapq.heappushpop(arr, heapq.heappop(arr))\n        i = i-1\n    return arr\n\n\nif __name__ == \"__main__\":\n    print(heap_sort([4, 7, 9, 8, 2, 1, 5, 6, 3, 7]))"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "class Solution(object):\n    def sortArrayByHeap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        for i in range(n-1, -1, -1):\n            if nums[i] > nums[0]:\n                temp = nums[0]\n                nums[0] = nums[i]\n                nums[i] = temp\n                self.heapSort(nums)\n\n    def heapSort(self, nums):\n        for i in range(n//2-1, -1, -1):\n            if nums[i] > nums[0]:\n                temp = nums[i]\n                nums[i] = nums[0]\n                nums[0] = temp\n                self.heapSort(nums)"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "def heapsort(arr):\n    n = len(arr)\n    for i in range(n//2):\n        largest = i\n        for j in range(i+1, n):\n            if arr[j] > arr[largest]:\n                largest = j\n        arr[i], arr[largest] = arr[largest], arr[i]\n\n    return arr\n\nif __name__ == \"__main__\":\n    arr = [4, 2, 3, 5, 1, 6]\n    print(heapsort(arr))"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef heap_sort(arr):\n    heap = []\n    for i in arr:\n        heapq.heappush(heap, i)\n\n    while len(heap) > 1:\n        heapq.heappop(heap)\n        heapq.heappush(heap, heapq.heappop(heap))\n\n    return heap\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([5, 2, 6, 7, 1, 3, 4]) == [1, 2, 3, 4, 5, 6, 7]"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heapSort(nums):\n    n = len(nums)\n    for i in range(n // 2 - 1, -1, -1):\n        heappush(nums, heappop(nums))\n    return nums\n\n\nif __name__ == \"__main__\":\n    print(heapSort([3, 2, 7, 1, 4, 8]))"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "class Solution:\n    # @param A : list of integers\n    # @return a list of integers\n    def sortList(self, A):\n        n = len(A)\n        A.sort()\n        q = [(A[0], 0)]\n        while q:\n            a, i = q.pop()\n            for j in range(i + 1, n):\n                if a > A[j]:\n                    q.append((A[j], j))\n        return A\n\n\nif __name__ == \"__main__\":\n    sol = Solution()\n    print(sol.sortList([3, 1, 2, 4]))"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "import heapq\n\n\ndef heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapq.heappush(arr, heapq.heappop(arr))\n    return arr\n\n\nif __name__ == \"__main__\":\n    assert heap_sort([]) == []\n    assert heap_sort([2, 4, 1, 3, 5]) == [1, 2, 3, 4, 5]\n    assert heap_sort([1, 2, 3, 4]) == [1, 2, 3, 4]"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "def heap_sort(arr):\n    n = len(arr)\n    if n < 2:\n        return arr\n\n    # sort from left to right\n    for i in range(n-1, -1, -1):\n        # find the largest element\n        largest = i\n        for j in range(i+1, n):\n            if arr[j] > arr[largest]:\n                largest = j\n        # swap the largest element with it's position\n        arr[largest], arr[i] = arr[i], arr[largest]\n    return arr\n\n\nif __name__ == \"__main__\":\n    arr = [5, 3, 2, 7, 4, 1, 8]\n    print(heap_sort(arr))"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "class HeapSort:\n    def __init__(self, arr):\n        self.arr = arr\n        self.heap = []\n        self.heapify(0, len(self.arr))\n\n    def heapify(self, i, size):\n        l = 2 * i + 1\n        r = 2 * i + 2\n        if l < size and self.arr[l] > self.arr[i]:\n            l = l + 1\n        if r < size and self.arr[r] > self.arr[i]:\n            r = r + 1\n        if l < size and self.arr[l] > self.arr[i]:\n            self.arr[i], self.arr[l] = self.arr[l], self.arr[i]\n            self.heapify(l, size)\n        if r < size and self.arr[r] > self.arr[i]:\n            self.arr[i], self.arr[r] = self.arr[r], self.arr[i]\n            self.heapify(r, size)\n\n    def sort(self):\n        while self.heap:\n            self.arr[0], self.arr[len(self.arr) - 1] = self.arr[len(self.arr) - 1], self.arr[0]\n            self.heapify(0, len(self.arr) - 1)\n\n\nif __name__ == \"__main__\":\n    arr = [4, 2, 7, 1, 6, 5, 8, 3, 9]\n    heap = HeapSort(arr)\n    heap.sort()\n    print(arr)"
    }
  ]
}