{
  "timestamp": "2025-09-14T13:55:19.628666",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "mbpp",
  "problem_number": 198,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        heappush(self.heap, item)\n\n    def delete(self):\n        if len(self.heap) > 0:\n            return heappop(self.heap)\n        return None\n\n\nif __name__ == '__main__':\n    heap = MinHeap()\n    heap.insert(2)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "class Solution:\n    def insert(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        # find the smallest element\n        smallest = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < smallest:\n                smallest = nums[i]\n        # insert the smallest element\n        nums.insert(0, smallest)\n        # find the largest element\n        largest = nums[-1]\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] > largest:\n                largest = nums[i]\n        # insert the largest element\n        nums.insert(len(nums) - 1, largest)\n        # loop through the list\n        for i in range(len(nums)):\n            # delete the smallest element\n            nums.pop(0)\n            # insert the smallest element\n            nums.insert(0, nums[i])"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "from heapq import heappop, heappush\n\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\ndef insert_node(heap, val):\n    if len(heap) == 0:\n        heappush(heap, Node(val))\n    else:\n        heappush(heap, Node(val))\n        while len(heap) > 1:\n            if val < heap[0].val:\n                heappop(heap)\n                heappush(heap, Node(val))\n\n\nif __name__ == \"__main__\":\n    heap = [Node(i) for i in range(1, 11)]\n    insert_node(heap, 4)\n    insert_node(heap, 5)\n    insert_node(heap, 7)\n    insert_node(heap, 9)\n    insert_node(heap, 10)\n    insert_node(heap, 11)\n    insert_node(heap, 12)\n    insert_node(heap, 13)\n    insert_node(heap, 14)\n    insert_node(heap, 15)\n    insert_node(heap, 16)\n    insert_node(heap, 17)\n    insert_node(heap, 18)\n    insert_node(heap, 19)\n    insert_node(heap, 20)\n    insert_node(heap, 21)\n    insert_node(heap, 22)\n    insert_node(heap, 23)\n    insert_node(heap, 24)\n    insert_node(heap, 25)\n    insert_node(heap, 26)\n    insert_node(heap, 27)\n    insert_node(heap, 28)\n    insert_node(heap, 29)\n    insert_node(heap, 30)\n    insert_node(heap, 31)\n    insert_node(heap, 32)\n    print(heap)"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "class Heap:\n    def __init__(self, val=None):\n        self.val = val\n        self.heap = []\n\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return\n        smallest = heapq.heappop(self.heap)\n        self.val = smallest\n        heapq.heappush(self.heap, smallest)\n\n    def size(self):\n        return len(self.heap)\n\n    def get(self):\n        return self.val\n\n\n# Example 1:\n# Input: heap = [3, 2, 1, 4, 5]\n# Output: 4\n# Explanation: The heap is sorted in ascending order.\n# Example 2:\n# Input: heap = [2, 1, 4, 5, 3]\n# Output: 2\n# Explanation: The heap is sorted in ascending order.\n# Example 3:\n# Input: heap = [1, 4, 5, 3]\n# Output: 1\n# Explanation: The heap is sorted in ascending order.\n\nheap = Heap(3)\nheap.add(2)\nheap.add(1)\nheap.add(4)\nheap.add(5)\nheap.delete()\nprint(heap.get())"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heap_sort(arr):\n    for i in range(len(arr)//2 - 1, -1, -1):\n        heappush(arr, -heappop(arr))\n    return arr\n\n\nif __name__ == '__main__':\n    arr = [5, 2, 3, 7, 6, 8, 4, 1]\n    print(heap_sort(arr))"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "from heapq import heappush, heappop\n\ndef heapify(h):\n    for i in range(len(h)-1, 0, -1):\n        heappush(h, heappop(h))\n\n\ndef insert(h, new_item):\n    heappush(h, new_item)\n\n\nif __name__ == '__main__':\n    heapify([1, 2, 3, 4, 5, 6])\n    insert(heapify([1, 2, 3, 4, 5, 6]), 7)\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 7))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 8))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 9))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 10))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 11))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 12))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 13))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6]), 14))\n    print(heapify([1, 2, 3, 4, 5, 6]))\n    print(insert(heapify([1, 2, 3, 4, 5, 6"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "import heapq\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        heapq.heappush(self.heap, val)\n\n    def delete(self):\n        if not self.heap:\n            return None\n        else:\n            return heapq.heappop(self.heap)\n\n\nif __name__ == '__main__':\n    h = Heap()\n    h.insert(2)\n    h.insert(1)\n    h.insert(3)\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print(h.delete())\n    print("
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n        self.heapify(len(self.heap) - 1)\n\n    def heapify(self, index):\n        while index > 0 and self.heap[index] > self.heap[index - 1]:\n            self.heap[index], self.heap[index - 1] = self.heap[index - 1], self.heap[index]\n            index = index - 1\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return None\n\n        item = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.heapify(0)\n\n        return item\n\n\nif __name__ == \"__main__\":\n    h = Heap()\n    h.insert(5)\n    h.insert(4)\n    h.insert(3)\n    h.insert(2)\n    h.insert(1)\n\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h.delete_min())\n    print(h"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "class Solution:\n    def heapSort(self, A: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify A in-place instead.\n        \"\"\"\n        n = len(A)\n        for i in range(n//2-1, -1, -1):\n            self.heapify(A, i)\n        for i in range(n-1, 0, -1):\n            self.heapify(A, i)\n\n    def heapify(self, A, idx):\n        largest = idx\n        left = 2*idx + 1\n        right = 2*idx + 2\n        if left < n and A[idx] > A[left]:\n            largest = left\n        if right < n and A[idx] > A[right]:\n            largest = right\n        if largest!= idx:\n            temp = A[idx]\n            A[idx] = A[largest]\n            A[largest] = temp\n            self.heapify(A, largest)"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n\nclass Heap:\n    def __init__(self, value=0):\n        self.head = Node(value)\n\n    def insert(self, value):\n        heappush(self.head.next, Node(value))\n\n    def delete_min(self):\n        if self.head.next:\n            min_node = heappop(self.head.next)\n            self.head = min_node\n            heappush(self.head.next, min_node)\n\n    def __str__(self):\n        return str(self.head)\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    print(heap)\n    heap.delete_min()\n    print(heap)"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\ndef heapify_insert(arr):\n    for i in range(len(arr) - 1, 0, -1):\n        heappush(arr, -heappop(arr))\n\n\ndef heapify_delete(arr):\n    for i in range(len(arr) - 1, 0, -1):\n        heappush(arr, heappop(arr))\n\n\ndef main():\n    print(\"insertion\")\n    heapify_insert([4, 6, 8, 2, 5, 9, 1, 3, 7, 0])\n    print(heapify_insert([4, 6, 8, 2, 5, 9, 1, 3, 7, 0]))\n    print(\"deletion\")\n    heapify_delete([4, 6, 8, 2, 5, 9, 1, 3, 7, 0])\n    print(heapify_delete([4, 6, 8, 2, 5, 9, 1, 3, 7, 0]))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 12,
      "score": 9.996490721568136,
      "candidate": "from heapq import heappush, heappop\n\nclass Heap:\n    def __init__(self, data):\n        self.data = data\n        self.heap = []\n\n    def insert(self, val):\n        heappush(self.heap, val)\n\n    def delete_min(self):\n        if len(self.heap) > 0:\n            return heappop(self.heap)\n        else:\n            return None\n\n\nif __name__ == \"__main__\":\n    heap = Heap([3, 2, 6, 1, 5])\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())"
    },
    {
      "rank": 13,
      "score": 9.942885309162246,
      "candidate": "class Heap:\n\n    def __init__(self, arr=[]):\n        self.arr = arr\n\n    def delete(self, key):\n        i = 0\n        while i < len(self.arr):\n            if self.arr[i] > key:\n                break\n            else:\n                self.arr[i], self.arr[len(self.arr) - 1] = self.arr[len(self.arr) - 1], self.arr[i]\n                i += 1\n\n    def insert(self, key):\n        self.arr.append(key)\n        self.delete(key)\n\n    def print_heap(self):\n        for i in range(len(self.arr) - 1, 0, -1):\n            print(self.arr[i], end=\" \")\n\n\nif __name__ == \"__main__\":\n    heap = Heap([3, 2, 1, 4, 5, 6])\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    heap.insert(10)\n    heap.insert(11)\n    heap.print_heap()\n    print(heap.arr)\n    heap.delete(6)\n    heap.print_heap()\n    print(heap.arr)"
    },
    {
      "rank": 14,
      "score": 9.939120122571932,
      "candidate": "from heapq import heapify, heappop, heappush\n\n\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef heapify_heap(arr):\n    for i in range(len(arr)-1, 0, -1):\n        heappush(arr, Node(arr[i]))\n\n\ndef insert_new_node(arr, val):\n    if not arr:\n        return\n    heappush(arr, Node(val))\n    heapify_heap(arr)\n\n\ndef test():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    insert_new_node(arr, 7)\n    assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nif __name__ == \"__main__\":\n    test()"
    },
    {
      "rank": 15,
      "score": 9.921713039146784,
      "candidate": "def heap_sort(arr):\n    for i in range(len(arr) // 2, -1, -1):\n        swap(arr, i)\n    return arr\n\n\ndef swap(arr, i):\n    if i == 0:\n        return\n    if i == len(arr) - 1:\n        arr[i], arr[0] = arr[0], arr[i]\n    else:\n        temp = arr[i]\n        arr[i] = arr[0]\n        arr[0] = temp\n\n\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nheap_sort(arr)\nprint(arr)"
    },
    {
      "rank": 16,
      "score": 9.919604782278684,
      "candidate": "from heapq import heappush, heappop\n\n\ndef delete_smallest(heap):\n    if len(heap) == 0:\n        return\n\n    smallest_element = heappop(heap)\n\n    while len(heap) > 1:\n        heappush(heap, heappop(heap))\n\n    heappush(heap, smallest_element)\n\n\ndef insert_new_item(heap):\n    if len(heap) == 0:\n        return\n\n    smallest_element = heappop(heap)\n\n    while len(heap) > 1:\n        heappush(heap, heappop(heap))\n\n    heappush(heap, smallest_element)"
    },
    {
      "rank": 17,
      "score": 9.878910264071733,
      "candidate": "from heapq import heappop, heappush\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        heappush(self.heap, val)\n\n    def delete_smallest(self):\n        if len(self.heap) == 0:\n            return None\n        return heappop(self.heap)\n\nif __name__ == '__main__':\n    h = Heap()\n    h.insert(10)\n    h.insert(20)\n    h.insert(30)\n    h.insert(40)\n    h.insert(50)\n    h.insert(60)\n    h.insert(70)\n    h.insert(80)\n    h.insert(90)\n    h.insert(100)\n    h.insert(110)\n    h.insert(120)\n    h.insert(130)\n    h.insert(140)\n    h.insert(150)\n    h.insert(160)\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_smallest())\n    print(h.delete_"
    },
    {
      "rank": 18,
      "score": 9.877936659656912,
      "candidate": "class HeapNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass Heap:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, data):\n        node = HeapNode(data)\n        if self.root is None:\n            self.root = node\n        else:\n            self.insert_node(node)\n\n    def insert_node(self, node):\n        if node.data > self.root.data:\n            if self.root.left is not None:\n                self.insert_node(self.root.left)\n            self.root.left = node\n        else:\n            if self.root.right is not None:\n                self.insert_node(self.root.right)\n            self.root.right = node\n\n    def delete(self):\n        if self.root is None:\n            return\n        root = self.root\n        self.root = self.root.left\n        if root.right is None:\n            if self.root.left is not None:\n                self.insert_node(self.root.left)\n                self.root = None\n\n    def __str__(self):\n        if self.root is None:\n            return \"Heap is empty\"\n        return str(self.root.data)\n\n\ndef main():\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    print(heap)\n    heap.delete()\n    print(heap)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 19,
      "score": 9.86954316866802,
      "candidate": "from heapq import heapify, heappush, heappop\n\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        heappush(self.heap, item)\n\n    def delete(self):\n        if not self.heap:\n            return None\n        return heappop(self.heap)\n\n    def get_min(self):\n        return self.heap[0]\n\n    def size(self):\n        return len(self.heap)\n\n    def __str__(self):\n        return str(self.heap)\n\nif __name__ == \"__main__\":\n    heap = MinHeap()\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    print(heap)\n    print(heap.delete())\n    print(heap)\n    print(heap.delete())\n    print(heap)\n    print(heap.delete())\n    print(heap)\n    print(heap)\n    print(heap.delete())\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print(heap)\n    print"
    },
    {
      "rank": 20,
      "score": 9.858460491623452,
      "candidate": "class Heap:\n\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap.sort()\n        self.heap.pop()\n\n    def delete_smallest(self):\n        if self.heap:\n            return self.heap.pop()\n        return None\n\n    def print_heap(self):\n        print(self.heap)\n\n\ndef main():\n    h = Heap()\n    h.insert(3)\n    h.insert(2)\n    h.insert(1)\n    h.print_heap()\n    print(h.delete_smallest())\n    h.print_heap()\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 21,
      "score": 9.843556280820357,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n        self.heap.sort()\n\n    def delete(self):\n        if len(self.heap) > 0:\n            self.heap.pop()\n            self.heap.sort()\n\n    def peek(self):\n        return self.heap[0]\n\n    def size(self):\n        return len(self.heap)\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(10)\n    heap.insert(20)\n    heap.insert(30)\n    heap.insert(40)\n    heap.insert(50)\n    heap.insert(60)\n    heap.insert(70)\n    heap.insert(80)\n    heap.insert(90)\n\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()\n    heap.delete()"
    },
    {
      "rank": 22,
      "score": 9.78979166324777,
      "candidate": "class Node:\n    def __init__(self, val, next_node=None):\n        self.val = val\n        self.next_node = next_node\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, val):\n        new_node = Node(val)\n        if self.head:\n            self.tail.next_node = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def delete_min(self):\n        if self.head is None:\n            return None\n\n        node_to_delete = self.head\n        if self.head.next_node is not None:\n            self.head = self.head.next_node\n            node_to_delete.next_node = None\n\n        if self.head.next_node is None:\n            self.head = None\n\n        self.head.next_node = None\n        self.tail = None\n        return node_to_delete\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    heap.insert(10)\n\n    print(heap.delete_min())"
    },
    {
      "rank": 23,
      "score": 9.781803443962113,
      "candidate": "from typing import List, Optional\n\n\ndef heapify(heap: List[int], index: int) -> None:\n    left = 2 * index + 1\n    right = 2 * index + 2\n    if left < len(heap) and heap[left] > heap[index]:\n        left = left + 1\n\n    if right < len(heap) and heap[right] > heap[index]:\n        right = right + 1\n\n    if left < len(heap) and heap[left] > heap[right]:\n        heap[index], heap[left] = heap[left], heap[index]\n\n        heapify(heap, left)\n    elif right < len(heap):\n        heap[index], heap[right] = heap[right], heap[index]\n\n        heapify(heap, right)\n\n\ndef insert(heap: List[int], value: int) -> None:\n    heapify(heap, len(heap) - 1)\n    heap.append(value)\n\n\ndef delete(heap: List[int], index: int) -> None:\n    if index < 0 or index >= len(heap):\n        return\n\n    value = heap[index]\n    heap[index] = heap[len(heap) - 1]\n    heapify(heap, 0)\n\n    return value\n\n\ndef heapify_sort(heap: List[int]) -> None:\n    for i in range(len(heap) // 2, -1, -1):\n        delete(heap, i)\n\n    for i in range(len(heap) - 1, 0, -1):\n        heapify(heap, i)\n\n\nif __name__ == \"__main__\":\n    heap: List[int] = [1, 2, 3, 4, 5, 6, 7]\n    insert(heap, 9)\n    insert(heap, 8)\n    insert(heap, 7)\n    insert(heap, 6)\n    insert(heap, 5)\n    heapify_sort(heap)\n    assert heap == [1, 2, 3, 4, 5, 6, 7]\n\n    heap = [1, 2, 3, 4, 5, 6, 7]\n    insert(heap, 9)"
    },
    {
      "rank": 24,
      "score": 9.712352906758433,
      "candidate": "class Heap:\n\n    def __init__(self, array):\n        self.array = array\n        self.length = len(array)\n\n    def insert(self, item):\n        if self.length == 0:\n            self.array.append(item)\n        else:\n            self.heapify(self.array, 0, self.length - 1)\n\n    def heapify(self, array, start, end):\n        if start == end:\n            return\n\n        mid = (start + end) // 2\n\n        if array[start] > array[mid]:\n            array[start], array[mid] = array[mid], array[start]\n            self.heapify(array, start, mid - 1)\n            self.heapify(array, mid + 1, end)\n\n    def delete(self):\n        if self.length == 0:\n            return\n\n        self.array[0], self.array[self.length] = self.array[self.length], self.array[0]\n        self.length -= 1\n        self.heapify(self.array, 0, self.length - 1)\n\n    def get_min(self):\n        if self.length == 0:\n            return\n\n        return self.array[0]\n\n    def print_heap(self):\n        print(self.array)\n\n\nif __name__ == '__main__':\n    heap = Heap([6, 4, 3, 2, 1])\n    heap.insert(5)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()"
    },
    {
      "rank": 25,
      "score": 9.61558428250447,
      "candidate": "from heapq import heappop, heappush\n\nclass Heap:\n    def __init__(self, data):\n        self.heap = [x for x in data]\n        self.size = len(data)\n\n    def insert(self, data):\n        heappush(self.heap, data)\n        self.size -= 1\n\n    def delete(self):\n        if self.size == 0:\n            return\n        data = heappop(self.heap)\n        self.size -= 1\n        return data\n\n    def __str__(self):\n        return str(self.heap)\n\n\nif __name__ == \"__main__\":\n    h = Heap([4, 5, 6, 7, 8, 9])\n    h.insert(4)\n    h.insert(5)\n    h.insert(6)\n    h.insert(7)\n    h.insert(8)\n    h.insert(9)\n    print(h)\n    print(h.delete())\n    print(h)\n    print(h.delete())\n    print(h)\n    print(h.delete())\n    print(h)\n    print(h)\n    print(h)"
    },
    {
      "rank": 26,
      "score": 9.490485767791258,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, val):\n        new_node = Node(val)\n        if self.head:\n            new_node.left = self.head\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.head = new_node\n            self.tail = new_node\n\n    def delete(self):\n        if self.head is None:\n            return\n\n        if self.head.val > self.tail.val:\n            temp = self.head\n            self.head = self.head.left\n            self.head.right = temp\n\n        elif self.head.val < self.tail.val:\n            temp = self.tail\n            self.tail = self.tail.right\n            self.tail.left = temp\n\n        elif self.head.val == self.tail.val:\n            self.head = None\n            self.tail = None\n\n        else:\n            temp = self.head\n            self.head = self.head.left\n            self.head.right = temp\n\n        if self.head is None:\n            self.tail = None\n\n    def print_heap(self):\n        if self.head:\n            print(self.head.val)\n            self.print_heap(self.head.left)\n            self.print_heap(self.head.right)\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    heap.insert(8)\n    heap.insert(9)\n    heap.insert(10)\n    heap.insert(11)\n    heap.print_heap()\n    heap.delete()\n    heap.print_"
    },
    {
      "rank": 27,
      "score": 9.370583536698913,
      "candidate": "class Heap:\n\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, data):\n        self.heap.append(data)\n        self.heap = self.heap[1:]\n        self.heap.sort()\n\n    def delete(self):\n        if self.heap:\n            return self.heap.pop()\n        else:\n            return None\n\n    def size(self):\n        return len(self.heap)\n\n\nif __name__ == \"__main__\":\n    h = Heap()\n    h.insert(1)\n    h.insert(3)\n    h.insert(2)\n    h.insert(4)\n    h.insert(5)\n\n    print(h.delete())\n    print(h.size())"
    },
    {
      "rank": 28,
      "score": 9.234050852198141,
      "candidate": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n\n    def insert(self, data):\n        new_node = Node(data)\n\n        if self.head is None:\n            self.head = new_node\n            return\n\n        cur = self.head\n        while cur.right is not None:\n            if cur.data > cur.right.data:\n                cur.data, cur.right.data = cur.right.data, cur.data\n            else:\n                cur = cur.right\n\n    def delete(self):\n        if self.head is None:\n            return\n\n        cur = self.head\n        while cur.right is not None:\n            if cur.data < cur.right.data:\n                cur.data, cur.right.data = cur.right.data, cur.data\n            else:\n                cur = cur.right\n\n        cur.data = self.head.data\n        self.head = self.head.right\n\n    def display(self):\n        if self.head is None:\n            return\n\n        cur = self.head\n        while cur.right is not None:\n            print(cur.data, end=' ')\n            cur = cur.right\n\n\nheap = Heap()\nheap.insert(5)\nheap.insert(3)\nheap.insert(2)\nheap.insert(1)\nheap.insert(6)\nheap.insert(4)\nheap.insert(8)\nheap.insert(7)\nheap.insert(8)\nheap.insert(9)\nheap.insert(0)\nheap.insert(3)\nheap.insert(2)\nheap.insert(1)\nheap.insert(6)\nheap.insert(4)\nheap.insert(8)\nheap.insert(7)\nheap.insert(8)\nheap.insert(9)\nheap.insert(0)\nheap.insert(4)\nheap.insert(8)\nheap.insert(7)\nheap.insert(9)\nheap.insert"
    },
    {
      "rank": 29,
      "score": 9.21346272767743,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def insert(self, val):\n        node = Node(val)\n        if not self.head:\n            self.head = node\n            self.size += 1\n            return\n\n        while self.head.right:\n            if self.head.right.val < node.val:\n                self.head = self.head.right\n            else:\n                break\n\n        if not self.head.right:\n            self.head.right = node\n            self.size += 1\n            return\n\n        self.head.right = node\n        self.size += 1\n\n    def delete(self):\n        if self.size == 0:\n            return\n\n        if self.head.val == self.head.right.val:\n            self.head = self.head.right\n            self.size -= 1\n            return\n\n        if self.head.val > self.head.right.val:\n            self.head.right = self.head.right.left\n            self.size -= 1\n            return\n\n        if self.head.val == self.head.right.val:\n            self.head.right = self.head.right.right\n            self.size -= 1\n            return\n\n        self.head = self.head.right\n        self.size -= 1\n        self.head.right = None\n        self.size -= 1\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(5)\n    heap.insert(6)\n\n    assert heap.size == 5\n    assert heap.head.val == 1\n    assert heap.head.left.val == 2\n    assert heap.head.right.val == 3\n    assert heap.head.right.left.val == 4\n    assert heap.head.right"
    },
    {
      "rank": 30,
      "score": 9.205959372648458,
      "candidate": "class Heap(object):\n    def __init__(self):\n        self.data = []\n\n    def insert(self, item):\n        self.data.append(item)\n        self.heapify(len(self.data)-1)\n\n    def heapify(self, index):\n        while index > 0 and self.data[index] > self.data[index-1]:\n            self.data[index], self.data[index-1] = self.data[index-1], self.data[index]\n            index -= 1\n\n    def delete_min(self):\n        self.data[0], self.data[len(self.data)-1] = self.data[len(self.data)-1], self.data[0]\n        self.heapify(0)\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.delete_min()\n    print(heap.data)"
    },
    {
      "rank": 31,
      "score": 9.183391466815202,
      "candidate": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n        self._heapify(len(self.heap)-1)\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return None\n        return self.heap.pop()\n\n    def _heapify(self, i):\n        parent = (i - 1)//2\n        if parent >= 0 and self.heap[parent] > self.heap[i]:\n            self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]\n            self._heapify(parent)\n\n\nif __name__ == \"__main__\":\n    m = MinHeap()\n    m.insert(1)\n    m.insert(3)\n    m.insert(5)\n    m.insert(7)\n    m.insert(9)\n    m.insert(11)\n    m.insert(13)\n    m.insert(15)\n    m.insert(17)\n    m.insert(19)\n    m.insert(23)\n    m.insert(25)\n    m.insert(29)\n    m.insert(31)\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_min())\n    print(m.delete_"
    },
    {
      "rank": 32,
      "score": 9.177268828905222,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.size += 1\n        self.heapify(self.size)\n\n    def heapify(self, size):\n        parent = size // 2\n        while parent > 0:\n            if self.heap[parent] > self.heap[parent + 1]:\n                self.heap[parent], self.heap[parent + 1] = self.heap[parent + 1], self.heap[parent]\n            parent = parent // 2\n\n    def delete(self):\n        if self.size == 0:\n            return\n        self.heap[0], self.heap[self.size] = self.heap[self.size], self.heap[0]\n        self.size -= 1\n        self.heapify(0)\n\n\nheap = Heap()\nheap.insert(3)\nheap.insert(4)\nheap.insert(5)\nheap.insert(2)\nheap.insert(1)\nheap.delete()\nprint(heap.heap)"
    },
    {
      "rank": 33,
      "score": 9.122564458729856,
      "candidate": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n        self.heap.sort()\n\n    def delete_min(self):\n        if len(self.heap) > 0:\n            min_item = self.heap[0]\n            self.heap[0] = self.heap.pop()\n            self.heap.sort()\n            return min_item\n\n    def print_heap(self):\n        for i in self.heap:\n            print(i, end=\" \")\n\n\nif __name__ == \"__main__\":\n    heap = MinHeap()\n    heap.insert(5)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(6)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(7)\n    heap.print_heap()\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())\n    print(heap.delete_min())\n    print(heap.print_heap())"
    },
    {
      "rank": 34,
      "score": 8.973005557553902,
      "candidate": "import heapq\n\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Heap:\n    def __init__(self):\n        self.size = 0\n        self.heap = []\n\n    def insert(self, val):\n        node = Node(val)\n        heapq.heappush(self.heap, node)\n        self.size += 1\n\n    def delete(self):\n        if self.size == 0:\n            return\n        node = heapq.heappop(self.heap)\n        if self.size == 1:\n            self.heap.pop()\n        else:\n            self.heap.pop()\n            self.size -= 1\n        return node.val\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())"
    },
    {
      "rank": 35,
      "score": 8.95994420569242,
      "candidate": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, e):\n        self.heap.append(e)\n        self._heapify(len(self.heap) - 1)\n\n    def pop(self):\n        if self.heap:\n            return self.heap[0]\n        else:\n            raise IndexError(\"Heap is empty\")\n\n    def _heapify(self, pos):\n        while pos > 0:\n            parent = (pos - 1) // 2\n            if self.heap[pos] > self.heap[parent]:\n                self.heap[pos], self.heap[parent] = self.heap[parent], self.heap[pos]\n            pos = parent\n\n\nif __name__ == \"__main__\":\n    heap = MinHeap()\n    heap.push(1)\n    heap.push(2)\n    heap.push(3)\n    heap.push(4)\n    heap.push(5)\n    heap.push(6)\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop"
    },
    {
      "rank": 36,
      "score": 8.946210893390457,
      "candidate": "class Heap:\n    def __init__(self, data = []):\n        self.heap = data\n        self.heap.sort()\n        \n    def insert(self, data):\n        self.heap.append(data)\n        self.heap.sort()\n        \n    def delete(self):\n        if self.heap:\n            self.heap.pop()\n            self.heap.sort()\n        \n    def display(self):\n        print(self.heap)\n        \n        \nif __name__ == \"__main__\":\n    heap = Heap([5,4,3,2,1])\n    heap.insert(2)\n    heap.insert(4)\n    heap.insert(1)\n    heap.delete()\n    heap.display()"
    },
    {
      "rank": 37,
      "score": 8.92876693971089,
      "candidate": "def insert_heap(heap, element):\n    heap.append(element)\n    heapify(heap)\n\n\ndef heapify(heap):\n    for i in range(len(heap) // 2, -1, -1):\n        heap[i], heap[0] = heap[0], heap[i]\n        heap.pop()\n\n\ndef delete_min(heap):\n    if len(heap) > 1:\n        root = heap[0]\n        heap[0] = heap[len(heap) - 1]\n        heapify(heap)\n        return root\n\n\ndef main():\n    heap = [2, 3, 1, 1, 5, 6, 4]\n    insert_heap(heap, 5)\n    print(delete_min(heap))\n    print(heap)\n\n\nmain()"
    },
    {
      "rank": 38,
      "score": 8.910084504002544,
      "candidate": "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap.sort()\n        self.heap.append(None)\n\n    def delete(self):\n        self.heap.pop()\n        self.heap.sort()\n\n    def print_heap(self):\n        for i in self.heap:\n            print(i, end=' ')\n        print()\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(5)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.delete()\n    heap.print_heap()"
    },
    {
      "rank": 39,
      "score": 8.902145503295483,
      "candidate": "from heapq import heappush, heappop\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        heappush(self.heap, val)\n\n    def delete(self):\n        if self.heap:\n            return heappop(self.heap)\n\n    def print(self):\n        print(self.heap)\n\n    def __str__(self):\n        return str(self.heap)\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.print()\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.print())"
    },
    {
      "rank": 40,
      "score": 8.85571690049604,
      "candidate": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\nclass Heap:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, value):\n        new_node = Node(value)\n        if self.root is None:\n            self.root = new_node\n        else:\n            new_node.left = self.root\n            self.root = new_node\n\n    def delete(self):\n        if self.root is None:\n            return\n        if self.root.right is None:\n            self.root = self.root.left\n            return\n        new_node = self.root\n        self.root = new_node.right\n        new_node.right = None\n\n    def print_heap(self):\n        if self.root is None:\n            return\n        node = self.root\n        while node.left is not None:\n            print(node.value, end=\" \")\n            node = node.left\n        print(node.value)\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()"
    },
    {
      "rank": 41,
      "score": 8.855395696632057,
      "candidate": "from typing import List\n\n\nclass HeapNode:\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.left = None\n        self.right = None\n\n\ndef insert_data(heap: List[HeapNode], data: int) -> None:\n    if len(heap) == 0:\n        return\n\n    if heap[0].data > data:\n        heap[0] = HeapNode(data)\n        return\n\n    if heap[0].data == data:\n        return\n\n    if heap[0].left is None:\n        heap[0].left = HeapNode(data)\n        return\n\n    heap[0].left.left = HeapNode(data)\n    return\n\n\ndef delete_data(heap: List[HeapNode], data: int) -> None:\n    if len(heap) == 0:\n        return\n\n    if heap[0].data > data:\n        return\n\n    if heap[0].data == data:\n        return\n\n    if heap[0].left is None:\n        heap[0].left = None\n        return\n\n    if heap[0].left.left is None:\n        return\n\n    heap[0].left.left = None\n    return\n\n\nif __name__ == '__main__':\n    heap = [HeapNode(i) for i in range(5)]\n    print(heap)\n    insert_data(heap, 1)\n    print(heap)\n    delete_data(heap, 2)\n    print(heap)"
    },
    {
      "rank": 42,
      "score": 8.8281618090209,
      "candidate": "from heapq import heapify, heappush, heappop\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def insert(self, val):\n        if self.head is None:\n            self.head = Node(val)\n            self.tail = self.head\n        else:\n            heappush(self.head.right, Node(val))\n            self.size += 1\n\n    def delete(self):\n        if self.head is None:\n            return None\n        if self.tail.left is None:\n            return self.tail.val\n        else:\n            temp = heappop(self.head.right)\n            temp.left = None\n            self.size -= 1\n            return temp.val\n\n    def print_heap(self):\n        if self.head is None:\n            print(\"heap is empty\")\n        else:\n            print(self.head.val)\n            self.print_heap(self.head.right)\n\nheap = Heap()\nheap.insert(1)\nheap.insert(2)\nheap.insert(3)\nheap.insert(4)\nheap.insert(5)\nheap.insert(6)\nheap.insert(7)\nheap.print_heap()\nprint(heap.delete())\nprint(heap.print_heap())"
    },
    {
      "rank": 43,
      "score": 8.81367773444215,
      "candidate": "from typing import List\n\n\nclass HeapNode:\n    def __init__(self, val, parent=None):\n        self.val = val\n        self.parent = parent\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, val: int) -> None:\n        node = HeapNode(val)\n        if not self.head:\n            self.head = node\n            self.tail = node\n        else:\n            parent = self.head\n            while parent.parent:\n                if parent.val < val:\n                    parent = parent.parent\n                else:\n                    parent = parent.parent\n            parent.parent = node\n            self.tail = node\n\n    def delete(self) -> None:\n        if not self.head:\n            return\n        if self.head.val == self.tail.val:\n            self.head = self.head.parent\n            self.tail = self.tail.parent\n            self.tail.val = None\n        else:\n            parent = self.head\n            while parent.parent:\n                if parent.val > self.tail.val:\n                    parent = parent.parent\n                else:\n                    break\n            parent.parent = self.tail\n            self.tail = self.tail.parent\n\n    def __str__(self) -> str:\n        if not self.head:\n            return 'Empty Heap'\n        return str(self.head.val)\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    for i in range(5):\n        heap.insert(i)\n    for i in range(5):\n        print(heap)\n        heap.delete()\n        print(heap)"
    },
    {
      "rank": 44,
      "score": 8.750282588864879,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def push(self, val):\n        self.heap.append(val)\n        self.size += 1\n\n    def pop(self):\n        if self.size == 0:\n            return\n        self.heap.pop()\n        self.size -= 1\n\n    def peek(self):\n        return self.heap[0]\n\n    def __repr__(self):\n        return f\"Heap: {self.heap}\"\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.push(1)\n    heap.push(2)\n    heap.push(3)\n    heap.push(4)\n    heap.push(5)\n    print(heap)\n    heap.pop()\n    print(heap)\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())\n    print(heap.pop())"
    },
    {
      "rank": 45,
      "score": 8.715724466237427,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heapify(h):\n    while len(h) > 1:\n        heappush(h, heappop(h))\n\n\ndef heap_insert(h, item):\n    heapify(h)\n    heappush(h, item)\n\n\nif __name__ == \"__main__\":\n    heap_insert([3, 1, 2, 4, 5], 5)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 4)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 3)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 1)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 4)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 3)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 1)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 4)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 3)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 1)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 4)\n    print(h)\n    heap_insert([2, 1, 3, 4, 5], 2)\n    print("
    },
    {
      "rank": 46,
      "score": 8.623000730200317,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n        self.heap_size = 0\n\n    def insert(self, item):\n        self.heap.append(item)\n        self.heap_size += 1\n        self.heapify(self.heap_size)\n\n    def heapify(self, size):\n        while size > 0:\n            parent = (size - 1) // 2\n            if self.heap[parent] > self.heap[size]:\n                temp = self.heap[size]\n                self.heap[size] = self.heap[parent]\n                self.heap[parent] = temp\n            size = parent\n\n    def delete_min(self):\n        if self.heap_size == 0:\n            return None\n\n        min_element = self.heap[0]\n        self.heap[0] = self.heap[self.heap_size]\n        self.heap_size -= 1\n\n        temp = self.heap[0]\n        self.heap[0] = temp\n\n        self.heapify(0)\n\n        return min_element\n\n\ndef main():\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 47,
      "score": 8.616253589228675,
      "candidate": "from heapq import heappush, heappop\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        heappush(self.heap, item)\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return\n        item = heappop(self.heap)\n        if len(self.heap) == 1:\n            return item\n        return self.delete()\n\n    def __len__(self):\n        return len(self.heap)\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(9)\n    heap.insert(8)\n    heap.insert(7)\n    heap.insert(6)\n    heap.insert(5)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    print(heap)\n    print(heap.delete())\n    print(heap)"
    },
    {
      "rank": 48,
      "score": 8.610076160146226,
      "candidate": "from heapq import heappush, heappop\n\ndef heapify(arr):\n    # O(n) space\n    for i in range(len(arr)-1, 0, -1):\n        heappush(arr, heappop(arr))\n\ndef insert(arr, item):\n    # O(1) space\n    heapify(arr)\n    arr.append(item)\n\n# Test cases\n\narr = [4, 2, 1, 3, 5, 6]\ninsert(arr, 3)\ninsert(arr, 7)\ninsert(arr, 1)\nprint(arr)"
    },
    {
      "rank": 49,
      "score": 8.608819999274287,
      "candidate": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def insert(self, data):\n        new_node = Node(data)\n\n        if self.head is None:\n            self.head = new_node\n        else:\n            current_node = self.head\n            while current_node.next:\n                if current_node.data < new_node.data:\n                    new_node.next = current_node.next\n                    current_node = current_node.next\n                else:\n                    break\n\n            new_node.next = current_node\n\n        self.tail = new_node\n        self.size += 1\n        self.rebuild()\n\n    def rebuild(self):\n        if self.size <= 1:\n            return\n\n        current_node = self.head\n        while current_node.next:\n            current_node = current_node.next\n\n        current_node.next = self.tail\n        self.tail = current_node\n        self.size -= 1\n        self.rebuild()\n\n    def delete_smallest(self):\n        if self.head is None:\n            return\n\n        new_node = self.head\n        current_node = new_node.next\n        while current_node:\n            if current_node.data < new_node.data:\n                new_node.data = current_node.data\n                current_node = current_node.next\n            else:\n                break\n\n        self.head = new_node\n        self.size -= 1\n        self.rebuild()\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    heap.insert(8)\n\n    print(heap.head)\n    print(heap"
    },
    {
      "rank": 50,
      "score": 8.606486429141842,
      "candidate": "class Heap:\n    def __init__(self, max_heap_size):\n        self.max_heap_size = max_heap_size\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n\n        while len(self.heap) > 1:\n            if self.heap[0] > self.heap[1]:\n                self.heap[0], self.heap[1] = self.heap[1], self.heap[0]\n            else:\n                break\n\n    def delete(self):\n        if len(self.heap) > 1:\n            self.heap[0], self.heap[1] = self.heap[1], self.heap[0]\n            self.heap = self.heap[1:]\n\n    def print_heap(self):\n        for i in range(len(self.heap)):\n            print(self.heap[i], end=' ')\n\n\nif __name__ == '__main__':\n    h = Heap(3)\n    h.insert(5)\n    h.insert(6)\n    h.insert(2)\n    h.insert(7)\n    h.print_heap()\n    h.delete()\n    h.print_heap()\n    h.delete()\n    h.print_heap()"
    },
    {
      "rank": 51,
      "score": 8.565425580227462,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n\n        # Find the smallest item\n        smallest_index = 0\n        for i in range(len(self.heap)):\n            if self.heap[i] < self.heap[smallest_index]:\n                smallest_index = i\n\n        if smallest_index == 0:\n            return\n\n        # Swap the smallest item with the last item in the heap\n        self.heap[smallest_index], self.heap[0] = self.heap[0], self.heap[smallest_index]\n\n        # Delete the smallest item from the heap\n        self.heap.pop()\n\n        # Recalculate the index of the smallest item\n        # since we are not deleting it from the heap\n        smallest_index = 0\n        for i in range(len(self.heap)):\n            if self.heap[i] < self.heap[smallest_index]:\n                smallest_index = i\n\n        # Swap the smallest item with the last item in the heap\n        self.heap[smallest_index], self.heap[0] = self.heap[0], self.heap[smallest_index]\n\n        # Recalculate the index of the smallest item\n        # since we are not deleting it from the heap\n        smallest_index = 0\n        for i in range(len(self.heap)):\n            if self.heap[i] < self.heap[smallest_index]:\n                smallest_index = i\n\n        # Swap the smallest item with the last item in the heap\n        self.heap[smallest_index], self.heap[0] = self.heap[0], self.heap[smallest_index]\n\n        # Recalculate the index of the smallest item\n        # since we are not deleting it from the heap\n        smallest_index = 0\n        for i in range(len(self.heap)):\n            if self.heap[i] < self.heap[smallest_index]:\n                smallest_index = i\n\n        # Swap the smallest item with the last item in the heap\n        self.heap[smallest_index"
    },
    {
      "rank": 52,
      "score": 8.542875062379007,
      "candidate": "class Heap:\n    def __init__(self, val):\n        self.val = val\n        self.heap = []\n    \n    def insert(self, val):\n        heapq.heappush(self.heap, val)\n        while len(self.heap) > 1:\n            heapq.heappop(self.heap)\n            heapq.heappush(self.heap, val)\n    \n    def delete_smallest(self):\n        if len(self.heap) > 1:\n            heapq.heappop(self.heap)\n\n    def print_heap(self):\n        print(self.heap)\n\n\nif __name__ == '__main__':\n    heap = Heap(5)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.print_heap()\n    heap.delete_smallest()\n    heap.print_heap()\n    heap.insert(1)\n    heap.print_heap()\n    heap.insert(3)\n    heap.print_heap()\n    heap.insert(2)\n    heap.print_heap()\n    heap.delete_smallest()\n    heap.print_heap()\n    heap.insert(4)\n    heap.print_heap()\n    heap.insert(5)\n    heap.print_heap()\n    heap.delete_smallest()\n    heap.print_heap()\n    heap.insert(1)\n    heap.print_heap()\n    heap.insert(3)\n    heap.print_heap()\n    heap.insert(2)\n    heap.print_heap()\n    heap.insert(4)\n    heap.print_heap()\n    heap.insert(5)\n    heap.print_heap()\n    heap.delete_smallest()\n    heap.print_heap()\n    heap.insert(1)\n    heap.print_heap()\n    heap.insert(3)\n    heap.print_heap()\n    heap.insert(2)\n    heap.print_heap()\n    heap.insert(4)\n    heap.print_heap()\n    heap.insert(5)"
    },
    {
      "rank": 53,
      "score": 8.53012858503943,
      "candidate": "from heapq import heapify, heappop\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, x):\n        heappush(self.heap, x)\n\n    def delete(self):\n        if not self.heap:\n            return None\n        x = heappop(self.heap)\n        self.heap.append(x)\n        return x\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(4)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(3)\n    print(heap.heap)\n    print(heap.delete())\n    print(heap.heap)"
    },
    {
      "rank": 54,
      "score": 8.499905739299377,
      "candidate": "class MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap.sort()\n\n    def delete(self):\n        if self.heap:\n            self.heap[0] = self.heap.pop()\n            self.heap.sort()\n\n    def peek(self):\n        if self.heap:\n            return self.heap[0]\n\n    def __str__(self):\n        return str(self.heap)\n\n\nif __name__ == \"__main__\":\n    minHeap = MinHeap()\n    minHeap.insert(1)\n    minHeap.insert(2)\n    minHeap.insert(3)\n    minHeap.insert(4)\n    minHeap.insert(5)\n    minHeap.insert(6)\n    minHeap.insert(7)\n    print(minHeap)\n    minHeap.delete()\n    print(minHeap)\n    minHeap.insert(8)\n    print(minHeap)\n    minHeap.insert(9)\n    print(minHeap)\n    minHeap.insert(10)\n    print(minHeap)\n    minHeap.insert(11)\n    print(minHeap)\n    print(minHeap)\n    print(minHeap)\n    print(minHeap)"
    },
    {
      "rank": 55,
      "score": 8.492983219118464,
      "candidate": "import heapq\n\n\nclass Solution:\n    def heapify(self, h):\n        while len(h) > 1:\n            min_idx = heapq.heappop(h)\n            heapq.heappush(h, min_idx)\n\n    def heapify_1(self, h):\n        while len(h) > 1:\n            min_idx = heapq.heappop(h)\n            heapq.heappush(h, min_idx)\n            heapq.heappush(h, min_idx)\n\n    def insert(self, nums, v):\n        self.heapify(nums)\n        heapq.heappush(nums, v)\n\n    def delete(self, nums):\n        self.heapify_1(nums)\n        return heapq.heappop(nums)\n\n\nif __name__ == \"__main__\":\n    nums = [2, 1, 5, 6, 3, 4]\n    solution = Solution()\n    solution.insert(nums, 3)\n    solution.insert(nums, 4)\n    solution.insert(nums, 7)\n    solution.insert(nums, 8)\n    solution.delete(nums)\n    print(nums)"
    },
    {
      "rank": 56,
      "score": 8.490324832712195,
      "candidate": "from heapq import heappush, heappop\n\ndef insert(heap, item):\n    heappush(heap, item)\n    return heap\n\ndef delete(heap, item):\n    if len(heap) == 0:\n        return None\n    if heap[0] == item:\n        return heappop(heap)\n    if heap[0] > item:\n        return heappop(heap)\n    return heappop(heap)\n\ndef heap_sort(heap):\n    for i in range(len(heap)-1, -1, -1):\n        if i == 0:\n            continue\n        item = delete(heap, heap[i])\n        insert(heap, item)\n    return heap\n\nif __name__ == \"__main__\":\n    heap = [2, 4, 6, 8, 10, 12]\n    heap = heap_sort(heap)\n    print(heap)"
    },
    {
      "rank": 57,
      "score": 8.48796797856353,
      "candidate": "class HeapNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\ndef heap_insert(heap, value):\n    if not heap:\n        return\n    node = HeapNode(value)\n    node.left = heap[0]\n    heap[0] = node\n    heapify(heap, 0)\n\n\ndef heapify(heap, pos):\n    if pos > 0:\n        child = pos * 2 + 1\n        if child > len(heap) or heap[child] > heap[pos]:\n            heap[pos], heap[child] = heap[child], heap[pos]\n            heapify(heap, child)\n\n\ndef heap_delete(heap):\n    if not heap:\n        return\n    node = heap[0]\n    heap[0] = heap.pop()\n    heapify(heap, 0)\n\n\nif __name__ == '__main__':\n    heap = [1, 2, 3, 4, 5]\n    heap_insert(heap, 5)\n    heap_insert(heap, 2)\n    heap_insert(heap, 1)\n    heap_delete(heap)\n    assert heap == [2, 1, 3, 4, 5]"
    },
    {
      "rank": 58,
      "score": 8.478208546788407,
      "candidate": "from typing import List\n\n\nclass Heap:\n    def __init__(self) -> None:\n        self.heap: List[int] = []\n\n    def insert(self, val: int) -> None:\n        self.heap.append(val)\n        self.heap.sort()\n\n    def delete_min(self) -> int:\n        if len(self.heap) == 0:\n            return\n\n        val = self.heap[0]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        self.heap.sort()\n\n        return val"
    },
    {
      "rank": 59,
      "score": 8.426531424889468,
      "candidate": "class HeapNode:\n    def __init__(self, key, value, left=None, right=None):\n        self.key = key\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def __lt__(self, other):\n        return self.key < other.key\n\n    def __repr__(self):\n        return f\"{self.key} {self.value}\"\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert(self, key, value):\n        new_node = HeapNode(key, value)\n\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n            return\n\n        if self.head.key < new_node.key:\n            self.tail.left = new_node\n            self.tail = new_node\n        else:\n            self.head.right = new_node\n            self.head = new_node\n\n    def delete(self):\n        if self.head is None:\n            return\n\n        if self.head.key == self.tail.key:\n            self.head = self.head.right\n            self.tail = self.head\n            return\n\n        if self.head.key > self.tail.key:\n            new_node = self.head\n            self.head = self.head.left\n            return new_node\n\n        new_node = self.tail\n        self.tail = new_node.right\n        return new_node\n\n    def __str__(self):\n        return f\"{self.head} {self.tail}\"\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1, 2)\n    heap.insert(2, 3)\n    heap.insert(3, 4)\n    heap.insert(4, 5)\n    heap.insert(5, 6)\n    heap.insert(6, 7)\n    heap.insert(7, 8)\n    heap.insert(8, 9)\n\n    print(heap)\n    print(heap.delete"
    },
    {
      "rank": 60,
      "score": 8.408439383654278,
      "candidate": "class Heap:\n    def __init__(self):\n        self.arr = []\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.insert_min()\n\n    def insert_min(self):\n        while len(self.arr) > 1:\n            min_val = self.arr[0]\n            min_idx = 0\n            for i in range(len(self.arr) - 1, 0, -1):\n                if self.arr[i] < min_val:\n                    min_idx = i\n                    break\n            if min_idx == 0:\n                break\n            self.arr[min_idx], self.arr[0] = self.arr[0], self.arr[min_idx]\n\n    def delete_min(self):\n        if len(self.arr) > 1:\n            min_val = self.arr[0]\n            min_idx = 0\n            for i in range(len(self.arr) - 1, 0, -1):\n                if self.arr[i] == min_val:\n                    min_idx = i\n                    break\n            if min_idx == 0:\n                break\n            self.arr[0], self.arr[min_idx] = self.arr[min_idx], self.arr[0]\n            self.delete_min()\n\n    def print_heap(self):\n        print(self.arr)\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(5)\n    heap.print_heap()\n    heap.delete_min()\n    heap.print_heap()"
    },
    {
      "rank": 61,
      "score": 8.386620303250325,
      "candidate": "from heapq import heappush, heappop\n\n\ndef heapify(arr):\n    for i in range(len(arr)):\n        heappush(arr, -heappop(arr))\n\n\ndef heap_insert(arr, val):\n    heapify(arr)\n    heappush(arr, val)\n\n\nif __name__ == \"__main__\":\n    arr = [1, 2, -1, -3, 5, 4, 7]\n    heap_insert(arr, 10)\n    print(arr)"
    },
    {
      "rank": 62,
      "score": 8.375312293858853,
      "candidate": "from heapq import heappush, heappop\n\n\nclass Heap:\n    def __init__(self, values=[]):\n        self.heap = values\n        self.size = len(self.heap)\n\n    def insert(self, value):\n        heappush(self.heap, value)\n        self.size -= 1\n\n    def delete(self):\n        if self.size < 1:\n            return None\n        return heappop(self.heap)\n\n\nif __name__ == \"__main__\":\n    h = Heap([3, 2, 1, 4, 5])\n    h.insert(6)\n    print(h.heap)\n    print(h.delete())\n    print(h.heap)\n    print(h.delete())\n    print(h.heap)\n    print(h.delete())\n    print(h.heap)\n    print(h.delete())"
    },
    {
      "rank": 63,
      "score": 8.351614956112536,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def push(self, item):\n        self.heap.append(item)\n        self.heap.sort()\n\n    def pop(self):\n        if self.heap:\n            return self.heap.pop()\n        return None\n\n    def __repr__(self):\n        return str(self.heap)\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.push(1)\n    heap.push(2)\n    heap.push(3)\n    heap.push(4)\n    print(heap)\n    heap.pop()\n    print(heap)\n    heap.pop()\n    print(heap)\n    heap.pop()\n    print(heap)\n    heap.pop()\n    print(heap)\n    heap.pop()\n    print(heap)"
    },
    {
      "rank": 64,
      "score": 8.331556294201176,
      "candidate": "class Heap:\n    def __init__(self):\n        self.arr = []\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.heapify(len(self.arr) - 1)\n\n    def heapify(self, idx):\n        while idx > 0 and self.arr[idx] > self.arr[idx - 1]:\n            self.arr[idx], self.arr[idx - 1] = self.arr[idx - 1], self.arr[idx]\n            idx = idx - 1\n\n    def delete(self):\n        if len(self.arr) == 1:\n            return self.arr.pop()\n        elif len(self.arr) == 2:\n            if self.arr[0] > self.arr[1]:\n                return self.arr.pop()\n            else:\n                return self.arr.pop()\n        else:\n            if self.arr[0] > self.arr[1]:\n                min_val = self.arr[1]\n                min_idx = 1\n                for idx in range(1, len(self.arr)):\n                    if self.arr[idx] < min_val:\n                        min_val = self.arr[idx]\n                        min_idx = idx\n                self.arr[1] = self.arr[min_idx]\n                self.heapify(min_idx)\n                return self.arr.pop()\n            else:\n                min_val = self.arr[0]\n                min_idx = 0\n                for idx in range(1, len(self.arr)):\n                    if self.arr[idx] < min_val:\n                        min_val = self.arr[idx]\n                        min_idx = idx\n                self.arr[0] = self.arr[min_idx]\n                self.heapify(min_idx)\n                return self.arr.pop()"
    },
    {
      "rank": 65,
      "score": 8.327375965969855,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n\nclass Heap:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        new_node = Node(val)\n        if self.root is None:\n            self.root = new_node\n        else:\n            new_node.left = self.root\n            self.root = new_node\n\n    def delete_smallest(self):\n        if self.root is None:\n            return\n        else:\n            smallest_node = self.root\n            if smallest_node.left is None:\n                smallest_node.left = self.root\n            else:\n                self.root = smallest_node.left\n            if smallest_node.right is None:\n                smallest_node.right = self.root\n            else:\n                self.root = smallest_node.right\n            return smallest_node\n\n    def __str__(self):\n        if self.root is None:\n            return \"Heap is empty\"\n        else:\n            return str(self.root.val) + \" -> \" + str(self.root.left.val) + \" -> \" + str(self.root.right.val)\n\n\nheap = Heap()\nheap.insert(1)\nheap.insert(2)\nheap.insert(3)\nprint(heap)\nprint(heap.delete_smallest())\nprint(heap)"
    },
    {
      "rank": 66,
      "score": 8.298597569547805,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\nclass Heap:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def insert(self, val):\n        new_node = Node(val)\n        if self.root is None:\n            self.root = new_node\n            self.size += 1\n        else:\n            new_node.next = self.root\n            self.root = new_node\n            self.size += 1\n\n    def delete(self):\n        if self.size == 0:\n            return\n        if self.root is None:\n            return\n        self.size -= 1\n        node = self.root\n        while node.next is not None:\n            node.next.val = node.val\n            node = node.next\n        self.root = node.next\n\n    def print(self):\n        if self.root is None:\n            print(\"heap is empty\")\n            return\n        node = self.root\n        while node.next is not None:\n            print(node.val, end=\" \")\n            node = node.next\n        print(\"\")\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(10)\n    heap.insert(20)\n    heap.insert(30)\n    heap.insert(40)\n    heap.insert(50)\n    heap.insert(60)\n    heap.insert(70)\n    heap.insert(80)\n    heap.insert(90)\n    heap.print()\n    heap.delete()\n    heap.print()"
    },
    {
      "rank": 67,
      "score": 8.294940769211511,
      "candidate": "class Heap:\n    def __init__(self, value):\n        self.value = value\n        self.left = 0\n        self.right = len(value) - 1\n\n    def __repr__(self):\n        return str(self.value)\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __le__(self, other):\n        return self.value <= other.value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __ge__(self, other):\n        return self.value >= other.value\n\n    def __gt__(self, other):\n        return self.value > other.value\n\n    def __ne__(self, other):\n        return self.value!= other.value\n\n    def __add__(self, other):\n        return Heap([self.value + other.value])\n\n    def __sub__(self, other):\n        return Heap([self.value - other.value])\n\n    def __mul__(self, other):\n        return Heap([self.value * other.value])\n\n    def __truediv__(self, other):\n        return Heap([self.value / other.value])\n\n    def __floordiv__(self, other):\n        return Heap([self.value // other.value])\n\n    def __mod__(self, other):\n        return Heap([self.value % other.value])\n\n    def __pow__(self, other):\n        return Heap([self.value ** other.value])\n\n    def __neg__(self):\n        return Heap([-self.value])\n\n    def __abs__(self):\n        return Heap([abs(self.value)])\n\n    def __invert__(self):\n        return Heap([-self.value])\n\n    def __add_one(self):\n        return Heap([self.value + 1])\n\n    def __sub_one(self):\n        return Heap([self.value - 1])\n\n    def __mul_one(self):\n        return Heap([self.value * 1])\n\n    def __truediv_"
    },
    {
      "rank": 68,
      "score": 8.280613371145561,
      "candidate": "class Heap:\n\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n\n        if len(self.heap) > 1:\n            self.heap = self.heap[1:]\n\n        return self.heap\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return None\n\n        # pop element from end\n        value = self.heap.pop()\n\n        # if element is smaller than the last element in the heap\n        if self.heap[0] > value:\n            # pop element from the left\n            self.heap = self.heap[1:]\n\n        return value\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(4)\n\n    print(heap.delete())"
    },
    {
      "rank": 69,
      "score": 8.251903304236286,
      "candidate": "class Heap:\n    def __init__(self, data=[]):\n        self.data = data\n\n    def insert(self, val):\n        self.data.append(val)\n        self.min_heapify(len(self.data) - 1)\n\n    def delete(self):\n        if len(self.data) > 0:\n            self.data.pop()\n            self.min_heapify(0)\n\n    def min_heapify(self, pos):\n        left = pos * 2 + 1\n        right = pos * 2 + 2\n        if left < len(self.data) and self.data[left] > self.data[pos]:\n            self.data[pos], self.data[left] = self.data[left], self.data[pos]\n        if right < len(self.data) and self.data[right] > self.data[pos]:\n            self.data[pos], self.data[right] = self.data[right], self.data[pos]\n        if pos < len(self.data) - 1 and self.data[pos] > self.data[pos + 1]:\n            self.data[pos], self.data[pos + 1] = self.data[pos + 1], self.data[pos]\n        if left < len(self.data) - 1 and self.data[pos] > self.data[pos - 1]:\n            self.data[pos], self.data[pos - 1] = self.data[pos - 1], self.data[pos]\n        if right < len(self.data) - 1 and self.data[pos] > self.data[pos + 1]:\n            self.data[pos], self.data[pos + 1] = self.data[pos + 1], self.data[pos]\n\n    def print_heap(self):\n        print(self.data)\n\n\nif __name__ == \"__main__\":\n    heap = Heap([1, 2, 3, 4, 5, 6, 7, 8])\n    heap.insert(6)\n    heap.insert(8)\n    heap.insert(7)\n    heap.insert(4)\n    heap.insert(3)"
    },
    {
      "rank": 70,
      "score": 8.214125058964552,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heapify(0)\n\n    def insert_min(self, val):\n        if len(self.heap) == 0:\n            return\n        min_val = self.heap[0]\n        if val < min_val:\n            self.heap[0] = val\n            self.heapify(0)\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return\n        self.heap.pop()\n        self.heapify(0)\n\n    def heapify(self, parent):\n        child = parent * 2 + 1\n        while child <= len(self.heap):\n            if self.heap[child] > self.heap[parent]:\n                break\n            else:\n                self.heap[child], self.heap[parent] = self.heap[parent], self.heap[child]\n                parent = child\n                child = parent * 2 + 1\n\n\nheap = Heap()\nheap.insert_min(3)\nheap.insert_min(1)\nheap.insert_min(4)\nheap.insert_min(5)\nheap.insert_min(6)\nheap.insert_min(7)\nheap.insert_min(8)\nheap.insert_min(9)\nheap.insert_min(10)\nheap.delete()\n\nprint(heap.heap)"
    },
    {
      "rank": 71,
      "score": 8.212735598038213,
      "candidate": "from typing import List\n\n\nclass Heap:\n    def __init__(self, items: List[int]):\n        self.items = items\n        self.heap_size = len(items)\n        self.heap = [0] * self.heap_size\n\n    def insert(self, item: int) -> None:\n        self.heap[0] = item\n        self.heapify_up()\n\n    def insert_at_index(self, item: int, index: int) -> None:\n        if index < 0 or index >= self.heap_size:\n            return\n        self.heap[index] = item\n        self.heapify_up(index)\n\n    def insert_at_index_end(self, item: int, index: int) -> None:\n        if index < 0 or index >= self.heap_size:\n            return\n        self.heap[index] = item\n        self.heapify_up(index)\n\n    def heapify_up(self, index: int):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.items[parent] > self.items[index]:\n                self.items[parent], self.items[index] = self.items[index], self.items[parent]\n            index = parent\n\n    def heap_delete(self) -> None:\n        if self.heap_size == 0:\n            return\n\n        item = self.heap[0]\n        self.items[0] = self.items[-1]\n        self.heapify_down(0)\n\n    def heapify_down(self, index: int):\n        while index * 2 + 1 < self.heap_size:\n            left_child = index * 2 + 1\n            right_child = index * 2 + 2\n            if left_child < self.heap_size and self.items[left_child] > self.items[index]:\n                left_child = left_child + 1\n            if right_child < self.heap_size and self.items[right_child] > self.items[index]:\n                right_child = right_child + 1\n            if left_child < right_child:\n                self"
    },
    {
      "rank": 72,
      "score": 8.2048573255218,
      "candidate": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n\nclass Heap:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, data):\n        if not self.root:\n            self.root = Node(data)\n        else:\n            node = self.root\n            while node.left:\n                node = node.left\n            node.left = Node(data)\n\n    def delete_min(self):\n        if not self.root:\n            return\n        node = self.root\n        if self.root.data < node.data:\n            node.left = self.root.left\n        else:\n            self.root = node.left\n        node.data = node.data - 1\n        while self.root.right:\n            node = node.right\n        self.root.right = self.root.right.left\n        return node.data\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    print(heap.delete_min())\n    print(heap.delete_min())\n    print(heap.delete_min())"
    },
    {
      "rank": 73,
      "score": 8.185309335307622,
      "candidate": "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\n\nclass Heap:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def insert(self, key):\n        if self.head is None:\n            self.head = Node(key)\n            self.tail = self.head\n        else:\n            self.tail.next = Node(key)\n            self.tail = self.tail.next\n        self.size += 1\n\n    def delete(self):\n        if self.head is None:\n            return\n\n        key = self.head.key\n        self.head = self.head.next\n        self.size -= 1\n\n        if self.head is None:\n            self.tail = None\n\n        return key\n\n    def print_heap(self):\n        if self.head is None:\n            print(\"Heap is empty\")\n            return\n\n        node = self.head\n        while node is not None:\n            print(node.key)\n            node = node.next\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    for i in range(10):\n        heap.insert(i)\n\n    print(heap.delete())\n    heap.print_heap()"
    },
    {
      "rank": 74,
      "score": 8.179564342560925,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, data):\n        self.heap.append(data)\n        self._heapify(len(self.heap) - 1)\n\n    def _heapify(self, position):\n        largest = position\n        while (2 * largest + 1) <= position:\n            if self.heap[largest] > self.heap[2 * largest + 1]:\n                largest = 2 * largest + 1\n            if self.heap[largest] > self.heap[largest + 1]:\n                largest = largest + 1\n        if largest!= position:\n            self.heap[largest], self.heap[position] = self.heap[position], self.heap[largest]\n            self._heapify(largest)\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return\n        if len(self.heap) == 1:\n            self.heap.pop()\n            return\n\n        smallest = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self._heapify(0)\n        return smallest\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())"
    },
    {
      "rank": 75,
      "score": 8.163300679823958,
      "candidate": "from heapq import heappush, heappop\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def add(self, val):\n        heappush(self.heap, val)\n\n    def get_min(self):\n        if len(self.heap) > 0:\n            return heappop(self.heap)\n        else:\n            return None\n\n    def __str__(self):\n        return str(self.heap)\n\n\nheap = Heap()\nheap.add(10)\nheap.add(5)\nheap.add(4)\nheap.add(6)\nheap.add(7)\nheap.add(2)\nheap.add(9)\nprint(heap)\nheap.get_min()\nprint(heap)\nprint(heap.get_min())\nprint(heap.get_min())\nheap.add(1)\nprint(heap)\nheap.get_min()\nprint(heap)\nprint(heap.get_min())\nheap.get_min()\nprint(heap.get_min())\nheap.get_min()\nprint(heap.get_min())\nprint(heap.get_min())\nprint(heap.get_min())\nprint(heap.get_min())\nheap.get_min()\nprint(heap)\nprint(heap.get_min())"
    },
    {
      "rank": 76,
      "score": 8.144125099485041,
      "candidate": "from heapq import heapify, heappush, heappop\n\ndef heapify_heap(h):\n    while len(h) > 1:\n        heappush(h, heappop(h))\n    return h\n\ndef heapify_insert(h, value):\n    heappush(h, value)\n    return h\n\ndef heap_insert(h, value):\n    heapify_heap(h)\n    return heappush(h, value)\n\n\nif __name__ == \"__main__\":\n    h = [1, 2, 3, 4, 5]\n    print(heapify_insert(h, 7))\n    print(heapify_insert(h, 8))\n    print(heapify_insert(h, 9))\n    print(heapify_heap(h))"
    },
    {
      "rank": 77,
      "score": 8.121884567141883,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\ndef heapify(heap, node, parent=None):\n    if node.next is None:\n        return\n\n    # find smallest child\n    left = node.next.left\n    right = node.next.right\n\n    if left is not None:\n        if left.val > node.val:\n            node.val, node.next.val = node.next.val, left\n            heapify(heap, left, node)\n\n    if right is not None:\n        if right.val > node.val:\n            node.val, node.next.val = node.next.val, right\n            heapify(heap, right, node)\n\n    # swap if needed\n    if node.val < heap[0].val:\n        heap[0], heap[node] = heap[node], heap[0]\n\n\ndef insert_node(heap, node):\n    heapify(heap, node)\n\n\ndef heap_sort(heap):\n    for i in range(len(heap) - 1, 0, -1):\n        insert_node(heap, Node(heap[0].val))\n        heap.pop(0)"
    },
    {
      "rank": 78,
      "score": 8.105983444291466,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap = self.heap[1:]\n        self.heap.sort()\n\n    def delete(self):\n        if not self.heap:\n            return\n\n        val = self.heap[0]\n        self.heap = self.heap[1:]\n        self.heap.sort()\n        return val\n\n    def show(self):\n        for i in self.heap:\n            print(i, end=\" \")\n        print()\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(2)\n    heap.insert(4)\n    heap.insert(3)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(8)\n    heap.show()\n    heap.delete()\n    heap.show()"
    },
    {
      "rank": 79,
      "score": 8.093417897505768,
      "candidate": "# Time: O(n)\n# Space: O(1)\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return None\n        min_value = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.heapify_up(0)\n        return min_value\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.heapify_up(len(self.heap) - 1)\n\n    def heapify_up(self, index):\n        while index > 0:\n            parent = (index - 1) // 2\n            if self.heap[parent] > self.heap[index]:\n                self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]\n            index = parent\n\n\nheap = Heap()\nheap.insert(1)\nheap.insert(2)\nheap.insert(3)\nprint(heap.delete_min())"
    },
    {
      "rank": 80,
      "score": 8.08452234024709,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n\n        while len(self.heap) > 1:\n            self.heap.pop(0)\n\n            self.heap.append(self.heap.pop(0))\n\n    def delete(self):\n        if len(self.heap) > 0:\n            return self.heap.pop()\n        else:\n            return None\n\n    def __len__(self):\n        return len(self.heap)\n\n\nif __name__ == \"__main__\":\n    h = Heap()\n    h.insert(2)\n    h.insert(3)\n    h.insert(4)\n    h.insert(5)\n    h.insert(6)\n    print(h.heap)\n    print(h.delete())\n    print(h.heap)"
    },
    {
      "rank": 81,
      "score": 7.990432406683839,
      "candidate": "from heapq import heappush, heappop\n\n\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        heappush(self.heap, item)\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return None\n        else:\n            return heappop(self.heap)\n\n\nif __name__ == \"__main__\":\n    heap = MinHeap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    print(heap.heap)\n    print(heap.delete_min())\n    print(heap.heap)"
    },
    {
      "rank": 82,
      "score": 7.938028884277233,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap.sort()\n\n    def delete_min(self):\n        return self.heap.pop()\n\n    def size(self):\n        return len(self.heap)\n\n\n\n\nheap = Heap()\nheap.insert(2)\nheap.insert(1)\nprint(heap.size())\nheap.delete_min()\nprint(heap.size())"
    },
    {
      "rank": 83,
      "score": 7.915588979966494,
      "candidate": "class Heap(object):\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        self.heap.append(val)\n        self.heap.sort()\n\n    def delete(self):\n        if len(self.heap) == 0:\n            return\n        item = self.heap[0]\n        self.heap.pop(0)\n        self.heap.sort()\n        return item\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())"
    },
    {
      "rank": 84,
      "score": 7.868947655733293,
      "candidate": "from heapq import heappush, heappop\n\nclass Heap:\n\n    def __init__(self):\n        self.data = []\n\n    def insert(self, item):\n        self.data.append(item)\n        heappush(self.data, item)\n\n    def delete(self):\n        if self.data:\n            return heappop(self.data)\n        else:\n            return None\n\n    def peek(self):\n        if self.data:\n            return self.data[0]\n        else:\n            return None\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(6)\n    heap.insert(7)\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())\n    print(heap.delete())"
    },
    {
      "rank": 85,
      "score": 7.84634113240411,
      "candidate": "class Solution:\n    def insert(self, nums: List[int], val: int) -> None:\n        i = len(nums) - 1\n        while i >= 0 and nums[i] > val:\n            nums[i+1] = nums[i]\n            i -= 1\n        nums.append(val)\n        return nums\n\n    def deleteMin(self, nums: List[int]) -> int:\n        i = len(nums) - 1\n        while i >= 0:\n            if nums[i] > nums[i-1]:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n            i -= 1\n        return nums[0]"
    },
    {
      "rank": 86,
      "score": 7.834022619458933,
      "candidate": "import heapq\n\nclass Heap:\n    def __init__(self, array):\n        self.array = array\n        self.size = len(array)\n\n    def delete(self):\n        if self.size > 0:\n            smallest = heapq.heappop(self.array)\n            self.array.append(smallest)\n            self.size -= 1\n            self.size -= 1\n            self.size -= 1\n\n    def insert(self, value):\n        heapq.heappush(self.array, value)\n        self.size += 1\n\n    def print_heap(self):\n        for i in range(self.size):\n            print(self.array[i], end=\" \")\n\n\n# Driver code\nif __name__ == \"__main__\":\n    heap = Heap([1, 2, 3, 4, 5])\n    heap.insert(2)\n    heap.insert(4)\n    heap.insert(5)\n    heap.insert(3)\n    heap.insert(1)\n    heap.insert(0)\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()"
    },
    {
      "rank": 87,
      "score": 7.780351419995229,
      "candidate": "import heapq\n\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def insert(self, val):\n        node = Node(val)\n        heapq.heappush(self.heap, node)\n        self.size += 1\n\n    def delete_smallest(self):\n        if not self.heap:\n            return\n        node = heapq.heappop(self.heap)\n        self.size -= 1\n        return node.val\n\n\nheap = Heap()\nheap.insert(1)\nheap.insert(2)\nheap.insert(3)\nheap.insert(4)\nheap.insert(5)\nprint(heap.heap)\nprint(heap.delete_smallest())\nprint(heap.heap)\nprint(heap.size)"
    },
    {
      "rank": 88,
      "score": 7.738292593776799,
      "candidate": "import heapq\n\n\nclass Node:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, val):\n        node = Node(val)\n        heapq.heappush(self.heap, node)\n\n    def delete_min(self):\n        if len(self.heap) == 0:\n            return\n        min_node = heapq.heappop(self.heap)\n        if min_node.left:\n            heapq.heappush(self.heap, min_node.left)\n        if min_node.right:\n            heapq.heappush(self.heap, min_node.right)\n        return min_node.val\n\n\ndef test():\n    heap = Heap()\n    heap.insert(1)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(5)\n    assert heap.delete_min() == 1\n    assert heap.delete_min() == 2\n    assert heap.delete_min() == 3\n    assert heap.delete_min() == 4\n    assert heap.delete_min() == 5\n\n\ntest()"
    },
    {
      "rank": 89,
      "score": 7.7320703513377165,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, item):\n        self.heap.append(item)\n\n    def delete(self):\n        if len(self.heap) > 0:\n            self.heap.pop()\n\n    def print_heap(self):\n        for i in self.heap:\n            print(i, end=\" \")\n\n\nif __name__ == '__main__':\n    heap = Heap()\n    heap.insert(5)\n    heap.insert(2)\n    heap.insert(3)\n    heap.insert(4)\n    heap.print_heap()\n    heap.delete()\n    heap.print_heap()\n    heap.insert(6)\n    heap.print_heap()\n    heap.insert(7)\n    heap.print_heap()"
    },
    {
      "rank": 90,
      "score": 7.5819855281879285,
      "candidate": "class Heap:\n    def __init__(self, elements):\n        self.heap = elements\n        self.size = len(elements)\n\n    def delete_smallest(self):\n        if self.size == 0:\n            return\n        if self.size == 1:\n            self.heap.pop()\n            self.size -= 1\n            return\n        if self.heap[0] > self.heap[1]:\n            self.heap.pop()\n        else:\n            self.heap[0] = self.heap.pop()\n        self.size -= 1\n        self.delete_smallest()\n\n    def insert(self, element):\n        self.heap.append(element)\n        self.size += 1\n        self.delete_smallest()\n\n\ndef heap_insert(heap, element):\n    heap.insert(element)\n    heap.delete_smallest()\n\n\nheap = Heap([9, 8, 7, 6, 5, 4, 3, 2, 1])\nheap_insert(heap, 7)\nheap_insert(heap, 6)\nheap_insert(heap, 5)\nheap_insert(heap, 4)\nheap_insert(heap, 3)\nheap_insert(heap, 2)\nheap_insert(heap, 1)\n\nprint(heap.heap)"
    },
    {
      "rank": 91,
      "score": 7.562924366763077,
      "candidate": "class Heap:\n    def __init__(self):\n        self.heap = []\n\n    def __len__(self):\n        return len(self.heap)\n\n    def push(self, item):\n        self.heap.append(item)\n        self._heapify(len(self.heap)-1)\n\n    def _heapify(self, index):\n        while index > 0 and self.heap[index] > self.heap[index-1]:\n            self.heap[index], self.heap[index-1] = self.heap[index-1], self.heap[index]\n            index -= 1\n\n    def pop(self):\n        if self.heap:\n            return self.heap.pop()\n        else:\n            return None\n\n    def delete(self):\n        if self.heap:\n            return self.heap.pop()\n        else:\n            return None\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.push(1)\n    heap.push(2)\n    heap.push(3)\n    heap.push(4)\n    heap.push(5)\n    print(heap.heap)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(6)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(7)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(8)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(9)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(10)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(11)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(12)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(13)\n    print(heap.delete())\n    print(heap.heap)\n    heap.push(14)\n    print(heap.delete())\n    print(heap.heap)\n    heap."
    },
    {
      "rank": 92,
      "score": 7.4878043221155455,
      "candidate": "from heapq import heappush, heappop\n\nclass Heap:\n    def __init__(self, val):\n        self.val = val\n        self.heap = []\n\n    def insert(self, new_val):\n        heappush(self.heap, new_val)\n\n    def delete(self):\n        if not self.heap:\n            return None\n        return heappop(self.heap)\n\n    def __str__(self):\n        return str(self.heap)\n\n\nheap = Heap(3)\nheap.insert(4)\nheap.insert(2)\nheap.insert(1)\nprint(heap)\nprint(heap.delete())\nprint(heap)\nprint(heap.delete())\nprint(heap)"
    },
    {
      "rank": 93,
      "score": 7.4506599871439985,
      "candidate": "class Heap:\n    def __init__(self, values):\n        self.heap = list(values)\n        self.heap.sort()\n\n    def delete_smallest(self):\n        if self.heap:\n            smallest = self.heap[0]\n            self.heap[0] = self.heap.pop()\n            self.heap.sort()\n            return smallest\n        return None\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.heap.sort()\n        return self.heap\n\n\nif __name__ == \"__main__\":\n    heap = Heap([3, 2, 1, 4, 5, 6, 7])\n    print(heap.delete_smallest())\n    print(heap.insert(8))\n    print(heap.insert(6))\n    print(heap.insert(4))\n    print(heap.insert(1))\n    print(heap.insert(5))\n    print(heap.insert(2))\n    print(heap.insert(3))\n    print(heap.insert(7))\n    print(heap.insert(9))\n    print(heap.insert(8))\n    print(heap.insert(5))\n    print(heap.insert(4))\n    print(heap.insert(3))\n    print(heap.insert(2))\n    print(heap.insert(1))\n    print(heap.insert(0))\n    print(heap.insert(6))\n    print(heap.insert(7))\n    print(heap.insert(8))\n    print(heap.insert(5))\n    print(heap.insert(9))\n    print(heap.insert(8))\n    print(heap.insert(4))\n    print(heap.insert(3))\n    print(heap.insert(2))\n    print(heap.insert(1))\n    print(heap.insert(0))\n    print(heap.insert(6))\n    print(heap.insert(7))\n    print(heap.insert(8))\n    print(heap.insert(5))\n    print(heap.insert(4))\n    print(heap.insert(3))\n    print(heap.insert(2))"
    },
    {
      "rank": 94,
      "score": 7.134571892399572,
      "candidate": "from heapq import heappush, heappop\n\n\nclass Heap:\n    def __init__(self):\n        self.data = []\n\n    def insert(self, item):\n        self.data.append(item)\n\n    def delete_min(self):\n        if len(self.data) == 0:\n            return\n        else:\n            item = heappop(self.data)\n            self.data.remove(item)\n            return item\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(5)\n    heap.insert(3)\n    heap.insert(2)\n    heap.insert(1)\n\n    print(heap.delete_min())"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Heap:\n    def __init__(self):\n        self.heap = []\n        self.size = 0\n\n    def insert(self, val):\n        node = Node(val)\n        self.heap.append(node)\n        self.size += 1\n\n    def delete(self):\n        if self.size == 0:\n            return\n\n        node = self.heap.pop()\n        self.size -= 1\n        if node.left:\n            self.heap.append(node.left)\n        if node.right:\n            self.heap.append(node.right)\n\n    def get_min(self):\n        if self.size == 0:\n            return\n\n        return self.heap[0].val\n\n\nif __name__ == \"__main__\":\n    heap = Heap()\n    heap.insert(5)\n    heap.insert(3)\n    heap.insert(4)\n    heap.insert(2)\n    heap.insert(1)\n\n    print(heap.get_min())\n    print(heap.heap)\n    heap.delete()\n    print(heap.heap)\n    heap.insert(5)\n    print(heap.heap)"
    },
    {
      "rank": 96,
      "score": 3.0,
      "candidate": "class Solution:\n    def deleteSmallest(self, h, n):\n        \"\"\"\n        :type h: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify h in-place instead.\n        \"\"\"\n        if n == 0:\n            return\n        l, r = 0, len(h) - 1\n        while l <= r:\n            if h[l] > h[r]:\n                m = l\n                l += 1\n            else:\n                m = r\n                r -= 1\n            if h[l] > h[m]:\n                h[l], h[m] = h[m], h[l]\n                n -= 1\n                m -= 1\n            else:\n                break\n        return"
    },
    {
      "rank": 97,
      "score": 3.0,
      "candidate": "class Heap:\n    def __init__(self, arr):\n        self.arr = arr\n\n    def delete_smallest(self):\n        if not self.arr:\n            return\n\n        min_val = self.arr[0]\n        self.arr.pop(0)\n        self.heapify(min_val)\n\n    def heapify(self, val):\n        left = 2 * val\n        right = 2 * val + 1\n\n        if left < len(self.arr) and self.arr[left] > val:\n            min_val = left\n        if right < len(self.arr) and self.arr[right] > val:\n            min_val = right\n\n        if min_val!= val:\n            self.arr[val], self.arr[min_val] = self.arr[min_val], self.arr[val]\n            self.heapify(min_val)\n\n    def insert(self, val):\n        self.arr.append(val)\n        self.heapify(len(self.arr) - 1)\n\n\nif __name__ == \"__main__\":\n    arr = [4, 5, 1, 2, 3, 6, 7, 8, 9]\n    heap = Heap(arr)\n    heap.delete_smallest()\n    heap.insert(7)\n    heap.insert(2)\n    heap.insert(1)\n    heap.insert(6)\n    heap.insert(8)\n    heap.insert(3)\n    heap.insert(9)\n    heap.insert(5)\n    heap.insert(4)\n    heap.insert(8)\n    heap.insert(7)\n    heap.insert(0)\n\n    print(\"Before deleting:\", arr)\n\n    heap.delete_smallest()\n    print(\"After deleting:\", arr)\n\n    print(\"Before inserting:\", arr)\n\n    heap.insert(3)\n    print(\"After inserting:\", arr)\n\n    print(\"Before inserting:\", arr)\n\n    heap.insert(4)\n    print(\"After inserting:\", arr)\n\n    print(\"Before inserting:\", arr)\n\n    heap.insert(7)"
    },
    {
      "rank": 98,
      "score": 3.0,
      "candidate": "class Solution(object):\n    def deleteSmallest(self, h, n):\n        \"\"\"\n        :type h: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify h in-place instead.\n        \"\"\"\n        # find the smallest element in the heap\n        smallest = -1\n        smallest_index = 0\n        for i in range(len(h)):\n            if smallest == -1 or h[smallest] > h[smallest_index]:\n                smallest = smallest_index\n                smallest_index = i\n        # delete the smallest element\n        h[smallest], h[smallest_index] = h[smallest_index], h[smallest]\n        # find the largest element in the heap\n        largest = len(h) - 1\n        largest_index = 0\n        for i in range(len(h)):\n            if largest == len(h) - 1 or h[largest] > h[largest_index]:\n                largest = largest_index\n                largest_index = i\n        # delete the largest element\n        h[largest], h[largest_index] = h[largest_index], h[largest]\n        # find the smallest element in the heap\n        smallest = len(h) - 1\n        smallest_index = 0\n        for i in range(len(h)):\n            if smallest == 0 or h[smallest] > h[smallest_index]:\n                smallest = smallest_index\n                smallest_index = i\n        # delete the smallest element\n        h[smallest], h[smallest_index] = h[smallest_index], h[smallest]\n        # find the largest element in the heap\n        largest = 0\n        largest_index = len(h) - 1\n        for i in range(len(h)):\n            if largest == len(h) - 1 or h[largest] > h[largest_index]:\n                largest = largest_index\n                largest_index = i\n        # insert a new element\n        h.append(n)\n        # recursive call\n        self.deleteSmallest(h, n)\n\na = Solution()\na.deleteSmallest([1,2"
    },
    {
      "rank": 99,
      "score": 3.0,
      "candidate": "class Solution:\n    def deleteSmallest(self, h: List[int], n: int) -> None:\n        if len(h) < n:\n            return\n        i, j = 0, n - 1\n        while i <= j:\n            if h[i] > h[j]:\n                temp = h[i]\n                h[i] = h[j]\n                j -= 1\n            else:\n                temp = h[j]\n                h[j] = h[i]\n                i += 1\n\n        temp = h[0]\n        h[0] = h[n - 1]\n        h[n - 1] = temp\n\n        i = n - 1\n        while i > 0:\n            temp = h[i]\n            h[i] = h[n - 1]\n            h[n - 1] = temp\n            i -= 1\n\n        return\n\n\ns = Solution()\nprint(s.deleteSmallest([2, 3, 1, 5, 4], 3))"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "class Solution:\n    def deleteSmallest(self, nums: List[int], k: int) -> None:\n        if k == 0:\n            return\n        if k > len(nums):\n            return\n\n        while k > 0:\n            if nums[0] > nums[k]:\n                break\n            nums[0], nums[k] = nums[k], nums[0]\n            k -= 1\n\n        nums.pop()\n\n    def insert(self, nums: List[int], k: int) -> None:\n        if k == 0:\n            return\n        nums.append(k)\n        while len(nums) > 1:\n            self.deleteSmallest(nums, k)\n        nums.pop()"
    }
  ]
}