{
  "timestamp": "2025-09-14T11:54:12.291952",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "humaneval",
  "problem_number": 87,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "if not lst:\n        return []\n\n    result = []\n    lst.sort(key=lambda x: (x[0], x[1]))\n    for row in lst:\n        if row[0] == x:\n            result.append((row[1], row[0]))\n    result.sort(key=lambda x: (x[0], x[1]), reverse=True)\n    return result\n\n\ndef get_column(lst, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n\n    result = []\n    lst.sort(key=lambda x: (x[0], x[1]))\n    for row in lst:\n        if row[1] == y:\n            result.append((row[0], row[1]))\n    result.sort(key=lambda x: (x[0], x[1]), reverse=True)\n    return result\n\n\ndef get_column_with_index(lst, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, un"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "assert len(lst) > 0\n    assert isinstance(lst, list)\n    assert isinstance(x, int)\n    row = []\n    for row_i in lst:\n        row_sorted = sorted(row_i, key=lambda x: x[1])\n        if row_sorted[0][0] == x:\n            row.append(row_sorted[0])\n    return row\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    assert len(lst) > 0\n    assert isinstance(lst, list)\n    assert isinstance(x, int)\n    col = []\n    for row in lst:\n        col_sorted = sorted(row, key=lambda x: x[0])\n        if col_sorted[0][1] == x:\n            col.append(col_sorted[0])\n    return col\n\n\ndef get_diagonal(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows or columns"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "if not lst: return []\n    if not isinstance(lst, list): return lst\n    return sorted([(row, col) for col, row in enumerate(lst) if col == x], reverse=True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst: return []\n    if not isinstance(lst, list): return lst\n    return sorted([(row, col) for row in range(len(lst)) for col in lst[row] if col == x], reverse=True)\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows or columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "rows = []\n    for row in lst:\n        row.sort()\n        if row[x-1]!= None:\n            rows.append((row.index(x-1), x-1))\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    for row in lst:\n        cols.append(row)\n    cols.sort(reverse=True)\n    return cols[x-1]\n\n\ndef get_column_and_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order."
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "if not lst:\n        return []\n    row = []\n    for row_num in range(len(lst)):\n        row.append((row_num, lst[row_num][x]))\n    row.sort(key=lambda x: x[0])\n    row.sort(key=lambda x: x[1], reverse=True)\n    return row\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    col = []\n    for col_num in range(len(lst[0])):\n        col.append((col_num, lst[0][x]))\n    col.sort(key=lambda x: x[0])\n    col.sort(key=lambda x: x[1], reverse=True)\n    return col\n\n\ndef get_column_with_row(lst, x, row_num):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "if not lst:\n        return []\n    row = []\n    for i in lst:\n        for j in i:\n            if j == x:\n                row.append((i.index(x), i.index(x)))\n    return sorted(row, key=lambda x: x[0], reverse=True)\n\n\ndef get_col(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (columns, rows), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    col = []\n    for i in lst:\n        for j in i:\n            col.append((j, i.index(x)))\n    return sorted(col, key=lambda x: x[1], reverse=True)\n\n\ndef get_col_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "if not lst:\n        return []\n    row = []\n    for i in lst:\n        row.append((i[0], i[1]))\n    row.sort(key=lambda x: x[0])\n    row.sort(key=lambda x: x[1], reverse=True)\n    return row"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "rows = []\n    for i in lst:\n        rows.append((i[x-1], x-1))\n        rows.append((x-1, i[x-1]))\n    rows.sort(key=lambda x: x[0])\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    for i in lst:\n        cols.append((x-1, i[x-1]))\n        cols.append((x-1, i[x-1]))\n    cols.sort(key=lambda x: x[1])\n    return cols\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "if lst == []:\n        return []\n    if len(lst) == 1:\n        return [(0, x)]\n    if len(lst) == 2:\n        if lst[0] == []:\n            return [(x, 0)]\n        if lst[1] == []:\n            return [(0, x)]\n        if lst[0][0] == []:\n            return [(0, x)]\n        if lst[1][0] == []:\n            return [(x, 0)]\n        if lst[0][0] == lst[1][0]:\n            return [(0, x), (x, 0)]\n        if lst[0][0] == lst[1][1]:\n            return [(0, x), (x, 0)]\n    result = []\n    for row in lst:\n        result += get_row(row, x)\n    return sorted(result, key = lambda x: x[0], reverse = True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "if lst == []:\n        return []\n    if len(lst) == 1:\n        return [(0, x)]\n    res = []\n    for row in lst:\n        res += get_row(row, x)\n    res.sort(reverse=True)\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    if len(lst) == 1:\n        return [(x, 0)]\n    res = []\n    for row in lst:\n        res += get_column(row, x)\n    res.sort(reverse=True)\n    return res\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row and column may contain different numbers of elements.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "if lst == []:\n        return []\n    res = []\n    for row in lst:\n        for i, item in enumerate(row):\n            if item == x:\n                res.append((i, row.index(row)))\n    res.sort(key=lambda x: x[1], reverse=True)\n    return res\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    res = []\n    for row in lst:\n        res.append([item for item in row])\n    res.sort(key=lambda x: x[0], reverse=True)\n    return res\n\n\ndef get_col_row(lst, x, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integers x, find integers x in the list,\n    and integers y, find integers y in the list,\n    and return list of tuples, [(x1"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "def get_row_helper(lst, x, row, col, result):\n        if lst[row][col] == x:\n            result.append((row, col))\n        if lst[row][col] < x:\n            get_row_helper(lst, x, row-1, col, result)\n        if lst[row][col] > x:\n            get_row_helper(lst, x, row+1, col, result)\n    \n    result = []\n    get_row_helper(lst, x, 0, 0, result)\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    def get_column_helper(lst, x, row, col, result):\n        if lst[row][col] == x:\n            result.append((row, col))\n        if lst[row][col] < x:\n            get_column_helper(lst, x, row-1, col, result)\n        if lst[row][col] > x:\n            get_column_helper(lst, x, row+1, col,"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "if not lst:\n        return []\n    rows = []\n    for row in lst:\n        rows.append((row.index(x), row.index(x)))\n    rows.sort(key=lambda row: row[0])\n    rows.reverse()\n    return rows\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    cols = []\n    for row in lst:\n        cols.append((row.index(x), row))\n    cols.sort(key=lambda col: col[1])\n    cols.reverse()\n    return cols\n\ndef get_row_column(lst, x, y):\n    \"\"\"\n    Given a nested list lst, and integer x, find integers x in the list,\n    and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "rows = []\n    if lst:\n        for i in lst[0]:\n            if i == x:\n                rows.append((0, i))\n                rows.sort(reverse=True)\n            else:\n                rows.append((i, 0))\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    if lst:\n        for i in lst:\n            cols.append(i)\n        cols.sort(reverse=True)\n    return cols\n\n\ndef get_all_columns(lst):\n    \"\"\"\n    Given a nested list, return a list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_all_columns([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "rows = []\n    if lst:\n        for row in lst:\n            rows.append((row.index(x), row))\n        rows.sort(key=lambda x: x[1], reverse=True)\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    if lst:\n        for col in lst:\n            cols.append((col.index(x), col))\n        cols.sort(key=lambda x: x[0], reverse=True)\n    return cols\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "result = []\n\n    for row in lst:\n        if x in row:\n            result.append((row.index(x), row.index(x)))\n\n    result.sort(key=lambda x: x[0])\n    result.sort(key=lambda x: x[1], reverse=True)\n\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    result = []\n\n    for row in lst:\n        for col in row:\n            if col == x:\n                result.append((row.index(x), col))\n\n    result.sort(key=lambda x: x[1])\n    result.sort(key=lambda x: x[0], reverse=True)\n\n    return result"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "if lst == []:\n        return []\n    rows = []\n    for row in lst:\n        if x in row:\n            rows.append((row.index(x), row.index(x)))\n    rows.sort(key=lambda x: x[0], reverse=True)\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    cols = []\n    for row in lst:\n        cols.append([])\n        for col in row:\n            if x in col:\n                cols[-1].append(col)\n    cols.sort(key=lambda x: x[1], reverse=True)\n    return cols\n\n\ndef get_column_of_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), ("
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "rows = []\n    for row in lst:\n        rows.sort(key=lambda x: x[1])\n    row = rows[0]\n    columns = []\n    for i in range(len(row)):\n        columns.append(row[i])\n    columns.sort(reverse=True)\n    return [(i, columns[i]) for i in range(len(columns)) if columns[i] == x]\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    for row in lst:\n        cols.sort(key=lambda x: x[0])\n    col = cols[0]\n    rows = []\n    for i in range(len(col)):\n        rows.append(col[i])\n    rows.sort(reverse=True)\n    return [(i, rows[i]) for i in range(len(rows)) if rows[i] == x]\n\ndef get_row_and_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    row = []\n    for i in range(len(lst)):\n        row.append(get_row(lst[i], x))\n    return sorted(row, key=lambda x: x[0])\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    column = []\n    for i in range(len(lst)):\n        column.append(get_column(lst[i], x))\n    return sorted(column, key=lambda x: x[1])\n\nif __name__ == \"__main__\":\n    print(get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1))\n    print(get_column(["
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "if lst:\n        return sorted(\n            [(row, col) for row in lst for col in row if col == x],\n            key=lambda t: (t[0], -t[1]),\n            reverse=True\n        )\n    return []\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst:\n        return sorted(\n            [(x, row) for row in lst for x in row],\n            key=lambda t: (t[1], t[0]),\n            reverse=True\n        )\n    return []\n\n\ndef get_matrix(lst, x):\n    \"\"\"\n    Given a list of lists, and integer x, find integers x in the list,\n    and return a matrix.\n    The matrix is represented as a nested list of lists,\n    where each list is a list of integers.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_matrix([\n      [1,2,3,4,5,6],"
    },
    {
      "rank": 21,
      "score": 9.994601110104826,
      "candidate": "if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(0, lst[0][x])]\n    lst.sort(key=lambda x: x[0])\n    return [(x[0], lst[i][x[1]]) for i in range(len(lst))]\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(x, lst[0][i]) for i in range(len(lst[0]))]\n    lst.sort(key=lambda x: x[1])\n    return [(lst[i][x], x) for i in range(len(lst))]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of rows.\n    Given lst, and integer x, find integers x in"
    },
    {
      "rank": 22,
      "score": 9.971195951367866,
      "candidate": "result = []\n    lst.sort()\n    for row in lst:\n        if row[x]!= 0:\n            result.append((row.index(x), x))\n    return result\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    lst.sort()\n    for col in lst:\n        result.append((col.index(x), x))\n    return result\n\n\ndef get_max(lst):\n    \"\"\"\n    Given a nested list, return the maximum value of x in the list.\n    \"\"\"\n    max_x = 0\n    for row in lst:\n        for x in row:\n            if x > max_x:\n                max_x = x\n    return max_x\n\n\ndef get_min(lst):\n    \"\"\"\n    Given a nested list, return the minimum value of x in the list.\n    \"\"\"\n    min_x = 0\n    for row in lst:\n        for x in row:\n            if x < min_x:\n                min_x = x\n    return min_x"
    },
    {
      "rank": 23,
      "score": 9.953740687044704,
      "candidate": "assert len(lst) == len(x), \"lst and x must be the same length\"\n    assert all(isinstance(i, int) for i in lst), \"lst and x must be of integers\"\n    \n    row = []\n    for i in lst:\n        if i[x-1]!= -1:\n            row.append((i[x-1], x-1))\n        elif i[x-2]!= -1:\n            row.append((i[x-2], x-2))\n        else:\n            row.append((x, x))\n            \n    row.sort(reverse=True)\n    return row\n\n\ndef get_col(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    assert len(lst) == len(x), \"lst and x must be the same length\"\n    assert all(isinstance(i, int) for i in lst), \"lst and x must be of integers\"\n    \n    col = []\n    for i in lst:\n        col.append(i[x-1])\n        \n    col.sort()\n    return col"
    },
    {
      "rank": 24,
      "score": 9.909689479805385,
      "candidate": "result = []\n    for i in lst:\n        if i[x]!= x:\n            result.append((lst.index(i), lst.index(i)[::-1].index(x)))\n    return sorted(result, key=lambda x: (x[0], x[1]))\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in lst:\n        result.append((i, lst.index(i)[::-1].index(x)))\n    return sorted(result, key=lambda x: (x[0], x[1]))"
    },
    {
      "rank": 25,
      "score": 9.906345217220327,
      "candidate": "return sorted(lst, key=lambda x: x[x], reverse=True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    return sorted(lst, key=lambda x: x[x], reverse=True)\n\n\ndef get_column_reverse(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column_reverse([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,"
    },
    {
      "rank": 26,
      "score": 9.906338650110666,
      "candidate": "if lst == []:\n        return []\n    result = []\n    lst.sort(key=lambda x: x[0])\n    for i in lst:\n        if i[1] == x:\n            result.append((i[0], i[1]))\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    result = []\n    lst.sort(key=lambda x: x[1])\n    for i in lst:\n        if i[0] == x:\n            result.append((i[1], i[0]))\n    return result\n\n\ndef get_matrix(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns"
    },
    {
      "rank": 27,
      "score": 9.879558521764285,
      "candidate": "rows = []\n    for row in lst:\n        rows.append(get_column(row, x))\n    rows.sort(key=lambda x: x[0])\n    rows.sort(key=lambda x: x[1], reverse=True)\n    return rows\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    for row in lst:\n        cols.append(get_row(row, x))\n    cols.sort(key=lambda x: x[1], reverse=True)\n    cols.sort(key=lambda x: x[0], reverse=True)\n    return cols"
    },
    {
      "rank": 28,
      "score": 9.876315049659514,
      "candidate": "if not lst:\n        return []\n    if not x:\n        return lst\n    if len(lst) == 1:\n        return [(0, x)]\n    rows = []\n    for i in lst:\n        rows.append(get_row(i, x))\n    rows.sort(key=lambda x: x[0])\n    return rows\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if not x:\n        return lst\n    if len(lst[0]) == 1:\n        return [(x, i) for i in range(len(lst))]\n    cols = []\n    for i in range(len(lst[0])):\n        cols.append(get_column(lst[0][i], x))\n    cols.sort(key=lambda x: x[1])\n    return cols\n\ndef get_column_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each"
    },
    {
      "rank": 29,
      "score": 9.845967087833474,
      "candidate": "# Your code here\n    row_list = [lst[i] for i in range(len(lst))]\n    row_list.sort(key=lambda x: x[x.index(x)])\n    return [(i, x) for i in range(len(row_list))]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    # Your code here\n    col_list = [lst[i][x] for i in range(len(lst))]\n    col_list.sort(key=lambda x: x)\n    return [(x, i) for i in range(len(col_list))]"
    },
    {
      "rank": 30,
      "score": 9.815744491616085,
      "candidate": "result = []\n    if lst == []:\n        return result\n\n    rows = len(lst)\n    columns = len(lst[0])\n\n    for i in range(rows):\n        for j in range(columns):\n            if lst[i][j] == x:\n                result.append((i, j))\n    return sorted(result, key=lambda x: (-x[0], x[1]))\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    result = []\n    if lst == []:\n        return result\n\n    rows = len(lst)\n    columns = len(lst[0])\n\n    for i in range(columns):\n        for j in range(rows):\n            if lst[j][i] == x:\n                result.append((j, i))\n    return sorted(result, key=lambda x: (-x[0], x[1]))\n\n\ndef get_all_rows(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices"
    },
    {
      "rank": 31,
      "score": 9.813708098571897,
      "candidate": "if not lst or len(lst) == 0:\n        return []\n\n    row_list = []\n    for row in lst:\n        if isinstance(row, list):\n            row_list += get_row(row, x)\n        else:\n            row_list.append((row, x))\n\n    row_list.sort(key = lambda x: x[0])\n    row_list.sort(key = lambda x: x[1], reverse = True)\n\n    return row_list\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst or len(lst) == 0:\n        return []\n\n    column_list = []\n    for row in lst:\n        if isinstance(row, list):\n            column_list += get_column(row, x)\n        else:\n            column_list.append((x, row))\n\n    column_list.sort(key = lambda x: x[1], reverse = True)\n    column_list.sort(key = lambda x: x[0], reverse = True)\n\n    return column_"
    },
    {
      "rank": 32,
      "score": 9.81221024562602,
      "candidate": "if lst == []:\n        return []\n\n    if lst[0] == []:\n        return []\n\n    lst = sorted(lst, key=lambda x: (x[0], x[1]))\n    return [(row, col) for row, col in lst if col == x]\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    if lst == []:\n        return []\n\n    if lst[0] == []:\n        return []\n\n    lst = sorted(lst, key=lambda x: (x[0], x[1]))\n    return [(row, col) for col, row in lst if col == x]"
    },
    {
      "rank": 33,
      "score": 9.759744524032477,
      "candidate": "if not lst:\n        return []\n    return sorted(list(zip(*lst)), key=lambda x: x[1])[x]\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    return sorted(list(zip(*lst)), key=lambda x: x[0])[x]\n\ndef get_row_column(lst, x, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row_"
    },
    {
      "rank": 34,
      "score": 9.74195209815795,
      "candidate": "if lst:\n        row_list = [(i, j) for i in range(len(lst[0])) for j in range(len(lst))]\n        row_list.sort(key=lambda x: x[0], reverse=True)\n        return [(row, col) for row, col in row_list if col == x]\n    else:\n        return []\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst:\n        col_list = [(i, j) for i in range(len(lst)) for j in range(len(lst[0]))]\n        col_list.sort(key=lambda x: x[1], reverse=True)\n        return [(row, col) for row, col in col_list if col == x]\n    else:\n        return []\n\n\ndef get_all_rows(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst,"
    },
    {
      "rank": 35,
      "score": 9.712062316642116,
      "candidate": "if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    \n    lst.sort(key=lambda x: x[0])\n    rows = [(r, i) for i, r in enumerate(lst) if i == x]\n    rows.sort(reverse=True)\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    \n    lst.sort(key=lambda x: x[1])\n    cols = [(r, i) for i, r in enumerate(lst) if i == x]\n    cols.sort(reverse=True)\n    return cols\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a nested list, return the diagonal of the list.\n    The diagonal is the sum of the elements in the diagonal.\n    Examples:\n    get_diagonal([\n      [1,2,3,4,5,6],"
    },
    {
      "rank": 36,
      "score": 9.57691562841764,
      "candidate": "result = []\n    for i in range(len(lst)):\n        if lst[i][x]!= 0:\n            result.append((i, x))\n    result.sort(key = lambda x: x[0])\n    return result\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        result.append((x, i))\n    result.sort(key = lambda x: x[1])\n    return result\n\ndef get_matrix(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in"
    },
    {
      "rank": 37,
      "score": 9.521517350367732,
      "candidate": "def get_row_helper(lst, x, r, c):\n        if len(lst) == 0:\n            return []\n        if len(lst[0]) == 0:\n            return []\n        if lst[r][c] == x:\n            return [(r, c)]\n        res = get_row_helper(lst[1:], x, r + 1, c)\n        res.extend(get_row_helper(lst[0], x, r, c - 1))\n        return res\n\n    return get_row_helper(lst, x, 0, 0)\n\n\ndef get_col(lst, r, c):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integers r, c, find integers c in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 0, 0) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 0, 0) == []\n    get_col([[], [1], [1, 2, 3]], 0, 3) == [(2, 2)]\n    \"\"\"\n    def get_col_helper(lst, r, c):\n        if len(lst) == 0:\n            return []\n        if len(lst[0]) == 0:\n            return []\n        res = get_col_helper(lst[1:], r, c + 1)\n        res.extend(get_col_helper(lst[0], r, c - 1))"
    },
    {
      "rank": 38,
      "score": 9.430100725514617,
      "candidate": "if lst:\n        lst.sort(key=lambda x: x[0])\n        row = []\n        for i in lst:\n            if i[0] == x:\n                row.append((i[1], i[0]))\n        return row\n    else:\n        return []"
    },
    {
      "rank": 39,
      "score": 9.408591203853028,
      "candidate": "if not lst:\n        return []\n\n    rows = []\n\n    for row in lst:\n        if x in row:\n            rows.append((row.index(x), row.index(x)))\n\n    rows.sort(key=lambda tup: tup[0])\n    rows.reverse()\n\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n\n    columns = []\n\n    for row in lst:\n        if x in row:\n            columns.append((row.index(x), row.index(x)))\n\n    columns.sort(key=lambda tup: tup[1])\n    columns.reverse()\n\n    return columns\n\n\ndef get_column_by_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, ["
    },
    {
      "rank": 40,
      "score": 9.222401281938199,
      "candidate": "if not lst: return []\n    if not isinstance(lst, list): return lst\n    lst.sort(key=lambda lst_item: lst_item[0])\n    return [(row, col) for col, row in enumerate(lst) if row[x-1] == x]\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst: return []\n    if not isinstance(lst, list): return lst\n    lst.sort(key=lambda lst_item: lst_item[1])\n    return [(row, col) for col, row in enumerate(lst) if row[x-1] == x]"
    },
    {
      "rank": 41,
      "score": 9.101594779886327,
      "candidate": "if not lst:\n        return []\n    result = []\n    for row in lst:\n        if x in row:\n            result.append((row.index(x), row.index(x)))\n    result.sort(key=lambda tup: tup[0])\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    result = []\n    for row in lst:\n        result.append((row.index(x), row))\n    result.sort(key=lambda tup: tup[1])\n    return result\n\n\ndef get_diagonal(lst, x, y):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integers x, and integers y, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, column),"
    },
    {
      "rank": 42,
      "score": 9.084116984135814,
      "candidate": "if lst == []:\n        return []\n    rows = []\n    for row in lst:\n        rows.append((row.index(x), row))\n    rows.sort(key=lambda x: x[0])\n    return rows"
    },
    {
      "rank": 43,
      "score": 9.060016927391498,
      "candidate": "lst = sorted(lst, key=lambda lst_row: lst_row[0])\n    result = []\n    for lst_row in lst:\n        if lst_row[1] == x:\n            result.append((lst_row[0], x))\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    lst = sorted(lst, key=lambda lst_row: lst_row[1])\n    result = []\n    for lst_row in lst:\n        if lst_row[0] == x:\n            result.append((x, lst_row[1]))\n    return result\n\n\ndef get_diagonal(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row,"
    },
    {
      "rank": 44,
      "score": 8.952101958364102,
      "candidate": "row = []\n    if len(lst) == 0:\n        return row\n    for i in lst:\n        row.append((i[0], i[1]))\n    row.sort(key=lambda x: x[0], reverse=True)\n    return row\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    col = []\n    if len(lst[0]) == 0:\n        return col\n    for i in lst:\n        col.append((i[0], i[1]))\n    col.sort(key=lambda x: x[1], reverse=True)\n    return col"
    },
    {
      "rank": 45,
      "score": 8.888435779456389,
      "candidate": "if len(lst) == 0:\n        return []\n\n    if len(lst) == 1:\n        return [(0, lst[0])]\n\n    return sorted([(row, col) for row in range(len(lst)) for col in lst[row]], key=lambda x: x[1], reverse=True)\n\n\nif __name__ == \"__main__\":\n    print(get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1))"
    },
    {
      "rank": 46,
      "score": 8.877464243892744,
      "candidate": "if lst == []:\n        return []\n    sorted_lst = sorted(lst, key=lambda x: x[0])\n    return [(x[0], sorted_lst.index(x)) for x in lst if sorted_lst.index(x) == x]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    return [(sorted_lst.index(x), x[1]) for x in lst if sorted_lst.index(x) == x]\n\n\ndef get_column_by_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate -"
    },
    {
      "rank": 47,
      "score": 8.835582094473247,
      "candidate": "if lst == []:\n        return []\n    elif len(lst[0]) == 1:\n        return [(i, lst[0][0]) for i in range(len(lst))]\n    else:\n        return [(i, lst[0][j]) for i in range(len(lst)) for j in range(len(lst[0])) if lst[i][j] == x]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    elif len(lst[0]) == 1:\n        return [(lst[0][0], i) for i in range(len(lst))]\n    else:\n        return [(lst[i][0], lst[0][j]) for i in range(len(lst)) for j in range(len(lst[0])) if lst[i][j] == x]"
    },
    {
      "rank": 48,
      "score": 8.78964349628204,
      "candidate": "if not lst or len(lst) == 0:\n        return []\n    row = []\n    for i in lst:\n        row.append((i, lst.index(i)))\n    row.sort(key=lambda x: x[1], reverse=True)\n    return row"
    },
    {
      "rank": 49,
      "score": 8.754600408042517,
      "candidate": "return sorted(lst, key=lambda x: (x[0], x[1]))\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    return sorted(lst, key=lambda x: (x[1], x[0]))\n\n\ndef get_col_by_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_col_by_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      ["
    },
    {
      "rank": 50,
      "score": 8.67231966275055,
      "candidate": "if lst == []:\n        return []\n    else:\n        row = []\n        for i in lst:\n            row.append((i, i.count(x)))\n        row.sort(key=lambda x: x[1], reverse=True)\n        return row\n    \ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    else:\n        col = []\n        for i in lst:\n            col.append((i, i.count(x)))\n        col.sort(key=lambda x: x[1], reverse=True)\n        return col\n    \ndef get_col_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate -"
    },
    {
      "rank": 51,
      "score": 8.653064388709163,
      "candidate": "lst = sorted(lst, key=lambda x: x[0])\n    return [(row, lst.index(x)) for row in lst]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    lst = sorted(lst, key=lambda x: x[1])\n    return [(lst.index(x), x[0]) for x in lst]\n\n\ndef get_matrix(lst):\n    \"\"\"\n    Given a nested list, return a list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples\n    get_matrix([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ]) == [[(0, 0), (1, 4), (1, 0), ("
    },
    {
      "rank": 52,
      "score": 8.602237612149628,
      "candidate": "if lst:\n        row = []\n        for i in range(len(lst)):\n            row.append((i, lst[i][x]))\n        row.sort(key=lambda x: x[0])\n        return row\n    else:\n        return []\n\n\ndef get_col(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst:\n        col = []\n        for i in range(len(lst[0])):\n            col.append((lst[0][x], i))\n        col.sort(key=lambda x: x[1])\n        return col\n    else:\n        return []\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0."
    },
    {
      "rank": 53,
      "score": 8.59633157496445,
      "candidate": "if lst == []:\n        return []\n    if x > len(lst[0]) or x < 0:\n        return []\n    return sorted(list(zip(lst, range(len(lst)))))\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    if x > len(lst[0]) or x < 0:\n        return []\n    return sorted(list(zip(range(len(lst)), lst)))\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order."
    },
    {
      "rank": 54,
      "score": 8.580559711590258,
      "candidate": "if lst == []:\n        return []\n\n    sorted_lst = sorted(lst, key=lambda row: row[x])\n    return [(i, j) for i, row in enumerate(sorted_lst) for j in range(len(row))]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n\n    sorted_lst = sorted(lst, key=lambda col: col[x])\n    return [(i, j) for i, row in enumerate(sorted_lst) for j in range(len(row))]\n\n\ndef get_column_with_keys(lst, x, keys):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row"
    },
    {
      "rank": 55,
      "score": 8.54606859850218,
      "candidate": "row = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                row.append((i, j))\n    return sorted(row, key=lambda x: x[1], reverse=True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    column = []\n    for i in range(len(lst)):\n        for j in range(len(lst[0])):\n            if lst[i][j] == x:\n                column.append((i, j))\n    return sorted(column, key=lambda x: x[0], reverse=True)\n\n\ndef get_column_with_value(lst, value):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer value, find integers x in the list,\n    and return list of tuples, [(x1, y1"
    },
    {
      "rank": 56,
      "score": 8.491031932122588,
      "candidate": "if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n\n    if x in lst[0]:\n        return [(0, lst[0].index(x))]\n    else:\n        return get_row(lst[1:], x) + get_row(lst[0], x)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n\n    if x in lst[0]:\n        return [(lst[0].index(x), i) for i in range(len(lst))]\n    else:\n        return get_column(lst[1:], x) + get_column(lst[0], x)\n\n\ndef get_matrix_coordinates(matrix):\n    \"\"\"\n    Given a 2 dimensional list, matrix, and integer x, find integers x in the matrix,\n    and return list of tuples, [(x1, y1), (x2, y2"
    },
    {
      "rank": 57,
      "score": 8.472806290413372,
      "candidate": "if not lst:\n        return []\n    rows = sorted(lst, key=lambda x: x[0])\n    res = []\n    for row in rows:\n        if x in row:\n            res.append((row.index(x), x))\n    return res\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    cols = sorted(lst, key=lambda x: x[1])\n    res = []\n    for col in cols:\n        if x in col:\n            res.append((x, col.index(x)))\n    return res\n\n\ndef get_matrix(lst):\n    \"\"\"\n    Given a nested list of lists, return a list of lists,\n    where each element is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_matrix([\n      [1,2,3,4,5,6],\n      [1,2,3,4"
    },
    {
      "rank": 58,
      "score": 8.429397508018265,
      "candidate": "if lst == []:\n        return []\n    if x < 0 or x > len(lst[0]):\n        return []\n    return sorted([(r, c) for r in range(len(lst)) for c in range(len(lst[r])) if lst[r][c] == x], reverse = True)\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    if x < 0 or x > len(lst[0]):\n        return []\n    return sorted([(r, c) for r in range(len(lst)) for c in range(len(lst[r])) if lst[r][c] == x], reverse = False)\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2"
    },
    {
      "rank": 59,
      "score": 8.386373437952548,
      "candidate": "row = []\n    for i in lst:\n        row.append((i.index(x), i.index(x)))\n    row.sort(key=lambda x: x[0], reverse=True)\n    return row\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    col = []\n    for i in lst:\n        col.append((i.index(x), i))\n    col.sort(key=lambda x: x[1].index(x), reverse=True)\n    return col\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the diagonal by"
    },
    {
      "rank": 60,
      "score": 8.36646767424564,
      "candidate": "rows = lst\n    if not rows:\n        return []\n    cols = len(rows[0])\n    res = []\n    for i in range(cols):\n        if i == x:\n            res.append((0, i))\n        elif i > x:\n            res.append((i, x))\n        else:\n            res.append((x, i))\n    res.sort(reverse=True)\n    return res\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = lst\n    if not cols:\n        return []\n    rows = len(cols[0])\n    res = []\n    for i in range(rows):\n        if i == x:\n            res.append((i, 0))\n        elif i > x:\n            res.append((x, i))\n        else:\n            res.append((i, x))\n    res.sort(reverse=True)\n    return res\n\n\ndef get_col_recursive(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which"
    },
    {
      "rank": 61,
      "score": 8.352182251552689,
      "candidate": "if lst == []:\n        return []\n    return sorted(zip(*[row[x] for row in lst]), key=lambda x: x[0])\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    return sorted(zip(*[row[x] for row in lst]), key=lambda x: x[1])\n\n\ndef get_col_row(lst, x, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order."
    },
    {
      "rank": 62,
      "score": 8.32193306953127,
      "candidate": "if lst == []:\n        return []\n    elif x in lst[0]:\n        return [(0, i) for i in range(len(lst))]\n    else:\n        return get_row(lst[1:], x) + get_row(lst[0:1], x)\n\n\nif __name__ == '__main__':\n    assert get_row([\n        [1, 2, 3, 4, 5, 6],\n        [1, 2, 3, 4, 1, 6],\n        [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert get_row([], 1) == []\n    assert get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]"
    },
    {
      "rank": 63,
      "score": 8.31886135724878,
      "candidate": "if lst == []:\n        return []\n    res = []\n    for row in lst:\n        res.append((row.index(x), row.index(x)))\n    res.sort(key = lambda x: x[1])\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    res = []\n    for row in lst:\n        res.append((row.index(x), row))\n    res.sort(key = lambda x: x[0])\n    return res\n\n\ndef get_all_rows_and_columns(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially"
    },
    {
      "rank": 64,
      "score": 8.24980901346321,
      "candidate": "if lst == []:\n        return []\n    if isinstance(lst, list):\n        lst = sorted(lst, key=lambda row: row[x])\n    return lst\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    if isinstance(lst, list):\n        lst = sorted(lst, key=lambda col: col[x])\n    return lst\n\ndef get_col_by_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_col"
    },
    {
      "rank": 65,
      "score": 8.243191264549424,
      "candidate": "if lst == []:\n        return []\n    res = []\n    for row in lst:\n        if type(row)!= list:\n            raise TypeError(\"Expecting list\")\n        res.extend(sorted(zip(row, range(len(row))), key=lambda x: x[1]))\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    res = []\n    for row in lst:\n        if type(row)!= list:\n            raise TypeError(\"Expecting list\")\n        res.extend(sorted(zip(row, range(len(row))), key=lambda x: x[0]))\n    return res\n\n\ndef get_matrix(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)"
    },
    {
      "rank": 66,
      "score": 8.215803700143868,
      "candidate": "if len(lst) == 0:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    \n    rows = sorted(lst, key=lambda row: (row[0], row[x]))\n    return [(row[0], row[x]) for row in rows]\n\n\nprint(get_row([[1, 2, 3, 4, 5, 6],\n               [1, 2, 3, 4, 1, 6],\n               [1, 2, 3, 4, 5, 1]], 1))\nprint(get_row([], 1))\nprint(get_row([[], [1], [1, 2, 3]], 3))\nprint(get_row([[], [1], [1, 2, 3]], 2))"
    },
    {
      "rank": 67,
      "score": 8.208283682163236,
      "candidate": "if not lst or not lst[0]:\n        return []\n    else:\n        rows = []\n        for row in lst:\n            cols = []\n            for col in row:\n                cols.append((col, row.index(col)))\n            cols.sort(key=lambda x: x[0])\n            rows.append(cols)\n        return rows"
    },
    {
      "rank": 68,
      "score": 8.191727667308099,
      "candidate": "if lst == []:\n        return []\n    if x in lst[0]:\n        return [(0, lst.index(x))]\n    return sorted(get_row(lst[1:], x), key=lambda x: x[0])\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    if x in lst[0][0]:\n        return [(x, lst.index(x))]\n    return sorted(get_column(lst[1:], x), key=lambda x: x[1])\n\ndef get_column_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0."
    },
    {
      "rank": 69,
      "score": 8.160137204315943,
      "candidate": "if not lst:\n        return []\n    if not x:\n        return [(0, 0)]\n    return sorted(\n        [(row, col) for row in lst for col in row],\n        key=lambda tup: tup[0],\n        reverse=True\n    )\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if not x:\n        return [(0, col) for col in range(len(lst[0]))]\n    return sorted(\n        [(col, row) for row in lst for col in range(len(row))],\n        key=lambda tup: tup[1],\n        reverse=True\n    )\n\n\ndef get_diagonal(lst, x, y):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and integer y, find integers y in the list,"
    },
    {
      "rank": 70,
      "score": 8.091973084690936,
      "candidate": "row = []\n    for row in lst:\n        row.sort(reverse=True)\n        if row[0] == x:\n            row.append((0, 0))\n    return row\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    column = []\n    for row in lst:\n        column.sort(reverse=True)\n        if column[0] == x:\n            column.append((0, row[0]))\n    return column\n\n\ndef get_diagonal(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the diagonal by columns in descending order."
    },
    {
      "rank": 71,
      "score": 8.063074332725536,
      "candidate": "if not lst:\n        return []\n    return sorted(\n        [(row, lst[row].index(x)) for row in range(len(lst))],\n        key=lambda t: (t[0], t[1]),\n        reverse=True\n    )\n\n\ndef get_column(lst, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    return sorted(\n        [(row, lst[row].index(y)) for row in range(len(lst))],\n        key=lambda t: (t[1], t[0]),\n        reverse=True\n    )\n\n\ndef get_column_with_values(lst, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is"
    },
    {
      "rank": 72,
      "score": 8.019055373903987,
      "candidate": "if lst == []:\n        return []\n    if lst[0] == []:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    res = []\n    i = 0\n    j = 0\n    while i < len(lst):\n        if lst[i][0] == x:\n            res.append((i, j))\n        i += 1\n    res.sort(reverse=True)\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    if lst[0] == []:\n        return []\n    if len(lst[0]) == 0:\n        return []\n    res = []\n    i = 0\n    j = 0\n    while i < len(lst):\n        if lst[j] == []:\n            res.append((i, j))\n        j += 1\n    res.sort(reverse=True)\n    return res\n\n\ndef get_column_with_index(lst, x):\n    \"\"\"\n    You are given a 2 dimensional"
    },
    {
      "rank": 73,
      "score": 7.979783755361913,
      "candidate": "lst = [item for sublist in lst for item in sublist]\n    lst.sort()\n    return [(lst.index(x), i) for i in range(len(lst))]\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    lst = [item for sublist in lst for item in sublist]\n    lst.sort(reverse=True)\n    return [(i, lst.index(x)) for i in range(len(lst))]\n\n\ndef get_col_reverse(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order."
    },
    {
      "rank": 74,
      "score": 7.961027141927078,
      "candidate": "if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return [(0, x)]\n    else:\n        rows = sorted(lst, key=lambda x: x[1])\n        row = rows[0][0]\n        columns = rows[0][1]\n        return [(row, columns), (row, columns - 1)]"
    },
    {
      "rank": 75,
      "score": 7.931690111456615,
      "candidate": "if not lst:\n        return []\n    if not isinstance(lst, list):\n        return []\n    rows = [(row, col) for row in lst for col in row]\n    rows.sort(key=lambda row: row[0], reverse=True)\n    return rows\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if not isinstance(lst, list):\n        return []\n    cols = [(row, col) for row in lst for col in row]\n    cols.sort(key=lambda col: col[1], reverse=True)\n    return cols\n\n\ndef get_column_by_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate"
    },
    {
      "rank": 76,
      "score": 7.8866063039071035,
      "candidate": "if lst == []:\n        return []\n    result = []\n    for i in lst:\n        if i[x]!= None:\n            result.append((lst.index(i), x))\n    result.sort(key=lambda x: x[0])\n    result.reverse()\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    result = []\n    for i in lst:\n        result.append((x, i))\n    result.sort(key=lambda x: x[1])\n    result.reverse()\n    return result\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, column"
    },
    {
      "rank": 77,
      "score": 7.851276889883622,
      "candidate": "if len(lst) == 0:\n        return []\n    row = []\n    for i in range(len(lst)):\n        if lst[i][x]!= 0:\n            row.append((i, x))\n            row.sort(reverse=True)\n    return row\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    column = []\n    for i in range(len(lst[0])):\n        if lst[0][x]!= 0:\n            column.append((x, i))\n            column.sort(reverse=True)\n    return column\n\n\ndef get_diagonal(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that"
    },
    {
      "rank": 78,
      "score": 7.719978954788971,
      "candidate": "if not lst:\n        return []\n    if len(lst[0]) == 1:\n        return [(i, lst[0][0]) for i in range(len(lst))]\n    return sorted([(i, lst[i][x]) for i in range(len(lst))], key=lambda x: x[1])\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if len(lst[0]) == 1:\n        return [(lst[0][0], i) for i in range(len(lst))]\n    return sorted([(lst[i][x], i) for i in range(len(lst))], key=lambda x: x[0])\n\n\ndef get_column_reverse(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples"
    },
    {
      "rank": 79,
      "score": 7.7039675791920965,
      "candidate": "res = []\n    if not lst:\n        return res\n    for i in range(len(lst)):\n        res += get_row(lst[i], x)\n    res.sort(key=lambda x: x[0], reverse=True)\n    return res"
    },
    {
      "rank": 80,
      "score": 7.6408667416881695,
      "candidate": "if lst == []:\n        return []\n    res = []\n    for row in lst:\n        res.append((row.index(x), row))\n    res.sort(key=lambda x: x[0], reverse=True)\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    res = []\n    for col in lst:\n        res.append((col.index(x), col))\n    res.sort(key=lambda x: x[1], reverse=True)\n    return res\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort"
    },
    {
      "rank": 81,
      "score": 7.621382992414939,
      "candidate": "if lst == []:\n        return []\n    elif lst[0] == []:\n        return []\n    elif lst[0][0] == x:\n        return [(0, 0)]\n    elif len(lst) > 1:\n        return sorted(get_row(lst[1:], x), key=lambda x: x[1], reverse=True)\n    else:\n        return []\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    elif lst[0] == []:\n        return []\n    elif lst[0][0] == x:\n        return [(0, i) for i in range(len(lst[0]))]\n    elif len(lst) > 1:\n        return sorted(get_column(lst[1:], x), key=lambda x: x[0], reverse=True)\n    else:\n        return []"
    },
    {
      "rank": 82,
      "score": 7.60966550031207,
      "candidate": "if lst == []:\n        return []\n    result = []\n    for row in lst:\n        result.append((row.index(x), row.index(x)))\n    result.sort(key=lambda tup: tup[1], reverse=True)\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (column, row), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    result = []\n    for column in lst[0]:\n        result.append((column.index(x), column.index(x)))\n    result.sort(key=lambda tup: tup[0], reverse=True)\n    return result\n\n\ndef get_column_from_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a"
    },
    {
      "rank": 83,
      "score": 3.0,
      "candidate": "rows = len(lst)\n    columns = len(lst[0])\n    res = []\n    for i in range(rows):\n        if lst[i][x] == x:\n            res.append((i, x))\n    res.sort(key=lambda x: x[0], reverse=True)\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    columns = len(lst[0])\n    res = []\n    for i in range(columns):\n        if lst[x][i] == x:\n            res.append((x, i))\n    res.sort(key=lambda x: x[1], reverse=True)\n    return res\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a nested list lst, return the first and last diagonal elements.\n    If there is no diagonal, return None.\n    \"\"\"\n    res = None\n    for i in range(len(lst)):\n        for j in range(len(lst[0])):\n            if lst[i][j] == lst[i][j+1"
    },
    {
      "rank": 84,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    return sorted([(x, y) for y in lst[0] if y == x], key=lambda t: t[0])\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    return sorted([(x, y) for y in lst[0] if y == x], key=lambda t: t[1])\n\n\ndef get_column_and_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by rows in descending order.\n    \n    Examples:\n    get"
    },
    {
      "rank": 85,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    # first get the rows in ascending order\n    rows = sorted(lst, key=lambda row: row[0])\n    # then sort them by columns in descending order\n    rows = sorted(rows, key=lambda row: row[1])\n    # create a list to hold the results\n    result = []\n    # iterate through the rows\n    for row in rows:\n        # if the value is equal to x\n        if row[1] == x:\n            # add it to the list\n            result.append((row[0], x))\n    return result\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    # first get the columns in ascending order\n    columns = sorted(lst, key=lambda row: row[1])\n    # then sort them by rows in descending order\n    columns = sorted(columns, key=lambda row: row[0])\n    # create a list to hold the results\n    result = []\n    # iterate through the columns\n    for column in columns:\n        # if the"
    },
    {
      "rank": 86,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    if not isinstance(lst, list):\n        raise TypeError(\"input is not a list\")\n    if not isinstance(x, int):\n        raise TypeError(\"input is not an integer\")\n    if not isinstance(lst[0], list):\n        raise TypeError(\"input is not a list\")\n    if not isinstance(x, int):\n        raise TypeError(\"input is not an integer\")\n    if not x < 0 or x > len(lst):\n        raise ValueError(\"input x is out of range\")\n    row = []\n    for i in range(len(lst)):\n        row += sorted(get_row(lst[i], x), reverse=True)\n    return row\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if not isinstance(lst, list):\n        raise TypeError(\"input is not a list\")\n    if not isinstance(x, int):\n        raise TypeError(\"input is not an integer\")\n    if not x < 0 or x > len(lst[0]):\n        raise ValueError(\""
    },
    {
      "rank": 87,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    if not lst[0]:\n        return []\n    return sorted(zip(lst[0], range(len(lst))), key=lambda x: x[1])[0:x]\n\n\ndef get_column(lst, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (0, 4), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if not lst[0]:\n        return []\n    return sorted(zip(range(len(lst)), lst[0]), key=lambda x: x[1])[0:y]"
    },
    {
      "rank": 88,
      "score": 3.0,
      "candidate": "if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(0, x)]\n    if len(lst) == 2:\n        return [(0, x), (1, x)]\n    if len(lst) == 3:\n        return [(0, x), (1, x), (2, x)]\n\n    lst = sorted(lst, key=lambda x: x[0])\n    return [(row[0], col) for row in lst for col in row[1:]]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(x, 0)]\n    if len(lst) == 2:\n        return [(x, col) for col in range(len(lst[0]))]\n    if len(lst) == 3:\n        return [(x, col) for col in range(len(lst[0])) for row in lst[col]]\n\n    lst = sorted(lst, key="
    },
    {
      "rank": 89,
      "score": 3.0,
      "candidate": "if lst == []:\n        return []\n    else:\n        return sorted([(row, col) for row in range(len(lst)) for col in range(len(lst[0])) if lst[row][col] == x], key=lambda x: x[0], reverse=True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    else:\n        return sorted([(row, col) for row in range(len(lst[0])) for col in range(len(lst)) if lst[row][col] == x], key=lambda x: x[1], reverse=True)\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows and columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a"
    },
    {
      "rank": 90,
      "score": 3.0,
      "candidate": "if lst == []:\n        return []\n    row = []\n    for i in lst:\n        if i[x]!= None:\n            row.append((i.index(x)+1, x))\n    row.sort(reverse=True)\n    return row\n\n\ndef get_column(lst, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    col = []\n    for i in lst:\n        if i[y]!= None:\n            col.append((y, i.index(y)+1))\n    col.sort(reverse=True)\n    return col\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a nested list lst, find the diagonal elements of lst.\n    For example, if lst = [[1,2,3],[4,5,6],[7,8,9]],\n    then the diagonal elements of lst are [4, 5, 6].\n    The diagonal elements of a matrix should be a list of integers.\n    Return the diagonal elements of lst.\n    \n    Examples:\n    get_diagonal(["
    },
    {
      "rank": 91,
      "score": 3.0,
      "candidate": "res = []\n    if lst == []:\n        return res\n    if len(lst) == 1:\n        if lst[0][x]!= None:\n            res.append((0, lst[0][x]))\n        else:\n            res.append((0, None))\n    else:\n        for i in range(len(lst)):\n            if lst[i][x]!= None:\n                res.append((i, lst[i][x]))\n            else:\n                res.append((i, None))\n    res.sort(reverse=True)\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    res = []\n    if lst == []:\n        return res\n    if len(lst) == 1:\n        if lst[0][x]!= None:\n            res.append((0, lst[0][x]))\n        else:\n            res.append((0, None))\n    else:\n        for i in range(len(lst)):\n            if lst[i][x]!= None:\n                res.append((i"
    },
    {
      "rank": 92,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n\n    return sorted(zip(lst, range(len(lst))), key=lambda x: x[1], reverse=True)\n\n\ndef get_col(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    if not lst:\n        return []\n\n    return sorted(zip(range(len(lst[0])), lst), key=lambda x: x[0], reverse=True)\n\n\ndef get_col_and_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_col"
    },
    {
      "rank": 93,
      "score": 3.0,
      "candidate": "rows = []\n    for row in lst:\n        for i in range(len(row)):\n            if row[i] == x:\n                rows.append((i, row.index(x)))\n    rows.sort(key=lambda x: x[0], reverse=True)\n    return rows\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    cols = []\n    for row in lst:\n        cols.append(row)\n    cols.sort(key=lambda x: x[1], reverse=True)\n    return cols\n\n\ndef get_diagonal(lst):\n    \"\"\"\n    Given a nested list, return the diagonal of the list.\n    Note that you can't use any function.\n    \"\"\"\n    return [lst[i][i] for i in range(len(lst))]\n\n\ndef get_diagonal_sum(lst):\n    \"\"\"\n    Given a nested list, return the sum of the diagonal of the list.\n    Note that you can't use any function.\n    \"\"\"\n    return sum(get_diagonal(lst))\n\n\ndef get_"
    },
    {
      "rank": 94,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    if len(lst) == 1:\n        return [(0, lst[0][x])]\n    if len(lst) == 2:\n        return sorted([(0, lst[0][x]), (1, lst[1][x])], key=lambda x: x[0])\n    return sorted([(0, lst[i][x]) for i in range(len(lst))], key=lambda x: x[0])\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    if len(lst) == 1:\n        return [(x, lst[0][i]) for i in range(len(lst[0]))]\n    if len(lst) == 2:\n        return sorted([(x, lst[i][x]) for i in range(len(lst))], key=lambda x: x[1])\n    return sorted([(x, lst[i][x]) for i in range(len(lst)) for x in range(len(lst[0]))], key=lambda x"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    return sorted(lst, key=lambda x: x[x], reverse=True)\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    return sorted(lst, key=lambda x: x[x], reverse=False)"
    },
    {
      "rank": 96,
      "score": 3.0,
      "candidate": "if not lst: return []\n    res = []\n    for row in lst:\n        res.append((row.index(x), row.index(x)))\n    res.sort(reverse=True)\n    return res\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst: return []\n    res = []\n    for row in lst:\n        res.append((row.index(x), row))\n    res.sort(reverse=True)\n    return res\n\n\ndef get_min_max(lst):\n    \"\"\"\n    Given a 2 dimensional data, as a nested lists,\n    find the minimum and maximum values of a given column.\n    Return the minimum and maximum values of the given column.\n    \n    Examples:\n    get_min_max([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == (0, 2)\n    get_min_max([], 1) =="
    },
    {
      "rank": 97,
      "score": 3.0,
      "candidate": "if lst == []:\n        return []\n    \n    return sorted(zip(lst, range(len(lst))), key=lambda tup: tup[0][x], reverse=True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if lst == []:\n        return []\n    \n    return sorted(zip(range(len(lst[0])), lst), key=lambda tup: tup[1][x], reverse=True)\n\n\ndef get_diagonal(lst, x, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each diagonal may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and integer y, find integers y in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort"
    },
    {
      "rank": 98,
      "score": 3.0,
      "candidate": "# Your code here\n    if not lst:\n        return []\n    if not x:\n        return sorted(lst, key=lambda x: x[0])\n    return sorted(lst, key=lambda x: x[x], reverse=True)\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    # Your code here\n    if not lst:\n        return []\n    if not x:\n        return sorted(lst, key=lambda x: x[1])\n    return sorted(lst, key=lambda x: x[x], reverse=True)\n\n\nif __name__ == \"__main__\":\n    print(get_row([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1))\n    print(get_row([], 1))\n    print(get_row([[], [1], [1, 2, 3]], 3))"
    },
    {
      "rank": 99,
      "score": 3.0,
      "candidate": "if lst == []:\n        return []\n\n    lst.sort(key = lambda x: x[0])\n    return lst[x-1]\n\n\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each column may contain a different number of rows.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the column by rows in descending order.\n    \n    Examples\n    get_column([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 1), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_column([], 1) == []\n    get_column([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    if lst == []:\n        return []\n\n    lst.sort(key = lambda x: x[1])\n    return lst[x-1]\n\n\ndef get_rows_and_columns(lst):\n    \"\"\"\n    Given a nested list, return a list of tuples,\n    [(row1, column1), (row2, column2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n\n    return sorted(get_row(lst, 0), key=lambda x: x[0]) + sorted(get_column(lst, 0), key=lambda x: x[1])\n\n\ndef get_rows_and_columns_in_order(lst):\n    \"\"\"\n    Given"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "if not lst:\n        return []\n    \n    def get_row_helper(lst, x, row, col):\n        if not lst:\n            return []\n        \n        if row >= len(lst[0]):\n            return []\n        \n        if col >= len(lst[row]):\n            return []\n        \n        if lst[row][col] == x:\n            return [(row, col)]\n        \n        return get_row_helper(lst[row], x, row + 1, col) + get_row_helper(lst[row], x, row, col + 1)\n    \n    return sorted(get_row_helper(lst, x, 0, 0), key=lambda x: x[0])\n\n\ndef get_col(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2)...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by columns in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_col([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_col([], 1) == []\n    get_col([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    if not lst:\n        return []\n    \n    def get_col_helper(lst, x, row, col):\n        if not lst:\n            return []\n        \n        if row >= len(lst):\n            return []\n        \n        if col >= len(lst[row]"
    }
  ]
}