{
  "timestamp": "2025-09-14T12:08:21.009793",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "humaneval",
  "problem_number": 119,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "open_paren = []\n    close_paren = []\n    for element in lst:\n        if element == '(':\n            open_paren.append(element)\n        elif element == ')':\n            close_paren.append(element)\n        else:\n            if open_paren and close_paren:\n                if open_paren[-1]!= close_paren[-1]:\n                    return 'No'\n                else:\n                    open_paren.pop()\n                    close_paren.pop()\n            else:\n                return 'No'\n\n    return 'Yes' if not open_paren else 'No'"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "open_parens = 0\n    close_parens = 0\n    for string in lst:\n        if string[0] == '(':\n            open_parens += 1\n        elif string[-1] == ')':\n            close_parens += 1\n        if open_parens < close_parens:\n            return 'No'\n    return 'Yes'\n\n\nprint(match_parens([\"()()\", \"(())()\", \"()()\", \"(())()\", \"(())()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()\", \"()()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "stack = []\n    for s in lst:\n        if s == '(':\n            stack.append('(')\n        elif s == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens_2(lst):\n    '''\n    Same as above but using a stack instead of a list.\n    '''\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append('(')\n        elif s == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= ')':\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens_3(lst):\n    '''\n    Same as above but using a list instead of a stack.\n    '''\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append('(')\n        elif s == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n        else:\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    lst = ['()(', ')']\n    print(match_parens(lst))\n    print(match_parens_2(lst))\n    print(match_parens_3(lst))"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "open_p = []\n    close_p = []\n    for p in lst:\n        if p == '(':\n            open_p.append(p)\n        elif p == ')':\n            close_p.append(p)\n\n    if len(open_p) == 0 or len(close_p) == 0:\n        return 'No'\n\n    for p in open_p:\n        if p in close_p:\n            close_p.remove(p)\n        else:\n            return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'Yes'\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    if lst[0] == lst[1]:\n        return 'Yes'\n\n    stack = []\n    for elem in lst:\n        if elem == '(':\n            stack.append(elem)\n        elif elem == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    print(match_parens([]))\n    print(match_parens([]))\n    print(match_parens([]))\n    print(match_parens([]))\n    print(match_parens([]))\n    print(match_parens([()]))"
    },
    {
      "rank": 6,
      "score": 9.370583536698913,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                last_open = stack.pop()\n                if last_open!= '(':\n                    return 'No'\n    return 'Yes' if len(stack) == 0 else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'No'\n    assert match_parens([']) == 'No'\n    assert match_parens(['(()())', ')']) == 'Yes'\n    assert match_parens(['(()())', ')']) == 'No'\n    assert match_parens(['(())()', ')']) == 'Yes'\n    assert match_parens([]) == 'No'"
    },
    {
      "rank": 7,
      "score": 9.234050852198141,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return 'Yes'\n        else:\n            return 'No'\n\n    open_parens = 0\n    close_parens = 0\n\n    for i in lst:\n        if i == '(':\n            open_parens += 1\n        elif i == ')':\n            close_parens += 1\n\n    if open_parens == close_parens:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['())', ')']) == 'Yes'\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', '(())']) == 'No'"
    },
    {
      "rank": 8,
      "score": 9.226766272351448,
      "candidate": "open_p = []\n    close_p = []\n    for s in lst:\n        if s[0] == '(':\n            open_p.append(s)\n        else:\n            if open_p:\n                if open_p[-1] == '(':\n                    open_p.pop()\n                else:\n                    return 'No'\n            else:\n                return 'No'\n        if s[1] == ')':\n            close_p.append(s)\n        else:\n            if close_p:\n                if close_p[-1] == '(':\n                    close_p.pop()\n                else:\n                    return 'No'\n            else:\n                return 'No'\n\n    if not open_p:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 9,
      "score": 9.21346272767743,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    def check(s):\n        if len(s) % 2 == 1:\n            return False\n        if s[0]!= '(':\n            return False\n        if s[-1]!= ')':\n            return False\n        for i in range(len(s) // 2):\n            if s[i]!= s[len(s) - 1 - i]:\n                return False\n        return True\n\n    def check_pair(s):\n        if check(s[0:len(s) // 2]):\n            return True\n        if check(s[len(s) // 2:]):\n            return True\n        return False\n\n    if check_pair(lst[0]) and check_pair(lst[1]):\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 10,
      "score": 9.205959372648458,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    for i in range(len(lst) - 1):\n        if lst[i][0]!= lst[i + 1][0]:\n            return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['(())', '(())']) == 'Yes'\n    assert match_parens(['(()(', ')']) == 'No'"
    },
    {
      "rank": 11,
      "score": 9.177268828905222,
      "candidate": "stack = []\n    for s in lst:\n        if s[0] == '(':\n            stack.append(s)\n        elif s[0] == ')':\n            if len(stack) == 0:\n                return 'No'\n            if stack[-1]!= '(':\n                return 'No'\n            stack.pop()\n    return 'Yes'"
    },
    {
      "rank": 12,
      "score": 9.122564458729856,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        else:\n            if len(stack) == 0:\n                return 'No'\n            if item == ')' and stack[-1] == '(':\n                stack.pop()\n    return 'Yes' if len(stack) == 0 else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([']) == 'Yes'\n    assert match_parens([']) == 'No'\n    assert match_parens([']) == 'Yes'\n    assert match_parens(['())', ')()']) == 'Yes'\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 13,
      "score": 8.973005557553902,
      "candidate": "stack = []\n    for s in lst:\n        if s[0] == '(':\n            stack.append(s[1:])\n        elif s[-1] == ')':\n            if not stack:\n                return 'No'\n            else:\n                stack.pop()\n    return 'Yes'"
    },
    {
      "rank": 14,
      "score": 8.95994420569242,
      "candidate": "for i in range(len(lst) - 1):\n        if lst[i][0] == lst[i + 1][0] and lst[i][1] == lst[i + 1][1]:\n            continue\n        else:\n            return 'No'\n    return 'Yes'"
    },
    {
      "rank": 15,
      "score": 8.946210893390457,
      "candidate": "if len(lst)!= 2:\n        return 'No'\n    if lst[0][0] == lst[1][-1]:\n        return 'No'\n    elif lst[0][-1] == lst[1][0]:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 16,
      "score": 8.932217008005624,
      "candidate": "lst.sort()\n    return lst[0] == lst[-1] and lst[0] == lst[-2] and lst[0] == lst[-3]\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()', '(()(())']) == 'Yes'\n    assert match_parens(['()(()(()(()()()(()()()(()(()()(()(()()()(()(()(()(()('\n    assert match_parens([')', '(()(()(()(()(()()(()()(()(()(()(()(()(()('"
    },
    {
      "rank": 17,
      "score": 8.910084504002544,
      "candidate": "s1 = ''\n    s2 = ''\n    for s in lst:\n        if s[0] == '(':\n            s1 += s\n        elif s[0] == ')':\n            if len(s1) == 0:\n                return 'No'\n            else:\n                s1 = s1[1:]\n        else:\n            if len(s2) == 0:\n                return 'No'\n            else:\n                s2 = s2[1:]\n    if len(s1) == 0 and len(s2) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    print(match_parens(['()(', ')']))\n    print(match_parens([')', ')']))\n    print(match_parens(['(', ')']))\n    print(match_parens(['(', ')']))"
    },
    {
      "rank": 18,
      "score": 8.85571690049604,
      "candidate": "stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes' if len(stack) == 0 else 'No'"
    },
    {
      "rank": 19,
      "score": 8.855395696632057,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    stack = []\n\n    for s in lst:\n        if s == '(':\n            stack.append(s)\n        elif s == ')':\n            if not stack:\n                return 'No'\n            else:\n                stack.pop()\n\n    return 'Yes' if not stack else 'No'\n\n\nprint(match_parens(['()(', ')']))\nprint(match_parens([')', ')']))\nprint(match_parens(['(())', ')']))\nprint(match_parens(['()(', ')()']))\nprint(match_parens(['(())', ')()()']))\nprint(match_parens(['(())', ')()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['(())', ')()()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['(())', ')()()()']))\nprint(match_parens(['(())', ')()()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()()']))\nprint(match_parens(['()(', ')()']))\nprint(match_parens(['()(', ')()()']))"
    },
    {
      "rank": 20,
      "score": 8.850707355641543,
      "candidate": "if not lst:\n        return 'No'\n    if len(lst) == 1:\n        return lst[0] == lst[0]\n\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            elif stack.pop()!= '(':\n                return 'No'\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 21,
      "score": 8.8281618090209,
      "candidate": "if len(lst) == 1:\n        return lst[0]\n\n    if len(lst) == 2:\n        return lst[0] + lst[1]\n\n    if lst[0] == lst[1]:\n        return match_parens(lst[1:])\n\n    return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()', '(())']) == 'Yes'\n    assert match_parens(['())', '(())']) == 'No'\n    assert match_parens(['())', '()(())']) == 'Yes'"
    },
    {
      "rank": 22,
      "score": 8.81367773444215,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    if lst[0][0] == lst[1][0] and lst[0][1] == lst[1][1]:\n        return 'Yes'\n    return 'No'"
    },
    {
      "rank": 23,
      "score": 8.76828871349479,
      "candidate": "l = len(lst)\n    if l < 2:\n        return \"No\"\n\n    open = []\n    close = []\n    for i in lst:\n        if i[0] == '(':\n            open.append(i)\n        else:\n            if len(open) > 0:\n                open.pop()\n            else:\n                return \"No\"\n        if i[1] == ')':\n            close.append(i)\n        else:\n            if len(close) > 0:\n                close.pop()\n            else:\n                return \"No\"\n\n    if len(open) == 0 and len(close) == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n\nif __name__ == \"__main__\":\n    assert match_parens(['()(', ')']) == \"Yes\"\n    assert match_parens([')', ')']) == \"No\"\n    assert match_parens(['())', '(())']) == \"Yes\""
    },
    {
      "rank": 24,
      "score": 8.750282588864879,
      "candidate": "if len(lst) == 0:\n        return 'No'\n\n    stack = []\n    for element in lst:\n        if element == '(':\n            stack.append(element)\n        elif element == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens_2(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    ( or close parentheses ) only. Your job is to check if it is possible\n    to concatenate the two strings in some order, that the resulting string will\n    be good. A string S is considered to be good if and only if all parentheses\n    in S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens_2(['()(', ')']) == 'Yes'\n    match_parens_2([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n\n    stack = []\n    for element in lst:\n        if element == '(':\n            stack.append(element)\n        elif element == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= ')':\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens_3(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    ( or close parentheses ) only. Your job is to check if it is possible\n    to concatenate the two strings in some order, that the resulting string will\n    be good. A string S is considered to be good if and only if all parentheses\n    in S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and"
    },
    {
      "rank": 25,
      "score": 8.715724466237427,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    open_paren = 0\n    close_paren = 0\n\n    for i in lst:\n        if i == '(':\n            open_paren += 1\n        elif i == ')':\n            close_paren += 1\n\n        if open_paren == close_paren:\n            return 'No'\n\n    return 'Yes'"
    },
    {
      "rank": 26,
      "score": 8.692801520950061,
      "candidate": "stack = []\n    for s in lst:\n        if s[0] == '(' and s[-1] == ')':\n            stack.append(s[1:-1])\n        elif s[0] == ')' and s[-1] == '(':\n            if len(stack) == 0:\n                return 'No'\n            elif stack.pop()!= '(':\n                return 'No'\n        elif len(stack) == 0:\n            return 'No'\n    return 'Yes'"
    },
    {
      "rank": 27,
      "score": 8.632293453617281,
      "candidate": "if len(lst) == 1:\n        return 'Yes' if lst[0] == lst[1] else 'No'\n\n    if lst[0] == lst[1][::-1]:\n        return 'Yes'\n\n    return 'No'"
    },
    {
      "rank": 28,
      "score": 8.625262456968262,
      "candidate": "stack = []\n\n    for elem in lst:\n        if elem == '(':\n            stack.append('(')\n        elif elem == ')':\n            if len(stack) == 0:\n                return 'No'\n            if stack[-1]!= '(':\n                return 'No'\n            stack.pop()\n\n    return 'Yes' if len(stack) == 0 else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['())()', ')']) == 'Yes'\n    assert match_parens(['()(', ')']) == 'No'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 29,
      "score": 8.625142247198651,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    stack = []\n    for char in lst[0]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if char!= top:\n                    return 'No'\n\n    return 'Yes'"
    },
    {
      "rank": 30,
      "score": 8.616253589228675,
      "candidate": "if len(lst)!= 2:\n        return 'No'\n\n    stack = []\n\n    for item in lst:\n        if item == '(':\n            stack.append('(')\n        elif item == ')':\n            if not stack:\n                return 'No'\n            else:\n                stack.pop()\n\n    if not stack:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens([')', ')']) == 'Yes'\n    assert match_parens(['(()())', ')']) == 'No'\n    assert match_parens(['()()', ')']) == 'Yes'"
    },
    {
      "rank": 31,
      "score": 8.610076160146226,
      "candidate": "if len(lst)!= 2:\n        return 'No'\n\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append('(')\n        elif item == ')':\n            if not stack:\n                return 'No'\n            elif stack[-1]!= '(':\n                return 'No'\n            stack.pop()\n\n    return 'Yes' if not stack else 'No'\n\n\nprint(match_parens(['()(', ')']))\nprint(match_parens([')', ')']))\nprint(match_parens(['()', '(']))\nprint(match_parens(['()', ')']))"
    },
    {
      "rank": 32,
      "score": 8.606486429141842,
      "candidate": "stack = []\n    for s in lst:\n        if s[0] == '(':\n            stack.append(s)\n        elif s[0] == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                stack.pop()\n    return 'Yes'"
    },
    {
      "rank": 33,
      "score": 8.60156811074208,
      "candidate": "stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        elif item == ')':\n            if not stack:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes' if not stack else 'No'"
    },
    {
      "rank": 34,
      "score": 8.565425580227462,
      "candidate": "if len(lst) == 1:\n        return lst[0]\n    elif len(lst) == 2:\n        return lst[0] + lst[1]\n\n    if lst[0][0] == lst[1][0]:\n        return match_parens(lst[1:])\n\n    return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()', '(())']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['(()', '(())']) == 'Yes'\n    assert match_parens(['())', ')']) == 'Yes'"
    },
    {
      "rank": 35,
      "score": 8.548876241946822,
      "candidate": "open_paren = ['()', '(']\n    close_paren = [')', ')']\n    if len(lst) == 1:\n        return lst[0] == lst[1]\n    elif len(lst) == 2:\n        return lst[0] == lst[1] and lst[0] == lst[1]\n\n    for i in range(len(lst)):\n        if lst[i] in open_paren:\n            if lst[i+1] in close_paren:\n                return True\n        else:\n            if lst[i+1] in close_paren:\n                return False\n    return False"
    },
    {
      "rank": 36,
      "score": 8.542875062379007,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    stack = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            stack.append(lst[i])\n        elif lst[i] == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes' if stack else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 37,
      "score": 8.53012858503943,
      "candidate": "stack = []\n    for s1 in lst:\n        if s1[0] == '(':\n            stack.append(s1)\n        elif s1[-1] == ')':\n            if len(stack) == 0:\n                return 'No'\n            elif stack[-1]!= '(':\n                return 'No'\n            else:\n                stack.pop()\n    return 'Yes'\n\n\ndef match_parens2(lst):\n    '''\n    Same as above, but with a different logic.\n    '''\n    stack = []\n    for s1 in lst:\n        if s1[0] == '(':\n            stack.append(s1)\n        elif s1[-1] == ')':\n            if len(stack) == 0:\n                return 'No'\n            elif stack[-1]!= '(':\n                return 'No'\n            else:\n                stack.pop()\n    return 'Yes'\n\n\ndef match_parens3(lst):\n    '''\n    Same as above, but with a different logic.\n    '''\n    stack = []\n    for s1 in lst:\n        if s1[0] == '(':\n            stack.append(s1)\n        elif s1[-1] == ')':\n            if len(stack) == 0:\n                return 'No'\n            elif stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.pop()\n    return 'Yes'\n\n\ndef main():\n    lst = ['()(', ')']\n    print(match_parens(lst))\n    lst = [')', ')']\n    print(match_parens2(lst))\n    lst = ['(()())', ')']\n    print(match_parens3(lst))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 38,
      "score": 8.499905739299377,
      "candidate": "if len(lst) == 1:\n        return lst[0] == lst[1]\n    if len(lst) == 2:\n        return lst[0] == lst[1][::-1]\n    if len(lst) == 3:\n        return lst[0] == lst[1][::-1] and lst[0] == lst[2][::-1]\n\n    return False\n\n\nif __name__ == \"__main__\":\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()', '(()(())']) == 'Yes'\n    assert match_parens(['(())', '(())']) == 'Yes'"
    },
    {
      "rank": 39,
      "score": 8.490324832712195,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    lst.sort()\n    open_parens = 0\n    close_parens = 0\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            open_parens += 1\n        elif lst[i] == ')':\n            close_parens += 1\n        if open_parens > close_parens:\n            return 'No'\n    return 'Yes'"
    },
    {
      "rank": 40,
      "score": 8.48796797856353,
      "candidate": "stack = []\n    for ele in lst:\n        if ele == '(':\n            stack.append(ele)\n        elif ele == ')':\n            if not stack:\n                return 'No'\n            if len(stack) == 0:\n                return 'Yes'\n            top = stack.pop()\n            if ele!= top:\n                return 'No'\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['(()', ')']) == 'No'"
    },
    {
      "rank": 41,
      "score": 8.478208546788407,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    if lst[0][0]!= lst[1][0]:\n        return 'No'\n\n    stack = []\n\n    for i in lst:\n        if i[0] == '(':\n            stack.append(i[1])\n        elif i[0] == ')':\n            if not stack:\n                return 'No'\n            elif stack[-1] == '(':\n                stack.pop()\n            else:\n                return 'No'\n\n    if not stack:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 42,
      "score": 8.437695832075478,
      "candidate": "if not lst:\n        return 'No'\n    if lst[0][0] == lst[-1][-1]:\n        return match_parens(lst[1:-1])\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['())', ')()']) == 'Yes'\n    assert match_parens(['())', ')()()') == 'No'\n    assert match_parens(['()()', ')']) == 'Yes'\n    assert match_parens([')', '(())']) == 'No'\n    assert match_parens(['()', ')']) == 'Yes'\n    assert match_parens([')', '(())']) == 'Yes'"
    },
    {
      "rank": 43,
      "score": 8.426531424889468,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    if lst[0] == lst[1]:\n        return 'No'\n\n    open_parens = 0\n    close_parens = 0\n    for i in lst:\n        if i == '(':\n            open_parens += 1\n        elif i == ')':\n            close_parens += 1\n        if open_parens == close_parens:\n            return 'No'\n\n    return 'Yes'\n\n\nprint(match_parens([]))\nprint(match_parens([('())', ')']))"
    },
    {
      "rank": 44,
      "score": 8.408439383654278,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'"
    },
    {
      "rank": 45,
      "score": 8.386620303250325,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    if lst[0][0] == lst[-1][-1]:\n        return match_parens(lst[1:-1])\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    print(match_parens(['()(', ')']))"
    },
    {
      "rank": 46,
      "score": 8.375312293858853,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    stack = []\n\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                stack.pop()\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['(()())', '(())']) == 'Yes'\n    assert match_parens(['()', ')']) == 'No'\n    assert match_parens(['(()(())', '(())']) == 'Yes'"
    },
    {
      "rank": 47,
      "score": 8.351614956112536,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    if lst[0] == lst[1]:\n        return 'Yes'\n    if lst[0] == lst[-1]:\n        return 'No'\n\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        elif item == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'No'\n    assert match_parens(['()', ')']) == 'Yes'\n    assert match_parens([')', '(())']) == 'Yes'"
    },
    {
      "rank": 48,
      "score": 8.331556294201176,
      "candidate": "if lst[0] == lst[1]:\n        return 'Yes'\n    elif lst[0] == '' and lst[1] == '':\n        return 'No'\n    else:\n        return 'No'"
    },
    {
      "rank": 49,
      "score": 8.327375965969855,
      "candidate": "stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes' if len(stack) == 0 else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes', '(())()'\n    assert match_parens([')', ')']) == 'No', ')())'\n    assert match_parens(['())', ')']) == 'Yes', '())())'\n    assert match_parens(['())', '(())']) == 'No', '())())'\n    assert match_parens(['()(()(()(()()())', ')']) == 'Yes', '(())()()(()()()()')\n    assert match_parens(['()(()(()(()()())', ')()()()(()())']) == 'No', ')()()()(()()()()()')"
    },
    {
      "rank": 50,
      "score": 8.327367757082776,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append(s)\n        elif s == ')':\n            if len(stack) == 0:\n                return 'No'\n            elif stack.pop()!= '(':\n                return 'No'\n    return 'Yes'"
    },
    {
      "rank": 51,
      "score": 8.298597569547805,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    open_parens = 0\n    close_parens = 0\n\n    for i in lst:\n        if i == '(':\n            open_parens += 1\n        elif i == ')':\n            close_parens += 1\n\n    if open_parens == close_parens:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 52,
      "score": 8.294940769211511,
      "candidate": "if len(lst) == 0:\n        return False\n    if len(lst) == 1:\n        return lst[0] == lst[0]\n    if lst[0][0] == lst[1][0]:\n        return match_parens(lst[1:])\n    return False"
    },
    {
      "rank": 53,
      "score": 8.2938925966498,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == lst[1]:\n            return 'Yes'\n        else:\n            return 'No'\n\n    open_p = [i for i in lst[0] if i == '(']\n    close_p = [i for i in lst[1] if i == ')']\n    if len(open_p) == 0 or len(close_p) == 0:\n        return 'No'\n\n    open_p_open = open_p.pop()\n    close_p_close = close_p.pop()\n    if open_p_open == close_p_close:\n        return match_parens(lst)\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    print(match_parens([]), 'Yes')\n    print(match_parens(['()', ')']), 'No')\n    print(match_parens(['()(', ')']), 'Yes')\n    print(match_parens(['()', ')']), 'No')\n    print(match_parens(['()(', '(())']), 'Yes')\n    print(match_parens(['()(', '())']), 'No')\n    print(match_parens(['()(', '()(())']), 'Yes')\n    print(match_parens(['()(', '(()()())']), 'Yes')\n    print(match_parens(['()(', '(()()())']), 'No')"
    },
    {
      "rank": 54,
      "score": 8.289838256518838,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    if lst[0][0] == lst[1][0] and lst[0][1] == lst[1][1]:\n        return 'Yes'\n    return 'No'"
    },
    {
      "rank": 55,
      "score": 8.251903304236286,
      "candidate": "if lst[0] == lst[1]:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'Yes'\n    assert match_parens(['())', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens(['())', '(())']) == 'Yes'\n    assert match_parens(['())', '(()))']) == 'Yes'\n    assert match_parens(['())', '(())()']) == 'Yes'\n    assert match_parens(['())', '(())()()') == 'Yes'\n    assert match_parens(['())', '(())()()(())']) == 'Yes'\n    assert match_parens(['())', '(())()()()()(())']) == 'Yes'"
    },
    {
      "rank": 56,
      "score": 8.214125058964552,
      "candidate": "if lst == []:\n        return False\n    elif len(lst) == 1:\n        return lst[0] == lst[1]\n    elif len(lst) == 2:\n        if lst[0] == lst[1]:\n            return True\n        else:\n            return False\n    else:\n        return match_parens(lst[1:]) or match_parens(lst[:-1])"
    },
    {
      "rank": 57,
      "score": 8.212735598038213,
      "candidate": "pairs = []\n    for pair in lst:\n        if pair[0] == pair[1]:\n            pairs.append(pair)\n        else:\n            if len(pairs) == 0:\n                return 'No'\n            else:\n                prev = pairs.pop()\n                if prev[0] == pair[0]:\n                    pairs.append(prev)\n                else:\n                    return 'No'\n    if len(pairs) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nprint(match_parens(['()(', ')']))\nprint(match_parens([')', ')']))\nprint(match_parens(['()(()', ')']))\nprint(match_parens([')', ')']))\nprint(match_parens(['()(()', ')']))\nprint(match_parens([')', ')']))\nprint(match_parens(['()(()', ')']))"
    },
    {
      "rank": 58,
      "score": 8.211579567659316,
      "candidate": "stack = []\n\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['())()', ')()']) == 'Yes'\n    assert match_parens(['()', '(()')] == 'No'"
    },
    {
      "rank": 59,
      "score": 8.209707251476969,
      "candidate": "stack = []\n    for s in lst:\n        if s == '(':\n            stack.append(s)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n    if not stack:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nprint(match_parens(['()(', ')']))\nprint(match_parens([')', ')']))\nprint(match_parens(['(()', ')']))\nprint(match_parens(['())(', ')']))\nprint(match_parens([')()(', ')']))\nprint(match_parens([')()(', ')']))\nprint(match_parens(['())()', ')']))\nprint(match_parens(['())()', ')']))"
    },
    {
      "rank": 60,
      "score": 8.2048573255218,
      "candidate": "if lst:\n        if lst[0][0] == lst[-1][-1]:\n            return match_parens(lst[1:-1])\n        return 'No'\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['())', ')']) == 'Yes'\n    assert match_parens(['())(', ')']) == 'Yes'\n    assert match_parens(['()(', ')()']) == 'Yes'\n    assert match_parens(['(()(', ')']) == 'No'\n    assert match_parens(['(()(', ')']) == 'Yes'"
    },
    {
      "rank": 61,
      "score": 8.172253082181854,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    open_parens = 0\n    close_parens = 0\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            open_parens += 1\n        elif lst[i] == ')':\n            close_parens += 1\n\n    if open_parens == close_parens:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['())', '(())']) == 'Yes'\n    assert match_parens([')', '(()(())']) == 'No'\n    assert match_parens([')', '(()())']) == 'No'\n    assert match_parens([')', '(()())']) == 'Yes'\n    assert match_parens([')', '(()())']) == 'No'"
    },
    {
      "rank": 62,
      "score": 8.163300679823958,
      "candidate": "open_p = []\n    close_p = []\n\n    for s in lst:\n        if s[0] == '(':\n            open_p.append(s)\n        elif s[0] == ')':\n            if len(open_p) == 0:\n                return 'No'\n            elif len(open_p) == 1:\n                if open_p[-1] == '(':\n                    close_p.append(s)\n                else:\n                    close_p.pop()\n            else:\n                return 'No'\n\n    if len(close_p) == 0:\n        return 'Yes'\n    elif len(close_p) == 1:\n        if close_p[-1] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    else:\n        return 'No'"
    },
    {
      "rank": 63,
      "score": 8.144125099485041,
      "candidate": "def match(s1, s2):\n        if s1 == s2:\n            return True\n        if s1[0] == s2[-1]:\n            return match(s1[1:-1], s2[:-1])\n        return False\n\n    if len(lst) == 1:\n        return lst[0] == lst[1]\n    if len(lst) == 2:\n        return match(lst[0], lst[1])\n    return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()', '(())(())']) == 'Yes'"
    },
    {
      "rank": 64,
      "score": 8.143591138329747,
      "candidate": "return match(lst, 0, len(lst), 0)\n\ndef match(lst, l, r, n):\n    if l == r:\n        return lst[l] == lst[r]\n    if n == 0:\n        return False\n    if n == 1:\n        return lst[l] == '('\n    if lst[l] == '(' and lst[r] == ')':\n        return match(lst, l+1, r-1, n-1) or match(lst, l+1, r, n-1)\n    return False"
    },
    {
      "rank": 65,
      "score": 8.121884567141883,
      "candidate": "if len(lst)!= 2:\n        return 'No'\n    open_parens = []\n    close_parens = []\n    for element in lst:\n        if element == '(':\n            open_parens.append(element)\n        elif element == ')':\n            close_parens.append(element)\n        else:\n            if len(open_parens)!= 0:\n                open_parens.pop()\n            if len(close_parens)!= 0:\n                close_parens.pop()\n            else:\n                return 'No'\n    if len(open_parens) == 0:\n        return 'Yes'\n    elif len(close_parens) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()(', '((']) == 'Yes'\n    assert match_parens(['())', '())']) == 'No'\n    assert match_parens(['())', '())']) == 'No'"
    },
    {
      "rank": 66,
      "score": 8.105983444291466,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    stack = []\n\n    for char in lst[0]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return 'No'\n            if stack.pop()!= '(':\n                return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 67,
      "score": 8.08452234024709,
      "candidate": "# Your code here\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n    if stack:\n        return 'No'\n    return 'Yes'\n\n\ndef main():\n    print(match_parens(['()(', ')']))\n    print(match_parens([')', ')']))\n    print(match_parens(['()(', '()']))\n    print(match_parens(['()(', '(()(']))\n    print(match_parens(['())', '(()(']))\n    print(match_parens(['())', '(()())']))\n    print(match_parens(['())', '(()()())']))\n    print(match_parens(['())', '(()()())']))\n    print(match_parens(['())', '(()()())']))\n    print(match_parens(['())', '(()()())']))\n    print(match_parens(['())', '(()()())']))\n    print(match_parens(['())', '(()()())']))\n    print(match_parens(['())', '(()()())']))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 68,
      "score": 8.024835682833125,
      "candidate": "stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                return 'No'\n    return 'Yes' if not stack else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 69,
      "score": 7.990432406683839,
      "candidate": "stack = []\n    for s in lst:\n        if s == '(':\n            stack.append('(')\n        elif s == ')':\n            if not stack:\n                return 'No'\n            if stack[-1]!= '(':\n                return 'No'\n            stack.pop()\n    if not stack:\n        return 'Yes'\n    return 'No'"
    },
    {
      "rank": 70,
      "score": 7.938028884277233,
      "candidate": "stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                if stack.pop()!= '(':\n                    return 'No'\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 71,
      "score": 7.915588979966494,
      "candidate": "stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        elif item == ')':\n            if not stack:\n                return 'No'\n            if stack[-1]!= '(':\n                return 'No'\n            stack.pop()\n    if not stack:\n        return 'Yes'\n    return 'No'\n\n\nprint(match_parens([\"()(()\", \"()()\", \"()(()\"]))"
    },
    {
      "rank": 72,
      "score": 7.8912769574414305,
      "candidate": "open_paren = []\n    close_paren = []\n    for item in lst:\n        if item[0] == '(':\n            open_paren.append(item)\n        elif item[0] == ')':\n            close_paren.append(item)\n\n    if len(open_paren) == len(close_paren):\n        for open_paren_item in open_paren:\n            if close_paren.count(open_paren_item) == 0:\n                return 'Yes'\n        for close_paren_item in close_paren:\n            if open_paren.count(close_paren_item) == 0:\n                return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 73,
      "score": 7.868947655733293,
      "candidate": "open_paren = []\n    close_paren = []\n    for i in lst:\n        if i == '(':\n            open_paren.append(i)\n        elif i == ')':\n            close_paren.append(i)\n\n    if len(open_paren) == len(close_paren):\n        return 'Yes'\n    else:\n        return 'No'\n\nprint(match_parens([\"()((),)\", \"()()()\"]))"
    },
    {
      "rank": 74,
      "score": 7.84634113240411,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    left_open_stack = []\n    right_open_stack = []\n\n    for item in lst:\n        if item == '(':\n            left_open_stack.append(item)\n        elif item == ')':\n            if len(left_open_stack) == 0:\n                return 'No'\n            else:\n                left_open_stack.pop()\n        else:\n            if len(right_open_stack) == 0:\n                return 'No'\n            else:\n                right_open_stack.pop()\n\n    if len(left_open_stack) == 0 and len(right_open_stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()', '(())']) == 'Yes'"
    },
    {
      "rank": 75,
      "score": 7.834022619458933,
      "candidate": "if lst[0] == lst[1]:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    print(match_parens(['()(', ')']))\n    print(match_parens([')', ')']))\n    print(match_parens(['()', ')']))\n    print(match_parens([')', '(']))\n    print(match_parens(['())(', ')']))\n    print(match_parens(['())', ')']))\n    print(match_parens(['()(', ')']))\n    print(match_parens(['())(', ')']))\n    print(match_parens(['()(', ')']))\n    print(match_parens(['()(', ')']))"
    },
    {
      "rank": 76,
      "score": 7.780351419995229,
      "candidate": "stack = []\n\n    for c in lst:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top == '(':\n                    stack.append(c)\n                elif top == ')':\n                    if len(stack) == 0:\n                        return 'No'\n                    else:\n                        return 'No'\n    return 'Yes'"
    },
    {
      "rank": 77,
      "score": 7.738292593776799,
      "candidate": "p = []\n    for s in lst:\n        if s[0] == '(':\n            p.append(s)\n        elif s[-1] == ')':\n            if len(p) > 0:\n                p.pop()\n            else:\n                return 'No'\n    if len(p) == 0:\n        return 'Yes'\n    return 'No'\n\n\nif __name__ == '__main__':\n    print(match_parens([()(', ')']))\n    print(match_parens([()]))\n    print(match_parens([()((),())()()()']))"
    },
    {
      "rank": 78,
      "score": 7.7320703513377165,
      "candidate": "for i in range(len(lst)-1):\n        if lst[i][0] == lst[i+1][-1] and lst[i][-1] == '(':\n            lst.pop(i)\n    if len(lst) == 0:\n        return 'Yes'\n    return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['(())', ')']) == 'Yes'"
    },
    {
      "rank": 79,
      "score": 7.705183449260731,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    for i in range(1, len(lst)):\n        if lst[i][0]!= lst[i-1]:\n            return 'No'\n    return 'Yes'"
    },
    {
      "rank": 80,
      "score": 7.5819855281879285,
      "candidate": "stack = []\n    for x in lst:\n        if x == '(':\n            stack.append(x)\n        elif x == ')':\n            if not stack:\n                return 'No'\n            else:\n                stack.pop()\n    return 'Yes' if not stack else 'No'"
    },
    {
      "rank": 81,
      "score": 7.562924366763077,
      "candidate": "if len(lst) == 1:\n        return lst[0] == lst[1]\n    else:\n        return lst[0] == lst[-1] and match_parens(lst[:-1])\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([\"(())\", \"()()\") == 'Yes'\n    assert match_parens([\"(())\", \"()(())\"]) == 'Yes'\n    assert match_parens([\"(())()\", \"(())()\"]) == 'Yes'\n    assert match_parens([\"(())()\", \"()(())\", \"()(())\"]) == 'No'"
    },
    {
      "rank": 82,
      "score": 7.4878043221155455,
      "candidate": "stack = []\n\n    for item in lst:\n        if item == '(':\n            stack.append('(')\n        elif item == ')':\n            if not stack:\n                return 'No'\n            elif stack[-1] == '(':\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes' if not stack else 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 83,
      "score": 7.464609382504557,
      "candidate": "if len(lst)!= 2:\n        return 'No'\n\n    if lst[0][0] == lst[1][0] and lst[0][1] == lst[1][1]:\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 84,
      "score": 7.134571892399572,
      "candidate": "if len(lst)!= 2:\n        return 'No'\n\n    open_parens = ['(']\n    close_parens = [')']\n\n    for i in range(len(lst[0])):\n        if lst[0][i] == open_parens[-1]:\n            open_parens.pop()\n        else:\n            return 'No'\n\n    for i in range(len(lst[1])):\n        if lst[1][i] == close_parens[-1]:\n            close_parens.pop()\n        else:\n            return 'No'\n\n    if len(open_parens) == 0:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
      "rank": 85,
      "score": 3.0,
      "candidate": "# Your code here\n    if not lst:\n        return 'No'\n\n    stack = []\n    for s in lst:\n        if s[0] == '(':\n            stack.append(s[1:])\n        else:\n            if not stack:\n                return 'No'\n            if stack[-1] == ')':\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'No'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'No'\n    assert match_parens([']) == 'Yes'\n    assert match_parens([]) == 'Yes'\n    assert match_parens([]) == 'No'\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 86,
      "score": 3.0,
      "candidate": "s1 = []\n    s2 = []\n    for i in lst:\n        if i[0] == '(':\n            s1.append(i[1])\n        elif i[0] == ')':\n            s2.append(i[1])\n\n    if len(s1) == len(s2):\n        for i in range(len(s1)):\n            if s1[i] == s2[i]:\n                continue\n            else:\n                return 'No'\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['(()(', ')', '(()', '((', '()))', '(())', '(())', '(())', '(())', '(())', '(()())']) == 'Yes'\n    assert match_parens(['(())(', ')(', '(()', '((', '()))', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '(())', '("
    },
    {
      "rank": 87,
      "score": 3.0,
      "candidate": "if len(lst) < 2:\n        return 'No'\n\n    open_paren = 0\n    close_paren = 0\n\n    for i in lst:\n        if i == '(':\n            open_paren += 1\n        elif i == ')':\n            close_paren += 1\n\n    if open_paren == close_paren:\n        return 'Yes'\n\n    return 'No'\n\n\ndef match_parens_2(lst):\n    '''\n    Two strings consist of open parentheses '(' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens_2(['()(', ')']) == 'Yes'\n    match_parens_2([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return 'Yes'\n\n    return 'No'\n\n\nif __name__ == '__main__':\n    print(match_parens([]))\n    print(match_parens([]))\n    print(match_parens([('()', ')')]))\n    print(match_parens([('())', ')')]))\n    print(match_parens([('())', ')'), ('()', ')')]))\n    print(match_parens([('()', ')'), ('())', ')')]))\n    print(match_parens([('()', ')'), ('())', ')')]))\n    print(match_parens([('())', ')'), ('())', ')')]))\n    print(match_parens([('()', ')'), ('())', ')')]))"
    },
    {
      "rank": 88,
      "score": 3.0,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    s = lst[0]\n    if len(lst) == 2:\n        return 'Yes'\n\n    for i in range(1, len(lst)):\n        if s[i]!= lst[i - 1]:\n            return 'No'\n\n    return 'Yes'\n\n\ndef match_parens_2(lst):\n    '''\n    Solution:\n    First, we need to check if the first string is balanced. If it is,\n    we need to check if the last string is balanced. If it is,\n    we need to check if both strings are balanced. If both strings are\n    balanced, we have a good string.\n    If there is a way to make a good string, we return 'Yes' if there is\n    a way to make a good string, and return 'No' otherwise.\n\n    If the two strings are balanced, we have a good string.\n\n    Examples:\n    match_parens_2(['())()', '))']) == 'Yes'\n    match_parens_2([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n\n    s = lst[0]\n    if len(lst) == 2:\n        return 'Yes'\n\n    l = len(s)\n    r = len(lst[1])\n\n    if s[0]!= lst[1][0]:\n        return 'No'\n\n    if s[l - 1]!= lst[1][r - 1]:\n        return 'No'\n\n    if s[l - 2]!= lst[1][r - 2]:\n        return 'No'\n\n    if s[l - 3]!= lst[1][r - 3]:\n        return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['())()', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['())()', ')']) == 'No'\n    assert match_parens(['())()', ')'])"
    },
    {
      "rank": 89,
      "score": 3.0,
      "candidate": "s1 = set(lst[0])\n    s2 = set(lst[1])\n\n    if len(s1)!= len(s2):\n        return 'No'\n\n    if len(s1) == 0:\n        return 'Yes'\n\n    if len(s2) == 0:\n        return 'Yes'\n\n    for i in range(len(s1)):\n        if s1[i]!= s2[i]:\n            return 'No'\n\n    return 'Yes'\n\n\ndef match_parens_2(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    '(', ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in\n    S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens_2(['()(', ')']) == 'Yes'\n    match_parens_2([')', ')']) == 'No'\n    '''\n\n    s1 = set(lst[0])\n    s2 = set(lst[1])\n\n    if len(s1)!= len(s2):\n        return 'No'\n\n    if len(s1) == 0:\n        return 'Yes'\n\n    if len(s2) == 0:\n        return 'Yes'\n\n    for i in range(len(s1)):\n        if s1[i]!= s2[i]:\n            return 'No'\n\n    return 'Yes'"
    },
    {
      "rank": 90,
      "score": 3.0,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    if lst[0][0] == lst[1][0] and lst[0][1] == lst[1][1]:\n        return 'Yes'\n    return 'No'\n\n\ndef match_parens2(lst):\n    '''\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens2(['()(', ')']) == 'Yes'\n    match_parens2([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    open_parens = 0\n    close_parens = 0\n    for i in lst:\n        if i[0] == '(':\n            open_parens += 1\n        if i[1] == ')':\n            close_parens += 1\n    if open_parens == close_parens:\n        return 'Yes'\n    return 'No'\n\n\ndef match_parens3(lst):\n    '''\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens3(['()(', ')']) == 'Yes'\n    match_parens3([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if lst[0][0] == lst[1][0] and lst[0]["
    },
    {
      "rank": 91,
      "score": 3.0,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens2(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    or close parentheses only. Your job is to check if it is possible\n    to concatenate the two strings in some order, that the resulting string will\n    be good. A string S is considered to be good if and only if all parentheses\n    in S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens2(['()(', ')']) == 'Yes'\n    match_parens2([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                top = stack.pop()\n                if top!= '(':\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens3(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    or close parentheses only. Your job is to check if it is possible\n    to concatenate the two strings in some order, that the resulting string will\n    be good. A string S is considered to be good if and only if all parentheses\n    in S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples"
    },
    {
      "rank": 92,
      "score": 3.0,
      "candidate": "n = len(lst)\n    if n < 2:\n        return 'No'\n    if n == 2:\n        if lst[0] == lst[1]:\n            return 'Yes'\n        else:\n            return 'No'\n\n    open_list = []\n    close_list = []\n    for i in lst:\n        if i == '(':\n            open_list.append(i)\n        elif i == ')':\n            close_list.append(i)\n\n    if len(open_list) == 0 or len(close_list) == 0:\n        return 'No'\n\n    if len(open_list) > len(close_list):\n        return 'Yes'\n    else:\n        return 'No'\n\n\nif __name__ == '__main__':\n    assert match_parens([]) == 'Yes'\n    assert match_parens(['(()()', ')']) == 'Yes'\n    assert match_parens([]) == 'No'\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    },
    {
      "rank": 93,
      "score": 3.0,
      "candidate": "s1 = ''.join(lst[0])\n    s2 = ''.join(lst[1])\n\n    if s1 == s2:\n        return 'Yes'\n    else:\n        return 'No'\n\n\ndef test_match_parens():\n    assert match_parens([]) == 'No'\n    assert match_parens([('(', ')')]) == 'Yes'\n    assert match_parens([(')', ')')]) == 'No'\n    assert match_parens([('(()', ')')]) == 'Yes'\n    assert match_parens([('()()', ')')]) == 'No'\n    assert match_parens([('()', '(()')]) == 'Yes'\n    assert match_parens([('()', ')')]) == 'No'\n    assert match_parens([('()', '(()()')]) == 'Yes'\n    assert match_parens([('()', '(()()()')]) == 'No'\n    assert match_parens([('())', '(())()')]) == 'Yes'\n    assert match_parens([('())', '(())()()')]) == 'No'\n    assert match_parens([('())', '(())()()')]) == 'Yes'\n    assert match_parens([('())', '(())()()')]) == 'Yes'\n    assert match_parens([('()', '(()()()')]) == 'Yes'\n    assert match_parens([('()', '(()()()')]) == 'Yes'\n    assert match_parens([('())', '(())()()')]) == 'Yes'\n    assert match_parens([('())', '(())()()')]) == 'No'\n    assert match_parens([('())', '(())()()')]) == 'No'\n    assert match_parens([('())', '(())()()')]) == 'Yes'\n    assert match_parens([('())', '(())()()')]) == 'No'\n    assert match_parens([('())', '(())()()')]) == 'No'\n    assert match_parens([('())', '(())()()')]) == 'No'\n    assert match_parens([('())',"
    },
    {
      "rank": 94,
      "score": 3.0,
      "candidate": "if not lst:\n        return 'No'\n\n    lst.sort()\n    if lst[0] == lst[-1]:\n        return 'Yes'\n    return 'No'\n\n\ndef match_parens2(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    or close parentheses only.\n    Your job is to check if it is possible to concatenate the two strings\n    in some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens2(['()(', ')']) == 'Yes'\n    match_parens2([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'No'\n\n    lst.sort()\n    if lst[0] == lst[-1]:\n        return 'Yes'\n    return 'No'\n\n\ndef match_parens3(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    or close parentheses only.\n    Your job is to check if it is possible to concatenate the two strings\n    in some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens3(['()(', ')']) == 'Yes'\n    match_parens3([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'No'\n\n    lst.sort()\n    if lst[0] == lst[-1]:\n        return 'Yes'\n    return 'No'\n\n\ndef match_parens4(lst):\n    '''\n    Given a list of two"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "stack = []\n    for s in lst:\n        if s[0] == '(':\n            stack.append(s)\n        elif s[0] == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'\n\n\ndef match_parens2(lst):\n    '''\n    You are given a list of two strings, both strings consist of open parentheses\n    or close parentheses only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens2(['()(', ')']) == 'Yes'\n    match_parens2([')', ')']) == 'No'\n    '''\n    stack = []\n    for s in lst:\n        if s[0] == '(':\n            stack.append(s)\n        elif s[0] == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens2([')', ')']) == 'Yes'\n    assert match_parens2(['(())', ')']) == 'Yes'\n    assert match_parens2(['()(', ')']) == 'Yes'\n    assert match_parens2([')', '(())']) == 'Yes'"
    },
    {
      "rank": 96,
      "score": 3.0,
      "candidate": "if len(lst) < 2:\n        return 'No'\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                last_open = stack.pop()\n                if i!= last_open:\n                    return 'No'\n    return 'Yes'\n\n\ndef match_parens_2(lst):\n    '''\n    Same as above, but with more complexity\n\n    Examples:\n    match_parens_2(['()(', ')']) == 'Yes'\n    match_parens_2([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                last_open = stack.pop()\n                if i!= last_open:\n                    return 'No'\n    return 'Yes'"
    },
    {
      "rank": 97,
      "score": 3.0,
      "candidate": "for i in lst:\n        if i.count('(')!= i.count(')'):\n            return 'No'\n    return 'Yes'\n\n\ndef match_parens2(lst):\n    '''\n    Solution to this problem is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens2(['()(', ')']) == 'Yes'\n    match_parens2([')', ')']) == 'No'\n    '''\n    def balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n\n    for i in lst:\n        if balanced(i):\n            return 'Yes'\n    return 'No'\n\n\nif __name__ == '__main__':\n    print(match_parens2(['()(', ')']))"
    },
    {
      "rank": 98,
      "score": 3.0,
      "candidate": "if lst[0][0] == lst[1][0]:\n        if lst[0][1] == lst[1][1]:\n            return 'Yes'\n        else:\n            return 'No'\n    else:\n        return 'No'\n\n\ndef match_parens_2(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    and close parentheses only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in\n    S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens_2(['()(', ')']) == 'Yes'\n    match_parens_2([')', ')']) == 'No'\n    '''\n    if lst[0][0] == lst[1][1]:\n        return 'Yes'\n    else:\n        return 'No'\n\n\ndef match_parens_3(lst):\n    '''\n    Given a list of two strings, both strings consist of open parentheses\n    and close parentheses only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in\n    S are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens_3(['()(', ')']) == 'Yes'\n    match_parens_3([')', ')']) == 'No'\n    '''\n    if lst[0][0] == lst[1][1] and lst[0][1] == lst[1][0]:\n        return 'Yes'\n    else:\n        return 'No'\n\n\ndef match_parens_"
    },
    {
      "rank": 99,
      "score": 3.0,
      "candidate": "open_parens = 0\n    close_parens = 0\n\n    for pair in lst:\n        if pair[0] == '(':\n            open_parens += 1\n        elif pair[0] == ')':\n            close_parens += 1\n\n        if open_parens < close_parens:\n            return 'No'\n\n    return 'Yes'\n\n\nif __name__ == '__main__':\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'\n    assert match_parens(['()', '(()')] == 'Yes'"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "stack = []\n\n    for c in lst:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'\n\n\ndef test_match_parens():\n    assert match_parens(['()(', ')']) == 'Yes'\n    assert match_parens([')', ')']) == 'No'"
    }
  ]
}