{
  "timestamp": "2025-09-14T11:59:57.698296",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "humaneval",
  "problem_number": 100,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "stones = [n]\n    for i in range(2, n+1):\n        stones.append(stones[i-1]+2 if i%2==0 else stones[i-1]+1)\n    return stones\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive(3)\n    [3, 5, 7]\n    \"\"\"\n    if n==1:\n        return [n]\n    else:\n        return [n+i for i in make_a_pile_recursive(n-1)]\n\n\ndef make_a_pile_iterative(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_iterative(3)\n    [3, 5, 7]\n    \"\"\"\n    stones = [n]\n    for i in range(2, n+1):\n        if i%2==0:\n            stones.append(stones[i-1]+2 if i%2==0 else stones[i-1]+1)\n        else:\n            stones.append(stones[i-1]+1 if i%2==0 else stones[i-1]+2)\n    return stones"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "lst = []\n    for i in range(n):\n        if i % 2 == 0:\n            lst.append(2 * i + 1)\n        else:\n            lst.append(i + 1)\n    return lst\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "if n == 1:\n        return [n]\n    if n % 2 == 0:\n        return make_a_pile(n // 2) + [n // 2]\n    else:\n        return make_a_pile(n // 2) + [2 * n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "return [n] + [i for i in range(2, n + 1, 2) if n % i == 0]\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive(3)\n    [3, 5, 7]\n    \"\"\"\n    if n == 1:\n        return [n]\n    return [i + 1 for i in make_a_pile_recursive(n - 1)] + [n]\n\n\ndef make_a_pile_recursive_2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive_2(3)\n    [3, 5, 7]\n    \"\"\"\n    return [i + 1 for i in range(2, n + 1, 2) if n % i == 0] + [n]\n\n\ndef make_a_pile_recursive_3(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "result = []\n    for i in range(n):\n        result.append(n - i)\n        if i % 2 == 0:\n            result.append(2 * i + 1)\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "if n == 0:\n        return [0]\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n % 2 == 0:\n        return [1, 2, 3]\n    else:\n        return [3, 5, 7]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "return [n] + [2 * i + 1 for i in range(n // 2)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "stones = [n]\n    for i in range(n):\n        if i % 2 == 1:\n            stones.append(stones[-1] + 1)\n        else:\n            stones.append(stones[-1] - 1)\n    return stones\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "result = []\n    current_level = n\n    while current_level > 0:\n        if current_level % 2 == 1:\n            result.append(current_level)\n        current_level = current_level // 2\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "if n <= 1:\n        return [n]\n    else:\n        return [n] + make_a_pile(n - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + 2)\n    return pile\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "return [n] + [[n + i for i in range(2) if i % 2 == 0] for i in range(1, n + 1)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "if n == 0:\n        return [0]\n    if n % 2 == 0:\n        return [n - 1, n, n + 1]\n    else:\n        return [n - 2, n, n + 2]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "if n == 1:\n        return [n]\n    return make_a_pile(n-1) + [n//2]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "if n < 2:\n        return []\n\n    pile = [n]\n    i = 1\n\n    while i <= n:\n        pile.append(i + 2)\n        i += 1\n\n    return pile\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Recursive implementation of the above.\n    \"\"\"\n    if n < 2:\n        return []\n\n    pile = [n]\n    i = 1\n    while i <= n:\n        pile.append(i + 2)\n        if i % 2 == 1:\n            i += 1\n        else:\n            i += 1\n\n    return pile\n\n\ndef make_a_pile_recursive2(n):\n    \"\"\"\n    Recursive implementation of the above.\n    \"\"\"\n    if n < 2:\n        return []\n\n    pile = [n]\n    i = 1\n    while i <= n:\n        pile.append(i + 2)\n        if i % 2 == 1:\n            i += 1\n        else:\n            i += 1\n            if i > 1:\n                pile.append(pile[-1] + 2)\n\n    return pile\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "if n == 0:\n        return [n]\n    if n == 1:\n        return [1, 1, 1]\n    return make_a_pile(n-1) + [1, 2, 2]"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "if n < 2:\n        return [n]\n\n    return make_a_pile(n-1) + [n//2]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "if n == 1:\n        return [n]\n    return make_a_pile(n-1) + [n//2]\n\n\ndef test_make_a_pile():\n    assert make_a_pile(3) == [3, 5, 7]\n    assert make_a_pile(4) == [3, 5, 7, 8]\n    assert make_a_pile(5) == [3, 5, 7, 8, 9]\n    assert make_a_pile(6) == [3, 5, 7, 8, 9, 10, 11, 12]\n    assert make_a_pile(7) == [3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n    assert make_a_pile(8) == [3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n    assert make_a_pile(9) == [3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n    assert make_a_pile(10) == [3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "level = [n]\n    for i in range(2, n+1):\n        level.append(i)\n        if i % 2 == 1:\n            level.append(level[i//2] + 1)\n    return level"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "return [0] + [i * 2 for i in range(n)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "if n < 0:\n        raise ValueError(\"n must be a positive integer\")\n    if n == 0:\n        return [n]\n    odd_numbers = []\n    even_numbers = []\n    odd_numbers.append(n)\n    odd_numbers.append(n + 1)\n    odd_numbers.append(n + 2)\n    odd_numbers.append(n + 3)\n    odd_numbers.append(n + 4)\n    odd_numbers.append(n + 5)\n    even_numbers.append(n + 6)\n    even_numbers.append(n + 7)\n    even_numbers.append(n + 8)\n    even_numbers.append(n + 9)\n    return odd_numbers + even_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "if n < 2:\n        return [n]\n    else:\n        return [\n            n if n % 2 == 1 else n + 1,\n            make_a_pile(n - 1)[-1],\n        ]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 10.0,
      "candidate": "pile = [n]\n    for i in range(1, n):\n        pile.append(pile[-1] + (i % 2))\n    return pile\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 10.0,
      "candidate": "if n < 2:\n        return [n]\n    else:\n        return [n] + make_a_pile(n-1)\n\n\ndef make_a_pile_2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_2(3)\n    [3, 5, 7]\n    \"\"\"\n    if n < 2:\n        return [n]\n    else:\n        return [n] + [0] + make_a_pile_2(n-1)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 10.0,
      "candidate": "if n <= 0:\n        raise ValueError(\"n must be positive\")\n\n    return [n] + [n+1 if i%2 == 0 else n+2 for i in range(n)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 10.0,
      "candidate": "result = []\n    for i in range(1, n + 1):\n        result.append(i)\n        if i % 2 == 0:\n            result.append(i // 2)\n        else:\n            result.append(i // 2 + 1)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 10.0,
      "candidate": "pile = [n]\n    for i in range(n):\n        if i % 2 == 0:\n            pile.append(pile[-1] + 2)\n        else:\n            pile.append(pile[-1] + 1)\n    return pile\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 10.0,
      "candidate": "return [n] + [n + 2 * i for i in range(n % 2, n - 1, -2)]"
    },
    {
      "rank": 29,
      "score": 9.993251387631034,
      "candidate": "if n == 1:\n        return [1]\n    else:\n        odd_stones = [1] * (n - 1)\n        even_stones = [1] * (n - 2)\n        for i in range(1, n):\n            odd_stones[i] = odd_stones[i - 1] + 2\n            even_stones[i] = even_stones[i - 1] + 2\n        return odd_stones + even_stones\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 30,
      "score": 9.982086980445024,
      "candidate": "if n == 0:\n        return []\n    return [n] + make_a_pile(n - 1)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 31,
      "score": 9.963994939209833,
      "candidate": "if n == 1:\n        return [1]\n    if n % 2 == 0:\n        return [1, 2]\n    return [1, 2, 3, 4]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 9.930867849414408,
      "candidate": "if n < 2:\n        return [n]\n    elif n % 2 == 0:\n        return [n, n+1]\n    else:\n        return [n, n+2]\n\n\ndef make_a_pile_recur(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recur(3)\n    [3, 5, 7]\n    \"\"\"\n    if n < 2:\n        return [n]\n    elif n % 2 == 0:\n        return [n, n+1]\n    else:\n        return [n, n+2]\n\n\ndef make_a_pile_recu(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recu(3)\n    [3, 5, 7]\n    \"\"\"\n    if n < 2:\n        return [n]\n    elif n % 2 == 0:\n        return [n, n+1]\n    else:\n        return [n, n+2]\n\n\ndef make_a_pile_recu_recur(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones"
    },
    {
      "rank": 33,
      "score": 9.907170511668092,
      "candidate": "return [n + 1] + [i + 1 for i in range(2, n + 1)]\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 34,
      "score": 9.887111849756732,
      "candidate": "result = []\n    for i in range(n):\n        result.append(0)\n        if i % 2 == 0:\n            result[i] = i + 1\n    return result\n\n\ndef make_a_pile_1(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_1(3)\n    [3, 5, 7]\n    \"\"\"\n    result = []\n    for i in range(n):\n        result.append(0)\n        if i % 2 == 0:\n            result[i] = i + 1\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 9.882923312638333,
      "candidate": "pile = []\n    for i in range(n):\n        pile.append(n)\n        if n % 2 == 0:\n            n -= 1\n        else:\n            n += 1\n    return pile\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 9.850496324767066,
      "candidate": "result = []\n    for i in range(n):\n        result.append(i+1)\n        if i % 2 == 1:\n            result.append(2*i+1)\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 9.807458859791842,
      "candidate": "if n == 0:\n        return [0]\n    elif n == 1:\n        return [1]\n    else:\n        return [n // 2 + 1, n // 2] + make_a_pile(n - (n // 2))\n\n\ndef main():\n    print(make_a_pile(3))\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 38,
      "score": 9.768291153593768,
      "candidate": "return [n] + [(n * 2) + (n * 3) + (n * 4)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 9.765262807032524,
      "candidate": "if n < 1:\n        return []\n    if n == 1:\n        return [n]\n    if n % 2 == 1:\n        return make_a_pile(n // 2) + [n // 2]\n    else:\n        return make_a_pile(n // 2) + [n]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 9.760412881077356,
      "candidate": "if n < 1:\n        raise ValueError\n    if n == 1:\n        return [n]\n    return make_a_pile(n-1) + [2*n]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 41,
      "score": 9.73511989811648,
      "candidate": "if n < 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    pile = [n]\n    for _ in range(1, n):\n        pile.append(pile[-1] + 2 if n % 2 else pile[-1])\n\n    return pile\n\n\ndef test_make_a_pile():\n    assert make_a_pile(3) == [3, 5, 7]\n    assert make_a_pile(4) == [3, 5, 7, 9]"
    },
    {
      "rank": 42,
      "score": 9.699680655040597,
      "candidate": "if n <= 0:\n        return []\n    result = [n]\n    for i in range(1, n):\n        result.append(result[-1] + (2 if i % 2 == 1 else 1))\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 43,
      "score": 9.699146693885302,
      "candidate": "a_pile = [n]\n    for _ in range(2, n+1):\n        a_pile.append(a_pile[-1]+2)\n    return a_pile\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 44,
      "score": 9.677440122697439,
      "candidate": "return [n] + [n + (2 if i % 2 == 1 else 1) for i in range(n)]"
    },
    {
      "rank": 45,
      "score": 9.648973453061323,
      "candidate": "res = [0] * (n+1)\n    res[0] = n\n    res[1] = 2\n\n    for i in range(2, n+1):\n        res[i] = res[i-1] + 2\n\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 46,
      "score": 9.595753198553407,
      "candidate": "res = [n]\n    for i in range(1, n):\n        res.append(res[-1] + 2)\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 47,
      "score": 9.58039123838868,
      "candidate": "pile = [n]\n    i = 1\n    while i < n:\n        pile.append(pile[i-1] + 2 if i % 2 else pile[i-1] + 1)\n        i += 1\n    return pile\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"
    },
    {
      "rank": 48,
      "score": 9.493584439832787,
      "candidate": "if n == 0:\n        return [0]\n    if n == 1:\n        return [1]\n\n    odd_odd = [2, 3, 4]\n    odd_even = [5, 6, 7]\n    even_odd = [8, 9, 10]\n    even_even = [11, 12, 13]\n\n    odd_odd.reverse()\n    odd_even.reverse()\n    even_odd.reverse()\n    even_even.reverse()\n\n    odd_odd.append(n % 2)\n    odd_even.append(n // 2)\n    even_odd.append(n % 2)\n    even_even.append(n // 2)\n\n    return odd_odd + odd_even + even_odd + even_even\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 49,
      "score": 9.47114453552205,
      "candidate": "if n <= 0:\n        raise ValueError\n\n    pile = [n]\n    for i in range(2, n):\n        pile.append(pile[i-1] + 2)\n    return pile\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 50,
      "score": 9.42450321128885,
      "candidate": "return [0] * n\n\n\ndef make_a_pile_2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_2(3)\n    [3, 5, 7]\n    \"\"\"\n    result = [0] * n\n    result[0] = n\n    result[1] = 2 * result[0] - 1\n    result[2] = 2 * result[1] - 1\n    return result\n\n\ndef make_a_pile_3(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_3(3)\n    [3, 5, 7]\n    \"\"\"\n    result = [0] * n\n    result[0] = n\n    result[1] = 2 * result[0] - 1\n    result[2] = 2 * result[1] - 1\n    result[3] = 2 * result[2] - 1\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 51,
      "score": 9.401896687959665,
      "candidate": "res = []\n    while n > 0:\n        if n & 1:\n            res.append(1)\n        else:\n            res.append(2)\n        n >>= 1\n    return res\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 52,
      "score": 9.389578175014488,
      "candidate": "pile = []\n    while n > 0:\n        pile.append(n % 2)\n        n = n // 2\n    return pile\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 53,
      "score": 9.293848149332355,
      "candidate": "if n < 2:\n        return []\n    else:\n        odd_stones = [n // 2]\n        even_stones = [n - n // 2]\n        return odd_stones + even_stones\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 54,
      "score": 9.26824252593394,
      "candidate": "return [n] + [n//2] * (n % 2)"
    },
    {
      "rank": 55,
      "score": 9.260739004816287,
      "candidate": "if n < 2:\n        return [n]\n\n    odd = []\n    even = []\n    for i in range(n - 1):\n        odd.append(i)\n        even.append(i + 1)\n\n    return odd + even\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 56,
      "score": 9.16683293640293,
      "candidate": "res = [n]\n    for i in range(2, n):\n        res.append(res[-1] + i)\n    return res\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Recursive solution to make a pile.\n\n    >>> make_a_pile_recursive(3)\n    [3, 5, 7]\n    \"\"\"\n    if n == 0:\n        return []\n    res = []\n    res.append(n)\n    for i in range(2, n):\n        res.append(res[-1] + i)\n    return res\n\n\ndef make_a_pile_stack(n):\n    \"\"\"\n    Stack solution to make a pile.\n\n    >>> make_a_pile_stack(3)\n    [3, 5, 7]\n    \"\"\"\n    res = [n]\n    while len(res) < n:\n        res.append(res[-1] + res[-1])\n    return res"
    },
    {
      "rank": 57,
      "score": 9.137541083743484,
      "candidate": "result = [0] * n\n    odd_numbers = [2, 4, 6, 8, 10, 12, 14, 16, 18]\n    even_numbers = [1, 3, 5, 7]\n    for i in range(n):\n        result[i] = result[i+1] = (odd_numbers[i] + even_numbers[i]) % 2\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 58,
      "score": 9.118479922318633,
      "candidate": "res = []\n    for i in range(n):\n        res.append(i + 1)\n        if i % 2 == 0:\n            res.append(2 * i + 1)\n    return res\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 59,
      "score": 9.0433598776711,
      "candidate": "return [n] + [n + 1 if n % 2 == 1 else n + 2 for n in range(n)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 60,
      "score": 9.038426088443575,
      "candidate": "a_pile = []\n    for i in range(n):\n        if i % 2 == 0:\n            a_pile.append(2)\n        else:\n            a_pile.append(1)\n    return a_pile"
    },
    {
      "rank": 61,
      "score": 9.006215542699554,
      "candidate": "if n == 0:\n        return []\n\n    if n % 2 == 0:\n        return [n] + make_a_pile(n // 2)\n    else:\n        return [n] + make_a_pile(n // 2 + 1)\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive(3)\n    [3, 5, 7]\n    \"\"\"\n    if n == 0:\n        return []\n\n    if n % 2 == 0:\n        return [n] + make_a_pile_recursive(n // 2)\n    else:\n        return [n] + make_a_pile_recursive(n // 2 + 1)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 62,
      "score": 8.761329515178183,
      "candidate": "if n == 0:\n        return []\n\n    if n % 2 == 1:\n        return [n]\n\n    return [n] + make_a_pile(n-1)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 63,
      "score": 8.732446410642655,
      "candidate": "if n < 2:\n        return []\n    if n % 2 == 0:\n        return [n + 1]\n    else:\n        return [n, 2 * n + 1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 64,
      "score": 8.690127447955128,
      "candidate": "if n == 0:\n        return [n]\n    return make_a_pile(n-1) + [n//2]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod(verbose=True)"
    },
    {
      "rank": 65,
      "score": 8.682998197092383,
      "candidate": "return [n] + make_a_pile(n - 1) + [n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 66,
      "score": 8.656042861442971,
      "candidate": "return [n] + [(n+1)//2] * (n%2)"
    },
    {
      "rank": 67,
      "score": 8.638162964118825,
      "candidate": "if n == 0:\n        return [0]\n    return make_a_pile(n - 1) + [n]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 68,
      "score": 8.590966671599256,
      "candidate": "return [0] + [n if n % 2 == 0 else (n + 1) % 2]\n\n\ndef make_a_pile_2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_2(3)\n    [3, 5, 7]\n    \"\"\"\n    return [0] + [n] * (n % 2)"
    },
    {
      "rank": 69,
      "score": 8.585482494213021,
      "candidate": "return [n] + [n + 1 if i % 2 else n + 2 for i in range(n)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(verbose=True)"
    },
    {
      "rank": 70,
      "score": 8.578455577376145,
      "candidate": "if n == 1:\n        return [n]\n    result = []\n    for i in range(1, n+1):\n        result.append(i)\n        if n % 2 == 0:\n            result.append(i+1)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 71,
      "score": 8.573637182691835,
      "candidate": "return [n] + [(n * 2) + 1 if i % 2 == 1 else (n * 2) + 0 for i in range(n - 1)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 72,
      "score": 8.55993135249963,
      "candidate": "return [i for i in range(n + 1) if i % 2 == 0]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 73,
      "score": 8.546256000594601,
      "candidate": "return [n] + [i + 1 for i in range(2, n + 1)]"
    },
    {
      "rank": 74,
      "score": 8.5259012464963,
      "candidate": "result = []\n    if n == 1:\n        result.append(n)\n    else:\n        result.append(n + 1)\n        if n % 2 == 0:\n            result.append(2 * n + 1)\n        else:\n            result.append(2 * n + 2)\n    return result\n\n\ndef test_make_a_pile():\n    assert make_a_pile(3) == [3, 5, 7]"
    },
    {
      "rank": 75,
      "score": 8.521220326433403,
      "candidate": "return [n] + [n + 2 if n % 2 == 0 else n + 1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 76,
      "score": 8.511278074108533,
      "candidate": "if n < 1:\n        return []\n    elif n == 1:\n        return [n]\n    elif n % 2 == 0:\n        return [n // 2, n // 2 + 1, n]\n    else:\n        return [n // 2 + 1, n // 2, n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 77,
      "score": 8.48023114729329,
      "candidate": "return [n] + [n+1 if i % 2 == 0 else n+2 for i in range(n)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 78,
      "score": 8.478392801057332,
      "candidate": "if n == 0:\n        return [0]\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [2, 1]\n    if n % 2 == 0:\n        odds = make_a_pile(n // 2)\n        odds.append(n // 2)\n        return odds\n    else:\n        evens = make_a_pile(n // 2)\n        evens.append(n // 2)\n        return evens"
    },
    {
      "rank": 79,
      "score": 8.39934161431303,
      "candidate": "if n == 0:\n        return [n]\n    if n % 2 == 0:\n        return [2*n, 2*n+1]\n    return [2*n+1, 2*n+2]"
    },
    {
      "rank": 80,
      "score": 8.358772408187814,
      "candidate": "if n == 1:\n        return [1]\n    if n == 2:\n        return [2, 1, 1]\n    if n % 2 == 1:\n        return [n // 2, 2, n // 2 + 1]\n    else:\n        return [n // 2, n // 2 + 1, n // 2 + 2]"
    },
    {
      "rank": 81,
      "score": 8.353131031234264,
      "candidate": "if n == 1:\n        return [1]\n\n    result = [n]\n    for i in range(2, n + 1):\n        result.append(result[-1] * 2)\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 82,
      "score": 8.330683882025067,
      "candidate": "return [n] + [0] * (n // 2)\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Recursive solution to make_a_pile.\n    :param n:\n    :return:\n    \"\"\"\n    if n == 1:\n        return [n]\n    else:\n        return make_a_pile_recursive(n - 1) + [n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 83,
      "score": 8.327014003164622,
      "candidate": "if n < 1:\n        return []\n    pile = [n]\n    while n > 1:\n        pile.append(pile[-1] + 2 if n & 1 else pile[-1] + 1)\n        n >>= 1\n    return pile"
    },
    {
      "rank": 84,
      "score": 8.323851617862472,
      "candidate": "if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return [0]\n    elif n == 1:\n        return [1]\n    else:\n        return make_a_pile(n - 1) + [n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 85,
      "score": 8.316656207271315,
      "candidate": "if n == 0:\n        return []\n\n    result = []\n    i = 0\n    while i < n:\n        if i % 2 == 0:\n            result.append(i)\n        i += 1\n    return result\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive(3)\n    [3, 5, 7]\n    \"\"\"\n    if n == 0:\n        return []\n\n    result = []\n    i = 0\n    while i < n:\n        if i % 2 == 0:\n            result.append(i)\n        if i % 2 == 1:\n            result.append(i + 1)\n        i += 1\n    return result"
    },
    {
      "rank": 86,
      "score": 8.291522264722904,
      "candidate": "if n == 1:\n        return [n]\n    return [n, *make_a_pile(n-1), *make_a_pile(n-2)]"
    },
    {
      "rank": 87,
      "score": 8.264795323770128,
      "candidate": "if n < 0:\n        return []\n    pile = []\n    for i in range(n):\n        if n % 2 == 0:\n            pile.append(2)\n            n = n // 2\n        else:\n            pile.append(4)\n            n = n * 2\n    return pile"
    },
    {
      "rank": 88,
      "score": 8.262809840552045,
      "candidate": "result = [n]\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            result.append(i)\n        else:\n            result.append(2*i)\n    return result\n\n\ndef make_a_pile_recursive(n):\n    \"\"\"\n    Recursive solution.\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive(3)\n    [3, 5, 7]\n    \"\"\"\n    if n <= 1:\n        return [n]\n    else:\n        return make_a_pile_recursive(n-1) + make_a_pile(n-1)\n\n\ndef make_a_pile_recursive_2(n):\n    \"\"\"\n    Recursive solution.\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_recursive_2(3)\n    [3, 5, 7]\n    \"\"\"\n    if n <= 1:\n        return [n]\n    else:\n        return make_a_pile_recursive_2(n-1) + make_a_pile(n-1)"
    },
    {
      "rank": 89,
      "score": 8.248759197446475,
      "candidate": "return [n * 2] + [n * 2 + 1] * (n - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 90,
      "score": 8.242319059317722,
      "candidate": "return [n] + [2 * i + 1 for i in range(n) if i % 2 == 1]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 91,
      "score": 8.232135181879624,
      "candidate": "if n == 1:\n        return [1]\n\n    result = [n]\n    for i in range(2, n + 1):\n        result.append(i)\n        result.append(2 * (i - 1))\n\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 92,
      "score": 8.225152308040466,
      "candidate": "if n == 1:\n        return [n]\n    elif n % 2 == 0:\n        return [n, 2 * n]\n    else:\n        return [2 * n, n]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 93,
      "score": 8.180444864325121,
      "candidate": "return [n, n * 2, n * 3]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 94,
      "score": 8.163705203170508,
      "candidate": "return [n] + [i + 1 for i in range(2, n + 1, 2)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 95,
      "score": 8.090315054991173,
      "candidate": "return [n] + [i + 1 for i in range(2, n + 1)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 96,
      "score": 8.012973804582094,
      "candidate": "result = []\n    for _ in range(n):\n        result.append(1)\n        if n % 2 == 1:\n            result.append(2)\n        else:\n            result.append(3)\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 7.926451885374057,
      "candidate": "if n == 0:\n        return [0]\n\n    if n < 0:\n        return []\n\n    if n == 1:\n        return [1]\n\n    odd_numbers = make_a_pile(n - 1)\n    even_numbers = make_a_pile(n - 2)\n    return [n] + odd_numbers + even_numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 98,
      "score": 7.888792651821197,
      "candidate": "return [n] + [i * 2 for i in range(n - 1)]"
    },
    {
      "rank": 99,
      "score": 7.680173096131332,
      "candidate": "return [n] + [(n + i) % 2 for i in range(1, n)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "if n <= 0:\n        return []\n\n    n_of_stones = [n]\n\n    while n > 1:\n        if n % 2 == 0:\n            n_of_stones.append(2)\n            n -= 2\n        else:\n            n_of_stones.append(1)\n            n -= 1\n\n    return n_of_stones\n\n\ndef make_a_pile_v2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile_v2(3)\n    [3, 5, 7]\n    \"\"\"\n\n    if n <= 0:\n        return []\n\n    n_of_stones = [n]\n\n    while n > 1:\n        if n % 2 == 0:\n            n_of_stones.append(2)\n            n -= 2\n        else:\n            n_of_stones.append(1)\n            n -= 1\n\n    return n_of_stones"
    }
  ]
}