{
  "timestamp": "2025-09-14T11:25:08.552375",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "humaneval",
  "problem_number": 21,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "numbers.sort()\n    if len(numbers) < 2:\n        return numbers\n    if numbers[0] == numbers[-1]:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [x - min_num for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "assert len(numbers) >= 2\n    smallest = min(numbers)\n    largest = max(numbers)\n    return [(x - smallest) / (largest - smallest) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "assert len(numbers) > 1\n\n    # Find the smallest number and make it 0\n    smallest_number = min(numbers)\n    smallest_number_index = numbers.index(smallest_number)\n    smallest_number_zero = 0\n    smallest_number_one = 1\n\n    # Find the largest number and make it 1\n    largest_number = max(numbers)\n    largest_number_index = numbers.index(largest_number)\n    largest_number_zero = 0\n    largest_number_one = 1\n\n    # Find the index of the largest number in the list\n    largest_number_index_zero = numbers.index(largest_number, largest_number_index)\n    largest_number_index_one = numbers.index(largest_number, largest_number_index + 1)\n\n    # Find the index of the smallest number in the list\n    smallest_number_index_zero = numbers.index(smallest_number, smallest_number_index_zero)\n    smallest_number_index_one = numbers.index(smallest_number, smallest_number_index_one)\n\n    # Add one to each number to make it 0\n    for i in range(largest_number_index_zero + 1, largest_number_index_one + 1):\n        numbers[i] = 0\n\n    # Add one to each number to make it 1\n    for i in range(smallest_number_index_zero + 1, smallest_number_index_one + 1):\n        numbers[i] = 1\n\n    # Add one to each number to make it 0\n    for i in range(largest_number_index_zero + 1, largest_number_index_one + 1):\n        numbers[i] = smallest_number\n\n    # Add one to each number to make it 1\n    for i in range(smallest_number_index_zero + 1, smallest_number_index_one + 1):\n        numbers[i] = largest_number\n\n    return numbers\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(num - min_val) / (max_val - min_val) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / max(numbers))\n    return rescaled_numbers\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(number - min_num) / (max_num - min_num) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [(number - smallest_number) / (largest_number - smallest_number) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(value - min_val) / (max_val - min_val) for value in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "minimum = min(numbers)\n    maximum = max(numbers)\n    return [(number - minimum) / (maximum - minimum) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num) / (max_num - min_num) for num in numbers]\n\n\ndef unit_test() -> None:\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    unit_test()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "assert len(numbers) > 2, \"Only one number per line allowed\"\n    assert all(n >= 0 for n in numbers), \"The first number must be non-negative\"\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    result = [0.0] * len(numbers)\n\n    for i in range(len(numbers)):\n        result[i] = (numbers[i] - min_num) / (max_num - min_num)\n\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 10.0,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    if max_number == min_number:\n        return numbers\n    return [(n - min_number) / (max_number - min_number) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 10.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 10.0,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Invalid list length: \" + str(len(numbers)))\n    unit = numbers[0]\n    for num in numbers:\n        if num < unit:\n            unit = num\n    for num in numbers:\n        if num > unit:\n            unit = num\n    return [(num - unit) / unit for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    rescaled_numbers = [(num - min_num) / (max_num - min_num) for num in numbers]\n    return rescaled_numbers\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 10.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 10.0,
      "candidate": "assert len(numbers) >= 2\n    assert all(number >= 0 for number in numbers)\n    assert all(number <= 1 for number in numbers)\n\n    return [float(number) / float(max(numbers)) for number in numbers]\n\n\ndef rescale_to_unit_recursive(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    assert len(numbers) >= 2\n    assert all(number >= 0 for number in numbers)\n    assert all(number <= 1 for number in numbers)\n\n    if len(numbers) == 1:\n        return [numbers[0]]\n\n    return [float(number) / float(max(numbers)) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 24,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 25,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(n - min_num) / (max_num - min_num) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 8.0,
      "candidate": "return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 8.0,
      "candidate": "assert len(numbers) >= 2, \"Numbers must have at least two elements\"\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 8.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 29,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return numbers\n    return [(num - min_num) / (max_num - min_num) for num in numbers]"
    },
    {
      "rank": 30,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 8.0,
      "candidate": "if len(numbers) <= 2:\n        return numbers\n    return [0.0 if number < 0 else 1.0 for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    if numbers[0] < numbers[-1]:\n        numbers = [0.0] + numbers[1:]\n    return [(n - numbers[0]) / (numbers[-1] - numbers[0]) for n in numbers]"
    },
    {
      "rank": 33,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 34,
      "score": 8.0,
      "candidate": "assert len(numbers) >= 2\n    min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 8.0,
      "candidate": "return [number / max(numbers) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 8.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 38,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n\n    return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]"
    },
    {
      "rank": 39,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 41,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 42,
      "score": 8.0,
      "candidate": "smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [(number - smallest_number) / (largest_number - smallest_number) for number in numbers]"
    },
    {
      "rank": 43,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 44,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 45,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 46,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [float(num - min_num) / (max_num - min_num) for num in numbers]"
    },
    {
      "rank": 47,
      "score": 8.0,
      "candidate": "assert len(numbers) >= 2\n    assert numbers[0] >= numbers[-1]\n    return [(n - numbers[0]) / (numbers[-1] - numbers[0]) for n in numbers]"
    },
    {
      "rank": 48,
      "score": 8.0,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(number - min_number) / (max_number - min_number) for number in numbers]"
    },
    {
      "rank": 49,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 50,
      "score": 8.0,
      "candidate": "return [n / max(numbers) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 51,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    elif len(numbers) == 2:\n        return [numbers[0], 1.0]\n    else:\n        min_num = min(numbers)\n        max_num = max(numbers)\n        return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 52,
      "score": 8.0,
      "candidate": "return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 53,
      "score": 8.0,
      "candidate": "return [number / max(numbers) for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 54,
      "score": 8.0,
      "candidate": "if len(numbers) <= 1:\n        return numbers\n    else:\n        return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 55,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 56,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n\n    return [(number - min_number) / (max_number - min_number) for number in numbers]"
    },
    {
      "rank": 57,
      "score": 8.0,
      "candidate": "rescaled_numbers = []\n    for number in numbers:\n        if number < 0:\n            rescaled_numbers.append(number * -1.0)\n        else:\n            rescaled_numbers.append(number)\n    return rescaled_numbers"
    },
    {
      "rank": 58,
      "score": 8.0,
      "candidate": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]"
    },
    {
      "rank": 59,
      "score": 8.0,
      "candidate": "min_number = min(numbers)\n    max_number = max(numbers)\n    return [(num - min_number) / (max_number - min_number) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 60,
      "score": 8.0,
      "candidate": "return [n / max(numbers) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 61,
      "score": 8.0,
      "candidate": "return [float(num) / max(numbers) for num in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 62,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 63,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 64,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]"
    },
    {
      "rank": 65,
      "score": 8.0,
      "candidate": "return [x / len(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 66,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return numbers\n    return [x / (max_num - min_num) for x in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 67,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 68,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    if numbers[0] > numbers[-1]:\n        return [0.0] + numbers\n    return [float(x) / len(numbers) for x in numbers]"
    },
    {
      "rank": 69,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]"
    },
    {
      "rank": 70,
      "score": 8.0,
      "candidate": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(n - min_val) / (max_val - min_val) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 71,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 72,
      "score": 8.0,
      "candidate": "return [float(x) / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 73,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]"
    },
    {
      "rank": 74,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef main() -> None:\n    \"\"\" Tests \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    print(f\"Rescale to unit: {rescale_to_unit(numbers)}\")\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 75,
      "score": 8.0,
      "candidate": "return [float(n) / float(min(numbers)), float(n) / float(max(numbers))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 76,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 77,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 78,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 79,
      "score": 8.0,
      "candidate": "rescaled_numbers = []\n    for number in numbers:\n        rescaled_numbers.append(number / (max(numbers) - min(numbers)))\n    return rescaled_numbers"
    },
    {
      "rank": 80,
      "score": 8.0,
      "candidate": "return [float(n) / max(numbers) for n in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 81,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [(x - min(numbers)) / (max(numbers) - min(numbers)) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 82,
      "score": 8.0,
      "candidate": "return [(num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 83,
      "score": 8.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 84,
      "score": 8.0,
      "candidate": "return [(1 - number) * 0.5 for number in numbers]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 85,
      "score": 8.0,
      "candidate": "return [(num - min(numbers)) / (max(numbers) - min(numbers)) for num in numbers]"
    },
    {
      "rank": 86,
      "score": 8.0,
      "candidate": "if len(numbers) < 2:\n        raise ValueError(\"Must provide at least two numbers to rescale_to_unit\")\n    smallest_number = min(numbers)\n    largest_number = max(numbers)\n    return [x / (largest_number - smallest_number) for x in numbers]"
    },
    {
      "rank": 87,
      "score": 8.0,
      "candidate": "return [float(n) / max(numbers) for n in numbers]\n\n\ndef main():\n    import doctest\n\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "rank": 88,
      "score": 8.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]"
    },
    {
      "rank": 89,
      "score": 8.0,
      "candidate": "return [(number - min(numbers)) / (max(numbers) - min(numbers)) for number in numbers]"
    },
    {
      "rank": 90,
      "score": 1.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n\n    # sort the numbers in descending order\n    numbers = sorted(numbers, reverse=True)\n\n    # initialize the result\n    result = [0.0 for _ in range(len(numbers))]\n\n    # loop through the numbers in ascending order\n    for i, number in enumerate(numbers):\n        # calculate the new value\n        result[i] = (number + 1) / 2\n\n    # return the result\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 91,
      "score": 1.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 92,
      "score": 1.0,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\ndef rescale_to_unit_with_negative_values(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_negative_values([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, -0.25, -0.5, -0.75, 1.0]\n    \"\"\"\n    return [x / max(numbers) for x in numbers if x > 0]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 93,
      "score": 1.0,
      "candidate": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\ndef test_rescale_to_unit():\n    assert rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert rescale_to_unit([]) == []"
    },
    {
      "rank": 94,
      "score": 1.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\ndef rescale_to_unit_no_min_max(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        return numbers\n    return [(x - numbers[0]) / (numbers[-1] - numbers[0]) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 95,
      "score": 1.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n\n    # find the smallest and largest value in the list\n    smallest = min(numbers)\n    largest = max(numbers)\n\n    # calculate the scaling factor (i.e. the difference between the smallest and largest value)\n    scaling_factor = largest - smallest\n\n    # rescale the list to be in the same units\n    return [num / scaling_factor for num in numbers]"
    },
    {
      "rank": 96,
      "score": 1.0,
      "candidate": "if len(numbers) <= 2:\n        return numbers\n\n    # find the minimum and maximum\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    # calculate the linear transformation\n    return [(num - min_num) / (max_num - min_num) for num in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 97,
      "score": 1.0,
      "candidate": "if len(numbers) < 2:\n        return numbers\n\n    min_num = min(numbers)\n    max_num = max(numbers)\n\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"
    },
    {
      "rank": 98,
      "score": 1.0,
      "candidate": "return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]\n\n\ndef rescale_to_unit_1(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
      "rank": 99,
      "score": 1.0,
      "candidate": "return [x / max(numbers) for x in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 100,
      "score": 1.0,
      "candidate": "return [n / max(numbers) for n in numbers]\n\n\ndef rescale_to_unit_with_padding(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_with_padding([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [n / (max(numbers) + 1) for n in numbers]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    }
  ]
}