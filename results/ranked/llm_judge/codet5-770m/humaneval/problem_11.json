{
  "timestamp": "2025-09-14T11:20:48.043243",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "humaneval",
  "problem_number": 11,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "return bin(int(a, 2) ^ int(b, 2))[2:]\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['100', '110']\n    \"\"\"\n    return [string_xor(a_i, b_i) for a_i in a for b_i in b]\n\n\ndef string_xor_set(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set(\"010\", \"110\")\n    '100'\n    \"\"\"\n    return {string_xor(a_i, b_i) for a_i in a for b_i in b}\n\n\ndef string_xor_dict(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict(\"010\", \"110\")\n    '100'\n    \"\"\"\n    return {string_xor(a_i, b_i) for a_i in a for b_i in b}\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "result = \"\"\n    for i in range(len(a)):\n        result += a[i] if b[i] == \"1\" else b[i]\n    return result\n\n\ndef binary_xor(a: List[int], b: List[int]) -> List[int]:\n    \"\"\" Input are two list of integers and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor([1, 0, 0], [0, 1, 0])\n    [1, 0, 0]\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        result.append(a[i] ^ b[i])\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_dict(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two dictionaries of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({\"010\": \"110\", \"110\": \"100\"}, {\"100\": \"110\", \"110\": \"010\"})\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "return bin(int(a, 2) ^ int(b, 2))[2:]\n\n\ndef binary_xor(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    Perform binary XOR on these inputs and return result also as a list of ints.\n    >>> binary_xor([0, 1, 1, 0], [0, 1, 1, 0])\n    [0, 1, 1, 0]\n    \"\"\"\n    return [int(x, 2) ^ int(y, 2) for x, y in zip(a, b)]\n\n\ndef binary_xor_from_file(path: str) -> List[int]:\n    \"\"\"\n    Read a binary file and return a list of ints.\n    >>> binary_xor_from_file('test/data/binary_xor.txt')\n    [0, 1, 1, 0]\n    \"\"\"\n    with open(path) as f:\n        return binary_xor(f.read().splitlines(), f.read().splitlines())\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef find_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> find_xor('010', '110')\n    '100'\n    \"\"\"\n    return string_xor(a, b).lstrip('0')\n\n\ndef find_xor_by_string(a: str) -> List[str]:\n    \"\"\" Input are two strings a consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> find_xor_by_string('010')\n    ['100']\n    \"\"\"\n    return [find_xor(a, b) for b in '010']\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            result += '0'\n        else:\n            result += '1'\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['100', '110'])\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            result += '0'\n        else:\n            result += '1'\n    for i in range(len(b)):\n        if b[i] == '1':\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "result = ''\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        result.append(string_xor(a[i], b[i]))\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list(['010', '110'], ['100'])\n    ['100']\n    \"\"\"\n    return [str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))]\n\n\ndef string_xor_set(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set(['010', '110'], ['100'])\n    {'100'}\n    \"\"\"\n    return set(string_xor(a_i, b_i) for a_i in a for b_i in b)\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['100', '110']\n    \"\"\"\n    return [''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))]) for i in range(len(a))]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Return the XOR of all strings.\n    >>> string_xor_all(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(string_xor(a, b) for a, b in zip(strings[::2], strings[1::2]))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "return ''.join(str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"010\"])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "return a if a == b else b\n\n\ndef string_xor_with_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_with_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef list_xor(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> list_xor([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    return [''.join(str(int(a_i) ^ int(b_i)) for a_i in a_list) for b_i in b_list]\n\n\ndef string_xor_list(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(str(int(a_i) ^ int(b_i)) for a_i in a for b_i in b)\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "return \"\".join([x if a[i] == b[i] else \"0\" for i in range(len(a))])\n\n\ndef check_xor(a: str, b: str) -> None:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Check if they are xor'd correctly.\n    >>> check_xor('010', '110')\n    True\n    \"\"\"\n    return a == string_xor(a, b)\n\n\ndef check_xor_all(a: List[str], b: List[str]) -> None:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Check if they are xor'd correctly.\n    >>> check_xor_all([\"010\", \"110\"], [\"010\", \"110\"])\n    True\n    \"\"\"\n    return all([check_xor(a_i, b_i) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_all(a: str, b: str) -> None:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join([x if a[i] == b[i] else \"0\" for i in range(len(a))])\n\n\ndef check_xor_all(a: str, b: str) -> None:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Check if they are xor'd correctly.\n    >>> check_xor_all([\"010\", \"110\"], [\"010\", \"110\"])\n    True\n    \"\"\"\n    return all([check_xor_all(a_i, b_i) for a_i, b_i in zip(a, b)])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "result = ''\n    for c in a:\n        result += str(int(c) ^ int(b))\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['100', '110']\n    \"\"\"\n    result = []\n    for c in a:\n        result.append(string_xor(c, b))\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 9.995275971341723,
      "candidate": "return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef binary_xor(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two strings a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor(['010', '110'], ['100', '110'])\n    ['100', '110']\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        result.append(string_xor(a[i], b[i]))\n    return result\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()"
    },
    {
      "rank": 17,
      "score": 9.987460886311517,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['100', '110'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a_i, 2) ^ int(b_i, 2)) for a_i, b_i in zip(a, b))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 9.959523101164116,
      "candidate": "return ''.join([str(a[i] ^ b[i]) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['100', '010'])\n    '100'\n    \"\"\"\n    return ''.join([str(a[i] ^ b[i]) for i in range(len(a))])\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 9.951607494590085,
      "candidate": "if len(a)!= len(b):\n        raise ValueError(\"Input strings must be of same length.\")\n    return \"\".join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef binary_xor(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> binary_xor([\"010\", \"110\"], [ \"011\", \"111\"])\n    '100'\n    \"\"\"\n    if len(a)!= len(b):\n        raise ValueError(\"Input lists must be of same length.\")\n    return \"\".join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 9.920978294829712,
      "candidate": "return bin(int(a, 2) ^ int(b, 2))[2:]\n\n\ndef find_prime(n: int) -> List[int]:\n    \"\"\" Find all prime numbers below n.\n    >>> find_prime(10)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    prime_list = []\n    for i in range(2, n + 1):\n        if n % i == 0:\n            prime_list.append(i)\n    return prime_list\n\n\ndef find_prime_iterative(n: int) -> List[int]:\n    \"\"\" Find all prime numbers below n.\n    >>> find_prime_iterative(10)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    prime_list = []\n    for i in range(2, n + 1):\n        if n % i == 0:\n            prime_list.append(i)\n    return prime_list\n\n\ndef find_prime_recursive(n: int) -> List[int]:\n    \"\"\" Find all prime numbers below n.\n    >>> find_prime_recursive(10)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    if n <= 1:\n        return []\n    if n == 2:\n        return [2]\n    if n % 2 == 0:\n        return find_prime_recursive(n // 2)\n    prime_list = []\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            prime_list.append(i)\n    return prime_list\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 9.918046318846832,
      "candidate": "return ''.join([chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef list_xor(a: List[int], b: List[int]) -> List[int]:\n    \"\"\" Input are two lists of integers a and b consisting only of 1s and 0s.\n    Perform binary XOR on these lists and return result also as a list.\n    >>> list_xor([0, 0, 1], [0, 0, 1])\n    [0, 0, 1]\n    \"\"\"\n    return [chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 9.895347427336947,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    return [string_xor(a[i], b[i]) for i in range(len(a))]\n\n\ndef string_xor_dict(a: Dict[str, str], b: Dict[str, str]) -> Dict[str, str]:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({\"010\": \"110\"}, {\"010\": \"110\"})\n    {'100': '100'}\n    \"\"\"\n    return {string_xor(a[i], b[i]): a[i] for i in range(len(a))}\n\n\ndef string_xor_set(a: Set[str], b: Set[str]) -> Set[str]:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set({\"010\": \"110\"}, {\"010\": \"110\"})\n    {'100'}\n    \"\"\"\n    return {string_xor(a[i], b[i]) for i in range(len(a))}\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 23,
      "score": 9.89461370654375,
      "candidate": "return ''.join([chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_rec(a: str, b: str) -> List[str]:\n    \"\"\"\n    >>> a = '0101'\n    >>> b = '1001'\n    >>> string_xor_rec(a, b)\n    ['1', '0', '0', '0']\n    \"\"\"\n    res = []\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            res.append(a[i])\n        else:\n            res.append('0')\n    return res\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()"
    },
    {
      "rank": 24,
      "score": 9.86522120185429,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['100'])\n    '100'\n    \"\"\"\n    return ''.join([str(int(a_i, 2) ^ int(b_i, 2)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_list_list(a: List[str], b: List[List[str]]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_list(['010', '110'], ['100', '200'])\n    '100'\n    \"\"\"\n    return ''.join([str(int(a_i, 2) ^ int(b_i, 2)) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_list_list_list(a: List[str], b: List[List[List[str]]]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_list_list(['010', '110'], ['100', '200'])\n    '100'\n    \"\"\"\n    return ''.join([str(int(a_i, 2) ^ int(b_i, 2)) for a_i, b_i in zip(a, b)])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 9.83699458625041,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef binary_xor(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor([\"0101\"], [\"0110\"])\n    ['101', '011', '010']\n    \"\"\"\n    return [string_xor(x, y) for x, y in zip(a, b)]\n\n\ndef xor_strings(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> xor_strings('010', '110')\n    '100'\n    \"\"\"\n    return string_xor(a, b)\n\n\ndef xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> xor_list([\"0101\"], [\"0110\"])\n    ['101', '011', '010']\n    \"\"\"\n    return [xor_strings(x, y) for x, y in zip(a, b)]\n\n\ndef xor_lists(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> xor_lists([\"0101\"], [\"0110\"])\n    ['101', '011', '010']\n    \"\"\"\n    return [xor_strings(x, y) for x, y in zip(a, b)]\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 9.832289016754148,
      "candidate": "return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef binary_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> binary_xor('010', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef main() -> None:\n    with open('input', 'r') as f:\n        data = f.read().splitlines()\n\n    print(f'Part 1: {string_xor(data[0], data[1])}')\n    print(f'Part 2: {binary_xor(data[0], data[1])}')\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 27,
      "score": 9.824385034745411,
      "candidate": "return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    [100, 110]\n    \"\"\"\n    return [''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a))) for j in range(len(b))]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 28,
      "score": 9.774208085888207,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef binary_xor(a: List[int], b: List[int]) -> List[int]:\n    \"\"\" Input are two lists of integers a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor([1, 0, 0], [0, 1, 0])\n    [0, 1, 0]\n    \"\"\"\n    return [chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))]\n\n\ndef main():\n    a = input().split()\n    b = input().split()\n\n    result = binary_xor(a, b)\n    print(' '.join(result))\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    main()"
    },
    {
      "rank": 29,
      "score": 9.763077299892915,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef get_all_xor_strings(string_list: List[str]) -> List[str]:\n    \"\"\" Given a list of strings, return all possible XOR strings.\n    >>> get_all_xor_strings(['010', '110'])\n    ['100', '101', '110']\n    \"\"\"\n    all_xor_strings = []\n    for a in string_list:\n        for b in string_list:\n            if string_xor(a, b) not in all_xor_strings:\n                all_xor_strings.append(string_xor(a, b))\n    return all_xor_strings\n\n\ndef get_xor_string(string_list: List[str]) -> str:\n    \"\"\" Given a list of strings, return the most common XOR string.\n    >>> get_xor_string(['010', '110'])\n    '110'\n    \"\"\"\n    all_xor_strings = get_all_xor_strings(string_list)\n    if len(all_xor_strings) == 1:\n        return all_xor_strings[0]\n    else:\n        return max(all_xor_strings, key=lambda x: len(x))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 9.748054527061852,
      "candidate": "return \"\".join(chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['100', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a, b))\n\n\ndef string_xor_set(a: Set[str], b: Set[str]) -> str:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set(['010', '110'], ['100', '110'])\n    '100'\n    \"\"\"\n    return \"\".join(chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a, b))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 31,
      "score": 9.645509107882951,
      "candidate": "return ''.join(x if x == '1' else '0' for x in a + b)\n\n\ndef string_xor_all(strings: List[str]) -> str:\n    \"\"\" Perform binary XOR on all strings and return result also as a string.\n    >>> string_xor_all([\"010\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(string_xor(x, y) for x in strings for y in strings)\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 32,
      "score": 9.61278275909789,
      "candidate": "return str(bin(int(a, 2) ^ int(b, 2)))[2:]\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\"])\n    '100'\n    \"\"\"\n    return \"\".join([string_xor(a[i], b[i]) for i in range(len(a))])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 33,
      "score": 9.535134882885549,
      "candidate": "result = ''\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef binary_xor(a: List[int], b: List[int]) -> List[int]:\n    \"\"\" Input are two lists of integers a and b consisting of only 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor([1, 0, 1], [0, 1, 1])\n    [0, 1, 1]\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        result.append(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef main() -> None:\n    \"\"\" This is the main function.\n    It should only be run when this file is called directly.\n    \"\"\"\n    print(string_xor('010', '110'))\n    print(binary_xor([1, 0, 1], [0, 1, 1]))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    main()"
    },
    {
      "rank": 34,
      "score": 9.382935945623043,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_dict(a: dict, b: dict) -> str:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({'010': '100', '110': '110'}, {'100': '110', '110': '010'})\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a.values(), b.values())])\n\n\ndef string_xor_dict_list(a: dict, b: dict) -> str:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict_list({'010': '100', '110': '110'}, {'100': '110', '110': '010'})\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a.values(), b.values())])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 35,
      "score": 9.330351914369771,
      "candidate": "return ''.join(str(x ^ y) for x, y in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['100', '110']\n    \"\"\"\n    return [''.join(str(x ^ y) for x, y in zip(a_i, b_i)) for a_i, b_i in zip(a, b)]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 36,
      "score": 8.444444444444445,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef main() -> None:\n    with open('input.txt') as f:\n        lines = f.readlines()\n\n    print(string_xor(*lines[0].strip().split()))\n\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "rank": 37,
      "score": 3.926139092254469,
      "candidate": "result = ''\n    for i, c in enumerate(a):\n        if i < len(b):\n            result += str(int(b[i]) ^ int(c))\n        else:\n            result += str(int(c))\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [ \"100\", \"101\"])\n    '101'\n    \"\"\"\n    result = ''\n    for i, c in enumerate(a):\n        if i < len(b):\n            result += str(int(b[i]) ^ int(c))\n        else:\n            result += str(int(c))\n    return result\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({\"010\": \"110\", \"110\": \"100\"}, {\"100\": \"101\", \"101\": \"010\"})\n    {'101': '101', '010': '010'}\n    \"\"\"\n    result = {}\n    for k, v in a.items():\n        if k in b:\n            result[v] = str(int(b[k]) ^ int(a[k]))\n        else:\n            result[v] = str(int(a[k]))\n    return result\n\n\ndef string_xor_list_dict(a: list, b: list) -> dict:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_list_dict([\"010\", \"110\"], [ \"100\", \"101\"])\n    {'101': '101', '010': '010'}\n    \"\"\"\n    result = {}\n    for i, c in enumerate(a):"
    },
    {
      "rank": 38,
      "score": 3.782321827907003,
      "candidate": "return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_2(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_2('010', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_3(a: str, b: str, c: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_3('010', '110', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_4(a: str, b: str, c: str, d: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_4('010', '110', '110', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_5(a: str, b: str, c: str, d: str, e: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_5('010', '110', '110', '110', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(a["
    },
    {
      "rank": 39,
      "score": 3.7690182832329846,
      "candidate": "result = ''\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 40,
      "score": 3.732824384460777,
      "candidate": "return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({\"010\": \"110\", \"110\": \"010\"}, {\"010\": \"110\", \"110\": \"010\"})\n    {'100': '010'}\n    \"\"\"\n    return {str(int(a[key], 2) ^ int(b[key], 2)): str(int(a[key], 2) ^ int(b[key], 2)) for key in a.keys()}\n\n\ndef string_xor_set(a: set, b: set) -> set:\n    \"\"\" Input are two sets a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set({\"010\": \"110\", \"110\": \"010\"}, {\"010\": \"110\", \"110\": \"010\"})\n    {'100', '010'}\n    \"\"\"\n    return {str(int(a[key], 2) ^ int(b[key], 2)) for key in a.keys()}\n\n\ndef string_xor_set_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return"
    },
    {
      "rank": 41,
      "score": 3.6781200142854114,
      "candidate": "return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef xor_string(strings: List[str]) -> str:\n    \"\"\" Given a list of strings, XOR each of them with the first one.\n    >>> xor_string(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(strings[0], strings[1:]))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 42,
      "score": 3.5285611131094576,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    return [string_xor(a[i], b[i]) for i in range(len(a))]\n\n\ndef string_xor_set(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set('010', '110')\n    {'100'}\n    \"\"\"\n    return set(string_xor(a, b))\n\n\ndef string_xor_dict(a: str, b: str) -> dict:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict('010', '110')\n    {'100': '010'}\n    \"\"\"\n    return {string_xor(a, b): a}\n\n\ndef string_xor_set_xor_dict(a: str, b: str) -> dict:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set and dictionary.\n    >>> string_xor_set_xor_dict('010', '110')\n    {'100': '010'}\n    \"\"\"\n    return {string_xor(a, b): a}\n\n\ndef string_xor_set_xor_list(a: str, b: str) -> list:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_set_xor_list('010', '110')"
    },
    {
      "rank": 43,
      "score": 3.5154997612479755,
      "candidate": "return a + b[1:]\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['100', '110']\n    \"\"\"\n    return [string_xor(a_i, b_i) for a_i, b_i in zip(a, b)]\n\n\ndef string_xor_dict(a: Dict[str, str], b: Dict[str, str]) -> Dict[str, str]:\n    \"\"\" Input are two dictionaries of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({\"010\": \"110\", \"110\": \"100\"}, {\"100\": \"110\", \"110\": \"010\"})\n    {'100': '110', '110': '010'}\n    \"\"\"\n    return {\n        key: string_xor(value, b[key])\n        for key, value in a.items()\n    }\n\n\ndef string_xor_dict_list(a: List[Dict[str, str]], b: List[Dict[str, str]]) -> List[Dict[str, str]]:\n    \"\"\" Input are two lists of dictionaries of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_dict_list([{\"010\": \"110\", \"110\": \"100\"}, {\"100\": \"110\", \"110\": \"010\"}], [{\"100\": \"110\", \"110\": \"010\"}])\n    [{'100': '110', '110': '010'}, {'100': '110', '110': '110'}]\n    \"\"\"\n    return [\n        {\n            key: string_xor(value, b[key])\n            for key, value in a[i].items()\n        }\n        for i in range(len(a))"
    },
    {
      "rank": 44,
      "score": 3.501766448946012,
      "candidate": "return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list_2(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_2([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list_3(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_3([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list_4(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_4([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return"
    },
    {
      "rank": 45,
      "score": 3.4877725635611796,
      "candidate": "assert len(a) == len(b)\n    return ''.join([str(int(i) ^ int(j)) for i, j in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list(['010', '110'], ['100', '010'])\n    [100, '010']\n    \"\"\"\n    assert len(a) == len(b)\n    result = []\n    for i, j in zip(a, b):\n        result.append(string_xor(i, j))\n    return result\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dicts a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dict.\n    >>> string_xor_dict({'010': '100', '110': '010'}, {'100': '010', '010': '110'})\n    {'100': '010', '010': '110'}\n    \"\"\"\n    assert len(a) == len(b)\n    result = {}\n    for k, v in a.items():\n        result[k] = string_xor(v, b[k])\n    return result"
    },
    {
      "rank": 46,
      "score": 3.4843224952664444,
      "candidate": "result = ''\n    for i in range(len(a)):\n        if a[i] == '0' and b[i] == '0':\n            result += '0'\n        elif a[i] == '0' and b[i] == '1':\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these lists and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '0' and b[i] == '0':\n            result += '0'\n        elif a[i] == '0' and b[i] == '1':\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_list_2(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these lists and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '0' and b[i] == '0':\n            result += '0'\n        elif a[i] == '0' and b[i] == '1':\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_list_3(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these lists and return result also as a string."
    },
    {
      "rank": 47,
      "score": 3.4656400595580994,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = \"\"\n    for i, j in zip(a, b):\n        result += string_xor(i, j)\n    return result\n\n\ndef string_xor_set(a: Set[str], b: Set[str]) -> str:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set({'010', '110'}, {'100', '110'})\n    '100'\n    \"\"\"\n    result = \"\"\n    for i, j in zip(a, b):\n        result += string_xor(i, j)\n    return result\n\n\ndef string_xor_set_xor(a: Set[str], b: Set[str]) -> str:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set_xor({'010', '110'}, {'100', '110'})\n    '100'\n    \"\"\"\n    result = \"\"\n    for i, j in zip(a, b):\n        result += string_xor(i, j)\n    return result\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({'010': '110', '110': '100'}, {'100': '110', '110': '010'})\n    {'100': '110', '110': '010'}"
    },
    {
      "rank": 48,
      "score": 3.457701058851037,
      "candidate": "result = \"\"\n    for i in range(len(a)):\n        if a[i] == \"1\":\n            result += \"0\"\n        elif b[i] == \"1\":\n            result += \"1\"\n    return result\n\n\ndef binary_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> binary_xor('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        result += str(int(a[i], 2) ^ int(b[i], 2))\n    return result\n\n\ndef string_xor_from_file(file_path: str) -> str:\n    \"\"\" Read a file and return a string that is XOR'd with each character of the line.\n    >>> string_xor_from_file('../files/sample_input.txt')\n    '100'\n    \"\"\"\n    with open(file_path, \"r\") as f:\n        return string_xor(f.readline().strip(), f.readline().strip())\n\n\ndef binary_xor_from_file(file_path: str) -> str:\n    \"\"\" Read a file and return a string that is XOR'd with each character of the line.\n    >>> binary_xor_from_file('../files/sample_input.txt')\n    '100'\n    \"\"\"\n    with open(file_path, \"r\") as f:\n        return binary_xor(f.readline().strip(), f.readline().strip())\n\n\ndef string_xor_from_list(list_of_strings: List[str]) -> str:\n    \"\"\" Read a list of strings and return a string that is XOR'd with each character of the line.\n    >>> string_xor_from_list([\"010\", \"110\"])\n    '100'\n    \"\"\"\n    result = \"\"\n    for string in list_of_strings:\n        result += string_xor(string[0], string[1])\n    return result\n\n\ndef binary_xor_from_list(list_"
    },
    {
      "rank": 49,
      "score": 3.4112724560515946,
      "candidate": "result = ''\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef find_binary_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> find_binary_xor('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef find_binary_xor_with_mask(a: str, b: str, mask: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> find_binary_xor_with_mask('010', '110', '11')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef find_binary_xor_with_mask_and_mask_string(a: str, b: str, mask: str, mask_string: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> find_binary_xor_with_mask_and_mask_string('010', '110', '11', '11')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef find_binary_xor_with_mask_and_mask_string_and_mask_string(a: str, b: str"
    },
    {
      "rank": 50,
      "score": 3.410951252187612,
      "candidate": "return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    return [''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))]) for i in range(len(b))]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 51,
      "score": 3.406262911197099,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100', '100']\n    \"\"\"\n    result = []\n    for a_elem, b_elem in zip(a, b):\n        result.append(string_xor(a_elem, b_elem))\n    return result\n\n\ndef string_xor_list_reverse(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list_reverse([\"010\", \"110\"], [\"010\", \"110\"])\n    ['110', '110']\n    \"\"\"\n    result = []\n    for a_elem, b_elem in zip(a, b):\n        result.append(string_xor(b_elem, a_elem))\n    return result\n\n\ndef string_xor_list_reverse_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list_reverse_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['110', '110']\n    \"\"\"\n    result = []\n    for a_elem, b_elem in zip(a, b):\n        result.append(string_xor(b_elem, a_elem))\n    return result"
    },
    {
      "rank": 52,
      "score": 3.305838144420434,
      "candidate": "return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these lists and return result also as a list.\n    >>> string_xor_list(['010', '110'], ['100'])\n    ['010', '110']\n    \"\"\"\n    return [''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))]) for i in range(len(a))]\n\n\ndef string_xor_tuple(a: Tuple[str, str], b: Tuple[str, str]) -> Tuple[str, str]:\n    \"\"\" Input are two tuples of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these tuples and return result also as a tuple.\n    >>> string_xor_tuple(('010', '110'), ('100', '010'))\n    ('110', '010')\n    \"\"\"\n    return tuple(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\ndef string_xor_set(a: Set[str], b: Set[str]) -> Set[str]:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these sets and return result also as a set.\n    >>> string_xor_set({'010', '110'}, {'100', '010'})\n    {'100', '010'}\n    \"\"\"\n    return set(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\ndef string_xor_dict(a: Dict[str, str], b: Dict[str, str]) -> Dict[str, str]:\n    \"\"\" Input are two dictionaries of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these dictionaries and return result also as a dictionary.\n    >>> string_xor_dict({'010': '110', '100': '010"
    },
    {
      "rank": 53,
      "score": 3.2712800217929825,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['010', '110']\n    \"\"\"\n    return [''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))) for j in range(len(b))]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 54,
      "score": 3.256633716556678,
      "candidate": "return \"\".join(str(int(b[i], 2) ^ int(a[i], 2)) for i in range(len(a)))\n\n\ndef xor_strings(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> xor_strings(['010', '110'], ['100'])\n    '010'\n    \"\"\"\n    return \"\".join(str(int(b[i], 2) ^ int(a[i], 2)) for i in range(len(b)))\n\n\ndef main() -> None:\n    \"\"\"\n    Enter your code here. Read input from STDIN. Print output to STDOUT\n    \"\"\"\n    a = input().strip()\n    b = input().strip()\n    print(string_xor(a, b))\n    print(xor_strings(a, b))\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    main()\n    sys.exit(0)"
    },
    {
      "rank": 55,
      "score": 3.180818012523817,
      "candidate": "result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            result += b[i]\n        elif a[i] == '0':\n            result += '1'\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    [100, 110]\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        if a[i] == '1':\n            result.append(b[i])\n        elif a[i] == '0':\n            result.append('1')\n    return result"
    },
    {
      "rank": 56,
      "score": 3.180697802754207,
      "candidate": "return \"\".join(c1 if c1!= c2 else \"0\" for c1, c2 in zip(a, b))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"0\"])\n    '100'\n    \"\"\"\n    return \"\".join(c1 if c1!= c2 else \"0\" for c1, c2 in zip(a, b))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 57,
      "score": 3.178556285755873,
      "candidate": "return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    return [string_xor(a_i, b_i) for a_i, b_i in zip(a, b)]\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({'010': '110', '110': '010'}, {'010': '110', '110': '010'})\n    {'100': '010'}\n    \"\"\"\n    return {\n        string_xor(a_key, b_key): a_value\n        for a_key, a_value in a.items()\n        for b_key, b_value in b.items()\n    }"
    },
    {
      "rank": 58,
      "score": 3.165631715701782,
      "candidate": "return \"\".join(\n        [\n            \"1\" if c == \"1\" else \"0\"\n            for c in a\n            if c == \"1\"\n        ]\n    ) + \"\".join([\"1\" if c == \"0\" else \"0\" for c in b])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return \"\".join(\n        [\n            \"1\" if c == \"1\" else \"0\"\n            for c in a\n            if c == \"1\"\n        ]\n    ) + \"\".join([\"1\" if c == \"0\" else \"0\" for c in b])\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 59,
      "score": 3.1643755548298422,
      "candidate": "result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            if b[i] == '1':\n                result += '0'\n            else:\n                result += '1'\n        else:\n            if b[i] == '1':\n                result += '1'\n            else:\n                result += '0'\n    return result\n\n\ndef string_xor_2(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            result += b[i]\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_3(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_3('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            result += b[i]\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_4(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_4('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] == '1':\n            result += b[i]\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_5(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting"
    },
    {
      "rank": 60,
      "score": 3.1620419846973977,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_v1(a: str, b: str) -> List[str]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_v1('010', '110')\n    ['100']\n    \"\"\"\n    return [x for x in a if x == '1'] + [x for x in b if x == '1']\n\n\ndef string_xor_v2(a: str, b: str) -> List[str]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_v2('010', '110')\n    ['100']\n    \"\"\"\n    return [x for x in a if x == '1'] + [x for x in b if x == '1']\n\n\ndef string_xor_v3(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v3('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(a, b))\n\n\ndef string_xor_v4(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v4('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(a, b))\n\n\ndef string_xor_v5(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a"
    },
    {
      "rank": 61,
      "score": 3.157123666297637,
      "candidate": "return \"\".join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_binary(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_binary([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return \"\".join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 62,
      "score": 3.148060138532288,
      "candidate": "return \"\".join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"110\", \"100\"])\n    ['100', '010']\n    \"\"\"\n    return [string_xor(x, y) for x, y in zip(a, b)]"
    },
    {
      "rank": 63,
      "score": 3.1305276360899446,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_multi(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_multi([\"010\", \"110\"], [\"100\", \"101\"])\n    '100'\n    \"\"\"\n    return ''.join([string_xor(a_, b_) for a_, b_ in zip(a, b)])\n\n\ndef string_xor_longest(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_longest([\"010\", \"110\"], [\"100\", \"101\"])\n    '101'\n    \"\"\"\n    return max(string_xor(a_, b_) for a_, b_ in zip(a, b))\n\n\ndef string_xor_shortest(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_shortest([\"010\", \"110\"], [\"100\", \"101\"])\n    '010'\n    \"\"\"\n    return min(string_xor(a_, b_) for a_, b_ in zip(a, b))\n\n\ndef string_xor_shortest_longest(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_shortest_longest([\"010\", \"110\"], [\"100\", \"101\"])\n    '110'\n    \"\"\"\n    return min(string_xor_longest(a_, b_) for a_,"
    },
    {
      "rank": 64,
      "score": 3.104431797502378,
      "candidate": "return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"101\"])\n    ['100', '101']\n    \"\"\"\n    return [''.join([str(int(a_i) ^ int(b_i)) for a_i in a]) for b_i in b]\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({\"010\": \"100\", \"110\": \"101\"}, {\"100\": \"101\", \"101\": \"110\"})\n    {'100': '101', '101': '110'}\n    \"\"\"\n    return {\n        k: ''.join([str(int(a_i) ^ int(b_i)) for a_i in a])\n        for k, b_i in b.items()\n    }\n\n\ndef string_xor_dict_list(a: list, b: list) -> list:\n    \"\"\" Input are two lists of dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_dict_list([{\"010\": \"100\", \"110\": \"101\"}, {\"100\": \"101\", \"101\": \"110\"}],\n   ...                     [{\"100\": \"101\", \"101\": \"110\"}])\n    [{\"100\": \"101\", \"101\": \"110\"}, {\"100\": \"101\", \"101\": \"110\"}]\n    \"\"\"\n    return [\n        {\n            k: ''.join([str(int(a_i) ^ int(b_i)) for a_i in a"
    },
    {
      "rank": 65,
      "score": 3.0984306179345618,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_recur(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_recur('010', '110')\n    '100'\n    \"\"\"\n    if len(a)!= len(b):\n        raise ValueError('Input strings must have the same length')\n    if len(a) == 0:\n        return ''\n    if a[0] == '0' and b[0] == '0':\n        return '0'\n    if a[0] == '0' and b[0] == '1':\n        return '1'\n    if a[0] == '1' and b[0] == '0':\n        return '0'\n    if a[0] == '1' and b[0] == '1':\n        return '1'\n    return string_xor_recur(a[1:], b[1:])\n\n\ndef string_xor_binary(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_binary([\"010\", \"110\"], [\"110\", \"010\"])\n    '100'\n    \"\"\"\n    if len(a)!= len(b):\n        raise ValueError('Input strings must have the same length')\n    if len(a) == 0:\n        return ''\n    if a[0] == '0' and b[0] == '0':\n        return '0'\n    if a[0] == '0' and b[0] == '1':\n        return '1'\n    if a[0] == '1' and b[0] == '0':\n        return '0'\n    if a[0] == '1' and b[0] == '1':\n        return '1'"
    },
    {
      "rank": 66,
      "score": 3.0485387746740202,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"010\"])\n    '100'\n    \"\"\"\n    return \"\".join(string_xor(a_element, b_element) for a_element, b_element in zip(a, b))\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dicts a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({\"010\": \"110\", \"110\": \"100\"}, {\"100\": \"010\", \"010\": \"110\"})\n    {'100': '100', '010': '010'}\n    \"\"\"\n    return {k: string_xor(v, a[k]) for k, v in a.items()}\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 67,
      "score": 3.0025567283212307,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = ''\n    for x, y in zip(a, b):\n        result += str(int(x) ^ int(y))\n    return result\n\n\ndef string_xor_set(a: Set[str], b: Set[str]) -> str:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set({\"010\", \"110\"}, {\"100\", \"110\"})\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_dict(a: dict, b: dict) -> str:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({\"010\": \"110\"}, {\"100\": \"110\"})\n    '100'\n    \"\"\"\n    result = ''\n    for k, v in a.items():\n        if k in b:\n            result += str(int(v) ^ int(b[k]))\n        else:\n            result += str(int(v))\n    return result\n\n\ndef string_xor_dict_list(a: List[dict], b: List[dict]) -> str:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict_list({\"010\": \"110\"}, {\"100\":"
    },
    {
      "rank": 68,
      "score": 2.963994939209833,
      "candidate": "result = ''\n    for i in range(0, len(a)):\n        result += a[i] if a[i] == '1' else b[i]\n    return result\n\n\ndef binary_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> binary_xor('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(0, len(a)):\n        if a[i] == '1':\n            result += b[i]\n        else:\n            result += '0'\n    return result\n\n\ndef xor_strings(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these strings and return result also as a string.\n    >>> xor_strings(['010', '110'], ['100', '110'])\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(0, len(a)):\n        result += a[i] if a[i] == '1' else b[i]\n    return result\n\n\ndef xor_strings_with_length(a: List[str], b: List[str], n: int) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these strings and return result also as a string.\n    >>> xor_strings_with_length(['010', '110'], ['100', '110'], 5)\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(0, len(a)):\n        result += a[i] if len(a[i]) == n else b[i]\n    return result\n\n\ndef xor_strings_with_length_with_padding(a: List[str], b: List[str], n: int) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR"
    },
    {
      "rank": 69,
      "score": 2.9071705116680913,
      "candidate": "return ''.join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    ['100']\n    \"\"\"\n    return [string_xor(a_i, b_i) for a_i, b_i in zip(a, b)]\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({'010': '110'}, {'010': '110'})\n    {'100': '010'}\n    \"\"\"\n    return {key: value for key, value in a.items() if key in b}"
    },
    {
      "rank": 70,
      "score": 2.890164056081244,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_array(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_array([\"010\", \"110\"], [\"100\", \"100\"])\n    ['100', '100']\n    \"\"\"\n    return [string_xor(a_i, b_i) for a_i, b_i in zip(a, b)]"
    },
    {
      "rank": 71,
      "score": 2.8829315215254097,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 72,
      "score": 2.8541531251033616,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_all(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_all_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_all_list_reverse(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_list_reverse([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_all_list_reverse_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_list_reverse"
    },
    {
      "rank": 73,
      "score": 2.8453938120743927,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_by_index(a: str, b: str, i: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_by_index('010', '110', 0)\n    '100'\n    \"\"\"\n    return str(int(a, 2) ^ int(b, 2) ^ i)\n\n\ndef string_xor_by_index_by_reverse(a: str, b: str, i: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_by_index_by_reverse('010', '110', 0)\n    '100'\n    \"\"\"\n    return str(int(a, 2) ^ int(b, 2) ^ i)\n\n\ndef string_xor_by_index_by_reverse_by_reverse(a: str, b: str, i: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_by_index_by_reverse_by_reverse('010', '110', 0)\n    '100'\n    \"\"\"\n    return str(int(a, 2) ^ int(b, 2) ^ i)\n\n\ndef string_xor_by_index_by_reverse_by_reverse(a: str, b: str, i: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_by_index_by_reverse_by_reverse('010', '110', 0)\n    '100'\n    \"\"\"\n    return str(int(a, 2) ^ int(b, 2) ^ i)\n\n\ndef string_xor_by_index_by_reverse_by"
    },
    {
      "rank": 74,
      "score": 2.836168926701116,
      "candidate": "result = ''\n    for i in range(0, len(a)):\n        if a[i] == '0':\n            result += b[i]\n        else:\n            result += a[i]\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    ['010', '110']\n    \"\"\"\n    result = []\n    for i in range(0, len(a)):\n        if a[i] == '0':\n            result.append(b[i])\n        else:\n            result.append(a[i])\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 2.803945923433921,
      "candidate": "return \"\".join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_iterative(a: str, b: str) -> str:\n    \"\"\" Iterative version of string_xor.\n    >>> string_xor_iterative('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_recursive(a: str, b: str) -> str:\n    \"\"\" Recursive version of string_xor.\n    >>> string_xor_recursive('010', '110')\n    '100'\n    \"\"\"\n    if len(a) == 0 or len(b) == 0:\n        return \"\"\n    if a[0] == '0' and b[0] == '0':\n        return a[1:] + b[1:]\n    if a[0] == '1' and b[0] == '0':\n        return a[1:] + b[1:]\n    return string_xor_recursive(a[1:], b[1:])\n\n\ndef string_xor_binary_search(a: str, b: str) -> str:\n    \"\"\" Binary search version of string_xor.\n    >>> string_xor_binary_search('010', '110')\n    '100'\n    \"\"\"\n    if len(a) == 0 or len(b) == 0:\n        return \"\"\n    if a[0] == '0' and b[0] == '0':\n        return a[1:] + b[1:]\n    if a[0] == '1' and b[0] == '0':\n        return a[1:] + b[1:]\n    return string_xor_binary_search(a[1:], b[1:])\n\n\ndef string_xor_binary_search_iterative(a: str, b: str) -> str:\n    \"\"\" Binary search version of string_xor.\n    >>> string_xor_binary_search_iterative('010', '110')\n    '100'"
    },
    {
      "rank": 76,
      "score": 2.769680614520106,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef get_string_xor(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> get_string_xor([\"010\", \"110\"], [\"011\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join([string_xor(a[i], b[i]) for i in range(len(a))])"
    },
    {
      "rank": 77,
      "score": 2.768291153593769,
      "candidate": "return \"\".join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_generator(a: str, b: str) -> List[str]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_generator('010', '110')\n    ['100']\n    \"\"\"\n    return [chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))]\n\n\ndef string_xor_generator_2(a: str, b: str) -> List[str]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_generator_2('010', '110')\n    ['100']\n    \"\"\"\n    return [chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))]"
    },
    {
      "rank": 78,
      "score": 2.765262807032524,
      "candidate": "return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_from_file(filename: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_from_file('010', '110')\n    '100'\n    \"\"\"\n    with open(filename) as f:\n        return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_from_lines(lines: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_from_lines(['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_from_lines_from_file(filename: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_from_lines_from_file('010', '110')\n    '100'\n    \"\"\"\n    with open(filename) as f:\n        return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\n\n\ndef string_xor_from_lines_from_file_and_split(filename: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_from_lines_from_file_and_split('010', '110')\n    '100'\n    \"\"\"\n    with open(filename) as f:\n        return ''.join(chr(ord(a[i]) ^ ord("
    },
    {
      "rank": 79,
      "score": 2.7408648908631763,
      "candidate": "return ''.join(chr(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_all(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all([\"010\", \"110\"], [\"\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_all_iter(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_iter([\"010\", \"110\"], [\"\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_all_iter_all(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_iter_all([\"010\", \"110\"], [\"\"])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 80,
      "score": 2.735119898116481,
      "candidate": "return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 81,
      "score": 2.7278086377374087,
      "candidate": "if len(a)!= len(b):\n        raise ValueError(\"Input strings must have the same length.\")\n    return \"\".join([str(int(a[i]!= b[i], 2)) for i in range(len(a))])\n\n\ndef find_max_bit(bit_list: List[int]) -> int:\n    \"\"\" Finds the most significant bit in a list of bits.\n    >>> find_max_bit([0, 0, 1, 1, 0])\n    1\n    >>> find_max_bit([0, 1, 0, 1, 0])\n    2\n    \"\"\"\n    max_bit = 0\n    for bit in bit_list:\n        if bit > max_bit:\n            max_bit = bit\n    return max_bit\n\n\ndef find_min_bit(bit_list: List[int]) -> int:\n    \"\"\" Finds the least significant bit in a list of bits.\n    >>> find_min_bit([0, 0, 1, 1, 0])\n    0\n    >>> find_min_bit([0, 1, 0, 1, 0])\n    1\n    \"\"\"\n    min_bit = 0\n    for bit in bit_list:\n        if bit < min_bit:\n            min_bit = bit\n    return min_bit\n\n\ndef find_max_or_min(bit_list: List[int]) -> int:\n    \"\"\" Finds the most significant bit in a list of bits.\n    >>> find_max_or_min([0, 0, 1, 1, 0])\n    1\n    >>> find_max_or_min([0, 1, 0, 1, 0])\n    0\n    \"\"\"\n    max_or_min = find_max_bit(bit_list)\n    min_or_max = find_min_bit(bit_list)\n    if max_or_min == 0:\n        return 0\n    if max_or_min == 1:\n        return 1\n    return max_or_min\n\n\ndef find_max_bit_and_min(bit_list: List[int]) -> int:\n    \"\"\" Finds the most significant bit in a list of bits.\n    >>> find_max_bit"
    },
    {
      "rank": 82,
      "score": 2.718856235379514,
      "candidate": "return ''.join(f\"{x}1\" if x == \"1\" else f\"{x}0\" for x in a + b)\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"010\"])\n    [100, '100']\n    \"\"\"\n    return [''.join(f\"{x}1\" if x == \"1\" else f\"{x}0\" for x in a + b) for a in a for b in b]\n\n\ndef string_xor_tuple(a: tuple, b: tuple) -> tuple:\n    \"\"\" Input are two tuples a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a tuple.\n    >>> string_xor_tuple((010, 110), (\"100\", \"010\"))\n    (100, '100')\n    \"\"\"\n    return tuple(f\"{x}1\" if x == \"1\" else f\"{x}0\" for x in a + b)\n\n\ndef string_xor_set(a: set, b: set) -> set:\n    \"\"\" Input are two sets a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set({'010', '110'}, {\"100\", \"010\"})\n    {100, '100'}\n    \"\"\"\n    return set(f\"{x}1\" if x == \"1\" else f\"{x}0\" for x in a + b)\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({'010': '110', '100': '010'}, {\"100\": '110', '010': '010'})\n    {100: '"
    },
    {
      "rank": 83,
      "score": 2.6996806550405976,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_iter(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_iter('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(map(str, [int(a, 2) ^ int(b, 2) for a in a for b in b]))\n\n\ndef string_xor_reversed(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_reversed('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(map(str, [int(a, 2) ^ int(b, 2) for a in a for b in b]))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join(map(str, [int(a, 2) ^ int(b, 2) for a in a for b in b]))\n\n\ndef string_xor_dict(a: str, b: str) -> str:\n    \"\"\" Input are two dicts of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({\"010\": \"100\", \"110\": \"110\"}, {\"100\": \"010\", \"110\": \"100\"})\n    '100'\n    \"\"\"\n    return ''.join(map(str, [int(a, 2) ^ int(b, 2) for a in a for b in b]))\n\n\ndef string"
    },
    {
      "rank": 84,
      "score": 2.6991466938853015,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\"])\n    ['010', '110']\n    \"\"\"\n    return [''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))) for j in range(len(b))]\n\n\ndef string_xor_set(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two sets of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set([\"010\", \"110\"], [\"100\"])\n    {'010', '110'}\n    \"\"\"\n    return set([''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))) for j in range(len(b))])\n\n\ndef string_xor_dict(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two dictionaries of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({'010': '110', '110': '100'}, {'010': '110', '110': '100'})\n    {'010': '110', '110': '100'}\n    \"\"\"\n    return {''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))) for j in range(len(b))}\n\n\ndef string_xor_set_xor_dict(a: List[str], b: List[str]) -> List["
    },
    {
      "rank": 85,
      "score": 2.648973453061324,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list_dict(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_dict([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = {}\n    for x, y in zip(a, b):\n        result[x] = y\n    return ''.join([str(int(x) ^ int(y)) for x, y in result.items()])\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 86,
      "score": 2.5957531985534064,
      "candidate": "return ''.join(map(lambda x, y: x ^ y, a, b))\n\n\ndef binary_xor(a: str, b: str) -> List[str]:\n    \"\"\" Input are two binary strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor('010', '110')\n    ['100', '101']\n    \"\"\"\n    return [x for x in a if x == b]\n\n\ndef string_xor_with_list(a: str, b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_with_list('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(map(lambda x, y: x ^ y, a, b))\n\n\ndef binary_xor_with_list(a: str, b: List[str]) -> List[str]:\n    \"\"\" Input are two binary strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> binary_xor_with_list('010', '110')\n    ['100', '101']\n    \"\"\"\n    return [x for x in a if x == b]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 87,
      "score": 2.580391238388681,
      "candidate": "return ''.join(map(lambda x: '1' if x == '1' else '0', list(a) ^ list(b)))\n\n\ndef find_longest_subsequence(\n        sequences: List[str]) -> List[int]:\n    \"\"\" Find the longest subsequence of a list of strings.\n    >>> find_longest_subsequence(['010', '110', '011', '110', '111'])\n    [0, 1, 2, 3, 4]\n    \"\"\"\n    longest_subsequence = []\n    for subsequence in sequences:\n        subsequence_length = 0\n        for i in range(len(subsequence)):\n            subsequence_length += 1\n            if subsequence_length > longest_subsequence[-1]:\n                longest_subsequence = [subsequence_length, i]\n    return longest_subsequence\n\n\ndef find_longest_subsequence_recursive(\n        sequences: List[str],\n        start_index: int = 0) -> int:\n    \"\"\" Find the longest subsequence of a list of strings.\n    >>> find_longest_subsequence_recursive(['010', '110', '011', '110', '111'])\n    [0, 1, 2, 3, 4]\n    \"\"\"\n    if start_index >= len(sequences):\n        return 0\n    subsequence = sequences[start_index]\n    subsequence_length = 0\n    for i in range(len(subsequence)):\n        subsequence_length += 1\n        if subsequence_length > longest_subsequence_recursive[0]:\n            longest_subsequence_recursive = [subsequence_length, i]\n    return longest_subsequence_recursive[1]\n\n\ndef find_longest_subsequence_iterative(\n        sequences: List[str],\n        start_index: int = 0) -> int:\n    \"\"\" Find the longest subsequence of a list of strings.\n    >>> find_longest_subsequence_iterative(['010', '110', '011', '110', '111'])\n    [0, 1, 2, 3, 4]\n    \"\"\"\n    if start_index >= len(sequences):\n        return 0\n    subsequence = sequences["
    },
    {
      "rank": 88,
      "score": 2.5459879622393946,
      "candidate": "return \"\".join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\"])\n    ['010', '110', '100']\n    \"\"\"\n    return [\"\".join([str(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a))]) for i in range(len(b))]\n\n\ndef string_xor_set(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set.\n    >>> string_xor_set('010', '110')\n    {'010', '110'}\n    \"\"\"\n    return set(string_xor(a, b))\n\n\ndef string_xor_dict(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict('010', '110')\n    {'010': '100', '110': '110'}\n    \"\"\"\n    return dict(string_xor(a, b))\n\n\ndef string_xor_set_dict(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a set and dictionary.\n    >>> string_xor_set_dict('010', '110')\n    {'010': '100', '110': '110'}\n    \"\"\"\n    return {a: string_xor(a, b), b: string_xor(b, a)}\n\n\ndef string_xor_list_dict(a: List["
    },
    {
      "rank": 89,
      "score": 2.4711445355220496,
      "candidate": "result = \"\"\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef string_xor_all(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]))\n    return result\n\n\ndef string_xor_all_reverse(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_all_reverse([\"010\", \"110\"], [\"100\", \"110\"])\n    '110'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        result += str(int(b[i]) ^ int(a[i]))\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 90,
      "score": 2.4245032112888487,
      "candidate": "return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n\n\ndef string_xor_all(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list.\n    >>> string_xor_all([\"010\", \"110\"], [\"100\", \"110\"])\n    [100, '110', '110']\n    \"\"\"\n    return [''.join(str(int(x) ^ int(y)) for x, y in zip(x, y)) for x, y in zip(a, b)]"
    },
    {
      "rank": 91,
      "score": 2.4018966879596646,
      "candidate": "return ''.join([chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['010', '110'])\n    '100'\n    \"\"\"\n    return ''.join([chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a, b)])\n\n\ndef string_xor_dict(a: dict, b: dict) -> str:\n    \"\"\" Input are two dicts a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({'010': '110', '110': '010'}, {'010': '110', '110': '010'})\n    '100'\n    \"\"\"\n    return ''.join([chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a.values(), b.values())])\n\n\ndef string_xor_set(a: set, b: set) -> str:\n    \"\"\" Input are two sets a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set({'010': '110', '110': '010'}, {'010': '110', '110': '010'})\n    '100'\n    \"\"\"\n    return ''.join([chr(int(x, 2) ^ int(y, 2)) for x, y in zip(a.intersection(b), a.union(b))])\n\n\ndef string_xor_dict_set(a: dict, b: dict) -> str:\n    \"\"\" Input are two dicts a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict_set({'010': '110"
    },
    {
      "rank": 92,
      "score": 2.389578175014489,
      "candidate": "return a if a == b else b\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    return \"\".join(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\ndef string_xor_tuple(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_tuple('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\ndef string_xor_set(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\ndef string_xor_dict(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(string_xor(a[i], b[i]) for i in range(len(a)))\n\n\ndef string_xor_set_dict(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string"
    },
    {
      "rank": 93,
      "score": 2.293848149332354,
      "candidate": "return str(bin(int(a, 2) ^ int(b, 2)).replace(\"0b\", \"\"))\n\n\ndef get_binary_string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> get_binary_string_xor('010', '110')\n    '100'\n    \"\"\"\n    return a + b\n\n\ndef get_binary_string_xor_with_index(a: str, b: str, index: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> get_binary_string_xor_with_index('010', '110', 2)\n    '100'\n    \"\"\"\n    return a + b[index]\n\n\ndef get_binary_string_xor_with_index_with_index(a: str, b: str, index: int, index_2: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> get_binary_string_xor_with_index('010', '110', 2, 2)\n    '100'\n    \"\"\"\n    return a + b[index] + b[index_2]\n\n\ndef get_binary_string_xor_with_index_with_index_2(a: str, b: str, index: int, index_2: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> get_binary_string_xor_with_index_with_index_2('010', '110', 2, 2)\n    '100'\n    \"\"\"\n    return a + b[index] + b[index_2]\n\n\ndef get_binary_string_xor_with_index_with_index_2(a: str, b: str, index: int,"
    },
    {
      "rank": 94,
      "score": 2.287625906893272,
      "candidate": "return str(bin(int(a, 2) ^ int(b, 2)))\n\n\ndef string_xor_with_binary(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_with_binary('010', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(x)) for x in a.split('0') if x!= '0'])\n\n\ndef string_xor_with_binary_list(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_with_binary_list('010', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(x)) for x in a.split('0') if x!= '0'])\n\n\ndef string_xor_with_binary_list_with_index(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_with_binary_list_with_index('010', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(x)) for x in a.split('0') if x!= '0'])\n\n\ndef string_xor_with_binary_list_with_index_with_binary(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_with_binary_list_with_index_with_binary('010', '110')\n    '100'\n    \"\"\"\n    return ''.join([str(int(x)) for x in a.split('0') if x!= '0'])\n\n\ndef string_xor_with_binary_list_with"
    },
    {
      "rank": 95,
      "score": 2.2682425259339407,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef find_xor_values(a: List[str], b: List[str]) -> List[str]:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return list of strings result.\n    >>> find_xor_values(['010', '110'], ['100'])\n    ['110']\n    \"\"\"\n    result = []\n    for i in range(len(a)):\n        result.append(string_xor(a[i], b[i]))\n    return result"
    },
    {
      "rank": 96,
      "score": 2.260739004816286,
      "candidate": "return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"110\"])\n    '100'\n    \"\"\"\n    result = ''\n    for x, y in zip(a, b):\n        result += str(int(x) ^ int(y))\n    return result\n\n\ndef string_xor_dict(a: dict, b: dict) -> str:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_dict({'010': '110'}, {'100': '110'})\n    '100'\n    \"\"\"\n    result = ''\n    for key, value in a.items():\n        result += str(int(key) ^ int(value))\n    for key, value in b.items():\n        result += str(int(key) ^ int(value))\n    return result\n\n\ndef string_xor_set(a: set, b: set) -> str:\n    \"\"\" Input are two sets a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set({'010': '110'}, {'100': '110'})\n    '100'\n    \"\"\"\n    result = ''\n    for x, y in zip(a, b):\n        result += str(int(x) ^ int(y))\n    return result\n\n\ndef string_xor_set_dict(a: dict, b: dict) -> str:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_set_dict({'010': '110'}, {'100': '110"
    },
    {
      "rank": 97,
      "score": 2.137541083743484,
      "candidate": "result = ''\n    for i in range(len(a)):\n        result += a[i] if b[i] == '1' else b[i]\n    return result\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"010\", \"110\"])\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        result += a[i] if b[i] == '1' else b[i]\n    return result\n\n\ndef string_xor_dict(a: dict, b: dict) -> dict:\n    \"\"\" Input are two dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_dict({\"010\": \"110\", \"110\": \"010\"}, {\"010\": \"110\", \"110\": \"010\"})\n    {'100': '010'}\n    \"\"\"\n    result = {}\n    for k in a.keys():\n        result[k] = a[k] if b[k] == '1' else b[k]\n    return result\n\n\ndef string_xor_list_dict(a: List[dict], b: List[dict]) -> dict:\n    \"\"\" Input are two lists of dictionaries a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a dictionary.\n    >>> string_xor_list_dict([{\"010\": \"110\", \"110\": \"010\"}, {\"010\": \"110\", \"110\": \"010\"}],\n    {\"010\": \"110\", \"110\": \"010\"})\n    {'100': '010'}\n    \"\"\"\n    result = {}\n    for k in a.keys():\n        result[k] = a[k] if b[k] == '1' else b[k]\n    return result\n\n\ndef string_xor_dict_list(a:"
    },
    {
      "rank": 98,
      "score": 2.020164938060112,
      "candidate": "return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list(['010', '110'], ['100'])\n    '100'\n    \"\"\"\n    return ''.join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))"
    },
    {
      "rank": 99,
      "score": 2.006215542699554,
      "candidate": "return str(int(a, 2) ^ int(b, 2))\n\n\ndef string_xor_list(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list([\"010\", \"110\"], [\"100\", \"100\"])\n    '100'\n    \"\"\"\n    return \"\".join([string_xor(a_i, b_i) for a_i, b_i in zip(a, b)])\n\n\ndef string_xor_list_iterative(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_iterative([\"010\", \"110\"], [\"100\", \"100\"])\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        result += string_xor(a[i], b[i])\n    return result\n\n\ndef string_xor_list_recursive(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list_recursive([\"010\", \"110\"], [\"100\", \"100\"])\n    '100'\n    \"\"\"\n    if len(a) == 0:\n        return \"\"\n    if len(b) == 0:\n        return a[0]\n    return a[0] + string_xor_list_recursive(a[1:], b[1:])\n\n\ndef string_xor_list_recursive_iterative(a: List[str], b: List[str]) -> str:\n    \"\"\" Input are two lists of strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_list"
    },
    {
      "rank": 100,
      "score": 1.6901274479551278,
      "candidate": "return \"\".join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_v1(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v1('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_v2(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v2('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '1'\n        else:\n            result += '0'\n    return result\n\n\ndef string_xor_v3(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v3('010', '110')\n    '100'\n    \"\"\"\n    return \"\".join(chr(int(a[i], 2) ^ int(b[i], 2)) for i in range(len(a)))\n\n\ndef string_xor_v4(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor_v4('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '1"
    }
  ]
}