{
  "timestamp": "2025-09-14T11:18:33.522942",
  "method": "improved_llm_judge",
  "judge_model": "codellama/CodeLlama-7b-Python-hf",
  "target_model": "codet5-770m",
  "dataset": "humaneval",
  "problem_number": 6,
  "total_candidates": 100,
  "results": [
    {
      "rank": 1,
      "score": 10.0,
      "candidate": "max_level = 0\n    stack = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                max_level += 1\n\n    return stack[::-1]\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod(verbose=True)"
    },
    {
      "rank": 2,
      "score": 10.0,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                max_level = max(max_level, len(stack))\n        else:\n            continue\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 3,
      "score": 10.0,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                max_level = max(max_level, len(stack))\n            stack.pop()\n    return [max_level] + stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 4,
      "score": 10.0,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            max_level = max(max_level, len(stack))\n        elif char == ')':\n            if len(stack) == 0:\n                stack.pop()\n                max_level = max(max_level, len(stack))\n            else:\n                stack.pop()\n        else:\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                max_level = max(max_level, len(stack))\n    return stack[::-1]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 5,
      "score": 10.0,
      "candidate": "nesting_stack: List[int] = []\n    for c in paren_string:\n        if c == '(':\n            nesting_stack.append(1)\n        elif c == ')':\n            nesting_stack.pop()\n            if nesting_stack:\n                nesting_stack[-1] += 1\n    return nesting_stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 6,
      "score": 10.0,
      "candidate": "stack: List[int] = []\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 7,
      "score": 10.0,
      "candidate": "result = []\n    for i in paren_string:\n        if i == \"(\":\n            result.append(1)\n        elif i == \")\":\n            result.pop()\n    return result\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 8,
      "score": 10.0,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                max_level = max(max_level, len(stack))\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 9,
      "score": 10.0,
      "candidate": "result = []\n\n    for paren in paren_string.split(' '):\n        if paren == '(':\n            result.append(1)\n        elif paren == ')':\n            result.pop()\n            if not result:\n                result.append(2)\n        else:\n            result.append(len(result) - 1)\n\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 10,
      "score": 10.0,
      "candidate": "nested_parens = []\n    for char in paren_string:\n        if char == '(':\n            nested_parens.append(1)\n        elif char == ')':\n            nested_parens.pop()\n        else:\n            continue\n    return nested_parens\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 11,
      "score": 10.0,
      "candidate": "def parse_nested_parens_helper(paren_string, depth, stack):\n        if len(paren_string) == 0:\n            return [depth]\n        if paren_string[0] == '(':\n            stack.append(paren_string[0])\n            depth += 1\n            return parse_nested_parens_helper(paren_string[1:], depth, stack)\n        if paren_string[0] == ')':\n            depth -= 1\n            if not stack:\n                return parse_nested_parens_helper(paren_string[1:], depth, stack)\n            return [stack.pop()]\n\n    return [parse_nested_parens_helper(paren_string, 0, [])[0]]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 12,
      "score": 10.0,
      "candidate": "nesting = [0] * len(paren_string)\n    for i, paren in enumerate(paren_string):\n        if paren == '(':\n            nesting[i] = nesting[i - 1] + 1\n        elif paren == ')':\n            nesting[i] = max(nesting[i - 1], nesting[i])\n    return nesting\n\n\nif __name__ == '__main__':\n    with open('input.txt') as f:\n        print(parse_nested_parens(f.read()))"
    },
    {
      "rank": 13,
      "score": 10.0,
      "candidate": "stack = []\n    max_level = 0\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0:\n                max_level = max(max_level, len(stack) - 1)\n            else:\n                stack.pop()\n        else:\n            pass\n\n    return stack\n\n\nif __name__ == '__main__':\n    with open('./input/day4.txt', 'r') as f:\n        paren_string = f.read().strip()\n\n    print(parse_nested_parens(paren_string))"
    },
    {
      "rank": 14,
      "score": 10.0,
      "candidate": "stack: List[int] = []\n    max_depth: int = 0\n\n    for char in paren_string:\n        if char == \"(\":\n            stack.append(1)\n        elif char == \")\":\n            if stack:\n                stack.pop()\n            else:\n                max_depth = max(max_depth, 1)\n        else:\n            stack.pop()\n\n    return stack\n\n\nif __name__ == \"__main__\":\n    with open(\"input.txt\") as file:\n        paren_string = file.read()\n    print(parse_nested_parens(paren_string))"
    },
    {
      "rank": 15,
      "score": 10.0,
      "candidate": "stack = []\n    max_level = 0\n    for c in paren_string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if stack:\n                max_level = max(max_level, len(stack))\n                stack.pop()\n            else:\n                break\n    return stack + [max_level]\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 16,
      "score": 10.0,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            stack.pop()\n        else:\n            stack.append(max(stack))\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 17,
      "score": 9.959903352660357,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return [1]\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 18,
      "score": 9.912679928279106,
      "candidate": "max_level = 0\n    last_level = 0\n    level_stack = []\n    for char in paren_string:\n        if char == '(':\n            level_stack.append(last_level)\n        elif char == ')':\n            last_level = max(level_stack.pop(), last_level)\n        else:\n            last_level = 0\n        max_level = max(last_level, max_level)\n\n    return level_stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 19,
      "score": 9.910328411003148,
      "candidate": "stack: List[int] = []\n    for char in paren_string:\n        if char == \"(\":\n            stack.append(1)\n        elif char == \")\":\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(3)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 20,
      "score": 9.888326138679268,
      "candidate": "stack = []\n    nesting = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(nesting)\n            nesting = 0\n        elif char == ')':\n            nesting = max(nesting - 1, stack.pop())\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 21,
      "score": 9.864938371464625,
      "candidate": "result = []\n    current_level = 0\n    for char in paren_string:\n        if char == '(':\n            current_level += 1\n        elif char == ')':\n            current_level -= 1\n        else:\n            result.append(current_level)\n            current_level = 0\n    result.append(current_level)\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 22,
      "score": 9.863852428078864,
      "candidate": "result = []\n\n    for char in paren_string:\n        if char == '(':\n            result.append(1)\n        else:\n            result.pop()\n\n    return result\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()())) ((())) () ((())()())'))"
    },
    {
      "rank": 23,
      "score": 9.836936616520118,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            current_level = stack.pop()\n            if current_level > max_level:\n                max_level = current_level\n        else:\n            current_level += 1\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 24,
      "score": 9.791245179565534,
      "candidate": "stack = []\n    max_level = 0\n\n    for c in paren_string:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) > 0:\n                max_level = max(max_level, len(stack) - 1)\n            else:\n                stack.pop()\n        else:\n            pass\n    return max_level\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 25,
      "score": 9.736673018098848,
      "candidate": "stack: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(1)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 26,
      "score": 9.590431926612766,
      "candidate": "result = [0] * len(paren_string)\n    stack = []\n    for c in paren_string:\n        if c == '(':\n            stack.append(c)\n        else:\n            if not stack:\n                result[len(stack)] = int(c)\n                stack = []\n            else:\n                top = stack.pop()\n                result[len(stack)] = int(c) + top\n                stack.append(c)\n    return result\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 27,
      "score": 9.586823025998097,
      "candidate": "stack: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if not stack:\n                stack.append(1)\n            else:\n                stack.pop()\n        else:\n            stack.pop()\n    return stack"
    },
    {
      "rank": 28,
      "score": 9.488718354944806,
      "candidate": "stack = []\n    for c in paren_string:\n        if c == '(':\n            stack.append(1)\n        elif c == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return [1]\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 29,
      "score": 9.431695664074866,
      "candidate": "nesting_level = 0\n    stack = []\n    for c in paren_string:\n        if c == '(':\n            stack.append(nesting_level)\n            nesting_level += 1\n        elif c == ')':\n            nesting_level -= 1\n            if nesting_level == 0:\n                stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 30,
      "score": 9.370583536698913,
      "candidate": "stack = []\n    for c in paren_string:\n        if c == '(':\n            stack.append(1)\n        elif c == ')':\n            if len(stack) == 0:\n                return [1]\n            else:\n                last_level = stack.pop()\n                if last_level == 1:\n                    return [2, 3, 1, 3]\n                else:\n                    return [last_level + 1, 3, 1, 3]\n\n\nif __name__ == \"__main__\":\n    print(parse_nested_parens(\"(()())\"))"
    },
    {
      "rank": 31,
      "score": 9.234050852198141,
      "candidate": "stack = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(depth)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                depth -= 1\n        else:\n            depth += 1\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))\n    print(parse_nested_parens('(()())) ((())) () ((())()())'))"
    },
    {
      "rank": 32,
      "score": 9.226766272351448,
      "candidate": "stack = []\n    for c in paren_string:\n        if c == '(':\n            stack.append(0)\n        elif c == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                break\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 33,
      "score": 9.21346272767743,
      "candidate": "nested_parens = []\n\n    for paren_group in paren_string.split():\n        if paren_group == '(':\n            nested_parens.append(1)\n        elif paren_group == ')':\n            nested_parens.pop()\n        else:\n            nested_parens.append(len(nested_parens))\n    return nested_parens\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 34,
      "score": 9.183391466815202,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            top = stack.pop()\n            stack.append(top + 1)\n        elif char == ')':\n            top = stack.pop()\n            stack.append(top - 1)\n    return stack"
    },
    {
      "rank": 35,
      "score": 9.122564458729856,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                max_level = max_level + 1\n        else:\n            pass\n    return stack + [max_level]\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))\n    print(parse_nested_parens('(())) ((())) ((())()())'))\n    print(parse_nested_parens('(())) ((())) ((())()())'))\n    print(parse_nested_parens('(())) ((())) ((())()())'))\n    print(parse_nested_parens('(())) ((())) ((())()())'))\n    print(parse_nested_parens('(())) ((())) ((())()())'))"
    },
    {
      "rank": 36,
      "score": 8.932217008005624,
      "candidate": "stack = []\n    nesting = 0\n    for char in paren_string:\n        if char == \"(\":\n            stack.append(nesting)\n            nesting += 1\n        elif char == \")\":\n            nesting -= 1\n            if nesting < 0:\n                stack.pop()\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 37,
      "score": 8.910084504002544,
      "candidate": "nesting_levels = []\n    for char in paren_string:\n        if char == '(':\n            nesting_levels.append(1)\n        elif char == ')':\n            nesting_levels.pop()\n        elif nesting_levels:\n            nesting_levels.append(max(nesting_levels[-1], 1))\n        else:\n            nesting_levels.append(1)\n    return nesting_levels\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()())) ((())) ((())()())'))"
    },
    {
      "rank": 38,
      "score": 8.902145503295483,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        else:\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(1)\n    if len(stack) > 0:\n        stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 39,
      "score": 8.855395696632057,
      "candidate": "stack = []\n    level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(level)\n        elif char == ')':\n            if len(stack) > 0:\n                level = stack.pop()\n            else:\n                level = 0\n    return stack"
    },
    {
      "rank": 40,
      "score": 8.850707355641543,
      "candidate": "return [1] + [max(parse_nested_parens(paren_string), key=lambda x: x if x > 1 else 0) for paren_string in paren_string.split()]"
    },
    {
      "rank": 41,
      "score": 8.81367773444215,
      "candidate": "stack: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(1)\n    return stack"
    },
    {
      "rank": 42,
      "score": 8.701078161001123,
      "candidate": "nesting_level = 0\n    bracket_stack = []\n    for c in paren_string:\n        if c == '(':\n            bracket_stack.append(nesting_level)\n            nesting_level += 1\n        elif c == ')':\n            nesting_level -= 1\n            if nesting_level < 0:\n                bracket_stack.pop()\n    return bracket_stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 43,
      "score": 8.692801520950061,
      "candidate": "return [max(parse_nested_parens(child) + [child]) for child in paren_string.split()]\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 44,
      "score": 8.625262456968262,
      "candidate": "return [max(parse_nested_parens(paren_string=paren_string[:i]), key=len) + 1 for i in range(len(paren_string))]\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 45,
      "score": 8.623000730200317,
      "candidate": "stack = []\n    for i in paren_string:\n        if i == '(':\n            stack.append(1)\n        elif i == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(0)\n    return stack"
    },
    {
      "rank": 46,
      "score": 8.616253589228675,
      "candidate": "stack: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        else:\n            if not stack:\n                stack.append(1)\n            else:\n                stack.pop()\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 47,
      "score": 8.606486429141842,
      "candidate": "max_level = 0\n    current_level = 0\n    nesting_stack = []\n    for char in paren_string:\n        if char == '(':\n            current_level += 1\n        elif char == ')':\n            current_level -= 1\n        elif current_level == 0:\n            nesting_stack.append(current_level)\n            current_level = 0\n    return nesting_stack\n\n\nif __name__ == '__main__':\n    with open('input.txt') as f:\n        input_string = f.read()\n    print(parse_nested_parens(input_string))"
    },
    {
      "rank": 48,
      "score": 8.60156811074208,
      "candidate": "stack = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(0)\n        elif paren == ')':\n            if len(stack) == 0:\n                stack.append(0)\n            else:\n                stack.pop()\n        else:\n            if len(stack) > 0:\n                stack.pop()\n    return stack"
    },
    {
      "rank": 49,
      "score": 8.565425580227462,
      "candidate": "if len(paren_string) == 0:\n        return []\n    if len(paren_string) == 1:\n        return [len(paren_string)]\n\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            stack.pop()\n            if stack:\n                stack.append(stack[-1] + 1)\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) ((())()())'))"
    },
    {
      "rank": 50,
      "score": 8.548876241946822,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(max_level)\n            max_level = 0\n        else:\n            max_level = max(max_level, stack.pop())\n    return stack\n\n\nif __name__ == \"__main__\":\n    with open(\"input.txt\", \"r\") as file:\n        paren_string = file.read()\n    print(parse_nested_parens(paren_string))"
    },
    {
      "rank": 51,
      "score": 8.542875062379007,
      "candidate": "stack = []\n    nesting_level = 0\n    for paren in paren_string:\n        if paren == ')':\n            nesting_level -= 1\n            if nesting_level < 0:\n                stack.pop()\n        else:\n            nesting_level += 1\n            stack.append(nesting_level)\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 52,
      "score": 8.53012858503943,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(3)\n    return stack"
    },
    {
      "rank": 53,
      "score": 8.48796797856353,
      "candidate": "stack = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(1)\n        elif paren == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(3)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 54,
      "score": 8.478208546788407,
      "candidate": "depth = 0\n    stack = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(depth)\n        elif char == ')':\n            stack.pop()\n        else:\n            depth = max(depth, stack.pop())\n\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 55,
      "score": 8.437695832075478,
      "candidate": "if not paren_string:\n        return []\n\n    stack = []\n    max_level = 0\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                max_level = max(max_level, len(stack))\n        else:\n            continue\n\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()())'))"
    },
    {
      "rank": 56,
      "score": 8.426531424889468,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            stack.pop()\n            if stack:\n                stack.append(stack.pop() + 1)\n        else:\n            pass\n    return stack"
    },
    {
      "rank": 57,
      "score": 8.408439383654278,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(0)\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 58,
      "score": 8.386620303250325,
      "candidate": "stack = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(0)\n        elif paren == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(1)\n    return stack"
    },
    {
      "rank": 59,
      "score": 8.351614956112536,
      "candidate": "nesting_levels = [0]\n    for paren in paren_string:\n        if paren == '(':\n            nesting_levels.append(nesting_levels[-1] + 1)\n        elif paren == ')':\n            nesting_levels.pop()\n    return nesting_levels\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod()"
    },
    {
      "rank": 60,
      "score": 8.334608500525688,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(1)\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 61,
      "score": 8.331556294201176,
      "candidate": "stack = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(depth)\n        elif char == ')':\n            depth = max(depth, stack.pop())\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 62,
      "score": 8.327375965969855,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(1)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(1)\n    return stack\n\n\nif __name__ == \"__main__\":\n    with open(\"input.txt\", \"r\") as file:\n        paren_string = file.read()\n        print(parse_nested_parens(paren_string))"
    },
    {
      "rank": 63,
      "score": 8.327367757082776,
      "candidate": "stack: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            stack.pop()\n        else:\n            stack.append(stack[-1] + 1)\n    return stack\n\n\nif __name__ == \"__main__\":\n    print(parse_nested_parens('(()())'))"
    },
    {
      "rank": 64,
      "score": 8.298597569547805,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                return [-1]\n    return stack"
    },
    {
      "rank": 65,
      "score": 8.294940769211511,
      "candidate": "stack = []\n    level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(level)\n        elif char == ')':\n            level = stack.pop()\n        else:\n            level += 1\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 66,
      "score": 8.214125058964552,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(3)\n    return stack"
    },
    {
      "rank": 67,
      "score": 8.212735598038213,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(0)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 68,
      "score": 8.2048573255218,
      "candidate": "result = []\n    for paren in paren_string:\n        if paren == '(':\n            result.append(1)\n        elif paren == ')':\n            result.pop()\n            if len(result) > 0:\n                result[-1] += 1\n    return result\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()"
    },
    {
      "rank": 69,
      "score": 8.193565922652176,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                return []\n    return stack\n\n\nif __name__ == '__main__':\n    paren_string = input()\n    print(parse_nested_parens(paren_string))"
    },
    {
      "rank": 70,
      "score": 8.185309335307622,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        else:\n            stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    from doctest import testmod\n\n    testmod()"
    },
    {
      "rank": 71,
      "score": 8.179564342560925,
      "candidate": "stack = []\n    level = 0\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(level)\n        elif paren == ')':\n            level = stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 72,
      "score": 8.172253082181854,
      "candidate": "nested_parens = []\n    for paren in paren_string:\n        if paren == '(':\n            nested_parens.append(0)\n        elif paren == ')':\n            nested_parens.pop()\n        else:\n            nested_parens[-1] += 1\n    return nested_parens"
    },
    {
      "rank": 73,
      "score": 8.144125099485041,
      "candidate": "max_level = 0\n    levels = []\n    for char in paren_string:\n        if char == '(':\n            levels.append(max_level)\n            max_level += 1\n        elif char == ')':\n            levels.pop()\n            if not levels:\n                max_level -= 1\n    return levels\n\n\nif __name__ == '__main__':\n    with open('input.txt') as f:\n        print(parse_nested_parens(f.read()))"
    },
    {
      "rank": 74,
      "score": 8.143591138329747,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                stack.pop()\n            else:\n                max_level = max(max_level, len(stack))\n                stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 75,
      "score": 8.121884567141883,
      "candidate": "if not paren_string:\n        return []\n    current_level = 0\n    nesting_list = []\n    for char in paren_string:\n        if char == '(':\n            current_level += 1\n        elif char == ')':\n            current_level -= 1\n            if current_level < 0:\n                nesting_list.append(current_level)\n    return nesting_list\n\n\nif __name__ == '__main__':\n    with open('input.txt') as f:\n        print(parse_nested_parens(f.read()))"
    },
    {
      "rank": 76,
      "score": 8.105983444291466,
      "candidate": "return [max(parse_nested_parens(paren_string=paren_string[:i]),\n                parse_nested_parens(paren_string=paren_string[i + 1:]))\n            for i in range(len(paren_string) - 1)]\n\n\nif __name__ == '__main__':\n    with open('input.txt') as f:\n        print(parse_nested_parens(paren_string=f.readline().strip()))"
    },
    {
      "rank": 77,
      "score": 8.040197642997851,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        else:\n            if not stack:\n                stack.append(char)\n            else:\n                previous_char = stack.pop()\n                if char == ')':\n                    max_level = max(max_level, len(stack) - 1)\n                else:\n                    stack.append(previous_char)\n    return stack\n\n\nif __name__ == '__main__':\n    with open('../input/day5.txt', 'r') as f:\n        paren_string = f.read().strip()\n\n    print(parse_nested_parens(paren_string))"
    },
    {
      "rank": 78,
      "score": 8.024835682833125,
      "candidate": "stack = []\n    max_level = 0\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                max_level = max(max_level, len(stack) - 1)\n            stack.pop()\n\n    return [max_level]\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()())) ((())) () ((())()())'))"
    },
    {
      "rank": 79,
      "score": 7.938028884277233,
      "candidate": "stack = []\n    for i in paren_string:\n        if i == '(':\n            stack.append(1)\n        elif i == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(3)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 80,
      "score": 7.915588979966494,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(3)\n        else:\n            stack.append(char)\n    return stack"
    },
    {
      "rank": 81,
      "score": 7.8912769574414305,
      "candidate": "stack = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(depth)\n            depth += 1\n        elif char == ')':\n            if len(stack) == 0:\n                return []\n            else:\n                stack.pop()\n                depth -= 1\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) ((())()())'))"
    },
    {
      "rank": 82,
      "score": 7.868947655733293,
      "candidate": "nesting_list = []\n    for char in paren_string:\n        if char == '(':\n            nesting_list.append(1)\n        elif char == ')':\n            nesting_list.pop()\n    return nesting_list\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 83,
      "score": 7.84634113240411,
      "candidate": "stack = []\n    max_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            max_level = max(max_level, len(stack))\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                max_level = max(max_level, len(stack))\n    return [max_level] + stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 84,
      "score": 7.834022619458933,
      "candidate": "level = []\n    for char in paren_string:\n        if char == '(':\n            level.append(1)\n        elif char == ')':\n            level.pop()\n            if not level:\n                level.append(0)\n        else:\n            level[-1] += 1\n    return level"
    },
    {
      "rank": 85,
      "score": 7.780351419995229,
      "candidate": "level = 0\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            level += 1\n        elif char == ')':\n            level -= 1\n        if level < 0:\n            depth += 1\n        else:\n            depth -= 1\n\n    return [level, depth]"
    },
    {
      "rank": 86,
      "score": 7.705183449260731,
      "candidate": "stack = []\n    nesting = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(nesting)\n            nesting = 0\n        else:\n            nesting += 1\n    stack.append(nesting)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 87,
      "score": 7.5819855281879285,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                return [1]\n    return stack\n\n\nif __name__ == \"__main__\":\n    print(parse_nested_parens(\"(()()) ((())) ((())()())\"))"
    },
    {
      "rank": 88,
      "score": 7.4878043221155455,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(1)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(1)\n    return stack\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 89,
      "score": 7.4506599871439985,
      "candidate": "return [1 if c == '(' else 2 if c == ')' else 3 for c in paren_string]\n\n\nif __name__ == '__main__':\n    print(parse_nested_parens('(()())) ((())) () ((())()())'))"
    },
    {
      "rank": 90,
      "score": 7.134571892399572,
      "candidate": "stack = []\n    for c in paren_string:\n        if c == '(':\n            stack.append(1)\n        elif c == ')':\n            if not stack:\n                return stack\n            else:\n                stack.pop()\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 91,
      "score": 3.0,
      "candidate": "stack = []\n    depth = 0\n    for c in paren_string:\n        if c == '(':\n            stack.append(depth)\n            depth += 1\n        elif c == ')':\n            stack.pop()\n            depth -= 1\n    return stack\n\n\ndef parse_nested_parens_recursive(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_recursive('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    depth = 0\n    for c in paren_string:\n        if c == '(':\n            stack.append(depth)\n            depth += 1\n        elif c == ')':\n            stack.pop()\n            depth -= 1\n    return stack"
    },
    {
      "rank": 92,
      "score": 3.0,
      "candidate": "stack = []\n    level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(level)\n        elif char == ')':\n            level = max(stack.pop(), level)\n    return stack\n\n\ndef parse_nested_parens_faster(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_faster('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(level)\n            level += 1\n        elif char == ')':\n            level -= 1\n        else:\n            stack.pop()\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 93,
      "score": 3.0,
      "candidate": "nesting = []\n    for paren in paren_string:\n        if paren == '(':\n            nesting.append(1)\n        elif paren == ')':\n            nesting.pop()\n    return nesting\n\n\ndef parse_nested_parens_fast(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_fast('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = []\n    for paren in paren_string:\n        if paren == '(':\n            nesting.append(1)\n        elif paren == ')':\n            nesting.pop()\n        elif paren == '(':\n            nesting.append(2)\n        elif paren == ')':\n            nesting.pop()\n    return nesting"
    },
    {
      "rank": 94,
      "score": 3.0,
      "candidate": "stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        else:\n            stack.pop()\n    return stack\n\n\ndef parse_nested_parens_2(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        else:\n            if len(stack) > 0:\n                stack.append(1 + max(stack[-1], stack[-2]))\n            else:\n                stack.append(1)\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 95,
      "score": 3.0,
      "candidate": "stack: List[int] = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(1)\n        elif paren == ')':\n            stack.pop()\n        else:\n            stack.append(max(stack[-1], 1))\n    return stack\n\n\ndef parse_nested_parens_2(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_2('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(1)\n        elif paren == ')':\n            stack.pop()\n        else:\n            if not stack:\n                stack.append(1)\n            else:\n                stack.pop()\n                stack.append(max(stack[-1], 1))\n    return stack\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
      "rank": 96,
      "score": 3.0,
      "candidate": "nesting_list = [0] * len(paren_string)\n    current_level = 0\n    for paren in paren_string:\n        if paren == \"(\":\n            current_level += 1\n        else:\n            nesting_list[current_level] = current_level\n            current_level = 0\n    nesting_list[current_level] = current_level\n    return nesting_list\n\n\ndef test_parse_nested_parens():\n    assert parse_nested_parens(\"(()())\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"(()(())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested_parens(\"((()))((()))((()()())))\") == [2, 3, 1, 3]\n    assert parse_nested"
    },
    {
      "rank": 97,
      "score": 3.0,
      "candidate": "# TODO: Implement this\n    return [0]\n\n\nif __name__ == \"__main__\":\n    print(parse_nested_parens('(()()) ((())) () ((())()())'))"
    },
    {
      "rank": 98,
      "score": 3.0,
      "candidate": "stack = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(0)\n        elif paren == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(0)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(0)\n    return stack\n\n\ndef parse_nested_parens_recursive(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_recursive('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for paren in paren_string:\n        if paren == '(':\n            stack.append(0)\n        elif paren == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(0)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(0)\n    return stack\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()"
    },
    {
      "rank": 99,
      "score": 3.0,
      "candidate": "stack = []\n    max_level = 0\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n            max_level = 0\n        elif char == ')':\n            if len(stack) > 0:\n                max_level = max(max_level, stack.pop())\n            else:\n                max_level = 0\n    return [max_level] + stack\n\n\nif __name__ == \"__main__\":\n    assert parse_nested_parens('(()())') == [2, 3, 1, 3]\n    assert parse_nested_parens('((())) ((())) ((())()())') == [2, 3, 1, 3]\n    assert parse_nested_parens('(()()(()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))((()))(("
    },
    {
      "rank": 100,
      "score": 3.0,
      "candidate": "return [max(parse_nested_parens_iter(paren_string_part), default=0) for paren_string_part in paren_string.split(' ')]\n\n\ndef parse_nested_parens_iter(paren_string_part: str) -> List[int]:\n    \"\"\" Given a string representing multiple groups for nested parentheses separated by spaces,\n    return the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_iter('(()()) ((())) ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for paren_string_part_part in paren_string_part.split(' '):\n        if paren_string_part_part == '(':\n            stack.append(0)\n        else:\n            paren_string_part_part = paren_string_part_part[::-1]\n            if len(stack) == 0:\n                return []\n            else:\n                top = stack.pop()\n                if top == 0:\n                    return [top] + parse_nested_parens_iter(paren_string_part_part)\n                else:\n                    return [top] + parse_nested_parens_iter(paren_string_part_part)"
    }
  ]
}