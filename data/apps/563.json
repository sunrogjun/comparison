{
  "task_id": "APPS/563",
  "problem_id": 563,
  "prompt": "Your friend has recently learned about coprime numbers. A pair of numbers {a, b} is called coprime if the maximum number that divides both a and b is equal to one. \n\nYour friend often comes up with different statements. He has recently supposed that if the pair (a, b) is coprime and the pair (b, c) is coprime, then the pair (a, c) is coprime. \n\nYou want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (a, b, c), for which the statement is false, and the numbers meet the condition l \u2264 a < b < c \u2264 r. \n\nMore specifically, you need to find three numbers (a, b, c), such that l \u2264 a < b < c \u2264 r, pairs (a, b) and (b, c) are coprime, and pair (a, c) is not coprime.\n\n\n-----Input-----\n\nThe single line contains two positive space-separated integers l, r (1 \u2264 l \u2264 r \u2264 10^18; r - l \u2264 50).\n\n\n-----Output-----\n\nPrint three positive space-separated integers a, b, c\u00a0\u2014 three distinct numbers (a, b, c) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. \n\nIf the counterexample does not exist, print the single number -1.\n\n\n-----Examples-----\nInput\n2 4\n\nOutput\n2 3 4\n\nInput\n10 11\n\nOutput\n-1\n\nInput\n900000000000000009 900000000000000029\n\nOutput\n900000000000000009 900000000000000010 900000000000000021\n\n\n\n-----Note-----\n\nIn the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. \n\nIn the second sample you cannot form a group of three distinct integers, so the answer is -1. \n\nIn the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three.",
  "solutions": "[\"from sys import stdin\\nfrom fractions import gcd\\nlines = list([_f for _f in stdin.read().split('\\\\n') if _f])\\n\\ndef parseline(line):\\n\\treturn list(map(int, line.split()))\\n\\nlines = list(map(parseline, lines))\\n\\nl, r = lines[0]\\n\\nfor a in range(l, r+1):\\n\\tfor b in range(a, r+1):\\n\\t\\tfor c in range(b, r + 1):\\n\\t\\t\\tif gcd(a, b) == gcd(b, c) == 1 != gcd(a, c):\\n\\t\\t\\t\\tprint(a, b, c)\\n\\t\\t\\t\\treturn\\nprint(-1)\\n\", \"def NOD(x, y):\\n    while (y != 0):\\n        x = x % y\\n        x, y = y, x\\n    return x\\ndef main():\\n    l, r = map(int, input().split())\\n    for a in range(l, r - 1):\\n        for b in range(a, r):\\n            for c in range(b, r + 1):\\n                if NOD(a, b) == 1 and NOD(b, c) == 1 and NOD(a, c) != 1:\\n                    print(a, b, c)\\n                    return\\n    print(-1)\\nmain()\", \"__author__ = \\\"zabidon\\\"\\n\\nl, r = map(int, input().split())\\n\\ndef alg_evk(a,b):\\n    while(a%b):\\n        b, a = a % b, b\\n\\n    return b\\n\\nfound = False\\nfor a in range(r+1)[l:]:\\n    if found:\\n        break\\n    for b in range(r+1)[l:]:\\n        if found:\\n            break\\n        if alg_evk(a,b) != 1:\\n            continue\\n        for c in range(r+1)[l:]:\\n            if a<b<c:\\n                if alg_evk(b,c) == 1 and alg_evk(a,c) != 1:\\n                    found = True\\n                    result = (a, b, c)\\n                    break\\n\\nif(found):\\n    print(\\\"{} {} {}\\\".format(result[0], result[1], result[2]))\\nelse:\\n    print(-1)\", \"import sys\\n\\ndef gcd(a, b):\\n    return a if b == 0 else gcd(b, a % b)\\n\\nl, r = list(map(int, input().split()))\\nfor a in range(l, r-1):\\n    for b in range(a+1, r):\\n        for c in range(b+1, r+1):\\n            if gcd(a, b) == gcd(b, c) == 1 and gcd(a, c) != 1:\\n                print(a, b, c)\\n                return\\nprint(-1)\\n\", \"def nod(x, y):\\n    while min(x, y) > 0 and x != y:\\n        if x > y:\\n            x = x % y\\n        else:\\n            y = y % x\\n    return max(x, y)\\ndef is_me_right(left, right):\\n    for a in range(l, r - 1):\\n        for b in range(a + 1, r):\\n            for c in range(b + 1, r + 1):\\n                if (nod(a, b) == 1) and (nod(b, c) == 1) and (nod(a, c) != 1):\\n                    return True, a, b, c\\n    return False, 1, 1, 1\\nl, r = list(map(int, input().split()))\\nimr, a, b, c = is_me_right(l, r)\\nif imr:\\n    print(a, b, c)\\nelse:\\n    print(-1)\", \"import math\\n\\nl, r = [int(x)for x in input().split(' ')]\\n\\nif r - l < 2:\\n    print(-1)\\n    quit()\\n\\ndef gcd(a, b):\\n    while b:\\n        a, b = b, a%b\\n    return a\\n\\nfor a in range(l, r + 1):\\n    for b in range(a + 1, r + 1):\\n        for c in range(b + 1, r + 1):\\n            if gcd(a, c) != 1 and gcd(b, c) == 1:\\n                print(a, b, c)\\n                quit()\\n\\nprint(-1)\\n\", \"def gcd(a, b):\\n    rem = 0\\n    while b != 0:\\n        rem = a%b\\n        a = b\\n        b = rem\\n    return a\\n\\n\\na, b = map(int, input().split())\\nif b-a == 1:\\n    print (-1)\\nelse:   \\n    found = False\\n    for i in range(a, b+1):\\n        for j in range(i+1, b+1):\\n            for k in range(j+1, b+1):\\n                if gcd(i, j) == 1 and gcd(j, k) == 1 and gcd(i, k) != 1:\\n                    found = True\\n                    print (i, j, k)\\n                    break\\n            if found:\\n                break\\n        if found:\\n            break\\n    if not found:\\n        print (-1)\", \"def gcd(a, b):\\n    if b == 0:\\n        return a\\n    else:\\n        return gcd(b, a%b)\\n\\ndef isCoprime(a,b):\\n\\tif gcd(a,b) == 1:\\n\\t\\treturn True\\n\\telse:\\n\\t\\treturn False\\n\\ndef main():\\n\\t(l,r) = map(int, input().split())\\n\\tfor a in range(l,r-1):\\n\\t\\tfor b in range(a+1,r):\\n\\t\\t\\tif isCoprime(a,b)==True:\\n\\t\\t\\t\\tfor c in range(b+1,r+1):\\n\\t\\t\\t\\t\\tif isCoprime(b,c)==True:\\n\\t\\t\\t\\t\\t\\tif isCoprime(a,c) == False:\\n\\t\\t\\t\\t\\t\\t\\tprint(a,b,c)\\n\\t\\t\\t\\t\\t\\t\\treturn\\n\\tprint(-1)\\n\\treturn\\n\\ndef __starting_point():\\n\\tmain()\\n__starting_point()\", \"def gcd(a, b):\\n    if(a == 0 or b == 0): return a + b\\n    else: return gcd(b, a % b);\\nl, r = list(map(int, input().split()))\\n\\nr = r + 1\\nfor a in range(l, r):\\n    for b in range(a + 1, r):\\n        for c in range(b + 1, r):\\n            if(gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1):\\n                print(str(a) + \\\" \\\" + str(b) + \\\" \\\" + str(c))\\n                return\\n\\nprint(-1)\\n\", \"from fractions import gcd\\ndef checkok(a, b, c):\\n    if gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c)!= 1:\\n        return True\\n    return False\\n\\nmark = False\\nl, r = list(map(int, input().split(' ')))\\nfor i in range(l, r+1):\\n    for j in range(i+1, r+1):\\n        for k in range(j+1, r+1):\\n            if checkok(i, j, k) and not mark:\\n                print(i, j, k)\\n                mark = True\\n\\nif not mark:\\n    print(-1)\\n\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"2 4\\n\",\n    \"10 11\\n\",\n    \"900000000000000009 900000000000000029\\n\",\n    \"640097987171091791 640097987171091835\\n\",\n    \"19534350415104721 19534350415104725\\n\",\n    \"933700505788726243 933700505788726280\\n\",\n    \"1 3\\n\",\n    \"1 4\\n\",\n    \"1 1\\n\",\n    \"266540997167959130 266540997167959164\\n\",\n    \"267367244641009850 267367244641009899\\n\",\n    \"268193483524125978 268193483524125993\\n\",\n    \"269019726702209402 269019726702209432\\n\",\n    \"269845965585325530 269845965585325576\\n\",\n    \"270672213058376250 270672213058376260\\n\",\n    \"271498451941492378 271498451941492378\\n\",\n    \"272324690824608506 272324690824608523\\n\",\n    \"273150934002691930 273150934002691962\\n\",\n    \"996517375802030516 996517375802030524\\n\",\n    \"997343614685146644 997343614685146694\\n\",\n    \"998169857863230068 998169857863230083\\n\",\n    \"998996101041313492 998996101041313522\\n\",\n    \"999822344219396916 999822344219396961\\n\",\n    \"648583102513043 648583102513053\\n\",\n    \"266540997167959130 266540997167959131\\n\",\n    \"267367244641009850 267367244641009850\\n\",\n    \"268193483524125978 268193483524125979\\n\",\n    \"269019726702209402 269019726702209402\\n\",\n    \"269845965585325530 269845965585325530\\n\",\n    \"270672213058376250 270672213058376254\\n\",\n    \"271498451941492378 271498451941492379\\n\",\n    \"272324690824608506 272324690824608508\\n\",\n    \"273150934002691930 273150934002691931\\n\",\n    \"996517375802030516 996517375802030518\\n\",\n    \"997343614685146644 997343614685146644\\n\",\n    \"2147483647 2147483649\\n\",\n    \"3 5\\n\",\n    \"1 7\\n\",\n    \"9 12\\n\",\n    \"4 4\\n\",\n    \"11 13\\n\",\n    \"2 2\\n\"\n  ],\n  \"outputs\": [\n    \"2 3 4\\n\",\n    \"-1\\n\",\n    \"900000000000000009 900000000000000010 900000000000000021\\n\",\n    \"640097987171091792 640097987171091793 640097987171091794\\n\",\n    \"19534350415104722 19534350415104723 19534350415104724\\n\",\n    \"933700505788726244 933700505788726245 933700505788726246\\n\",\n    \"-1\\n\",\n    \"2 3 4\\n\",\n    \"-1\\n\",\n    \"266540997167959130 266540997167959131 266540997167959132\\n\",\n    \"267367244641009850 267367244641009851 267367244641009852\\n\",\n    \"268193483524125978 268193483524125979 268193483524125980\\n\",\n    \"269019726702209402 269019726702209403 269019726702209404\\n\",\n    \"269845965585325530 269845965585325531 269845965585325532\\n\",\n    \"270672213058376250 270672213058376251 270672213058376252\\n\",\n    \"-1\\n\",\n    \"272324690824608506 272324690824608507 272324690824608508\\n\",\n    \"273150934002691930 273150934002691931 273150934002691932\\n\",\n    \"996517375802030516 996517375802030517 996517375802030518\\n\",\n    \"997343614685146644 997343614685146645 997343614685146646\\n\",\n    \"998169857863230068 998169857863230069 998169857863230070\\n\",\n    \"998996101041313492 998996101041313493 998996101041313494\\n\",\n    \"999822344219396916 999822344219396917 999822344219396918\\n\",\n    \"648583102513044 648583102513045 648583102513046\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"270672213058376250 270672213058376251 270672213058376252\\n\",\n    \"-1\\n\",\n    \"272324690824608506 272324690824608507 272324690824608508\\n\",\n    \"-1\\n\",\n    \"996517375802030516 996517375802030517 996517375802030518\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"2 3 4\\n\",\n    \"9 11 12\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/483/A",
  "starter_code": ""
}