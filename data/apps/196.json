{
  "task_id": "APPS/196",
  "problem_id": 196,
  "prompt": "Nastya received a gift on New Year\u00a0\u2014 a magic wardrobe. It is magic because in the end of each month the number of dresses in it doubles (i.e. the number of dresses becomes twice as large as it is in the beginning of the month).\n\nUnfortunately, right after the doubling the wardrobe eats one of the dresses (if any) with the 50% probability. It happens every month except the last one in the year. \n\nNastya owns x dresses now, so she became interested in the expected number of dresses she will have in one year. Nastya lives in Byteland, so the year lasts for k + 1 months.\n\nNastya is really busy, so she wants you to solve this problem. You are the programmer, after all. Also, you should find the answer modulo 10^9 + 7, because it is easy to see that it is always integer.\n\n\n-----Input-----\n\nThe only line contains two integers x and k (0 \u2264 x, k \u2264 10^18), where x is the initial number of dresses and k + 1 is the number of months in a year in Byteland.\n\n\n-----Output-----\n\nIn the only line print a single integer\u00a0\u2014 the expected number of dresses Nastya will own one year later modulo 10^9 + 7.\n\n\n-----Examples-----\nInput\n2 0\n\nOutput\n4\n\nInput\n2 1\n\nOutput\n7\n\nInput\n3 2\n\nOutput\n21\n\n\n\n-----Note-----\n\nIn the first example a year consists on only one month, so the wardrobe does not eat dresses at all.\n\nIn the second example after the first month there are 3 dresses with 50% probability and 4 dresses with 50% probability. Thus, in the end of the year there are 6 dresses with 50% probability and 8 dresses with 50% probability. This way the answer for this test is (6 + 8) / 2 = 7.",
  "solutions": "[\"x, k = map(int, input().split())\\nif x == 0:\\n    print(0)\\nelse:\\n    mod = 10 ** 9 + 7\\n    p = pow(2, k, mod)\\n    ans = (x * (p * 2) - (p - 1)) % mod\\n    print(ans)\", \"mod = 10**9+7\\nx, k = list(map(int, input().split(' ')))\\nif (x == 0):\\n    print(0)\\nelse:\\n    val1 = pow(2,k+1,mod) * x\\n    val2 = pow(2, k, mod) - 1\\n    val1 -= val2\\n    val1 %= mod\\n    print(val1)\\n\", \"\\n\\nx,k = map(int, input().strip().split())\\n\\nMOD = 1000000007\\n\\nif x > 0:\\n\\tr = (pow(2, k+1, MOD) * x - pow(2, k, MOD) + 1 + MOD * 10) % MOD\\nelse:\\n\\tr = 0\\n\\nprint(r)\", \"from sys import stdin\\n\\nline = stdin.readline().rstrip().split()\\nx = int(line[0])\\nk = int(line[1])\\n\\nif x == 0:\\n    print(0)\\nelse:\\n    nn = pow(2, k, 1000000007)\\n    result = (nn*2*x - nn + 1) % 1000000007\\n    print(result)\\n\\n\\n\\n\", \"l = input().split(' ')\\nx = int(l[0])\\nk = int(l[1])\\n\\nif x == 0:\\n    print('0')\\nelse:\\n    mod = 1000000007\\n\\n    def pow_mod(a, b):\\n        if b < 2:\\n            return int(a ** b) % mod\\n        elif b % 2 == 0:\\n            return int(pow_mod(a, b // 2) ** 2) % mod\\n        else:\\n            return pow_mod(a, b - 1) * a % mod\\n\\n    twop = pow_mod(2, k)\\n    high = x * twop\\n    leafs = twop\\n    low = high - leafs + 1\\n    s = (high + 1) * high // 2 - (low - 1 + 1) * (low - 1) // 2\\n    answer = s * 2 // leafs\\n    answer %= mod\\n\\n    print(answer)\", \"x, k = map(int, input().split())\\nans = 0\\nmd = 1000000007\\n\\ndef bpow(base, exp, md):\\n    if (exp == 0):\\n        return 1\\n    if (exp % 2 == 1):\\n        return (base * bpow(base, exp-1, md)) % md\\n    else:\\n        k = bpow(base, exp//2, md)\\n        return (k*k) % md\\n\\npw = bpow(2, k, md)\\nans = (2 * pw * x) % md\\nif (x != 0):\\n    ans -= pw-1\\nans = (ans + md) % md\\nprint(ans)\", \"x, k = list(map(int, input().split()))\\nif x == 0:\\n    print(0)\\n    return\\nx = 2 * x - 1\\nmod = 10**9 + 7\\n\\ndef pot(r, k):\\n    if k == 0: return 1\\n    if k % 2 == 1:\\n        return r * pot(r, k - 1) % mod\\n    y = pot(r, k // 2)\\n    return y * y % mod\\n\\nprint((pot(2, k) * x + 1) % mod)\\n\", \"mod = 1000000007\\nx, k = map(int, input().split())\\nif x == 0:\\n    print(0)\\nelse:\\n    ans = (pow(2, k + 1, mod) * x % mod - (pow(2, k, mod) - 1 + mod) % mod + mod) % mod\\n    print(ans)\", \"x, k = map(int, input().split())\\nif x == 0:\\n    print(0)\\n    return\\nres = pow(2, k + 1, 10 ** 9 + 7) * x - pow(2, k, 10 ** 9 + 7) + 1\\nres %= 10 ** 9 + 7\\nprint(res)\", \"x, k = map(int, input().split())\\nmod = 1000000007\\nflag = True\\nif x==0:\\n\\tflag = False\\n\\nx = x%mod\\ny = pow(2, k+1, mod)\\nz = pow(2, k, mod) - 1\\n\\nx = x*y\\nx = x%mod\\nx = x-z\\nif x==0:\\n\\tx=x+mod\\nx = x%mod\\n\\nif flag:\\n\\tprint(x)\\nelse:\\n\\tprint(0)\", \"from sys import stdin, stdout\\n\\n\\nMOD = 10 ** 9 + 7\\n\\n\\ndef bin_pow(n, k):\\n    res = 1\\n    \\n    while k:\\n        if k & 1:\\n            res = (res * n) % MOD\\n        \\n        n = (n * n) % MOD\\n        k >>= 1\\n        \\n    return res\\n\\n\\nx, k = map(int, stdin.readline().split())\\n\\nif x == 0:\\n    stdout.write('0')\\nelse:\\n    ans = (bin_pow(2, k + 1) * x - bin_pow(2, k) + 1) % MOD\\n    stdout.write(str(ans))\", \"x,k = list(map(int, input().split()))\\nmod = 10 ** 9 + 7\\nprint(0 if x == 0 else (x * pow(2, k + 1, mod) - pow(2, k, mod) + 1 + mod) % mod)\\n\", \"x, k = list(map(int, input().split()))\\nmod = 1000000007\\nif (k == 0):\\n    print((2 * x) % mod)\\nelif (x == 0):\\n    print(0)\\nelse:\\n    ans = ((2 * x - 1) * pow(2, k, mod) + 1) % mod\\n    print(ans)\\n\", \"x, k = map(int, input().split())\\n\\nmod = 10**9+7\\n\\ndef bp(n,p):\\n  if p == 0:\\n    return 1\\n  elif p % 2 == 0:\\n    return bp(n**2 % mod, p // 2)\\n  else:\\n    return (bp(n**2 % mod, p // 2) * n) % mod\\n\\ndef f(n,x):\\n  return (bp(2,n) * x - bp(2,n) + 1) % mod\\n\\nif x > 0:\\n  print(f(k,2*x) % mod)\\nelse:\\n  print(0)\", \"def pwr(a,n,m):\\n    if n==0:return 1\\n    ans=pwr(a,n//2,m)\\n    ans=ans*ans\\n    ans%=m\\n    if n%2==1:return (ans*a)%m\\n    else: return ans\\nM=1000000007\\ntx,tn=input().split()\\nx=int(tx)\\nn=int(tn)\\nans=pwr(2,n+1,M)*x\\nans%=M\\nans=ans-pwr(2,n,M)+1\\nans=(ans+M)%M\\nif x==0: ans=0\\nprint(ans)\\n\", \"#     Codeforces Round #489 (Div. 2)\\nimport collections\\nfrom functools import cmp_to_key\\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\\n\\nimport sys\\ndef getIntList():\\n    return list(map(int, input().split()))    \\n\\nimport bisect \\n            \\nbase = 10**9  + 7    \\ndef get2k(k) :\\n    f = 2\\n    b = 1\\n    r = 1\\n    while k>=b:\\n        if k &b >0:\\n            r = r*f % base\\n        b*=2\\n        f = f*f % base\\n    return r\\n\\nx, k = getIntList()\\nif x ==0:\\n    print(0)\\n    return\\nt2k = get2k(k)\\n\\nr = x *   t2k *2 - t2k + 1\\nr = r% base\\nprint(r)\\n\\n\", \"x, k = [int(x) for x in input().split()]\\n\\nif x == 0:\\n    print(0)\\n    return\\n\\nmod = 10 ** 9 + 7\\n\\nres = x * pow(2, k + 1, mod) % mod\\nres = ((res - (pow(2, k, mod) - 1)) % mod + mod) % mod\\n\\nprint(res)\\n\", \"def my_pow(a, n, m):\\n\\tif (n == 0) : return 1\\n\\tans = my_pow(a, n // 2, m)\\n\\tif (n % 2 == 0):\\n\\t\\treturn ans * ans % m\\n\\telse:\\n\\t\\treturn (ans * ans * a) % m\\n\\nx, k = map(int, input().split())\\nif (x == 0):\\n\\tprint(0)\\nelse:\\n\\tmod = 10**9 + 7\\n\\tx *= 2\\n\\tans = (x - 1) * my_pow(2, k, mod) + 1\\n\\tans %= mod\\n\\tans += 2 * mod\\n\\tprint(ans % mod)\", \"def binPow(x, n, r):\\n\\tif n == 0:\\n\\t\\treturn 1\\n\\telif n == 1:\\n\\t\\treturn x % r\\n\\tif n % 2 == 0:\\n\\t\\treturn binPow((x * x) % r, n // 2, r)\\n\\treturn (binPow((x * x) % r, n // 2, r) * x) % r\\n\\nx, k = list(map(int, input().split()))\\nr = 10 ** 9 + 7\\nif x == 0:\\n\\tprint(0)\\n\\treturn\\nelif k == 0:\\n\\tprint((x * 2) % r)\\n\\treturn\\nprint((binPow(2, k, r) * (2 * x - 1) + 1) % r)\\n\", \"MOD = 1000*1000*1000+7\\n\\ndef pow(x,e,m):\\n    res = 1\\n    x = x % m\\n\\n    while e>0:\\n        if(e % 2 == 1):\\n            res = (res*x) % m\\n\\n        e = e//2\\n        x = (x*x) % m\\n\\n    return res\\n\\nx, k = map(int, input().split(' '))\\n\\n\\nif x == 0:\\n    print(0)\\n\\nelse:\\n    myres = (pow(2,k,MOD)*(2*x-1) + 1) % MOD\\n    print(myres)\", \"x,k = list(map(int,input().split()))\\nmod = 10**9 + 7\\nif x == 0:\\n    print(0)\\nelse:\\n    print(((2*x-1)*pow(2,k,mod) + 1)%mod)\\n\", \"def powermod(base, power):\\n    if power == 0: return 1\\n    if power == 1: return base\\n    ret = powermod(base, power // 2)\\n    ret *= ret\\n    ret %= 1000000007\\n    if power % 2 == 1:\\n        ret *= base\\n        ret %= 1000000007\\n    return ret\\n\\nx, k = list(map(int, input().split()))\\n\\nb = x * 2 - 1\\nans = b * powermod(2, k) + 1\\nans %= 1000000007\\n\\nif x == 0: ans = 0\\nprint (ans)\\n\", \"#!/usr/bin/env python3\\n\\n\\nmod = 10**9 + 7\\n\\n\\n[x, k] = list(map(int, input().strip().split()))\\n\\nif x == 0:\\n\\tprint(0)\\n\\treturn\\n\\n\\ndef pow2(n):\\n\\tif n == 0:\\n\\t\\treturn 1\\n\\tif n % 2 == 0:\\n\\t\\treturn (pow2(n // 2) ** 2) % mod\\n\\telse:\\n\\t\\treturn (((pow2(n // 2) ** 2) % mod) * 2) % mod\\n\\nprint((pow2(k) * ((2 * x - 1) % mod) + 1) % mod)\\n\", \"mod=1000000007\\ndef fastexp(base,exp):\\n    if(exp==0):\\n        return 1;\\n    if(exp==1):\\n        return base%mod;\\n    t=fastexp(base,exp//2);\\n    if(exp%2==0):\\n        return (t%mod*t%mod)%mod;\\n    else:\\n        return (t%mod*t%mod*base%mod)%mod;\\nx,k=list(map(int,input().split()))\\nif(x==0):\\n    print((0));\\nelse:\\n    t=fastexp(2,k)%mod;\\n    before=((2*t)%mod*x%mod)%mod-(t+mod-1)%mod\\n    while(before<0):\\n        before+=mod;\\n    before=before%mod;\\n    print(before)\\n\", \"x, k = [int(v) for v in input().split()]\\nmod = 10**9 + 7\\n\\nif x == 0:\\n    print(0)\\nelse:\\n    print(((pow(2, k + 1, mod) * x) - (pow(2, k, mod) - 1)) % mod)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"2 0\\n\",\n    \"2 1\\n\",\n    \"3 2\\n\",\n    \"1 411\\n\",\n    \"1 692\\n\",\n    \"16 8\\n\",\n    \"18 12\\n\",\n    \"1 1000000000000000000\\n\",\n    \"0 24\\n\",\n    \"24 0\\n\",\n    \"1000000000000000000 1\\n\",\n    \"348612312017571993 87570063840727716\\n\",\n    \"314647997243943415 107188213956410843\\n\",\n    \"375000003 2\\n\",\n    \"451 938\\n\",\n    \"4 1669\\n\",\n    \"24 347\\n\",\n    \"1619 1813\\n\",\n    \"280 472\\n\",\n    \"1271 237\\n\",\n    \"626 560\\n\",\n    \"167 887\\n\",\n    \"1769 422\\n\",\n    \"160 929\\n\",\n    \"1075 274\\n\",\n    \"1332 332\\n\",\n    \"103872254428948073 97291596742897547\\n\",\n    \"157600018563121064 54027847222622605\\n\",\n    \"514028642164226185 95344332761644668\\n\",\n    \"91859547444219924 75483775868568438\\n\",\n    \"295961633522750187 84483303945499729\\n\",\n    \"8814960236468055 86463151557693391\\n\",\n    \"672751296745170589 13026894786355983\\n\",\n    \"909771081413191574 18862935031728197\\n\",\n    \"883717267463724670 29585639347346605\\n\",\n    \"431620727626880523 47616788361847228\\n\",\n    \"816689044159694273 6475970360049048\\n\",\n    \"313779810374175108 13838123840048842\\n\",\n    \"860936792402722414 59551033597232946\\n\",\n    \"332382902893992163 15483141652464187\\n\",\n    \"225761360057436129 49203610094504526\\n\",\n    \"216006901533424028 8313457244750219\\n\",\n    \"568001660010321225 97167523790774710\\n\",\n    \"904089164817530426 53747406876903279\\n\",\n    \"647858974461637674 18385058205826214\\n\",\n    \"720433754707338458 94180351080265292\\n\",\n    \"268086842387268316 76502855388264782\\n\",\n    \"488603693655520686 79239542983498430\\n\",\n    \"152455635055802121 50394545488662355\\n\",\n    \"585664029992038779 34972826534657555\\n\",\n    \"349532090641396787 12248820623854158\\n\",\n    \"353579407209009179 74469254935824590\\n\",\n    \"491414900908765740 49509676303815755\\n\",\n    \"91142854626119420 900651524977956\\n\",\n    \"73543340229981083 66918326344192076\\n\",\n    \"463958371369193376 89203995753927042\\n\",\n    \"911873413622533246 54684577459651780\\n\",\n    \"316313018463929883 78259904441946885\\n\",\n    \"889560480100219043 54181377424922141\\n\",\n    \"0 3259862395629356\\n\",\n    \"1 3\\n\",\n    \"3 1\\n\",\n    \"1000000007 1\\n\",\n    \"1000000007 2\\n\",\n    \"1000000007 0\\n\",\n    \"1000000007 12\\n\",\n    \"1000000007 70\\n\",\n    \"250000002 1\\n\",\n    \"1000000007 3\\n\",\n    \"999999999 0\\n\",\n    \"1000000007 5\\n\",\n    \"1000000007 1000000007\\n\",\n    \"10000000000000000 0\\n\",\n    \"1000000000000 0\\n\",\n    \"99999999999999999 0\\n\",\n    \"1000000000000000 0\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n\",\n    \"7\\n\",\n    \"21\\n\",\n    \"485514976\\n\",\n    \"860080936\\n\",\n    \"7937\\n\",\n    \"143361\\n\",\n    \"719476261\\n\",\n    \"0\\n\",\n    \"48\\n\",\n    \"195\\n\",\n    \"551271547\\n\",\n    \"109575135\\n\",\n    \"0\\n\",\n    \"598946958\\n\",\n    \"185365669\\n\",\n    \"860029201\\n\",\n    \"481568710\\n\",\n    \"632090765\\n\",\n    \"27878991\\n\",\n    \"399405853\\n\",\n    \"983959273\\n\",\n    \"698926874\\n\",\n    \"752935252\\n\",\n    \"476211777\\n\",\n    \"47520583\\n\",\n    \"283633261\\n\",\n    \"166795759\\n\",\n    \"718282571\\n\",\n    \"462306789\\n\",\n    \"11464805\\n\",\n    \"430718856\\n\",\n    \"260355651\\n\",\n    \"800873185\\n\",\n    \"188389362\\n\",\n    \"311078131\\n\",\n    \"211796030\\n\",\n    \"438854949\\n\",\n    \"359730003\\n\",\n    \"719128379\\n\",\n    \"54291755\\n\",\n    \"362896012\\n\",\n    \"907490480\\n\",\n    \"702270335\\n\",\n    \"375141527\\n\",\n    \"273505123\\n\",\n    \"288717798\\n\",\n    \"316399174\\n\",\n    \"697051907\\n\",\n    \"699566354\\n\",\n    \"233938854\\n\",\n    \"771349161\\n\",\n    \"237095803\\n\",\n    \"211575546\\n\",\n    \"710215652\\n\",\n    \"41857490\\n\",\n    \"926432198\\n\",\n    \"36284201\\n\",\n    \"281123162\\n\",\n    \"0\\n\",\n    \"9\\n\",\n    \"11\\n\",\n    \"1000000006\\n\",\n    \"1000000004\\n\",\n    \"0\\n\",\n    \"999995912\\n\",\n    \"729983755\\n\",\n    \"0\\n\",\n    \"1000000000\\n\",\n    \"999999991\\n\",\n    \"999999976\\n\",\n    \"1000000006\\n\",\n    \"860000007\\n\",\n    \"999986007\\n\",\n    \"600000012\\n\",\n    \"986000007\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/992/C",
  "starter_code": ""
}