{
  "task_id": "APPS/528",
  "problem_id": 528,
  "prompt": "Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).\n\nThere are n members, numbered 1 through n. m pairs of members are friends. Of course, a member can't be a friend with themselves.\n\nLet A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.\n\nFor example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.\n\nCan you help Limak and check if the network is reasonable? Print \"YES\" or \"NO\" accordingly, without the quotes.\n\n\n-----Input-----\n\nThe first line of the input contain two integers n and m (3 \u2264 n \u2264 150 000, $0 \\leq m \\leq \\operatorname{min}(150000, \\frac{n \\cdot(n - 1)}{2})$)\u00a0\u2014 the number of members and the number of pairs of members that are friends.\n\nThe i-th of the next m lines contains two distinct integers a_{i} and b_{i} (1 \u2264 a_{i}, b_{i} \u2264 n, a_{i} \u2260 b_{i}). Members a_{i} and b_{i} are friends with each other. No pair of members will appear more than once in the input.\n\n\n-----Output-----\n\nIf the given network is reasonable, print \"YES\" in a single line (without the quotes). Otherwise, print \"NO\" in a single line (without the quotes).\n\n\n-----Examples-----\nInput\n4 3\n1 3\n3 4\n1 4\n\nOutput\nYES\n\nInput\n4 4\n3 1\n2 3\n3 4\n1 2\n\nOutput\nNO\n\nInput\n10 4\n4 3\n5 10\n8 9\n1 2\n\nOutput\nYES\n\nInput\n3 2\n1 2\n2 3\n\nOutput\nNO\n\n\n\n-----Note-----\n\nThe drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is \"NO\" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.\n\n [Image]",
  "solutions": "[\"from collections import deque\\n\\n\\ndef bfs(start):\\n    res = []\\n    queue = deque([start])\\n    while queue:\\n        vertex = queue.pop()\\n        if not vis[vertex]:\\n            vis[vertex] = 1\\n            res.append(vertex)\\n            for i in s[vertex]:\\n                if not vis[i]:\\n                    queue.append(i)\\n    return res\\n\\nn, m = [int(i) for i in input().split()]\\ns = [[] for i in range(n)]\\nfor i in range(m):\\n    a, b = [int(i) for i in input().split()]\\n    s[a-1].append(b-1)\\n    s[b-1].append(a-1)\\nvis = [0 for i in range(n)]\\nr = 0\\nfor i in range(n):\\n    if not vis[i]:\\n        d = bfs(i)\\n        for j in d:\\n            if len(s[j]) != len(d)-1:\\n                r = 1\\n                print(\\\"NO\\\")\\n                break\\n    if r:\\n        break\\nelse:\\n    print(\\\"YES\\\")\", \"import sys\\n\\ndef main():\\n    n,m = map(int,sys.stdin.readline().split())\\n\\n    l = [[] for i in range(n+1)]\\n    u = [False]*(n+1)\\n\\n    for i in range(m):\\n        a, b = map(int,sys.stdin.readline().split())\\n        l[a].append(b)\\n        l[b].append(a)\\n        \\n    for i in range(n):\\n        j = i+1\\n        if u[j]:\\n            continue\\n        u[j] = True        \\n        q = []\\n        cl = len(l[j])\\n        cn = 1\\n        for a in l[j]:\\n            q.append(a)\\n\\n        while len(q)!=0 :\\n            cur = q.pop()\\n            if u[cur]:\\n                continue\\n            u[cur] = True\\n            cn+=1\\n            cl+=len(l[cur])\\n            for a in l[cur]:\\n                if u[a]:\\n                    continue\\n                q.append(a)\\n        if cl!=cn*(cn-1):\\n            #print(j, cl, cn)\\n            print(\\\"NO\\\")\\n            return\\n    print(\\\"YES\\\")\\n\\n\\nmain()\", \"n, m = [int(x) for x in input().split()]\\n\\nl = [] \\nfor i in range(m):\\n    x, y = [int(x) for x in input().split()]\\n    if x>y: x,y = y,x\\n    l.append((x, y))\\nl.sort(key=lambda x: x[0])\\n\\nlabels = {}\\nrels_count = {}\\nclass_count = {}\\nfor x, y in l:\\n    if x not in labels:\\n        labels[x] = len(rels_count)\\n        rels_count[labels[x]] = 0\\n        class_count[labels[x]] = 1\\n    if y not in labels:\\n        class_count[labels[x]] += 1\\n    labels[y] = labels[x]\\n    rels_count[labels[x]]+=1\\n    \\nflag = True\\nfor i in range(len(rels_count)):\\n    l_n = class_count[i]\\n    l_m = rels_count[i]\\n    if l_n*(l_n-1) != 2*l_m:\\n        flag = False\\n        break\\nif flag:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\", \"import sys\\nimport collections\\n\\n\\ndef bfs(u, adjList, vis):\\n    dq = collections.deque()\\n\\n    dq.append(u)\\n    vis[u] = True\\n    edgeCnt = 0\\n    vertexCnt = 0\\n\\n    while dq:\\n        u = dq.popleft()\\n\\n        vertexCnt += 1\\n        edgeCnt += len(adjList[u])\\n\\n        for v in adjList[u]:\\n            if not vis[v]:\\n                vis[v] = True\\n                dq.append(v)\\n\\n    edgeCnt = edgeCnt // 2\\n    return bool(edgeCnt == ((vertexCnt * vertexCnt - vertexCnt) // 2))\\n\\n\\ndef main():\\n    # sys.stdin = open(\\\"in.txt\\\", \\\"r\\\")\\n\\n    it = iter(map(int, sys.stdin.read().split()))\\n\\n    n = next(it)\\n    m = next(it)\\n\\n    adjList = [[] for _ in range(n+3)]\\n\\n    for _ in range(m):\\n        u = next(it)\\n        v = next(it)\\n        adjList[u].append(v)\\n        adjList[v].append(u)\\n\\n    vis = [False] * (n+3)\\n\\n    for u in range(1, n+1):\\n        if not vis[u]:\\n            if not bfs(u, adjList, vis):\\n                sys.stdout.write(\\\"NO\\\\n\\\")\\n                return\\n\\n    sys.stdout.write(\\\"YES\\\\n\\\")\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"# http://codeforces.com/contest/791/problem/B\\n\\nnax = 150123\\n\\nedges = [[] for _ in range(nax)]\\nvis = [False for j in range(nax)]\\n\\n\\ndef dfs(a, cnt_vertices, cnt_edges):\\n    stack = [a]\\n    while len(stack) > 0:\\n        a = stack.pop()\\n        if vis[a]:\\n            continue\\n        vis[a] = True\\n        cnt_vertices[0] += 1\\n        cnt_edges[0] += len(edges[a])\\n        for b in edges[a]:\\n            if not vis[b]:\\n                stack.append(b)\\n\\n\\ndef main():\\n    n, m = list(map(int, str(input()).strip().split()))\\n\\n    for _ in range(m):\\n        a, b = list(map(int, str(input()).strip().split()))\\n        edges[a].append(b)\\n        edges[b].append(a)\\n\\n    for i in range(1, n + 1):\\n        if not vis[i]:\\n            cnt_vertices = [0]\\n            cnt_edges = [0]\\n            dfs(i, cnt_vertices, cnt_edges)\\n            if cnt_edges[0] != cnt_vertices[0] * (cnt_vertices[0] - 1):\\n                print('NO')\\n                return 0\\n\\n    print('YES')\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"\\nn,m=[int(x)for x in input().split()]\\nd={}\\ncon=set()\\nfor x in range(m):\\n    a,b=input().split()\\n    d.setdefault(a,{a}).add(b)\\n    d.setdefault(b,{b}).add(a)\\nres=None\\nfor x,y in d.items():\\n    if x not in con:\\n        if all([d[u]==y for u in y]):\\n            con.update(y)\\n        else:\\n            res='NO'\\n            break\\nif not res:\\n    res='YES'\\nprint(res)\", \"n,m=[int(x)for x in input().split()]\\nd={}\\ncon=set()\\nfor x in range(m):\\n    a,b=input().split()\\n    d.setdefault(a,{a}).add(b)\\n    d.setdefault(b,{b}).add(a)\\nres=None\\nfor x,y in d.items():\\n    if x not in con:\\n        if all([d[u]==y for u in y]):\\n            con.update(y)\\n        else:\\n            res='NO'\\n            break\\nif not res:\\n    res='YES'\\nprint(res)\", \"def read():\\n    n, m = list(map(int, input().rstrip().split()))\\n    graph = [set() for _ in range(n + 1)]\\n    for _ in range(m):\\n        a, b = list(map(int, input().rstrip().split()))\\n        graph[a].add(b)\\n        graph[b].add(a)\\n        graph[a].add(a)\\n        graph[b].add(b)\\n    return (graph, n)\\n\\ndef main():\\n    graph, n = read()\\n    seen = set()\\n    for i in range(1, n + 1):\\n        if len(graph[i]) > 0 and i not in seen:\\n            if not all(graph[i] == graph[j] for j in graph[i]):\\n                return False\\n            seen |= graph[i]\\n    return True\\n\\ndef __starting_point():\\n    if main():\\n        print('YES')\\n    else:\\n        print('NO')\\n\\n__starting_point()\", \"def read():\\n    n, m = list(map(int, input().rstrip().split()))\\n    graph = [set() for _ in range(n + 1)]\\n    for _ in range(m):\\n        a, b = list(map(int, input().rstrip().split()))\\n        graph[a].add(b)\\n        graph[b].add(a)\\n        graph[a].add(a)\\n        graph[b].add(b)\\n    return (graph, n)\\n\\ndef main():\\n    graph, n = read() \\n    seen = set()\\n    for i in range(1, n + 1):\\n        if len(graph[i]) > 0 and i not in seen:\\n            if not all(graph[i] == graph[j] for j in graph[i]):\\n                return False\\n            seen |= graph[i]\\n    return True\\n\\ndef __starting_point():\\n    if main():\\n        print('YES')\\n    else:\\n        print('NO')\\n\\n__starting_point()\", \"n, m = [int(x) for x in input().split()]\\nd = {}\\nvisited = set()\\nfor x in range(m):\\n    a, b = input().split()\\n    d.setdefault(a, {a}).add(b)\\n    d.setdefault(b, {b}).add(a)\\nres='YES'\\nfor x, y in d.items():\\n    if x not in visited:\\n        if all([d[u]==y for u in y]):\\n            visited.update(y)\\n        else:\\n            res='NO'\\n            break\\nprint(res)\", \"from sys import *\\nf = lambda: map(int, stdin.readline().split())\\nn, m = f()\\ng = [[i] for i in range(n + 1)]\\nfor j in range(m):\\n    u, v = f()\\n    g[u].append(v)\\n    g[v].append(u)\\nk = 'YES'\\nfor t in g: t.sort()\\nfor t in g:\\n    s = len(t)\\n    if s > 1 and not all(g[x] == t for x in t):\\n        k = 'NO'\\n        break\\n    for j in t: g[j] = []\\nprint(k)\", \"from sys import *\\nf = lambda: map(int, stdin.readline().split())\\nn, m = f()\\ng = [[x] for x in range(n + 1)]\\np = [0] * (n + 1)\\nfor j in range(m):\\n    u, v = f()\\n    g[u].append(v)\\n    g[v].append(u)\\nk = 'YES'\\nfor y, t in enumerate(g):\\n    if not p[y]:\\n        if any(len(g[x]) != len(t) or any(p[y] for y in g[x]) for x in t):\\n            k = 'NO'\\n            break\\n        for x in t: p[x] = 1\\nprint(k)\", \"from collections import Counter as cntr\\nfrom math import inf\\ndef cin():\\n\\treturn list(map(int, input().split(' ')))\\ndef dfs(graph, src, n):\\n\\tq = [src]\\n\\th = 0\\n\\tnonlocal visited\\n\\tedges = 0\\n\\twhile q:\\n\\t\\tidx = q.pop()\\n\\t\\th += 1\\n\\n\\t\\tfor v in graph[idx]:\\n\\t\\t\\tedges += 1\\n\\t\\t\\tif visited[v] == False:\\n\\t\\t\\t\\tvisited[v] = True\\n\\t\\t\\t\\tq.append(v)\\n\\treturn h,edges\\nn,m = cin()\\ng = {i:[] for i in range(n)}\\nfor i in range(m):\\n\\ta, b = cin()\\n\\ta -= 1\\n\\tb -= 1\\n\\tg[a].append(b)\\n\\tg[b].append(a)\\nvisited = [False for i in range(n)]\\nfor i in range(n):\\n\\tif visited[i] == False:\\n\\t\\tvisited[i] = True\\n\\t\\tv,e = dfs(g, i, n)\\n\\t\\te = e//2\\n\\n\\t\\tif e != (v*(v-1))//2:\\n\\t\\t\\tprint('NO')\\n\\t\\t\\treturn\\nprint('YES')\\n\\n\\n\", \"n, m = [int(x) for x in input().split()]\\nd = {}\\nvisited = set()\\nfor x in range(m):\\n    a, b = input().split()\\n    d.setdefault(a, {a}).add(b)\\n    d.setdefault(b, {b}).add(a)\\nfor x, y in d.items():\\n       if x not in visited:\\n              if all([d[u]==y for u in y]):\\n                     visited.update(y)\\n              else:\\n                     print('NO');return\\n                     break\\nprint('YES')\", \"n,m=[int(x)for x in input().split()]\\nd={}\\ncon=set()\\nfor x in range(m):\\n    a,b=input().split()\\n    d.setdefault(a,{a}).add(b)\\n    d.setdefault(b,{b}).add(a)\\nres=None\\nfor x,y in list(d.items()):\\n    if x not in con:\\n        if all([d[u]==y for u in y]):\\n            con.update(y)\\n        else:\\n            res='NO'\\n            break\\nif not res:\\n    res='YES'\\nprint(res)\\n\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\", \"n,m=map(int,input().split())\\nv=[0]*150005\\ns=[set([i])for i in range(150005)]\\nfor _ in ' '*m:\\n    a,b=map(int,input().split())\\n    s[a].add(b)\\n    s[b].add(a)\\nfor i in range(n):\\n    if not v[i]:\\n        for j in s[i]:\\n            v[j]=1\\n            if s[j]!=s[i]:print('NO');return\\nprint('YES')\", \"n,m=map(int,input().split())\\nv=[0]*150005\\ns=[set([i])for i in range(150005)]\\nfor _ in ' '*m:\\n    a,b=map(int,input().split())\\n    s[a].add(b)\\n    s[b].add(a)\\nfor i in range(n):\\n    if not v[i]:\\n        for j in s[i]:\\n            v[j]=1\\n            if s[j]!=s[i]:print('NO');return\\nprint('YES')\", \"# -*- coding: utf-8 -*-\\nn, m = map(int, input().split(' '))\\nedges = [[] for i in range(n + 1)]\\nvis = [False] * (n + 1)\\n\\ndef dfs(a):\\n    nonlocal cnt_vertices\\n    nonlocal cnt_edges\\n    stack = [a]\\n    while len(stack) > 0:\\n        a = stack.pop()\\n        if vis[a]:\\n            continue\\n        vis[a] = True\\n        cnt_vertices += 1\\n        cnt_edges += len(edges[a])\\n        for b in edges[a]:\\n            if not vis[b]:\\n                stack.append(b)\\n\\nwhile m > 0:\\n    a, b = map(int, input().split(' '))\\n    edges[a].append(b)\\n    edges[b].append(a)\\n    m -= 1\\nfor i in range(1, n+1):\\n    if vis[i] == False:\\n        cnt_vertices = 0\\n        cnt_edges = 0\\n        dfs(i)\\n        if cnt_edges != cnt_vertices*(cnt_vertices-1):\\n            print(\\\"NO\\\")\\n            return\\nprint(\\\"YES\\\")\", \"inp = lambda : list(map(int, input().split()))\\nn, m = inp()\\nlines = [set([i]) for i in range(n + 1)]\\nfor i in range(m):\\n    x, y = inp()\\n    lines[x].add(y)\\n    lines[y].add(x)\\nf = [True] * (n + 1)\\nfor i in range(n):\\n    if f[i]:\\n        f[i] = False\\n        for j in lines[i]:\\n            f[j] = False\\n            if lines[i] != lines[j]:\\n                print(\\\"NO\\\")\\n                quit()\\nprint(\\\"YES\\\")\\n\", \"n, m = list(map(int, input().split()))\\nd = {}\\nfor i in range(m):\\n    a, b = list(map(int, input().split()))\\n    if a not in d:\\n        d[a] = {b}\\n    else:\\n        d[a].add(b)\\n    if b not in d:\\n        d[b] = {a}\\n    else:\\n        d[b].add(a)\\n\\nnot_visited = set(range(2, n+1))\\nvisited = set()\\ncurrent = set()\\nstack = [1]\\nsucc = True\\nwhile len(visited) < n:\\n\\n    if not stack:\\n        t = not_visited.pop()\\n        stack = [t]\\n        current = set()\\n\\n    p = stack.pop()\\n    visited.add(p)\\n    if p in d:\\n        for y in current:\\n            if y not in d[p]:\\n                succ = False\\n                break\\n        if not succ:\\n            break\\n        current.add(p)\\n        for x in d[p]:\\n            if x in not_visited:\\n                stack.append(x)\\n                not_visited.remove(x)\\n\\nif succ:\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"'''\\nn,m = map(int,input().split())\\neg,deg = [[] for _ in range(n+1)],[0 for _ in range(n+1)]\\nf,rk = list(range(n+1)),[0 for _ in range(n+1)]\\ndef fd(a):\\n    if f[a]!=a :return fd(f[a]) \\n    return f[a]\\ndef un(a,b):\\n    ra,rb = fd(a),fd(b)\\n    if ra==rb:return \\n    if rk[ra]>=rk[rb]:\\n        f[rb] = ra\\n        if rk[ra]==rk[rb]:rk[ra] +=1\\n    else :f[ra] = rb\\nfor i in range(1,n+1):\\n    for j in eg[i]:\\n        un(j,i)\\nfor x,y in [map(int,input().split()) for _ in range(m)]:\\n    un(x,y)\\n    deg[x],deg[y] = deg[x]+1,deg[y]+1\\ntable = [0 for _ in range(n+1)]\\nfor i in range(1,n+1):\\n    table[f[i]] += 1\\nok = 1\\nfor i in range(1,n+1):\\n    if deg[i]!=table[f[i]]-1:\\n        ok = 0\\n        break\\nprint(\\\"YES\\\") if ok else print(\\\"NO\\\")\\n'''\\nn, m = [int(x) for x in input().split()]\\nd = {}\\nvisited = set()\\nfor x in range(m):\\n    a, b = input().split()\\n    d.setdefault(a, {a}).add(b)\\n    d.setdefault(b, {b}).add(a)\\nres='YES'\\nfor x, y in d.items():\\n    if x not in visited:\\n        if all([d[u]==y for u in y]):\\n            visited.update(y)\\n        else:\\n            res='NO'\\n            break\\nprint(res)\", \"from collections import defaultdict \\nn,m=map(int,input().split())\\nd=defaultdict(list)\\nfor i in range(m):\\n    a,b=map(int,input().split())\\n    a-=1 \\n    b-=1\\n    d[a].append(b)\\n    d[b].append(a)\\nvis=[0]*n \\nfor i in range(n):\\n    if vis[i]==0:\\n        q=[i]\\n        ce=0\\n        cv=0 \\n        vis[i]=1 \\n        while q:\\n            t=q.pop()\\n            cv+=1 \\n            ce+=len(d[t])\\n            for i in d[t]:\\n                if not vis[i]:\\n                    vis[i]=1 \\n                    q.append(i)\\n    if ce!=cv*(cv-1):\\n        print('NO')\\n        return\\nprint('YES')\", \"#   In this template you are not required to write code in main\\n\\nimport sys\\ninf = float(\\\"inf\\\")\\n\\nsys.setrecursionlimit(1000000)\\n#from cmath import sqrt\\n#from collections import deque, Counter, OrderedDict,defaultdict\\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\\n#from math import ceil,floor,log,sqrt,factorial,pow,pi,gcd\\n#from bisect import bisect_left,bisect_right\\n#import numpy as np\\n\\nabc='abcdefghijklmnopqrstuvwxyz'\\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\\nmod,MOD=1000000007,998244353\\nvow=['a','e','i','o','u']\\ndx,dy=[-1,1,0,0],[0,0,1,-1]\\n\\ndef dfs(start):\\n    stack=[start]\\n    ct_vertex=1;ct_edges=0\\n    while stack:\\n        x=stack.pop()\\n        visited[x]=True\\n        for i in graph[x]:\\n            ct_edges+=1\\n            if not visited[i]:\\n                visited[i]=True\\n                ct_vertex+=1\\n                stack.append(i)\\n    # print(ct_vertex,ct_edges)\\n    if ct_edges==(ct_vertex*(ct_vertex-1)):\\n        return True\\n    else:\\n        return False\\n\\n\\ndef get_array(): return list(map(int, sys.stdin.readline().strip().split()))\\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\\ndef input(): return sys.stdin.readline().strip()\\n\\nn,m=get_ints()\\ngraph={i:[] for i in range(1,n+1)}\\nfor i in range(m):\\n    x,y=get_ints()\\n    graph[x].append(y)\\n    graph[y].append(x)\\n\\nvisited=[False]*(n+1);flag=0\\nfor i in range(1,n+1):\\n    if not visited[i]:\\n        if not dfs(i):\\n            flag=1\\n            break\\nif flag==0:\\n    print('YES')\\nelse:\\n    print(\\\"NO\\\")\"]",
  "input_output": "{\n  \"inputs\": [\n    \"4 3\\n1 3\\n3 4\\n1 4\\n\",\n    \"4 4\\n3 1\\n2 3\\n3 4\\n1 2\\n\",\n    \"10 4\\n4 3\\n5 10\\n8 9\\n1 2\\n\",\n    \"3 2\\n1 2\\n2 3\\n\",\n    \"3 0\\n\",\n    \"15 42\\n8 1\\n3 14\\n7 14\\n12 3\\n7 9\\n6 7\\n6 12\\n14 12\\n3 10\\n10 14\\n6 3\\n3 13\\n13 10\\n7 12\\n7 2\\n6 10\\n11 4\\n9 3\\n8 4\\n7 3\\n2 3\\n2 10\\n9 13\\n2 14\\n6 14\\n13 2\\n1 4\\n13 6\\n7 10\\n13 14\\n12 10\\n13 7\\n12 2\\n9 10\\n13 12\\n2 6\\n9 14\\n6 9\\n12 9\\n11 1\\n2 9\\n11 8\\n\",\n    \"20 80\\n17 4\\n10 1\\n11 10\\n17 7\\n15 10\\n14 15\\n13 1\\n18 13\\n3 13\\n12 7\\n9 13\\n10 12\\n14 12\\n18 11\\n4 7\\n10 13\\n11 3\\n19 8\\n14 7\\n10 17\\n14 3\\n7 11\\n11 14\\n19 5\\n10 14\\n15 17\\n3 1\\n9 10\\n11 1\\n4 1\\n11 4\\n9 1\\n12 3\\n13 7\\n1 14\\n11 12\\n7 1\\n9 12\\n18 15\\n17 3\\n7 15\\n4 10\\n7 18\\n7 9\\n12 17\\n14 18\\n3 18\\n18 17\\n9 15\\n14 4\\n14 9\\n9 18\\n12 4\\n7 10\\n15 4\\n4 18\\n15 13\\n1 12\\n7 3\\n13 11\\n4 13\\n5 8\\n12 18\\n12 15\\n17 9\\n11 15\\n3 10\\n18 10\\n4 3\\n15 3\\n13 12\\n9 4\\n9 11\\n14 17\\n13 17\\n3 9\\n13 14\\n1 17\\n15 1\\n17 11\\n\",\n    \"99 26\\n64 17\\n48 70\\n71 50\\n3 50\\n9 60\\n61 64\\n53 50\\n25 12\\n3 71\\n71 53\\n3 53\\n65 70\\n9 25\\n9 12\\n59 56\\n39 60\\n64 69\\n65 94\\n70 94\\n25 60\\n60 12\\n94 48\\n17 69\\n61 17\\n65 48\\n61 69\\n\",\n    \"3 1\\n1 2\\n\",\n    \"3 2\\n3 2\\n1 3\\n\",\n    \"3 3\\n2 3\\n1 2\\n1 3\\n\",\n    \"4 2\\n4 1\\n2 1\\n\",\n    \"4 3\\n3 1\\n2 1\\n3 2\\n\",\n    \"5 9\\n1 2\\n5 1\\n3 1\\n1 4\\n2 4\\n5 3\\n5 4\\n2 3\\n5 2\\n\",\n    \"10 5\\n9 5\\n1 2\\n6 8\\n6 3\\n10 6\\n\",\n    \"10 8\\n10 7\\n9 7\\n5 7\\n6 8\\n3 5\\n8 10\\n3 4\\n7 8\\n\",\n    \"10 20\\n8 2\\n8 3\\n1 8\\n9 5\\n2 4\\n10 1\\n10 5\\n7 5\\n7 8\\n10 7\\n6 5\\n3 7\\n1 9\\n9 8\\n7 2\\n2 10\\n2 1\\n6 4\\n9 7\\n4 3\\n\",\n    \"150000 10\\n62562 50190\\n48849 60549\\n139470 18456\\n21436 25159\\n66845 120884\\n99972 114453\\n11631 99153\\n62951 134848\\n78114 146050\\n136760 131762\\n\",\n    \"150000 0\\n\",\n    \"4 4\\n1 2\\n2 3\\n3 4\\n1 4\\n\",\n    \"30 73\\n25 2\\n2 16\\n20 12\\n16 20\\n7 18\\n11 15\\n13 11\\n30 29\\n16 12\\n12 25\\n2 1\\n18 14\\n9 8\\n28 16\\n2 9\\n22 21\\n1 25\\n12 28\\n14 7\\n4 9\\n26 7\\n14 27\\n12 2\\n29 22\\n1 9\\n13 15\\n3 10\\n1 12\\n8 20\\n30 24\\n25 20\\n4 1\\n4 12\\n20 1\\n8 4\\n2 28\\n25 16\\n16 8\\n20 4\\n9 12\\n21 30\\n23 11\\n19 6\\n28 4\\n29 21\\n9 28\\n30 10\\n22 24\\n25 8\\n27 26\\n25 4\\n28 20\\n9 25\\n24 29\\n20 9\\n18 26\\n1 28\\n30 22\\n23 15\\n28 27\\n8 2\\n23 13\\n12 8\\n14 26\\n16 4\\n28 25\\n8 1\\n4 2\\n9 16\\n20 2\\n18 27\\n28 8\\n27 7\\n\",\n    \"5 4\\n1 2\\n2 5\\n3 4\\n4 5\\n\",\n    \"4 4\\n1 2\\n2 3\\n3 4\\n4 1\\n\",\n    \"6 6\\n1 2\\n2 4\\n4 3\\n1 5\\n5 6\\n6 3\\n\",\n    \"3 2\\n1 2\\n1 3\\n\",\n    \"6 6\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n1 6\\n\",\n    \"4 4\\n1 2\\n1 3\\n2 4\\n3 4\\n\",\n    \"6 9\\n1 4\\n1 5\\n1 6\\n2 4\\n2 5\\n2 6\\n3 4\\n3 5\\n3 6\\n\",\n    \"4 3\\n1 2\\n1 3\\n3 4\\n\",\n    \"4 3\\n1 2\\n1 3\\n2 4\\n\",\n    \"6 6\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 1\\n\",\n    \"4 3\\n1 2\\n1 3\\n1 4\\n\",\n    \"150000 3\\n150000 149999\\n149998 149999\\n149998 150000\\n\",\n    \"10 15\\n1 2\\n1 3\\n2 4\\n2 5\\n3 4\\n3 5\\n4 5\\n1 6\\n6 7\\n6 8\\n7 9\\n7 10\\n8 9\\n8 10\\n9 10\\n\",\n    \"5 5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n\",\n    \"5 4\\n1 2\\n1 3\\n1 4\\n1 5\\n\",\n    \"9 9\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n7 8\\n8 9\\n9 1\\n\",\n    \"4 5\\n1 2\\n1 3\\n1 4\\n2 3\\n3 4\\n\",\n    \"4 4\\n1 2\\n1 3\\n4 2\\n4 3\\n\",\n    \"5 5\\n1 4\\n5 3\\n5 1\\n2 3\\n4 5\\n\",\n    \"4 5\\n1 2\\n1 3\\n2 3\\n1 4\\n2 4\\n\",\n    \"4 5\\n1 2\\n1 3\\n1 4\\n2 3\\n2 4\\n\",\n    \"6 12\\n1 2\\n1 4\\n1 5\\n1 6\\n2 3\\n2 5\\n2 6\\n3 4\\n3 5\\n3 6\\n4 5\\n4 6\\n\",\n    \"1000 4\\n100 132\\n100 164\\n196 132\\n196 164\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/771/A",
  "starter_code": ""
}