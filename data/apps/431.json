{
  "task_id": "APPS/431",
  "problem_id": 431,
  "prompt": "Some people leave the lights at their workplaces on when they leave that is a waste of resources. As a hausmeister of DHBW, Sagheer waits till all students and professors leave the university building, then goes and turns all the lights off.\n\nThe building consists of n floors with stairs at the left and the right sides. Each floor has m rooms on the same line with a corridor that connects the left and right stairs passing by all the rooms. In other words, the building can be represented as a rectangle with n rows and m + 2 columns, where the first and the last columns represent the stairs, and the m columns in the middle represent rooms.\n\nSagheer is standing at the ground floor at the left stairs. He wants to turn all the lights off in such a way that he will not go upstairs until all lights in the floor he is standing at are off. Of course, Sagheer must visit a room to turn the light there off. It takes one minute for Sagheer to go to the next floor using stairs or to move from the current room/stairs to a neighboring room/stairs on the same floor. It takes no time for him to switch the light off in the room he is currently standing in. Help Sagheer find the minimum total time to turn off all the lights.\n\nNote that Sagheer does not have to go back to his starting position, and he does not have to visit rooms where the light is already switched off.\n\n\n-----Input-----\n\nThe first line contains two integers n and m (1 \u2264 n \u2264 15 and 1 \u2264 m \u2264 100) \u2014 the number of floors and the number of rooms in each floor, respectively.\n\nThe next n lines contains the building description. Each line contains a binary string of length m + 2 representing a floor (the left stairs, then m rooms, then the right stairs) where 0 indicates that the light is off and 1 indicates that the light is on. The floors are listed from top to bottom, so that the last line represents the ground floor.\n\nThe first and last characters of each string represent the left and the right stairs, respectively, so they are always 0.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimum total time needed to turn off all the lights.\n\n\n-----Examples-----\nInput\n2 2\n0010\n0100\n\nOutput\n5\n\nInput\n3 4\n001000\n000010\n000010\n\nOutput\n12\n\nInput\n4 3\n01110\n01110\n01110\n01110\n\nOutput\n18\n\n\n\n-----Note-----\n\nIn the first example, Sagheer will go to room 1 in the ground floor, then he will go to room 2 in the second floor using the left or right stairs.\n\nIn the second example, he will go to the fourth room in the ground floor, use right stairs, go to the fourth room in the second floor, use right stairs again, then go to the second room in the last floor.\n\nIn the third example, he will walk through the whole corridor alternating between the left and right stairs at each floor.",
  "solutions": "[\"n, m = list(map(int, input().split()))\\nm += 2\\nl = []\\ndo = False\\nfor i in range(n):\\n\\ts = input().strip()\\n\\tif s.find('1') != -1 or do:\\n\\t\\tdo = True\\n\\t\\tl.append(s)\\nn = len(l)\\nif n == 0:\\n\\tprint(0)\\n\\treturn\\n\\n\\ndp = []\\nfor i in range(n):\\n\\tdp.append([None] * 2)\\n\\nfor i in range(n):\\n\\tR = 0\\n\\tfor j in range(m):\\n\\t\\tif l[i][j] == '1':\\n\\t\\t\\tR = j\\n\\tL = m - 1\\n\\tfor j in range(m - 1, -1, -1):\\n\\t\\tif l[i][j] == '1':\\n\\t\\t\\tL = j\\n\\tif i == 0:\\n\\t\\tdp[0][0] = R\\n\\t\\tdp[0][1] = (m - 1 - L)\\n\\telse:\\n\\t\\tdp[i][0] = min(dp[i - 1][0] + 2 * R, dp[i - 1][1] + (m - 1)) + 1\\n\\t\\tdp[i][1] = min(dp[i - 1][0] + (m - 1), dp[i - 1][1] + 2 * (m - 1 - L)) + 1\\n# print(dp)\\nprint(dp[-1][0])\\n\", \"def variant(cur):\\n    nonlocal minv\\n    if len(cur) < len(rooms):\\n        variant(cur + [0])\\n        variant(cur + [1])\\n    else:\\n        curpos = 0\\n        time = 0\\n        for i in range(len(rooms) - 1):\\n            if curpos != cur[i]:\\n                time += m + 1\\n                curpos = cur[i]\\n            else:\\n                time += 2 * rooms[i][curpos]\\n            if i != 0:\\n                time += 1\\n        time += rooms[-1][curpos] + 1\\n        if len(rooms) == 1:\\n            time -= 1\\n        minv = min(minv, time)\\n\\n\\n\\nn, m = map(int, input().split())\\nminv = 1000000000\\nrooms = []\\nstopdel = False\\n\\nfor i in range(n):\\n    line = input()\\n    a = 0\\n    for j in range(m + 2):\\n        if line[j] == '1':\\n            a = m + 1 - j\\n            break\\n    b = 0\\n    for j in range(m + 1, -1, -1):\\n        if line[j] == '1':\\n            b = j\\n            break\\n    if a != 0 or b != 0 or stopdel:\\n        rooms.append((b, a))\\n        stopdel = True\\n\\nrooms = rooms[::-1]\\n\\nif not rooms:\\n    print('0')\\nelse:\\n    variant([])\\n    print(minv)\", \"def sol():\\n\\n    n, m = map(int, input().split(' '))\\n\\n    mapp = []\\n\\n    for a in range(n):\\n        s = list(input())\\n        s = [c == \\\"1\\\" for c in s]\\n        mapp.insert(0, s[1:-1])\\n\\n    res = None\\n    #print(mapp)\\n\\n    empty_floor = n\\n    while True:\\n        litup = False\\n        for x in mapp[empty_floor-1]:\\n            if x:\\n                litup = True\\n                break\\n        if not litup:\\n            empty_floor -= 1\\n        else:\\n            break\\n        if empty_floor < 0:\\n            break\\n\\n    if empty_floor <= 0:\\n        return 0\\n\\n    #print(\\\"empty_floor\\\", empty_floor)\\n\\n    for comb in range(2**(empty_floor-1)):\\n        temp = 0\\n        c = bin(comb)[2:]\\n        c = \\\"0\\\" * ((empty_floor-1)-len(c)) + c\\n        c = list(c)\\n        c = [x == \\\"1\\\" for x in c]\\n\\n        #print(\\\"c\\\", c)\\n\\n        last = False # start from left\\n        if empty_floor != 1:\\n            for i, x in enumerate(c):\\n                if x != last:\\n                    temp += m+1 + 1\\n                else:\\n                    f = None\\n                    #print(i)\\n                    #print(\\\"last\\\", last)\\n                    for j, y in enumerate(mapp[i]):\\n                        if y:\\n                            f = j\\n                            if last:\\n                                break\\n                    if f is None:\\n                        temp += 1\\n                    else:\\n                        if last:\\n                            temp += 2 * (m - f) + 1\\n                        else:\\n                            temp += 2 * (f + 1) + 1\\n                last = x\\n\\n\\n        #final floor:\\n        f = None\\n        for j, y in enumerate(mapp[empty_floor-1]):\\n            if y:\\n                f = j\\n                if last:\\n                    break\\n        if f is not None:\\n            #print(f, \\\"f\\\")\\n            if c[-1]:\\n                temp += m - f\\n            else:\\n                temp += f + 1\\n\\n        if res is None:\\n            res = temp\\n        res = min(res, temp)\\n\\n        #print(c, temp)\\n\\n\\n    return res\\n\\nprint(sol())\", \"n, m = map(int, input().split())\\na = []\\nfor i in range(n):\\n    a.append(input())\\n# print(a)\\nl = 0\\nr = INF = 100000\\nh = 0\\nwhile h < n:\\n    if a[h] == '0' * (m + 2):\\n        h += 1\\n    else:\\n        break\\nif h != n:\\n    for i in range(n - 1, h, -1):\\n        x = INF\\n        y = 0\\n        for j in range(m + 2):\\n            if a[i][j] == '1':\\n                x = min(x, j)\\n                y = max(y, j)\\n        if x != INF:\\n            ll = min(l + y * 2, r + m + 1)\\n            rr = min(l + m + 1, r + (m + 1 - x) * 2)\\n            l = ll\\n            r = rr\\n        # print(i, l, r)\\n    x = INF\\n    y = 0\\n    for j in range(m + 2):\\n        if a[h][j] == '1':\\n            x = min(x, j)\\n            y = max(y, j)\\n    ans = min(l + y, r + (m + 1 - x))\\n    print(ans + n - 1 - h)\\nelse:\\n    print(0)\", \"def minimum(floor,j,s,n,m):\\n\\tif(s==[]):\\n\\t\\treturn 0\\n\\tif(floor==0):\\n\\t\\tif(j==0):\\n\\t\\t\\treturn s[floor].rfind('1')\\n\\t\\telse:\\n\\t\\t\\treturn m+1-s[floor].find('1')\\n\\tif(j==0):\\n\\t\\treturn min(2*s[floor].rfind('1')+1+minimum(floor-1,0,s,n,m),m+2+minimum(floor-1,m+1,s,n,m))\\n\\telse:\\n\\t\\treturn min(2*(m+1-s[floor].find('1'))+1+minimum(floor-1,m+1,s,n,m),m+2+minimum(floor-1,0,s,n,m))\\n\\ninp=input().split()\\nn=int(inp[0])\\nm=int(inp[1])\\ns=[]\\nfor i in range(n):\\n\\ts.append(input())\\ncounter=0\\nwhile(s!=[]):\\n\\tif(s[0].find('1')==-1):\\n\\t\\tcounter+=1\\n\\t\\ts.pop(0)\\n\\telse:\\n\\t\\tbreak\\ncounter2=0\\ns2=[]\\nfor val in s:\\n\\tif(val.find('1')==-1):\\n\\t\\tcounter2+=1\\n\\telse:\\n\\t\\ts2.append(val)\\n\\nprint(minimum(n-1-counter-counter2,0,s2,n,m)+counter2)\", \"n, m = list(map(int, input().split()))\\nL = [list(input()) for i in range(n)]\\nlight_floors = [n - i - 1 for i in range(n) if \\\"1\\\" in L[i]]\\nif len(light_floors) == 0:\\n    print(0)\\n    return\\nlimit = max(light_floors)\\n\\ndef rec(i, lst):\\n    if i == limit:\\n        # first: left\\n        # print(list(reversed(L[-1])))\\n        if \\\"1\\\" in L[-1]:\\n            cnt = m + 2 - list(reversed(L[-1])).index(\\\"1\\\") - 1\\n        else:\\n            cnt = 0\\n        now = cnt\\n        for j, l in enumerate(lst):\\n            if l == \\\"l\\\":\\n                cnt += now\\n                cnt += 1\\n                if \\\"1\\\" in L[-1 - j - 1]:\\n                    next_pos = (m + 2 - list(reversed(L[-1 - j - 1])).index(\\\"1\\\") - 1)\\n                else:\\n                    next_pos = 0\\n                cnt += next_pos\\n                now = next_pos\\n            else:\\n                cnt += (m + 2 - now - 1)\\n                cnt += 1\\n                if \\\"1\\\" in L[-1 - j - 1]:\\n                    next_pos = L[-1 - j - 1].index(\\\"1\\\")\\n                else:\\n                    next_pos = m + 2 - 1\\n                cnt += (m + 2 - next_pos - 1)\\n                now = next_pos\\n        return cnt\\n\\n    return min(rec(i + 1, lst + [\\\"l\\\"]), rec(i + 1, lst + [\\\"r\\\"]))\\n\\n\\nprint(rec(0, []))\\n\", \"import itertools\\n\\nn, m = list(map(int, input().split()))\\n\\nfloors = []\\nmax_lit = -1\\nfor floor_n in range(n-1, -1, -1):\\n    cur_floor = input()\\n    floors.insert(0, cur_floor)\\n    if max_lit == -1 and any(c == '1' for c in cur_floor):\\n        max_lit = floor_n + 1\\n\\nif max_lit == -1:\\n    print('0')\\n    return\\n\\n\\ndef calc_path(path):\\n    left = True\\n    result = 0\\n    for floor in range(max_lit):\\n        switch_stairs = path[floor]\\n        if left:\\n            pos = floors[floor].rfind('1')\\n            dist = 0 if pos == -1 else pos\\n        else:\\n            pos = floors[floor].find('1')\\n            dist = 0 if pos == -1 else m + 1 - pos\\n        is_last = floor == max_lit-1\\n        result += dist\\n        if switch_stairs:\\n            if not is_last:\\n                result += m + 1 - dist\\n            left = not left\\n        else:\\n            if not is_last:\\n                result += dist\\n        if not is_last:\\n            result += 1\\n    return result\\n\\n\\nmin_v = -1\\n\\nfor p in itertools.product([False, True], repeat=max_lit):\\n    v = calc_path(p)\\n    if min_v == -1 or min_v > v:\\n        min_v = v\\n\\nprint(min_v)\\n\", \"def booly(s):\\n    return bool(int(s))\\n\\nn, m = list(map(int, input().split()));\\n\\nnothing = \\\"0\\\"*(m+2);\\n\\na = [];\\nfor i in range(n):\\n    a.append(input())\\n\\nfor i in range(n):\\n    if a[i] != nothing:\\n        break;\\n\\na = a[i:]\\na.reverse();\\n\\nn = len(a)\\n\\n#print(a)\\n\\nleftA = [i.find(\\\"1\\\") for i in a]\\nrightA = [i.rfind(\\\"1\\\") for i in a]\\n\\nfor i in range(n):\\n    if leftA[i] == -1:\\n        leftA[i] = m+1\\n    if rightA[i] == -1:\\n        rightA[i] = 0\\n\\n#print(leftA, rightA);\\n\\nif len(a) == 1:\\n    print( rightA[0])\\n    return;\\n\\nleft = [None]*(n+1)\\nright = [None]*(n+1)\\n\\nleft[0] = rightA[0]*2\\nright[0] = m+1\\n\\nfor i in range(1,n-1):\\n    left[i] = 1 + min(left[i-1] + rightA[i]*2, right[i-1] + m+1)\\n    right[i] = 1 + min(right[i-1] + (m+2-1-leftA[i])*2, left[i-1] + m+1)\\n\\n#print(left, right)\\n\\nprint((min(1 +\\n    left[n-2] +\\n    rightA[n-1],\\n    1 + right[n-2]\\n    + (m+2 -1 -leftA[n-1]))));\\n\\n\", \"ans = 0\\nn, m = map(int, input().split())\\narr = [\\\"\\\"] + [input() for i in range(n)][::-1]\\ndp = [[-1, 10 ** 9, 0] for i in range(n + 1)]\\nz = 0\\nfor i in range(1, 1 + n):\\n    z += arr[i].count(\\\"1\\\")\\nfor i in range(1, n + 1):\\n    l = arr[i].find(\\\"1\\\")\\n    r = arr[i].rfind(\\\"1\\\")\\n    z -= arr[i].count(\\\"1\\\")\\n    if l != -1:\\n        dp[i][0] = min(dp[i - 1][0] + 2 * r, dp[i - 1][1] + m + 1) + 1\\n        dp[i][1] = min(dp[i - 1][0] + m + 1, dp[i - 1][1] + 2 * (m + 1 - l)) + 1\\n        dp[i][2] = min(dp[i - 1][0] + r, dp[i - 1][1] + (m + 1 - l)) + 1\\n    else:\\n        dp[i][0] = min(dp[i - 1][0], dp[i - 1][1] + m + 1) + 1\\n        dp[i][1] = min(dp[i - 1][0] + m + 1, dp[i - 1][1]) + 1\\n        \\n    #print(dp[i], l, r, arr[i][l], arr[i])\\n    #print(z, i)\\n    if z == 0:\\n        ans = dp[i][2]\\n        break\\nprint(ans)\", \"def gen(pr, n):\\n    nonlocal seq\\n    if len(pr) >= n:\\n        seq.append(pr)\\n    else:\\n        gen(pr + '0', n)\\n        gen(pr + '1', n)\\n\\n\\nn, m = map(int, input().split())\\nmatrix = []\\npref = [[] for i in range(n)]\\nseq = []\\nfor i in range(n):\\n    matrix.append(input()[1:m + 1])\\n    j = m - 1\\n    while j >= 0 and matrix[i][j] == '0':\\n        j -= 1\\n    tmp1 = (j + 1) * 2\\n    j = 0\\n    while j < m and matrix[i][j] == '0':\\n        j += 1\\n    tmp2 = (m - j) * 2\\n    pref[n - i - 1] = [tmp1, tmp2]\\ni = n - 1\\nwhile i >= 0 and pref[i] == [0, 0]:\\n    i -= 1\\ngen('0', i + 1)\\nn = i + 1\\nmi = float('inf')\\nfor i in seq:\\n    res = 0\\n    for j in range(n - 1):\\n        if i[j] == i[j + 1]:\\n            res += pref[j][int(i[j])] + 1\\n        else:\\n            res += m + 2\\n    res += pref[n - 1][int(i[n - 1])] // 2\\n    if res < mi:\\n        mi = res\\nprint(mi)\", \"n,m = map(int, input().split())\\nh = []\\nl = []\\nr = []\\nlast = -1\\nfor i in range(n):\\n    s = input()\\n    h.append(s)\\ni=0\\nfor s in reversed(h):\\n    lp, rp = m+1, 0\\n    for j in range(len(s)):\\n        let = s[j]\\n        if let == '1' and lp == m+1:\\n            lp = j\\n        if let == '1':\\n            rp = j\\n    l.append(lp)\\n    r.append(rp)\\n    if r[i] != 0 or l[i] != m+1:\\n        last = i\\n    i+=1\\n        \\n        \\ndp = [[2*r[0], m + 1]] \\nfor i in range(1,last):\\n    prev = dp[-1]\\n    ml = min(prev[0] + 2*r[i], prev[1] + m + 1) + 1\\n    rl = min(prev[1] + 2*(m+1 - l[i]), prev[0] + m+1) + 1\\n    dp.append([ml, rl])\\n    \\nif last == 0:\\n    ans = r[0]\\nelif last == -1:\\n    ans = 0\\nelse:\\n    ans = min(dp[-1][0] + r[last] + 1, dp[-1][1] + (m +1 - l[last]) + 1)\\n\\nprint(ans)\", \"import sys\\n\\ndef main():\\n    n,m = map(int,sys.stdin.readline().split())\\n    m+=2\\n    z = []\\n    for i in range(n):\\n        z.append(sys.stdin.readline().rstrip())\\n\\n    ans = 0\\n    y = n-1\\n    x = 0\\n    q = [[x,y,ans]]\\n    for i in range(n-1,-1,-1):\\n        first =-1\\n        last = -1\\n        for j in range(m):\\n            if z[i][j] == '1':\\n                if first == -1:\\n                    first = j\\n                last = j\\n        if first == -1 and last == -1:\\n            continue\\n        if i == n-1:\\n            q[0] = [last,n-1,last]\\n            continue\\n        if first == last :\\n            for t in q:\\n                t[2]+= min(t[0]+first, m-1-t[0]+m-1-first) + t[1]-i\\n                t[0] = first\\n                t[1] = i\\n            continue\\n        size = len(q)\\n        for s in range(size):\\n            t = q[s]\\n            q.append([last,i,t[2]+t[0]+last+t[1]-i])\\n            t[2]+= m-1-t[0]+m-1-first + t[1] - i\\n            t[0] = first\\n            t[1] = i\\n            q[s] = t\\n    ans = q[0][2]\\n    for i in range(len(q)):\\n        if q[i][2] < ans:\\n            ans = q[i][2]\\n\\n    print(ans)\\n\\n\\nmain()\", \"import sys\\n\\ninf = float('inf')\\nans = inf\\n\\ndef solve():\\n    nonlocal ans\\n    n, m = map(int, input().split())\\n    room = [[int(i) for i in input()] for j in range(n)]\\n    room.reverse()\\n\\n    exits = [False] * n\\n\\n    for i in range(n - 1, -1, -1):\\n        if any(room[i]):\\n            exits[i] = True\\n\\n        if i - 1 >= 0:\\n            exits[i - 1] |= exits[i]\\n\\n    # print(exits)\\n\\n    if not exits[0]:\\n        ans = 0\\n    else:\\n        dfs(0, n, m, room, exits, 0, 0)\\n\\n    print(ans)\\n\\ndef dfs(floor, n, m, room, exits, pos, move):\\n    nonlocal ans\\n\\n    k = -1\\n\\n    if pos == 0:\\n        for j in range(m + 1, -1, -1):\\n            if room[floor][j]:\\n                k = j\\n                break\\n        else:\\n            k = 0\\n    else:\\n        for j in range(0, m + 2):\\n            if room[floor][j]:\\n                k = j\\n                break\\n        else:\\n            k = m + 1\\n\\n    move += abs(k - pos)\\n\\n    if floor == n - 1 or not exits[floor + 1]:\\n        ans = min(ans, move)\\n        return\\n    else:\\n        dfs(floor + 1, n, m, room, exits, 0, move + k + 1)\\n        dfs(floor + 1, n, m, room, exits, m + 1, move + m + 1 - k + 1)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"#!/usr/bin/env python3\\nimport sys\\nfrom operator import itemgetter\\n\\ndef explore_floor(floor, light, from_, to, is_last_floor):\\n    \\\"\\\"\\\"from_, to is one of 'l' or 'r'\\\"\\\"\\\"\\n    if from_ != to:\\n        return len(floor) - 1\\n    else:\\n        if light == 0:\\n            return 0\\n        else:\\n            mul = 1 if is_last_floor else 2\\n            if from_ == 'l':\\n                indx = floor.rindex('1')\\n                return indx * mul\\n            else:\\n                indx = floor.index('1')\\n                return (len(floor) - indx - 1) * mul\\n\\ndef run_dp(n, m, floors, lights):\\n    dp_table = [[10 ** 10] * (n+1) for __ in range(4) ]\\n    dp_table[0][0] = -1\\n    dp_table[1][0] = 10 ** 10\\n    dp_table[2][0] = 10 ** 10\\n    dp_table[3][0] = 10 ** 10\\n    for indx in range(n):\\n        dp_table[0][indx + 1] = min(dp_table[2][indx], dp_table[0][indx]) + explore_floor(floors[indx], lights[indx], 'l', 'l', indx == n-1) + 1\\n        dp_table[1][indx + 1] = min(dp_table[2][indx], dp_table[0][indx]) + explore_floor(floors[indx], lights[indx], 'l', 'r', indx == n-1) + 1\\n        dp_table[2][indx + 1] = min(dp_table[1][indx], dp_table[3][indx]) + explore_floor(floors[indx], lights[indx], 'r', 'l', indx == n-1) + 1\\n        dp_table[3][indx + 1] = min(dp_table[1][indx], dp_table[3][indx]) + explore_floor(floors[indx], lights[indx], 'r', 'r', indx == n-1) + 1\\n    return dp_table\\n\\ndef get_virtual_max_floor(lights):\\n    n = len(lights)\\n    cnt = 0\\n    for val in reversed(list([elem == 0 for elem in lights])):\\n        if val:\\n            cnt += 1\\n        else:\\n            break\\n    return n - cnt\\n\\ndef main():\\n    n, m = list(map(int, sys.stdin.readline().split()))\\n    inp = sys.stdin.read().rstrip()\\n    floors = list(reversed(inp.split(\\\"\\\\n\\\")))\\n    assert len(floors) == n\\n    lights = list([sum(map(int, floor)) for floor in floors])\\n    assert len(lights) == n\\n    virtual_n = get_virtual_max_floor(lights)\\n    #sys.stderr.write(\\\"{}\\\\n\\\".format(lights))\\n    #sys.stderr.write(\\\"{}\\\\n\\\".format(virtual_n))\\n    if virtual_n == 0:\\n        print(0)\\n        return\\n    dp_table = run_dp(virtual_n, m, floors, lights)\\n    #sys.stderr.write(\\\"{}\\\\n\\\".format(dp_table))\\n    print(min([dp_table[indx][virtual_n] for indx in range(4)]))\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"def simulate(n, m, first, last, mask):\\n    pos = 'left'\\n    time = 0\\n\\n    for floor in range(n - 1):\\n        action = mask & 1\\n        mask >>= 1\\n\\n        if pos == 'left':\\n            if action == 0:\\n                time += 2 * last[floor]\\n            else:\\n                time += m + 1\\n                pos = 'right'\\n        else:\\n            if action == 0:\\n                time += 2 * (m + 1 - first[floor])\\n            else:\\n                time += m + 1\\n                pos = 'left'\\n\\n        time += 1\\n\\n    if pos == 'left':\\n        time += last[n - 1]\\n    else:\\n        time += m + 1 - first[n - 1]\\n\\n    return time\\n\\n\\ndef main():\\n    n, m = list(map(int, input().split()))\\n\\n    building = []\\n    for i in range(n):\\n        building.append(list(map(int, input())))\\n\\n    i_max = None\\n    for i in range(n):\\n        if any(x == 1 for x in building[i]):\\n            i_max = i\\n            break\\n\\n    if i_max is None:\\n        i_max = n\\n    n = n - i_max\\n\\n    if n == 0:\\n        print(0)\\n        return\\n\\n    building = building[::-1]\\n    building = building[:n]\\n\\n    first = [m + 1] * n\\n    last = [0] * n\\n\\n    for i in range(n):\\n        for j in range(m + 2):\\n            if building[i][j] == 1:\\n                if first[i] == m + 1:\\n                    first[i] = j\\n                last[i] = j\\n\\n    min_time = 10 * ((m + 1) * n + n)\\n    for mask in range(2 ** (n - 1)):\\n        min_time = min(min_time, simulate(n, m, first, last, mask))\\n\\n    print(min_time)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from itertools import dropwhile\\n\\n\\nn, m = list(map(int, input().split()))\\nm += 2\\n\\np = list(dropwhile(lambda line: '1' not in line, (input() for i in range(n))))\\np.reverse()\\naddition = len(p) - 1\\np = list([line for line in p if '1' in line])\\nn = len(p)\\n\\nif n == 0:\\n    print(0)\\n    return\\n\\nleft = [line.find('1') for line in p]\\nright = [line.rfind('1') for line in p]\\n\\nans = float('inf')\\nfor mask in range(2 ** n):\\n    cur_res = 0\\n    prev = 1\\n    for i in range(n):\\n        go_left = mask & (1 << i)\\n        if go_left and prev:\\n            cur_res += 2 * right[i]\\n        elif (go_left and not prev) or (not go_left and prev):\\n            cur_res += m - 1\\n        elif not go_left and not go_left:\\n            cur_res += 2 * (m - 1 - left[i])\\n        if i == n - 1:\\n            if go_left and prev:\\n                cur_res -= right[i]\\n            elif not go_left and not prev:\\n                cur_res -= m - 1 - left[i]\\n            elif go_left and not prev:\\n                cur_res -= left[i]\\n            elif not go_left and prev:\\n                cur_res -= m - 1 - right[i]\\n        prev = go_left\\n    ans = min(ans, cur_res)\\n\\nprint(ans + addition)\\n\", \"def coun(pref):\\n    now = 0\\n    for i in range(n):\\n        pos = pref[i]\\n        if pos == 'l':\\n            if i < n - 1 and sum(check[(i + 1):]) > 0:\\n                now += 1\\n                if \\\"1\\\" in mat[i]:\\n                    if pref[i + 1] == \\\"r\\\":\\n                        now += (m + 1)\\n                    else:\\n                        now += (2 * mat[i].rfind(\\\"1\\\"))\\n                else:\\n                    if pref[i + 1] == 'r':\\n                        now += (m + 1)\\n            else:\\n                if \\\"1\\\" in mat[i]:\\n                    now += mat[i].rfind(\\\"1\\\")\\n        else:\\n            if i < n - 1 and sum(check[(i + 1):]) > 0:\\n                now += 1\\n                if \\\"1\\\" in mat[i]:\\n                    if pref[i + 1] == \\\"l\\\":\\n                        now += (m + 1)\\n                    else:\\n                        now += (2 * (m + 1 - mat[i].find(\\\"1\\\")))\\n                else:\\n                    if pref[i + 1] == 'l':\\n                        now += (m + 1)\\n            else:\\n                if \\\"1\\\" in mat[i]:\\n                    now += (m + 1 - mat[i].find(\\\"1\\\"))\\n    return now\\ndef gen(pref):\\n    nonlocal ans\\n    if len(pref) == n:\\n        ans = min(ans, coun(pref))\\n        return\\n    gen(pref + \\\"l\\\")\\n    gen(pref + \\\"r\\\")\\nn, m = map(int, input().split())\\nmat = [0] * n\\nfor i in range(n):\\n    mat[i] = input()\\nmat.reverse()\\ncheck = [0] * n\\nfor i in range(n):\\n    check[i] = mat[i].count(\\\"1\\\")\\nans = 1000000000\\ngen(\\\"l\\\")\\nprint(ans)\", \"n, m = map(int, input().split())\\na = [input() for i in range(n)]\\ni = 0\\nwhile i < n and a[i] == '0' * (m + 2): i += 1\\na = a[i:]\\nn = len(a)\\ndp = [[10 ** 5, 10 ** 5] for i in range(n)]\\nfor i in range(n):\\n    l, r = a[i].find('1'), a[i].rfind('1')\\n    if l == r == -1: l, r = m + 1, 0\\n    if i == 0:\\n        dp[0] = [r, m + 1 - l]\\n    else:\\n        dp[i][0] = min(dp[i - 1][0] + 2 * r, dp[i - 1][1] + (m + 1)) + 1\\n        dp[i][1] = min(dp[i - 1][0] + m + 1, dp[i - 1][1] + 2 * (m + 1 - l)) + 1\\nans = dp[-1][0] if dp else 0\\nprint(ans)\", \"from sys import stdin as fin\\n# fin = open(\\\"cfr417b.in\\\", \\\"r\\\")\\n\\ndef f(i, csum, csl=True):\\n    nonlocal num_f, l_a, r_a, minv\\n    l, r = l_a[i], r_a[i]\\n    if i == num_f:\\n        csum += r if csl else l\\n        minv = min(minv, csum)\\n    else:\\n        f(i + 1, csum + m + 2, not csl)\\n        f(i + 1, csum + (r if csl else l) * 2 + 1, csl)\\n        # print(num_f)\\n\\nn, m = list(map(int, fin.readline().split()))\\narr = [list(int(sym) for sym in fin.readline().strip()) for i in range(n)]\\ncsl = True\\ncnt = 0\\n# print(arr)\\nborder = 0\\nfor i in range(n):\\n    if 1 in arr[i]:\\n        break\\n    else:\\n        border += 1\\nl_a, r_a = [], []\\nnum_f = -1\\nminv = float('inf')\\nfor i in range(n - 1, border - 1, -1):\\n    if 1 in arr[i]:\\n        l = arr[i].index(1)\\n        r = list(reversed(arr[i])).index(1)\\n        l = (m + 2 - l - 1)\\n        r = (m + 2 - r - 1)\\n    else:\\n        l = r = 0\\n    # print(l, r, m + 2 - l - 1, csl)\\n    l_a.append(l)\\n    r_a.append(r)\\n    num_f += 1\\n    continue\\nif num_f > -1:\\n    f(0, 0)\\n    print(minv)\\nelse:\\n    print(0)\\n\", \"INF = float('inf')\\n\\ndef solve(grid, n, m):\\n    # print('\\\\n'.join(map(str, grid)))\\n\\n    dp = [[INF for _ in range(2)] for _ in range(n)]\\n\\n    dp[0][0] = -1\\n    dp[0][1] = INF\\n\\n    for i in range(1, n):\\n        occur = [j for j in range(m+2) if grid[i-1][j] == '1']\\n\\n        if not occur:\\n            dp[i][0] = min(dp[i][0], dp[i-1][0] + 1)\\n            dp[i][0] = min(dp[i][0], dp[i-1][1] + (m + 2))\\n\\n            dp[i][1] = min(dp[i][1], dp[i-1][0] + (m + 2))\\n            dp[i][1] = min(dp[i][1], dp[i-1][1] + 1)\\n            continue\\n\\n        dp[i][0] = min(dp[i][0], dp[i-1][0] + (2 * max(occur)) + 1)\\n        dp[i][0] = min(dp[i][0], dp[i-1][1] + (m + 2))\\n\\n        dp[i][1] = min(dp[i][1], dp[i-1][0] + (m + 2))\\n        dp[i][1] = min(dp[i][1], dp[i-1][1] + (2 * (m + 2 - min(occur) - 1) + 1))\\n\\n    # print('\\\\n'.join(map(str, dp)))\\n\\n    occur = [j for j in range(m+2) if grid[n-1][j] == '1']\\n\\n    return min(dp[n-1][0] + max(occur) + 1, dp[n-1][1] + (m + 2 - min(occur)))\\n\\n\\ndef __starting_point():\\n    n, m = list(map(int, input().split()))\\n\\n    grid = [input() for _ in range(n)]\\n    grid.reverse()\\n\\n    n_real = -1\\n    for i in range(n-1, -1, -1):\\n        if '1' in grid[i]:\\n            n_real = i\\n            break\\n\\n    if n_real == -1:\\n        print(0)\\n    else:\\n        print(solve(grid[:n_real+1], n_real+1, m))\\n\\n__starting_point()\", \"n,m = list(map(int, input().split()))\\ninf = 10 ** 10\\ndp = [[inf, inf] for i in range(n)]\\na = []\\nlast = -1\\nfor i in range(n):\\n    tmp = input()\\n    tmp1 = []\\n    for j in range(len(tmp)):\\n        if tmp[j] == \\\"1\\\":\\n            tmp1.append(1)\\n            if last == -1:\\n                last = n - i - 1\\n        else:\\n            tmp1.append(0)\\n    a.append(tmp1)\\na = a[::-1]\\nleft = [-1] * n\\nright = [-1] * n\\nfor i in range(n):\\n    for j in range(m + 2):\\n        if a[i][j] and left[i] == -1:\\n            left[i] = j\\n        if a[i][j]:\\n            right[i] = j\\nif last == -1:\\n    print(0)\\n    return\\nif last == 0:\\n    print(right[0])\\n    return\\n            \\ndp[0][0] = max(0, right[0] * 2)\\ndp[0][1] = m + 1\\nfor i in range(1,last):\\n    if right[i] != - 1:\\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1 + 2 * right[i])\\n    else:\\n        dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1)\\n    dp[i][0] = min(dp[i][0], dp[i - 1][1] + m + 2)\\n    if left[i] != - 1:\\n        dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1 + (m + 1 - left[i]) * 2)\\n    else:\\n        dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1)\\n    dp[i][1] = min(dp[i][1], dp[i - 1][0] + m + 2)\\n    \\nlf,rf = inf,inf\\nif right[last] != -1:\\n    lf = dp[last - 1][0] + 1 + right[last]\\nelse:\\n    lf = dp[last - 1][0]  + 1\\nlf = min(lf, dp[last - 1][1] + m + 2)\\n\\nif left[last] != -1:\\n    rf = dp[last - 1][1] + 1 + (m + 1 - left[last])\\nelse:\\n    rf = dp[last - 1][1] + 1\\nrf = min(rf, dp[last - 1][0] + m + 2)\\nprint(min(lf,rf))\\n\\n\\n    \\n\", \"import sys\\n\\ninf = float('inf')\\nans = inf\\n\\ndef solve():\\n    n, m = map(int, input().split())\\n    s = [None] * n\\n    for i in range(n - 1, -1, -1):\\n        s[i] = [int(j) for j in input()]\\n\\n    e = [any(si) for si in s]\\n    es = e[:] + [False]\\n\\n    for i in range(n - 1, -1, -1):\\n        es[i] |= es[i + 1]\\n\\n    # print(es)\\n\\n    if not es[0]:\\n        print(0)\\n    elif es[0] and (not es[1]):\\n        k = -1\\n\\n        for j in range(m, 0, -1):\\n            if s[0][j]:\\n                k = j\\n                break\\n\\n        print(k)\\n    else:\\n        lim = 0\\n\\n        for i in range(n + 1):\\n            if not es[i]:\\n                lim = i - 1\\n                break\\n\\n        if not e[0]:\\n            left = 0\\n            right = m + 1\\n        else:\\n            for j in range(m, 0, -1):\\n                if s[0][j]:\\n                    kr = j\\n                    break\\n\\n            left = 2*kr\\n            right = m + 1\\n\\n        # print(left, right)\\n\\n        for i in range(1, lim):\\n            if not e[i]:\\n                left, right = min(left + 1, right + m + 2), min(right + 1, left + m + 2)\\n            else:\\n                kr = kl = -1\\n\\n                for j in range(m, 0, -1):\\n                    if s[i][j]:\\n                        kr = j\\n                        break\\n\\n                for j in range(1, m + 1):\\n                    if s[i][j]:\\n                        kl = j\\n                        break\\n\\n                left, right = min(left + 1 + 2*kr, right + m + 2), min(right + 1 + 2*(m + 1 - kl), left + m + 2)\\n\\n            # print(left, right)\\n\\n        kr = kl = -1\\n\\n        for j in range(m, 0, -1):\\n            if s[lim][j]:\\n                kr = j\\n                break\\n\\n        for j in range(1, m + 1):\\n            if s[lim][j]:\\n                kl = j\\n                break\\n\\n        ans = min(left + 1 + kr, right + 1 + m + 1 - kl)\\n\\n        print(ans)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\n\\ninf = float('inf')\\nans = inf\\n\\ndef solve():\\n    n, m = map(int, input().split())\\n    s = [None] * n\\n    for i in range(n - 1, -1, -1):\\n        s[i] = [int(j) for j in input()]\\n\\n    e = [any(si) for si in s]\\n    es = e[:] + [False]\\n\\n    for i in range(n - 1, -1, -1):\\n        es[i] |= es[i + 1]\\n\\n    # print(es)\\n\\n    if not es[0]:\\n        print(0)\\n    elif es[0] and (not es[1]):\\n        k = m + 1 - s[0][::-1].index(1)\\n        print(k)\\n    else:\\n        lim = 0\\n\\n        for i in range(n + 1):\\n            if not es[i]:\\n                lim = i - 1\\n                break\\n\\n        if not e[0]:\\n            left = 0\\n            right = m + 1\\n        else:\\n            kr = m + 1 - s[0][::-1].index(1)\\n            left = 2*kr\\n            right = m + 1\\n\\n        # print(left, right)\\n\\n        for i in range(1, lim):\\n            if not e[i]:\\n                left, right = min(left + 1, right + m + 2), min(right + 1, left + m + 2)\\n            else:\\n                kr = m + 1 - s[i][::-1].index(1)\\n                kl = s[i].index(1)\\n                left, right = min(left + 1 + 2*kr, right + m + 2), min(right + 1 + 2*(m + 1 - kl), left + m + 2)\\n\\n            # print(left, right)\\n\\n        kr = m + 1 - s[lim][::-1].index(1)\\n        kl = s[lim].index(1)\\n\\n        ans = min(left + 1 + kr, right + 1 + m + 1 - kl)\\n\\n        print(ans)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\nfrom itertools import accumulate\\nfrom operator import or_\\n\\ninf = float('inf')\\n\\ndef solve():\\n    n, m = map(int, input().split())\\n    s = [[int(j) for j in input()] for i in range(n)][::-1]\\n\\n    e = [any(si) for si in s]\\n    es = e[:] + [False]\\n    es = list(accumulate(es[::-1], or_))[::-1]\\n\\n    if not es[0]:\\n        print(0)\\n    else:\\n        lim = 0\\n\\n        for i in range(n + 1):\\n            if not es[i]:\\n                lim = i - 1\\n                break\\n\\n        left, right = -1, inf\\n\\n        for i in range(lim):\\n            if not e[i]:\\n                left, right = min(left + 1, right + m + 2), min(right + 1, left + m + 2)\\n            else:\\n                kr = rindex(s[i], 1)\\n                kl = s[i].index(1)\\n                left, right = min(left + 1 + 2*kr, right + m + 2), min(right + 1 + 2*(m + 1 - kl), left + m + 2)\\n\\n        kr = rindex(s[lim], 1)\\n        kl = s[lim].index(1)\\n\\n        ans = min(left + 1 + kr, right + m + 2 - kl)\\n\\n        print(ans)\\n\\ndef rindex(arr, x):\\n    return len(arr) - 1 - arr[::-1].index(x)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"from collections import Counter\\nimport sys\\n\\ndef left_time(floor):\\n    light_counter = Counter(floor)\\n    # print(light_counter)\\n    # print(light_counter['1'])\\n    if light_counter['1'] == 0:\\n        return 0\\n    else:\\n        last_light_search = 1\\n        while last_light_search <= len(floor):\\n            # print(last_light_search)\\n            if floor[-last_light_search] == '1':\\n                return((len(floor) - last_light_search) * 2)\\n                break\\n            else:\\n                last_light_search += 1\\n        \\n\\ndef right_time(floor):\\n    light_counter = Counter(floor)\\n    if light_counter['1'] == 0:\\n        return 0\\n    else:\\n        last_light_search = 0\\n        while True:\\n            if floor[last_light_search] == '1':\\n                return ((len(floor) - last_light_search - 1) * 2)\\n                break\\n            else:\\n                last_light_search += 1\\n\\nfloors_nr, rooms_nr = (int(x) for x in input().split())\\nbuilding_scheme = []\\nworth_counting_flag = False\\nfor i in range(floors_nr):\\n    floor_i = input()\\n    c = Counter(floor_i)\\n    if not worth_counting_flag and c['1'] > 0:\\n        worth_counting_flag = True\\n    if worth_counting_flag:\\n        building_scheme.append(floor_i)\\n\\nif len(building_scheme) == 0:\\n    print(0)\\n    return\\n    \\noptimal_time = [(-1, 10000)]\\n\\nlast_floor = building_scheme[0]\\nbuilding_scheme = building_scheme[1:]\\nfor floor in building_scheme[::-1]:\\n    prefix_left, prefix_right = optimal_time[-1]\\n    \\n    keep_right_left = rooms_nr + 1 + prefix_left + 1\\n    keep_right_right = right_time(floor) + prefix_right + 1\\n    keep_right = min(keep_right_left, keep_right_right)\\n    \\n    keep_left_left = left_time(floor) + prefix_left + 1\\n    keep_left_right = rooms_nr + 1 + prefix_right + 1\\n    keep_left = min(keep_left_left, keep_left_right)\\n    \\n    optimal_time.append((keep_left, keep_right))\\n\\n# print(optimal_time)\\n\\nlast_floor_time = min(optimal_time[-1][0] + 1 + left_time(last_floor) // 2, optimal_time[-1][1] + 1 + right_time(last_floor) // 2)\\nprint(last_floor_time)\\n    \\n    \\n\\n\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"2 2\\n0010\\n0100\\n\",\n    \"3 4\\n001000\\n000010\\n000010\\n\",\n    \"4 3\\n01110\\n01110\\n01110\\n01110\\n\",\n    \"3 2\\n0000\\n0100\\n0100\\n\",\n    \"1 89\\n0000000000000000000000000000000100000000000000010000000000010000000000000000000000000000000\\n\",\n    \"2 73\\n000000000000000000000000000000000000000000000000000000000000000000000000000\\n000000000000000000000000000000000000000100000010000000000000000000000000000\\n\",\n    \"3 61\\n000000000000000000000000000000000000000000000000000000000000000\\n000000000000000000000000000000000000000000000000000000000000000\\n000000000000000000000000000000000000000000000000000000000000000\\n\",\n    \"4 53\\n0000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000\\n\",\n    \"5 93\\n00000000000000000000000000000000000000000000000000000000100000000000000000000000000000000001010\\n00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n00000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n00000000000000000000000000000010000000000000000000100000000000000000000000000000000000000000000\\n00000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000\\n\",\n    \"6 77\\n0000000000000000100000000000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000010000000000000\\n0000000000010000000000000000000000000000000000000000000000000000000000000000010\\n0000000000000000000001000000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000100000000000000000000000000000\\n\",\n    \"7 65\\n0000000001000000000000000010000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000000\\n0000000001000001000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000000\\n0000000000000000000000000000000000000000000000000000000000000000000\\n\",\n    \"8 57\\n00000000100000000000000000000000000000000000000000000000000\\n00000000000000010000000000000000000000000000000000000000000\\n00000000000000000000000000000000000100000000000000000000000\\n00000000000000000000000000000000000000000000000000000000000\\n00000000000000000000000000000000000100000000000000000000000\\n00000000000000000000000000000000000000000000000000000000000\\n00000000000010000000000000000000000000000000000000000000000\\n00000000000000000000000000000000000000000000000001000000000\\n\",\n    \"12 13\\n000000000000000\\n000000000000000\\n000000000000000\\n000000000000000\\n000000000000000\\n000000000000000\\n010000000000000\\n000000000000000\\n000000000000000\\n000000000000000\\n000010000000000\\n000000000000000\\n\",\n    \"13 1\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n000\\n\",\n    \"1 33\\n00000100101110001101000000110100010\\n\",\n    \"2 21\\n00100110100010010010010\\n01000001111001010000000\\n\",\n    \"3 5\\n0001010\\n0100000\\n0100000\\n\",\n    \"4 45\\n00010000101101100000101101000000100000001101100\\n01110000100111010011000000100000000001000001100\\n00000000001000100110100001000010011010001010010\\n01111110100100000101101010011000100100001000000\\n\",\n    \"5 37\\n010100000000000000000110000110010000010\\n001101100010110011101000001010101101110\\n010000001000100010010100000000001010000\\n000000000100101000000101100001000001110\\n000010000000000000100001001000011100110\\n\",\n    \"6 25\\n011001000100111010000101000\\n000000000010000010001000010\\n011001100001100001001001010\\n000000100000010000000000110\\n010001100001000001000000010\\n011000001001010111110000100\\n\",\n    \"7 61\\n010000111100010100001000011010100001000000000011100000100010000\\n000010011000001000000100110101010001000000010001100000100100100\\n000010001000001000000100001000000100100011001110000111000000100\\n000000000101000011010000011000000101000001011001000011101010010\\n000010010011000000100000110000001000000101000000101000010000010\\n000010010101101100100100100011001011101010000101000010000101010\\n000100001100001001000000001000000001011000110010100000000010110\\n\",\n    \"8 49\\n000100100000000111110010011100110100010010000011000\\n001000000101111000000001111100010010100000010000000\\n000000010000011100001000000000101000110010000100100\\n000000000001000110000011101101000000100000101010000\\n000000110001000101101000000001000000110001000110000\\n000100000000000000100100010011000001111101010100110\\n000000001000000010101111000100001100000000010111000\\n001000010000110000011100000000100110000010001000000\\n\",\n    \"9 41\\n0011000000000101001101001000000001110000010\\n0000110000001010110010110010110010010001000\\n0001100010100000000001110100100001101000100\\n0001010101111010000000010010001001011111000\\n0101000101000011101011000000001100110010000\\n0001010000000000000001011000000100010101000\\n0000010011000000001000110001000010110001000\\n0000100010000110100001000000100010001111100\\n0000001110100001000001000110001110000100000\\n\",\n    \"10 29\\n0000000000101001100001001011000\\n0001110100000000000000100010000\\n0010001001000011000100010001000\\n0001000010101000000010100010100\\n0111000000000000100100100010100\\n0001000100011111000100010100000\\n0000000000000001000001001011000\\n0000101110000001010001011001110\\n0000001000101010011000001100100\\n0100010000101011010000000000000\\n\",\n    \"1 57\\n00011101100001110001111000000100101111000111101100111001000\\n\",\n    \"2 32\\n0011110111011011011101111101011110\\n0111000110111111011110011101011110\\n\",\n    \"3 20\\n0110011111110101101100\\n0111110000111010100100\\n0110111110010100011110\\n\",\n    \"4 4\\n011100\\n001010\\n010000\\n011110\\n\",\n    \"5 44\\n0001010010001111111001111111000010100100000010\\n0001111001111001101111011111010110001001111110\\n0111111010111111011101100011101010100101110110\\n0011010011101011101111001001010110000111111100\\n0110100111011100110101110010010011011101100100\\n\",\n    \"6 36\\n01110101111111110101011000011111110010\\n00011101100010110111111111110001100100\\n00001111110010111111101110101110111110\\n00110110011100100111011110000000000010\\n01100101101001010001011111100111101100\\n00011111111011001000011001011110011110\\n\",\n    \"7 24\\n01111001111001011010010100\\n00111011010101000111101000\\n01001110110010010110011110\\n00000101111011011111111000\\n01111111101111001001010010\\n01110000111101011111111010\\n00000100011100110000110000\\n\",\n    \"8 8\\n0011101110\\n0110010100\\n0100111110\\n0111111100\\n0011010100\\n0001101110\\n0111100000\\n0110111000\\n\",\n    \"9 48\\n00011010111110111011111001111111111101001111110010\\n01000101000101101101111110111101011100001011010010\\n00110111110110101110101110111111011011101111011000\\n00110111111100010110110110111001001111011010101110\\n01111111100101010011111100100111110011001101110100\\n01111011110011111101010101010100001110111111111000\\n01110101101101110001000010110100010110101111111100\\n00111101001010110010110100000111110101010100001000\\n00011011010110011111001100111100100011100110110100\\n\",\n    \"10 40\\n010011001001111011011011101111010001010010\\n011000000110000010001011111010100000110000\\n011010101001110010110110011111010101101000\\n000111111010101111000110011111011011011010\\n010110101110001001001111111000110011101010\\n010011010100111110010100100111100111011110\\n001111101100111111111111001010111010000110\\n001111110010101100110100101110001011100110\\n010111010010001111110101111111111110111000\\n011101101111000100111111111001111100111010\\n\",\n    \"11 28\\n011100111101101001011111001110\\n010001111110011101101011001000\\n001010011011011010101101101100\\n001100011001101011011001110100\\n010111110011101110000110111100\\n010010001111110000011111010100\\n001011111111110011101101111010\\n001101101011100100011011001110\\n001111110110100110101011000010\\n000101101011100001101101100100\\n010011101101111011100111110100\\n\",\n    \"1 68\\n0101111110111111111111111111110111111111111111111110111111101111111110\\n\",\n    \"2 56\\n0011111111111110111111111111111111011111111111011111011110\\n0111111111010111111111110111111111111110111111010111111110\\n\",\n    \"3 17\\n0111111101111111110\\n0111111111101011110\\n0101111111111111110\\n\",\n    \"4 4\\n011110\\n010110\\n010110\\n011110\\n\",\n    \"5 89\\n0011111111111101110110111111111101111011111011101110111111111111111111111111111111111111110\\n0111111111111111111111111101111111111111111111111111111111111111111111111111111111111111110\\n0111111111111011111111111111111111101111011111111111111111110110111101111111111111111011010\\n0111111111111111011011111111111011111111111111111111111111111111111111111111111110111111010\\n0111111101111011111110101011111111110111100100101111111011111111111111011011101111111111110\\n\",\n    \"6 77\\n0111111110101011111111111111111111111111111111111111100111111111101111111111110\\n0111111111111111111101111101111111111011111111011111111001011111111111101111110\\n0111101111111111111111111111111111111110110011111111111011111111101111111111110\\n0111110111111111111111111111111111111111111111111111011011111111111111111111110\\n0101111110111111111111111111111111111111111011111111111111111111101111011011110\\n0110111111101111110111111111111011111111101011111101111111111111111111110111100\\n\",\n    \"7 20\\n0111111111111111111100\\n0111110111111111111110\\n0111111111111111111100\\n0111111011111111111110\\n0111111111111011101110\\n0111101011110111111010\\n0111111111111111111010\\n\",\n    \"8 8\\n0111111110\\n0111101110\\n0111111110\\n0111111110\\n0111111110\\n0110111100\\n0101111110\\n0110111110\\n\",\n    \"11 24\\n01111111111101111111111110\\n01111111111111111111111110\\n01110111111111111111111110\\n01111111111111111111011110\\n01111111111111111110111110\\n01111010111111100111101110\\n01111111111111010101111100\\n01111111111111110111111110\\n01011101111111111101111110\\n00111111011111111110111110\\n01111111101111111101111110\\n\",\n    \"12 12\\n01111111111000\\n01101111110110\\n01111110111110\\n01111111111110\\n01111111111010\\n01011111110110\\n01111111111110\\n01101101011110\\n01111111111110\\n01111101011110\\n00111111111110\\n01111111011110\\n\",\n    \"15 28\\n011111111101011111111101111110\\n011111111111111111111111111110\\n011101110111011011101111011110\\n011111111011111011110111111110\\n011111111110101111111111111110\\n011111011111110011111111011010\\n011110111111001101111111111110\\n011111111110111111111011111110\\n011111111111111111111111011110\\n011111011111111111111011001010\\n011111111101111111111101111110\\n011111111110111111101111011110\\n010111111111101111111111111110\\n011111111111111111011111111110\\n011011111111111110110111110110\\n\",\n    \"2 11\\n0100000000000\\n0000000010000\\n\",\n    \"1 100\\n010010010011100001101101110111101010000101010001111001001101011110000011101110101000100111111001101110\\n\",\n    \"15 1\\n010\\n010\\n010\\n010\\n010\\n010\\n000\\n000\\n000\\n010\\n000\\n010\\n000\\n000\\n000\\n\",\n    \"3 3\\n00010\\n00000\\n00010\\n\"\n  ],\n  \"outputs\": [\n    \"5\\n\",\n    \"12\\n\",\n    \"18\\n\",\n    \"4\\n\",\n    \"59\\n\",\n    \"46\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"265\\n\",\n    \"311\\n\",\n    \"62\\n\",\n    \"277\\n\",\n    \"14\\n\",\n    \"0\\n\",\n    \"33\\n\",\n    \"43\\n\",\n    \"11\\n\",\n    \"184\\n\",\n    \"193\\n\",\n    \"160\\n\",\n    \"436\\n\",\n    \"404\\n\",\n    \"385\\n\",\n    \"299\\n\",\n    \"55\\n\",\n    \"65\\n\",\n    \"63\\n\",\n    \"22\\n\",\n    \"228\\n\",\n    \"226\\n\",\n    \"179\\n\",\n    \"77\\n\",\n    \"448\\n\",\n    \"418\\n\",\n    \"328\\n\",\n    \"68\\n\",\n    \"113\\n\",\n    \"55\\n\",\n    \"22\\n\",\n    \"453\\n\",\n    \"472\\n\",\n    \"151\\n\",\n    \"78\\n\",\n    \"284\\n\",\n    \"166\\n\",\n    \"448\\n\",\n    \"18\\n\",\n    \"100\\n\",\n    \"29\\n\",\n    \"7\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/812/B",
  "starter_code": ""
}