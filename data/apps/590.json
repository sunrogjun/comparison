{
  "task_id": "APPS/590",
  "problem_id": 590,
  "prompt": "Ivan has an array consisting of n elements. Each of the elements is an integer from 1 to n.\n\nRecently Ivan learned about permutations and their lexicographical order. Now he wants to change (replace) minimum number of elements in his array in such a way that his array becomes a permutation (i.e. each of the integers from 1 to n was encountered in his array exactly once). If there are multiple ways to do it he wants to find the lexicographically minimal permutation among them.\n\nThus minimizing the number of changes has the first priority, lexicographical minimizing has the second priority.\n\nIn order to determine which of the two permutations is lexicographically smaller, we compare their first elements. If they are equal \u2014 compare the second, and so on. If we have two permutations x and y, then x is lexicographically smaller if x_{i} < y_{i}, where i is the first index in which the permutations x and y differ.\n\nDetermine the array Ivan will obtain after performing all the changes.\n\n\n-----Input-----\n\nThe first line contains an single integer n (2 \u2264 n \u2264 200 000) \u2014 the number of elements in Ivan's array.\n\nThe second line contains a sequence of integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 n) \u2014 the description of Ivan's array.\n\n\n-----Output-----\n\nIn the first line print q \u2014 the minimum number of elements that need to be changed in Ivan's array in order to make his array a permutation. In the second line, print the lexicographically minimal permutation which can be obtained from array with q changes.\n\n\n-----Examples-----\nInput\n4\n3 2 2 3\n\nOutput\n2\n1 2 4 3 \n\nInput\n6\n4 5 6 3 2 1\n\nOutput\n0\n4 5 6 3 2 1 \n\nInput\n10\n6 8 4 6 7 1 6 3 4 5\n\nOutput\n3\n2 8 4 6 7 1 9 3 10 5 \n\n\n\n-----Note-----\n\nIn the first example Ivan needs to replace number three in position 1 with number one, and number two in position 3 with number four. Then he will get a permutation [1, 2, 4, 3] with only two changed numbers \u2014 this permutation is lexicographically minimal among all suitable. \n\nIn the second example Ivan does not need to change anything because his array already is a permutation.",
  "solutions": "[\"n = int(input())\\na = list(map(int, input().split()))\\n\\nnums = [False for i in range(200010)]\\nmust = [False for i in range(200010)]\\ncounter = dict()\\nnow_num = 0\\n\\n\\ndef inc():\\n    nonlocal now_num\\n    now_num += 1\\n    while nums[now_num - 1]:\\n        now_num += 1\\n\\n\\nfor el in a:\\n    if nums[el - 1]:\\n        counter[el] += 1\\n    else:\\n        counter[el] = 1\\n    nums[el - 1] = True\\n\\ninc()\\n\\nans = []\\nc = 0\\n\\nfor el in a:\\n    if counter[el] > 1:\\n        counter[el] -= 1\\n        if now_num < el:\\n            ans.append(now_num)\\n            c += 1\\n            inc()\\n        else:\\n            if must[el - 1] == False:\\n                ans.append(el)\\n                must[el - 1] = True\\n            else:\\n                ans.append(now_num)\\n                c += 1\\n                inc()\\n    else:\\n        if must[el - 1] == False:\\n            ans.append(el)\\n        else:\\n            ans.append(now_num)\\n            c += 1\\n            inc()\\n\\nprint(c)\\nprint(' '.join(str(el) for el in ans))\\n\", \"def list_input():\\n    return list(map(int,input().split()))\\ndef map_input():\\n    return map(int,input().split())\\ndef map_string():\\n    return input().split()\\n\\nfrom collections import Counter\\nn = int(input())    \\na = list_input()\\nc = Counter(a)\\nans = 0\\ns = set(a)\\ns1 = []\\nfor i in range(1,n+1):\\n\\tif i not in s:\\n\\t\\ts1.append(i)\\t\\t\\ncur = 0\\t\\t\\nleft = set([])\\nfor i in range(n):\\n\\tif(c[a[i]] > 1):\\n\\t\\tif s1[cur] < a[i] or a[i] in left:\\n\\t\\t\\tc[a[i]] -= 1\\n\\t\\t\\ta[i] = s1[cur]\\n\\t\\t\\tcur += 1\\n\\t\\t\\tans += 1\\n\\t\\telse: left.add(a[i])\\nprint(ans)\\t\\t\\t\\nfor i in a: print(i,end=' ')\\n\\n\", \"from sys import stdin, stdout\\n\\nn = int(stdin.readline().rstrip())\\na = list(map(int,stdin.readline().rstrip().split()))\\n\\naSet = set(a)\\naMinus = set(range(1,n+1)) - aSet\\nminusList = sorted(list(aMinus),reverse=True)\\nused=set()\\n\\ncountDict = {x : 0 for x in aSet}\\nfor x in a:\\n    countDict[x] +=1\\n\\nfinalList = a\\nfor i in range(n):\\n    x = a[i]\\n    if x in used:\\n        finalList[i] = minusList.pop()\\n    elif countDict[x]==1:\\n        continue\\n    elif x<minusList[-1]:\\n        used.add(x)\\n    else:\\n        countDict[x]-=1\\n        finalList[i] = minusList.pop()\\n\\nprint(len(aMinus))\\nprint(' '.join(map(str,finalList)))\\n\", \"def solve(printing):\\n\\n    n = int(input())\\n    nums = [int(st)-1 for st in input().split(\\\" \\\")]\\n    numdupe = [0] * n\\n    dupeindex = []\\n    dupeindexindv = {}\\n    missing = []\\n\\n    if printing:\\n        print(\\\"nums\\\"); print(nums)\\n\\n    for i in range(n):\\n        numdupe[nums[i]] += 1\\n\\n    for i in range(n):\\n        if numdupe[i] == 0:\\n            missing.append(i)\\n            \\n        if numdupe[nums[i]] >= 2:\\n            dupeindex.append(i)\\n            if nums[i] in dupeindexindv:\\n                dupeindexindv[nums[i]][1].append(i)\\n            else:\\n                dupeindexindv[nums[i]] = [0, [i], False]\\n                # left location, dupe indexs, if already located original\\n\\n    for num in dupeindexindv:\\n        dupeindexindv[num][0] = len(dupeindexindv[num][1])\\n\\n    if printing:\\n        print(\\\"missing\\\"); print(missing)\\n        print(\\\"dupeindexindv\\\"); print(dupeindexindv)\\n\\n    misslen = len(missing)\\n    misindex = 0\\n    #answer = 0\\n    for index in dupeindex:\\n\\n        if misslen <= misindex:\\n            break\\n\\n        elif dupeindexindv[nums[index]][0] == 1 and not dupeindexindv[nums[index]][2]:\\n            # one spot left but original not located yet.\\n            # locate original.\\n            dupeindexindv[nums[index]][0] -= 1\\n            dupeindexindv[nums[index]][2] = True\\n        \\n        elif dupeindexindv[nums[index]][0] > 0:\\n            \\n            if dupeindexindv[nums[index]][2] or missing[misindex] < nums[index]:\\n                # num is smaller or original is already located.\\n                # locate missing number.\\n                dupeindexindv[nums[index]][0] -= 1\\n                nums[index] = missing[misindex]\\n                misindex += 1\\n                #answer += 1\\n\\n            else: # locate original\\n                dupeindexindv[nums[index]][0] -= 1\\n                dupeindexindv[nums[index]][2] = True\\n\\n    print(misslen)\\n    for num in nums:\\n        print(num+1, end = \\\" \\\")\\n\\nsolve(False)\\n\", \"n = int(input())\\nair = [int(x) for x in  input().split()]\\na = [0]*(n+1)\\na[0] = 1\\nfor x in range(n):\\n\\ta[air[x]] += 1\\nst = [0]\\nfor x in range(n,-1,-1):\\n\\tif a[x] == 0:\\n\\t\\tst.append(x)\\ncnt = 0\\nlevel = dict()\\nfor x in range(n):\\n\\t#print a\\n\\tif a[air[x]] > 1:\\n\\t\\tif air[x] > st[-1]:\\n\\t\\t\\ta[air[x]] -= 1\\n\\t\\t\\tair[x] = st[-1]\\n\\t\\t\\tst.pop()\\n\\t\\t\\tcnt += 1\\n \\n\\t\\telse:\\n\\t\\t\\tif level.get(air[x],0) == 0:\\n\\t\\t\\t\\tlevel[air[x]] = 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ta[air[x]] -= 1\\n\\t\\t\\t\\tair[x] = st[-1]\\n\\t\\t\\t\\tst.pop()\\n\\t\\t\\t\\tcnt += 1\\n \\n \\n \\nprint (cnt)\\nfor x in air:\\n\\tprint(x, end=' ')\", \"n=int(input())\\nl=list(map(int,input().split()))\\nlis,ind=set(),{}\\nfor i in l:\\n    if i in ind:\\n        ind[i]+=1\\n    else:\\n        ind[i]=1\\n        lis.add(i)\\nmlis=sorted(set(range(1,n+1))-lis,key=int)\\nk=0\\nfor i,j in enumerate(l):\\n    if ind[j]!=1:\\n        if ind[j]==0 or mlis[k]<j:\\n            l[i]=mlis[k]\\n            k+=1\\n            if k==len(mlis):\\n                break\\n        else:\\n            ind[j]=0\\n        if ind[j]>1:\\n            ind[j]-=1\\n\\nprint(len(mlis),\\\" \\\".join(map(str,l)),sep='\\\\n')\\n\", \"n=int(input())\\narr=list(map(int,input().strip().split(' ')))\\na=[0 for i in range(200001)]\\nb=[0 for i in range(200001)]\\nfor i in arr:\\n    a[i]+=1\\nj=1\\nt=0\\nfor i in range(1,n+1):\\n    if(a[i]>0):\\n        t+=1\\nfor i in range(n):\\n    if(a[arr[i]]>1):\\n        while(a[j]!=0):\\n            j+=1\\n        if(arr[i]>j or b[arr[i]]==1 ):\\n            a[arr[i]]-=1\\n            arr[i]=j\\n            a[j]=1\\n        else:\\n            b[arr[i]]=1\\nprint(n-t)\\nfor i in arr:\\n    print(i,end=' ')\\nprint()\\n\\n\\n\", \"from collections import deque\\ndef main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    d = {}\\n    for i, x in enumerate(a):\\n        d.setdefault(x, []).append(i)\\n    s = []\\n    c = {}\\n    for k, v in list(d.items()):\\n        s.extend(v)\\n        c[k] = len(v)\\n    s.sort()\\n    killed = set()\\n    ava = deque(sorted(frozenset(list(range(1, n + 1))) - frozenset(a)))\\n    ans = 0\\n    for i in s:\\n        v = a[i]\\n        if (c[v] == 1 or ava[0] > v) and not v in killed:\\n            killed.add(v)\\n        else:\\n            a[i] = ava.popleft()\\n            ans += 1\\n        c[v] -= 1\\n    print(ans)\\n    print(' '.join(map(str, a)))\\nmain()\\n\\n\", \"import sys\\nn = int(input())\\na = input().split()\\narr = [int(_) for _ in a]\\ncnt = [0 for _ in range(n+1)]\\nmust = [False for _ in range(n+1)]\\nfor x in arr:\\n\\tcnt[x] += 1\\n\\nque = []\\nfor i in range(1,n+1):\\n\\tif cnt[i] == 0:\\n\\t\\tque.append(i)\\n\\t\\t\\ncur = 0\\nfor i in range(n):\\n\\tx = arr[i]\\n\\tif cnt[x] > 1 :\\n\\t\\tif must[x] or que[cur] < x:\\n\\t\\t\\tcnt[x] -= 1\\n\\t\\t\\tarr[i] = que[cur]\\n\\t\\t\\tcur += 1\\n\\t\\telse:\\n\\t\\t\\tmust[x] = True\\n\\n\\nprint(cur)\\nfor x in arr:\\n\\tprint(x,end=' ')\\n\", \"n = int(input()) + 1\\nt = [0] + list(map(int, input().split()))\\n\\ns = [0] * n\\nfor j in t: s[j] += 1\\n\\np = [0] * n\\nk = 1\\n\\nfor i, j in enumerate(t):\\n    if s[j] > 1:\\n        while s[k]: k += 1\\n        if j > k or p[j]:\\n            t[i] = k\\n            s[j] -= 1\\n            k += 1\\n        else:\\n            p[j] = 1\\n\\nprint(s.count(0))\\nprint(' '.join(map(str, t[1:])))\", \"from collections import defaultdict\\n\\nn = int(input())\\nl = list(map(int, input().split()))\\n\\ncount = defaultdict(int)\\nfor x in l:\\n    count[x] += 1\\n\\nneed = []\\n\\nfor x in range(1,n+1):\\n    if count[x] == 0:\\n        need.append(x)\\n\\npos_need = 0\\nopen = [False for _ in range(n+1)]\\nactions = 0\\n\\nfor i in range(n):\\n    if pos_need == len(need):\\n        break\\n    if count[l[i]] >= 2:\\n        if l[i] < need[pos_need]:\\n            if open[l[i]]: \\n                count[l[i]] -= 1\\n                l[i] = need[pos_need]\\n                actions += 1\\n                pos_need += 1\\n            else:\\n                open[l[i]] = True\\n        else:\\n            count[l[i]] -= 1\\n            l[i] = need[pos_need]\\n            actions += 1\\n            pos_need += 1\\n\\nprint(actions)\\nprint(*l)\\n\", \"n = int(input())\\nb = [0] * n\\nc = [0] * n\\narray = []\\nfor i in input().split():\\n    array.append(int(i))\\n    b[int(i)-1] += 1\\n    c[int(i)-1] = True\\nfree = []\\ncount = 0\\nfor i in range(n):\\n    if b[i] == 0:\\n        free.append(i+1)\\n    else:\\n        count += b[i] - 1\\nprint(count)\\nz = 0\\nfor i in range(n):\\n    if b[array[i]-1] > 1:\\n        if array[i] > free[z]:\\n            b[array[i]-1] -= 1 \\n            array[i] = free[z]\\n            z += 1\\n        elif c[array[i]-1] == False:\\n            b[array[i]-1] -= 1\\n            array[i] = free[z]\\n            z += 1\\n        else:\\n            c[array[i]-1] = False\\nfor i in range(n):\\n    print(array[i], end = ' ')\", \"n = int(input())\\nb = [0] * n\\nc = [0] * n\\narray = []\\nfor i in input().split():\\n    array.append(int(i))\\n    b[int(i)-1] += 1\\n    c[int(i)-1] = True\\nfree = []\\ncount = 0\\nfor i in range(n):\\n    if b[i] == 0:\\n        free.append(i+1)\\n    else:\\n        count += b[i] - 1\\nprint(count)\\nz = 0\\nfor i in range(n):\\n    if b[array[i]-1] > 1:\\n        if array[i] > free[z]:\\n            b[array[i]-1] -= 1 \\n            array[i] = free[z]\\n            z += 1\\n        elif c[array[i]-1] == False:\\n            b[array[i]-1] -= 1\\n            array[i] = free[z]\\n            z += 1\\n        else:\\n            c[array[i]-1] = False\\nfor i in range(n):\\n    print(array[i], end = ' ')\", \"n, ans, j = int(input()), 0, 1\\na = [int(i) for i in input().split()]\\nres, c, lft = [0] * n, [0] * (n + 1), [0] * (n + 1)\\nfor i in a:\\n    c[i] += 1\\nwhile j <= n and c[j]:\\n    j += 1\\nfor i in range(len(a)):\\n    if c[a[i]] > 1:\\n        if lft[a[i]] or a[i] > j:\\n            ans += 1\\n            c[a[i]] -= 1\\n            res[i] = j\\n            j += 1\\n            while j <= n and c[j]:\\n                j += 1\\n        else:\\n            lft[a[i]] = 1\\n            res[i] = a[i]\\n    else:\\n        res[i] = a[i]\\nprint(ans)\\nprint(*res)\\n    \\n\", \"n, ans, j = int(input()), 0, 1\\na = [int(i) for i in input().split()]\\nres, c, lft = [0] * n, [0] * (n + 1), [0] * (n + 1)\\nfor i in a:\\n    c[i] += 1\\nwhile j <= n and c[j]:\\n    j += 1\\nfor i in range(len(a)):\\n    if c[a[i]] > 1:\\n        if lft[a[i]] or a[i] > j:\\n            ans += 1\\n            c[a[i]] -= 1\\n            res[i] = j\\n            j += 1\\n            while j <= n and c[j]:\\n                j += 1\\n        else:\\n            lft[a[i]] = 1\\n            res[i] = a[i]\\n    else:\\n        res[i] = a[i]\\nprint(ans)\\nprint(*res)\\n    \\n\", \"\\\"\\\"\\\"http://codeforces.com/problemset/problem/864/D\\\"\\\"\\\"\\n# 17:54\\ndef make_a_permutation():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    occ = [0] * (n+1)\\n    for i in range(n):\\n        occ[a[i]] += 1\\n    missing = [i for i in range(1,n+1) if occ[i] == 0]\\n    mi = 0\\n    dupIndexes = [i for i in range(n) if occ[a[i]] >= 2]\\n    fixedNum = [False] * (n+1)\\n    for i in range(n):\\n        if occ[i] == 1:\\n            fixedNum[i] = True\\n    \\n    for dup in dupIndexes:\\n        dupNum = a[dup]\\n        if occ[dupNum] > 1 and (fixedNum[dupNum] or dupNum > missing[mi]):\\n            fixedNum[missing[mi]] = True\\n            occ[missing[mi]] += 1\\n            a[dup]= missing[mi]\\n            mi += 1\\n            occ[dupNum] -= 1\\n        else:\\n                fixedNum[dupNum] = True\\n    return mi, a\\n   \\nc, l = make_a_permutation()\\nprint(c)\\nfor i in range(len(l)):\\n    print(l[i], end=\\\" \\\")\\n\", \"n = int(input())\\na = input().split(' ')\\nfor i in range(n):\\n    a[i] = int(a[i]) - 1\\n    \\nocc = {}\\n\\nfor i in range(len(a)):\\n    if a[i] not in occ:\\n        occ[a[i]] = 1\\n    else:\\n        occ[a[i]] += 1\\n\\nmissing = []\\nfor i in range(n):\\n    if i not in occ:\\n        missing.append(i)\\n        \\nact_missing = 0\\nleft = [1] * n\\n\\n\\nfor pos in range(n):\\n    if occ[a[pos]] > left[a[pos]]:\\n        if missing[act_missing] < a[pos] or left[a[pos]] == 0:\\n            occ[a[pos]] -= 1\\n            a[pos] = missing[act_missing]        \\n            act_missing += 1\\n        else:\\n            left[a[pos]] -= 1\\n            occ[a[pos]] -= 1\\n            \\ns = \\\"\\\"\\nfor e in a:\\n    s += str(e + 1)\\n    s += ' '\\n    \\nprint(len(missing))\\nprint(s)\\n        \\n        \\n\\n\", \"from collections import Counter\\n\\n\\ndef readints():\\n    return [int(item) for item in input().strip().split()]\\n\\n\\nclass Solver:\\n    def main(self):\\n        n = readints()[0]\\n        a = readints()\\n        c = Counter(a)\\n        skipped = set()\\n        to_be_added = sorted(set(range(1, n+1)) - set(c.keys()))\\n        changes = 0\\n        for i in range(n):\\n            if c[a[i]] > 1:\\n                if a[i] < to_be_added[changes] and a[i] not in skipped:\\n                    skipped.add(a[i])\\n                else:\\n                    c[a[i]] -= 1\\n                    a[i] = to_be_added[changes]\\n                    changes += 1\\n\\n        print(changes)\\n        print(' '.join(map(str, a)))\\n\\nSolver().main()\\n\", \"import collections\\nn = int(input())\\na = list(map(int, input().split()))\\ncnt = collections.Counter(a)\\nres = []\\nb = []\\nfor i in range(1, n + 1):\\n    if i not in cnt:\\n        b.append(i)\\nb.sort(reverse = True)\\ns = set(a)\\nprint(len(b))\\nfor v in a:\\n    if v in cnt and cnt[v] > 1:\\n        t = b[-1]\\n        if v < t and v in s:\\n            res.append(v)\\n            s.remove(v)\\n        else:\\n            res.append(b.pop())\\n            cnt[v] -= 1\\n    else:\\n        res.append(v)\\nprint(\\\" \\\".join(list(map(str, res))))\\n\\n\", \"\\nn = int(input())\\na = list(map(int, input().split(' ')))\\nfreq = {}\\nseen = [False for i in range(n+1)]\\nch = 0\\nde = []\\nfor i in range(n):\\n    if a[i] not in list(freq.keys()):\\n        freq[a[i]] = 1\\n    else:\\n        freq[a[i]] += 1\\n        ch += 1\\n\\nfor i in range(n):\\n    if i+1 not in list(freq.keys()):\\n        de.append(i+1)\\n\\nindex = 0\\nfor i in range(n):\\n    if freq[a[i]] > 1:\\n        if seen[a[i]] or de[index] < a[i]:\\n            freq[a[i]] += -1\\n            a[i] = de[index]\\n            index += 1\\n        else:\\n            seen[a[i]] = True\\n\\n\\n\\nsol = \\\"\\\"\\nfor x in a:\\n    sol += str(x) + \\\" \\\"\\n\\nprint(str(ch) + \\\"\\\\n\\\" + sol )\\n\\n\", \"from collections import Counter\\nn = int(input())\\na = list(map(int,input().split()))\\nc = Counter(a)\\nb=dict()\\nfor i in c.keys():\\n  b[i]=0\\nd = list(sorted((Counter(range(1,n+1))-c).keys()))\\nr = n-len(c)\\nj=0\\nprint(r)\\nfor i in range(n):\\n  if j==r:\\n    break\\n  if c[a[i]]>1:\\n    if d[j]<a[i]:\\n      c[a[i]]-=1\\n      a[i]=d[j]\\n      j+=1\\n    else:\\n      if b[a[i]]!=0:\\n        c[a[i]]-=1\\n        a[i]=d[j]\\n        j+=1\\n      else:\\n        b[a[i]]+=1\\nprint(*a)\", \"n = int(input())\\na = list(map(int, input().split()))\\n\\nif sorted(a) == list(range(1, n+1)):\\n    print(0)\\n    print(' '.join(map(str,a)))\\nelse:\\n    cnt = [0] * (n+1)\\n    for i in a:\\n        cnt[i] += 1\\n\\n    add = []\\n    for i in range(1, n+1):  # 1 to 26\\n        if cnt[i] == 0:\\n            add.append(i)\\n\\n    pos = 0\\n    m_cnt = 0\\n    appeared = [False] * (n + 1)\\n    for i, t in enumerate(a):\\n        if cnt[t] > 1:\\n            if t > add[pos] or appeared[t]:\\n                a[i] = add[pos]\\n                pos += 1\\n                m_cnt += 1\\n                if pos == len(add):\\n                    break\\n                cnt[t] -= 1\\n                appeared[a[i]] = True\\n            else:\\n                appeared[t] = True\\n        else:\\n            appeared[t] = True\\n\\n    print(m_cnt)\\n    print(' '.join(map(str,a)))\\n\", \"from collections import Counter\\n\\nn = int(input())\\n\\narr = [int(x) for x in input().split(\\\" \\\")]\\ncounter = Counter(arr)\\n\\n\\ns = {x for x in range(1, n + 1)}\\nreplacements = sorted(list(s - set(counter.keys())))\\n\\nr = 0\\nans = 0\\nskipped = set()\\nfor index, value in enumerate(arr):\\n    if counter[value] > 1:\\n        if value > replacements[r] or value in skipped:\\n            arr[index] = replacements[r]\\n            ans += 1\\n            r += 1\\n            counter.subtract((value,))\\n        else:\\n            skipped.add(value)\\n\\n\\nprint(ans)\\nprint(\\\" \\\".join([str(x) for x in arr]))\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"4\\n3 2 2 3\\n\",\n    \"6\\n4 5 6 3 2 1\\n\",\n    \"10\\n6 8 4 6 7 1 6 3 4 5\\n\",\n    \"6\\n5 5 5 6 4 6\\n\",\n    \"50\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"50\\n1 1 2 1 1 1 1 1 1 1 1 1 2 1 2 1 1 2 1 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\",\n    \"50\\n2 4 1 2 3 7 2 2 1 1 3 4 2 12 4 3 2 1 2 5 1 3 3 7 9 6 10 5 7 1 4 3 6 2 3 12 1 3 2 6 2 2 2 4 1 6 1 3 7 13\\n\",\n    \"50\\n11 3 15 13 1 10 27 4 18 20 6 1 5 8 9 19 6 13 5 19 5 3 1 8 2 3 3 6 4 19 11 6 3 1 3 1 8 14 2 2 8 13 12 1 15 2 1 2 1 1\\n\",\n    \"50\\n9 10 1 6 7 3 25 4 11 15 3 6 25 1 6 17 1 25 16 2 10 22 17 11 1 14 4 6 9 18 12 9 10 1 10 13 8 13 24 28 12 14 1 2 1 4 20 9 7 4\\n\",\n    \"10\\n8 1 2 1 8 8 1 5 1 2\\n\",\n    \"3\\n2 1 2\\n\",\n    \"50\\n25 48 15 25 49 39 34 15 9 3 12 11 11 3 30 7 6 47 36 1 39 27 17 1 31 39 3 42 19 20 26 41 10 15 29 44 26 32 37 39 43 38 42 6 37 36 50 47 43 21\\n\",\n    \"50\\n50 46 38 41 49 23 16 17 48 32 31 49 40 21 41 31 47 17 15 50 38 20 37 47 24 47 15 46 24 18 41 40 45 25 31 45 14 30 17 16 16 44 44 46 45 5 41 16 24 34\\n\",\n    \"50\\n26 46 50 31 47 40 25 47 41 47 31 30 50 40 46 44 26 48 37 19 28 19 50 22 42 38 47 22 44 44 35 30 50 45 49 34 19 37 36 32 50 29 50 42 34 49 40 50 8 50\\n\",\n    \"20\\n15 18 20 6 19 13 20 17 20 16 19 17 17 19 16 12 14 19 20 20\\n\",\n    \"50\\n48 37 47 50 46 43 42 46 36 40 45 41 40 50 35 49 37 42 44 45 49 44 31 47 45 49 48 41 45 45 48 20 34 43 43 41 47 50 41 48 38 48 43 48 46 48 32 37 47 45\\n\",\n    \"26\\n26 26 23 25 22 26 26 24 26 26 25 18 25 22 24 24 24 24 24 26 26 25 24 26 26 23\\n\",\n    \"50\\n50 50 50 49 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 49 50 49 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 49\\n\",\n    \"50\\n50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50 50\\n\",\n    \"50\\n4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\\n\",\n    \"50\\n32 4 32 4 42 32 32 42 4 4 32 4 42 4 32 42 4 42 32 42 32 32 32 42 4 4 32 4 32 4 32 4 42 32 4 42 32 42 32 32 4 42 42 42 42 42 42 32 32 4\\n\",\n    \"50\\n18 42 38 38 38 50 50 38 49 49 38 38 42 18 49 49 49 49 18 50 18 38 38 49 49 50 49 42 38 49 42 38 38 49 38 49 50 49 49 49 18 49 18 38 42 50 42 49 18 49\\n\",\n    \"50\\n17 31 7 41 30 38 38 5 38 39 5 1 41 17 5 15 7 15 15 7 39 17 38 7 39 41 5 7 38 1 39 31 41 7 5 38 17 15 39 30 39 38 7 15 30 17 7 5 41 31\\n\",\n    \"50\\n23 14 39 19 31 39 18 18 31 14 45 7 42 25 20 25 14 19 29 45 33 7 8 32 29 24 26 13 25 24 25 13 4 23 39 45 25 21 38 45 20 45 18 7 27 23 29 15 31 39\\n\",\n    \"50\\n4 50 27 48 32 32 37 33 18 24 38 6 32 17 1 46 36 16 10 9 9 25 26 40 28 2 1 5 15 50 2 4 18 39 42 46 25 3 10 42 37 23 28 41 33 45 25 11 13 18\\n\",\n    \"50\\n39 49 43 21 22 27 28 41 35 6 31 9 4 39 27 27 7 41 9 28 43 37 20 47 28 37 8 46 23 14 50 48 21 47 9 31 9 37 34 17 15 17 18 16 29 6 43 33 16 17\\n\",\n    \"2\\n1 2\\n\",\n    \"2\\n2 1\\n\",\n    \"2\\n1 1\\n\",\n    \"2\\n2 2\\n\",\n    \"3\\n1 1 1\\n\",\n    \"3\\n2 2 2\\n\",\n    \"3\\n3 3 3\\n\",\n    \"3\\n1 2 2\\n\",\n    \"3\\n2 1 3\\n\",\n    \"3\\n3 2 1\\n\",\n    \"3\\n2 2 3\\n\",\n    \"3\\n3 1 3\\n\",\n    \"3\\n2 2 1\\n\",\n    \"3\\n3 1 2\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n1 2 4 3 \\n\",\n    \"0\\n4 5 6 3 2 1 \\n\",\n    \"3\\n2 8 4 6 7 1 9 3 10 5 \\n\",\n    \"3\\n1 2 5 3 4 6 \\n\",\n    \"49\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \\n\",\n    \"48\\n1 3 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \\n\",\n    \"39\\n2 4 1 8 3 7 11 14 15 16 17 18 19 12 20 21 22 23 24 5 25 26 27 28 9 6 10 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 13 \\n\",\n    \"32\\n7 3 15 13 1 10 27 4 18 20 6 16 5 8 9 17 21 22 23 19 24 25 26 28 2 29 30 31 32 33 11 34 35 36 37 38 39 14 40 41 42 43 12 44 45 46 47 48 49 50 \\n\",\n    \"28\\n5 10 1 6 7 3 19 4 11 15 21 23 25 26 27 17 29 30 16 2 31 22 32 33 34 14 35 36 9 18 12 37 38 39 40 13 8 41 24 28 42 43 44 45 46 47 20 48 49 50 \\n\",\n    \"6\\n3 1 2 4 6 8 7 5 9 10 \\n\",\n    \"1\\n2 1 3 \\n\",\n    \"17\\n2 48 4 25 49 5 34 8 9 3 12 11 13 14 30 7 6 16 18 1 22 27 17 23 31 24 28 33 19 20 26 41 10 15 29 44 35 32 37 39 40 38 42 45 46 36 50 47 43 21 \\n\",\n    \"24\\n1 2 3 4 6 23 7 8 48 32 9 49 10 21 11 12 13 17 15 50 38 20 37 19 22 47 26 27 24 18 28 40 29 25 31 33 14 30 35 16 36 39 44 46 45 5 41 42 43 34 \\n\",\n    \"25\\n1 2 3 4 5 6 25 7 41 9 31 10 11 12 46 13 26 48 14 15 28 16 17 18 20 38 47 22 21 44 35 30 23 45 24 27 19 37 36 32 33 29 39 42 34 49 40 43 8 50 \\n\",\n    \"10\\n15 18 1 6 2 13 3 4 5 7 8 9 17 10 16 12 14 19 11 20 \\n\",\n    \"31\\n1 2 3 4 5 6 7 8 36 9 10 11 40 12 35 13 14 42 15 16 17 44 31 18 19 49 21 22 23 24 25 20 34 26 27 28 29 50 41 30 38 33 43 39 46 48 32 37 47 45 \\n\",\n    \"20\\n1 2 3 4 5 6 7 8 9 10 11 18 12 22 13 14 15 16 17 19 20 25 24 21 26 23 \\n\",\n    \"48\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 50 49 \\n\",\n    \"49\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \\n\",\n    \"49\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \\n\",\n    \"47\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 33 34 32 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \\n\",\n    \"45\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 19 18 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 39 40 41 43 44 45 38 42 50 46 47 48 49 \\n\",\n    \"40\\n2 3 4 6 8 9 10 5 11 12 13 1 14 16 18 15 7 19 20 21 22 17 23 24 25 26 27 28 29 32 33 31 34 35 36 37 40 42 39 30 43 38 44 45 46 47 48 49 41 50 \\n\",\n    \"27\\n1 2 3 5 6 9 10 11 12 14 16 7 42 17 20 22 28 19 29 30 33 34 8 32 35 24 26 13 25 36 37 40 4 23 39 41 43 21 38 44 46 45 18 47 27 48 49 15 31 50 \\n\",\n    \"17\\n4 7 27 48 8 12 14 19 18 24 38 6 32 17 1 20 36 16 10 9 21 22 26 40 28 2 29 5 15 50 30 31 34 39 35 46 25 3 43 42 37 23 44 41 33 45 47 11 13 49 \\n\",\n    \"20\\n1 49 2 3 22 5 10 11 35 6 12 9 4 39 13 27 7 41 19 24 25 26 20 30 28 32 8 46 23 14 50 48 21 47 36 31 38 37 34 17 15 40 18 16 29 42 43 33 44 45 \\n\",\n    \"0\\n1 2 \\n\",\n    \"0\\n2 1 \\n\",\n    \"1\\n1 2 \\n\",\n    \"1\\n1 2 \\n\",\n    \"2\\n1 2 3 \\n\",\n    \"2\\n1 2 3 \\n\",\n    \"2\\n1 2 3 \\n\",\n    \"1\\n1 2 3 \\n\",\n    \"0\\n2 1 3 \\n\",\n    \"0\\n3 2 1 \\n\",\n    \"1\\n1 2 3 \\n\",\n    \"1\\n2 1 3 \\n\",\n    \"1\\n2 3 1 \\n\",\n    \"0\\n3 1 2 \\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/864/D",
  "starter_code": ""
}