{
  "task_id": "APPS/260",
  "problem_id": 260,
  "prompt": "One day, after a difficult lecture a diligent student Sasha saw a graffitied desk in the classroom. She came closer and read: \"Find such positive integer n, that among numbers n + 1, n + 2, ..., 2\u00b7n there are exactly m numbers which binary representation contains exactly k digits one\".\n\nThe girl got interested in the task and she asked you to help her solve it. Sasha knows that you are afraid of large numbers, so she guaranteed that there is an answer that doesn't exceed 10^18.\n\n\n-----Input-----\n\nThe first line contains two space-separated integers, m and k (0 \u2264 m \u2264 10^18; 1 \u2264 k \u2264 64).\n\n\n-----Output-----\n\nPrint the required number n (1 \u2264 n \u2264 10^18). If there are multiple answers, print any of them.\n\n\n-----Examples-----\nInput\n1 1\n\nOutput\n1\n\nInput\n3 2\n\nOutput\n5",
  "solutions": "[\"def nck(n, k, cache = {}):\\n    if k > n or k < 0: return 0\\n    if k == 0 or k == n: return 1\\n    if k*2 > n: k = n-k\\n    if (n, k) in cache: return cache[(n, k)]\\n\\n    z = cache[(n, k)] = nck(n-1, k-1) + nck(n-1, k)\\n    return z\\n\\ndef bits(n):\\n    b = 0\\n    while n:\\n        if n&1: b += 1\\n        n >>= 1\\n    return b\\n\\ndef count(n, k):\\n    z, b, c = 0, 63, 0\\n    for b in reversed(range(64)):\\n        if (n>>b)&1:\\n            z += nck(b, k-c)\\n            c += 1\\n        if not k: break\\n    return z + (bits(n) == k)\\n\\ndef solve(m, k):\\n    lo, hi = 1, 10**18\\n    while lo < hi:\\n        mi = (lo+hi)//2\\n        if count(2*mi, k) - count(mi, k) < m:\\n            lo = mi+1\\n        else:\\n            hi = mi\\n    return hi\\n\\nm, k = [int(x) for x in input().split()]\\nprint(solve(m, k))\", \"def dfs(n, k, cache = {}):\\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\\n    if k > n or k < 0: return 0\\n    # if num bits is 0 or num bits is equivalent to the number's bits\\n    if k == 0 or k == n: return 1\\n    if k*2 > n: k = n-k\\n    # Check is already calculated\\n    if (n, k) in cache: return cache[(n, k)]\\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\\n    return z\\n\\ndef bits(n):\\n    b = 0\\n    while n:\\n        if n&1: b += 1\\n        n >>= 1\\n    return b\\n\\ndef count(n, k):\\n    z, b, c = 0, 63, 0\\n    for b in reversed(range(64)):\\n        # Taking n and checking if bit is 1 or not\\n        if (n>>b)&1:\\n            z += dfs(b, k-c)\\n            c += 1\\n        if not k: break\\n    return z + (bits(n) == k)\\n\\ndef solve(m, k):\\n    # Binary Search for number 1-10^18\\n    low, high = 1, 10**18\\n    while low < high:\\n        mid = (low+high)//2\\n        if count(2*mid, k) - count(mid, k) < m:\\n            low = mid+1\\n        else:\\n            high = mid\\n    return high\\n\\nm, k = [int(x) for x in input().split()]\\nprint(solve(m, k))\", \"def dfs(n, k, cache = {}):\\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\\n    if k > n or k < 0: return 0\\n    # if num bits is 0 or num bits is equivalent to the number's bits\\n    if k == 0 or k == n: return 1\\n    # \\n    # if k*2 > n: k = n-k\\n    # Check is already calculated\\n    if (n, k) in cache: return cache[(n, k)]\\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\\n    return z\\n\\ndef bits(n):\\n    b = 0\\n    while n:\\n        if n&1: b += 1\\n        n >>= 1\\n    return b\\n\\ndef count(n, k):\\n    z, b, c = 0, 63, 0\\n    for b in reversed(range(64)):\\n        # Taking n and checking if bit is 1 or not\\n        if (n>>b)&1:\\n            z += dfs(b, k-c)\\n            c += 1\\n        if not k: break\\n    return z + (bits(n) == k)\\n\\ndef solve(m, k):\\n    # Binary Search for number 1-10^18\\n    low, high = 1, 10**18\\n    while low < high:\\n        mid = (low+high)//2\\n        if count(2*mid, k) - count(mid, k) < m:\\n            low = mid+1\\n        else:\\n            high = mid\\n    return high\\n\\nm, k = [int(x) for x in input().split()]\\nprint(solve(m, k))\", \"def dfs(n, k, cache = {}):\\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\\n    if k > n or k < 0: return 0\\n    # if num bits is 0 or num bits is equivalent to the number's bits\\n    if k == 0 or k == n: return 1\\n    # This optimization is not necessary but flips the 0s and the 1s\\n    # if k*2 > n: k = n-k\\n    # Check is already calculated\\n    if (n, k) in cache: return cache[(n, k)]\\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\\n    return z\\n\\ndef bits(n):\\n    b = 0\\n    while n:\\n        if n&1: b += 1\\n        n >>= 1\\n    return b\\n\\ndef count(n, k):\\n    z, b, c = 0, 63, 0\\n    for b in reversed(range(64)):\\n        # Taking n and checking if certain bit is 1 or not\\n        # This sums for every mod power of 2 that exists to account for every case\\n        if (n>>b)&1:\\n            # calculates by subtracting for bits not accounted for\\n            z += dfs(b, k-c)\\n            c += 1\\n        # if not k: break\\n    return z + (bits(n) == k)\\n\\ndef solve(m, k):\\n    # Binary Search for number 1-10^18\\n    low, high = 1, 10**18\\n    while low < high:\\n        mid = (low+high)//2\\n        if count(2*mid, k) - count(mid, k) < m:\\n            low = mid+1\\n        else:\\n            high = mid\\n    return high\\n\\nm, k = [int(x) for x in input().split()]\\nprint(solve(m, k))\", \"def dfs(n, k, cache = {}):\\n    # if number of bits is bigger than the number's bits of the number's bits is less than 0\\n    if k > n or k < 0: return 0\\n    # if num bits is 0 or num bits is equivalent to the number's bits\\n    if k == 0 or k == n: return 1\\n    # This optimization is not necessary but flips the 0s and the 1s\\n    # if k*2 > n: k = n-k\\n    # Check is already calculated\\n    if (n, k) in cache: return cache[(n, k)]\\n    # Use dfs addition for case where certain bit is 1 or certain bit is 0\\n    z = cache[(n, k)] = dfs(n-1, k-1) + dfs(n-1, k)\\n    return z\\n\\ndef bits(n):\\n    # counts number of 1s in the number\\n    b = 0\\n    while n:\\n        if n & 1: b += 1\\n        n >>= 1\\n    return b\\n\\ndef count(n, k):\\n    z, b, c = 0, 63, 0\\n    for b in reversed(range(64)):\\n        # Taking n and checking if certain bit is 1 or not\\n        # This sums for every mod power of 2 that exists to account for every case\\n        if (n>>b)&1:\\n            # calculates by subtracting for bits not accounted for\\n            z += dfs(b, k-c)\\n            c += 1\\n        # Unnecessary code\\n        # if not k: break\\n    # if original number has same number of 1s as digits required, add 1\\n    return z + (bits(n) == k)\\n\\ndef solve(m, k):\\n    # Binary Search for number 1-10^18\\n    low, high = 1, 10**18\\n    while low < high:\\n        mid = (low+high)//2\\n        if count(2*mid, k) - count(mid, k) < m:\\n            low = mid+1\\n        else:\\n            high = mid\\n    return high\\n\\nm, k = [int(x) for x in input().split()]\\nprint(solve(m, k))\", \"from math import factorial as f\\ndef C(n, m):\\n    if n < m: return 0\\n    return f(n) // ( f(n - m ) * f(m) )\\n\\nm, k = list(map(int, input().split()))\\nans = 1\\nfor bit in reversed(list(range(65))):\\n    if k == 0:\\n        break\\n    if C(bit, k - 1) < m:\\n        ans += ( 1 << bit )\\n        m -= C(bit, k - 1)\\n        k -= 1\\nprint(ans)\\n\", \"comb = [[0 for i in range(67)] for j in range(67)]\\n\\nfor i in range(67):\\n    comb[i][0], comb[i][i] = 1, 1\\n    for j in range(1, i):\\n        comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j]\\n\\ndef calc(x):\\n    cnt   = 0\\n    digit = []\\n    while (x > 0):\\n        digit.append(x % 2)\\n        x  //= 2\\n        cnt += 1\\n    ans, one = 0, 0\\n    for i in reversed(list(range(cnt))):\\n        if (digit[i] == 1):\\n            if (k - one >= 0):\\n                ans += comb[i][k - one]\\n            one += 1\\n    return ans\\n\\nm, k = list(map(int, input().split()))\\n\\nlcur, rcur = 0, 2 ** 64\\nwhile (lcur + 2 <= rcur):\\n    mid = (lcur + rcur) // 2\\n    if (calc(mid * 2) - calc(mid) < m):\\n        lcur = mid\\n    else:\\n        rcur = mid\\n\\nprint(rcur)\\n\\n\", \"MX_BIT = 64\\nC = [[int(0) for i in range(MX_BIT)] for j in range(MX_BIT)]\\n\\ndef ck(x, i):\\n\\treturn (x>>i) & 1\\ndef tot_bits(x):\\n\\tx = bin(x)[2:]\\n\\treturn len(x)\\ndef mkt():\\n\\tC[0][0] = 1\\n\\tfor i in range (1, MX_BIT):\\n\\t\\tfor j in range (i+1):\\n\\t\\t\\tC[i][j] = C[i-1][j] + (C[i-1][j-1] if j else 0)\\ndef solve(x, k):\\n\\ta = 0\\n\\tfor i in reversed(list(range(MX_BIT))):\\n\\t\\tif ck(x, i) != 0:\\n\\t\\t\\ta += C[i][k]\\n\\t\\t\\tk -= 1\\n\\t\\tif k == 0:\\n\\t\\t\\tbreak\\n\\treturn a\\nmkt()\\nm, k = list(input().split())\\nm = int(m)\\nk = int(k)\\nl = 1\\nr = 1e18\\nif not m:\\n    l = 1\\nelse:\\n    while l < r:\\n    \\tmid = int((l + r) // 2)\\n    \\tif (solve(2*mid, k) - solve(mid, k)) < m :\\n    \\t\\tl = mid + 1\\n    \\telse:\\n    \\t\\tr = mid\\nprint(l)\\n\", \"from math import factorial as f\\ndef C(n, m):\\n    if n < m: return 0\\n    return f(n) // ( f(n - m ) * f(m) )\\n \\nm, k = map(int, input().split())\\nans = 1\\nfor bit in reversed(range(65)):\\n    if k == 0:\\n        break\\n    if C(bit, k - 1) < m:\\n        ans += ( 1 << bit )\\n        m -= C(bit, k - 1)\\n        k -= 1\\nprint(ans)\", \"\\nimport math\\n\\nm, k = list(map(int, input().strip(' ').split(' ')))\\n\\n\\ndef solve(x):\\n    ans = 0\\n    tot = 0\\n    for i in reversed(list(range(int(math.log2(x)+1)))):\\n        if x & (1 << i):\\n            ans += math.comb(i, k-tot)\\n            tot += 1\\n            if tot > k:\\n                return ans\\n    return ans\\n\\n\\ndef judge(x):\\n    return solve(x*2)-solve(x) >= m\\n\\n\\nl, r = 1, 2\\nwhile not judge(r):\\n    l, r = r, r*2\\nans = -1\\nwhile l <= r:\\n    mid = (l+r) >> 1\\n    if judge(mid):\\n        ans, r = mid, mid-1\\n    else:\\n        l = mid+1\\nprint(ans)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"1 1\\n\",\n    \"3 2\\n\",\n    \"3 3\\n\",\n    \"1 11\\n\",\n    \"4 20\\n\",\n    \"45902564 24\\n\",\n    \"330 8\\n\",\n    \"10 10\\n\",\n    \"0 2\\n\",\n    \"1000000 55\\n\",\n    \"1 60\\n\",\n    \"1000000000 52\\n\",\n    \"101628400788615604 30\\n\",\n    \"101628400798615604 31\\n\",\n    \"55 55\\n\",\n    \"14240928 10\\n\",\n    \"1000000000 10\\n\",\n    \"1111111 11\\n\",\n    \"10000000000000000 35\\n\",\n    \"0 19\\n\",\n    \"768 10\\n\",\n    \"3691 6\\n\",\n    \"16 15\\n\",\n    \"427 4\\n\",\n    \"669 9\\n\",\n    \"0 16\\n\",\n    \"286 11\\n\",\n    \"6 16\\n\",\n    \"13111 8\\n\",\n    \"17 2\\n\",\n    \"440 4\\n\",\n    \"5733 6\\n\",\n    \"3322 6\\n\",\n    \"333398 7\\n\",\n    \"19027910 20\\n\",\n    \"73964712 13\\n\",\n    \"33156624 15\\n\",\n    \"406 3\\n\",\n    \"3600 4\\n\",\n    \"133015087 16\\n\",\n    \"14065439 11\\n\",\n    \"135647 6\\n\",\n    \"613794 8\\n\",\n    \"79320883 13\\n\",\n    \"433 3\\n\",\n    \"142129 6\\n\",\n    \"20074910 16\\n\",\n    \"27712 4\\n\",\n    \"109197403264830 17\\n\",\n    \"1767 3\\n\",\n    \"2518095982 9\\n\",\n    \"16184825266581 15\\n\",\n    \"60 2\\n\",\n    \"51908921235703 16\\n\",\n    \"373301530 8\\n\",\n    \"51140330728306 16\\n\",\n    \"78015012688021 17\\n\",\n    \"360651917262546 18\\n\",\n    \"15619605006173 15\\n\",\n    \"296851618 8\\n\",\n    \"1651507249349341 20\\n\",\n    \"234217752433205 18\\n\",\n    \"5004844 6\\n\",\n    \"820882585293 13\\n\",\n    \"0 64\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n\",\n    \"5\\n\",\n    \"7\\n\",\n    \"1024\\n\",\n    \"983040\\n\",\n    \"6406200698\\n\",\n    \"2033\\n\",\n    \"1023\\n\",\n    \"1\\n\",\n    \"504262282264444927\\n\",\n    \"576460752303423488\\n\",\n    \"542648557841154044\\n\",\n    \"999999999999995905\\n\",\n    \"981546175132942729\\n\",\n    \"36028797018963967\\n\",\n    \"999948289\\n\",\n    \"38209103398929\\n\",\n    \"7734675\\n\",\n    \"247948501945678280\\n\",\n    \"1\\n\",\n    \"9471\\n\",\n    \"39105\\n\",\n    \"40960\\n\",\n    \"18561\\n\",\n    \"5535\\n\",\n    \"1\\n\",\n    \"8185\\n\",\n    \"64512\\n\",\n    \"73033\\n\",\n    \"65537\\n\",\n    \"20993\\n\",\n    \"96257\\n\",\n    \"34441\\n\",\n    \"142974977\\n\",\n    \"530210696\\n\",\n    \"808934145\\n\",\n    \"217957249\\n\",\n    \"402653185\\n\",\n    \"310378497\\n\",\n    \"903250260\\n\",\n    \"277820673\\n\",\n    \"612761601\\n\",\n    \"47611905\\n\",\n    \"877746562\\n\",\n    \"603979777\\n\",\n    \"893386753\\n\",\n    \"156957897\\n\",\n    \"54078379900534785\\n\",\n    \"530824147803045889\\n\",\n    \"612489549322387457\\n\",\n    \"835136255900516353\\n\",\n    \"753750817529397249\\n\",\n    \"576460752303423489\\n\",\n    \"927684967108968449\\n\",\n    \"628568807366983681\\n\",\n    \"880672956240363521\\n\",\n    \"237668409087623169\\n\",\n    \"866841191969193985\\n\",\n    \"676897611185127425\\n\",\n    \"208581753835618305\\n\",\n    \"660934198681731073\\n\",\n    \"333773758789582849\\n\",\n    \"488640559569698817\\n\",\n    \"167167411424854017\\n\",\n    \"1\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/431/D",
  "starter_code": ""
}