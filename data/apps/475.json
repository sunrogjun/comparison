{
  "task_id": "APPS/475",
  "problem_id": 475,
  "prompt": "On his free time, Chouti likes doing some housework. He has got one new task, paint some bricks in the yard.\n\nThere are $n$ bricks lined in a row on the ground. Chouti has got $m$ paint buckets of different colors at hand, so he painted each brick in one of those $m$ colors.\n\nHaving finished painting all bricks, Chouti was satisfied. He stood back and decided to find something fun with these bricks. After some counting, he found there are $k$ bricks with a color different from the color of the brick on its left (the first brick is not counted, for sure).\n\nSo as usual, he needs your help in counting how many ways could he paint the bricks. Two ways of painting bricks are different if there is at least one brick painted in different colors in these two ways. Because the answer might be quite big, you only need to output the number of ways modulo $998\\,244\\,353$.\n\n\n-----Input-----\n\nThe first and only line contains three integers $n$, $m$ and $k$ ($1 \\leq n,m \\leq 2000, 0 \\leq k \\leq n-1$)\u00a0\u2014 the number of bricks, the number of colors, and the number of bricks, such that its color differs from the color of brick to the left of it.\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 the number of ways to color bricks modulo $998\\,244\\,353$.\n\n\n-----Examples-----\nInput\n3 3 0\n\nOutput\n3\n\nInput\n3 2 1\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first example, since $k=0$, the color of every brick should be the same, so there will be exactly $m=3$ ways to color the bricks.\n\nIn the second example, suppose the two colors in the buckets are yellow and lime, the following image shows all $4$ possible colorings. [Image]",
  "solutions": "[\"import math\\nn,m,k=map(int,input().split())\\nout=1\\nfor i in range(k):\\n    out*=(m-1)\\n    out%=998244353\\nout*=m\\nout%=998244353\\nout*=(math.factorial(n-1)//math.factorial(k)//math.factorial(n-1-k))\\nout%=998244353\\nprint(out)\", \"MOD = 998244353\\n\\nlist_size = 2100\\n\\nf_list = [1] * list_size\\nf_r_list = [1] * list_size\\n\\nfor i in range(list_size - 1):\\n\\tf_list[i + 1] = int((f_list[i] * (i + 2)) % MOD)\\n\\ndef power(n, x):\\n\\tif x == 1:\\n\\t\\treturn n\\n\\telif x % 2 == 0:\\n\\t\\treturn power(int((n * n) % MOD), int(x / 2))\\n\\telse:\\n\\t\\treturn int((n * power(n, x - 1)) % MOD)\\n\\nf_r_list[-1] = power(f_list[-1], MOD - 2)\\n\\nfor i in range(2, list_size + 1):\\n\\tf_r_list[-i] = int((f_r_list[-i + 1] * (list_size + 2 - i)) % MOD)\\n\\ndef comb(n, r):\\n\\tif n < r:\\n\\t\\treturn 0\\n\\telif n == 0 or r == 0 or n == r:\\n\\t\\treturn 1\\n\\telse:\\n\\t\\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \\n\\nn, m, k = map(int, input().split())\\nprint((m * (m-1) ** k) % MOD * comb(n-1, k) % MOD)\", \"m = list(map(int,input().split(' ')))\\na = m[0]\\nb = m[1]\\nc = m[2]\\nways = 1\\ndef fact(n):\\n    a = 1\\n    for i in range(2,n+1):\\n        a *= i\\n    return a\\ndef p(r,n):\\n    return fact(n)//fact(r)\\ndef entekhab(r,n):\\n    return p(r,n)//fact(n-r)\\nways *= b\\na -= 1\\nways *= entekhab(c,a)\\nways *= (b-1)**c\\nprint(ways%998244353)\\n\", \"import sys\\ninput = sys.stdin.readline\\nmod=998244353\\n\\nn,m,k=list(map(int,input().split()))\\n\\nN=n-1\\nINV=[None]*(n+1)#1/a\\u306e\\u30ea\\u30b9\\u30c8\\u3092\\u4e88\\u3081\\u4f5c\\u3063\\u3066\\u304a\\u304f.\\nfor i in range(1,n+1):\\n    INV[i]=pow(i,mod-2,mod)\\n\\n#nCk\\u306f\\u3001n\\u3082\\u3057\\u304f\\u306fk\\u304c\\u56fa\\u5b9a\\u306e\\u5834\\u5408\\u306f\\u30ea\\u30b9\\u30c8\\u3067\\u4f5c\\u308b\\n\\nCombi=[None]*(N+1)#Combi[i]=nCi \\u3092\\u8868\\u3059\\nCombi[0]=1\\nfor i in range(1,N+1):\\n    Combi[i]=Combi[i-1]*(N-i+1)*INV[i] %mod\\n\\n\\n\\n\\n\\nANS=Combi[k]%mod *m %mod *pow(m-1,k,mod)%mod\\nprint(ANS)\\n\", \"import math\\n\\ndef modi(a,m) : \\n\\treturn pow(a,m-2,m)\\n\\n\\ndef __starting_point():\\n\\n\\tn,m,k = [int(x) for x  in input().split()]\\n\\tmod = 998244353 \\n\\n\\n\\tans  = 1\\n\\n\\tfor i  in range(k) : \\n\\t\\tans *= (n-1-i)%mod\\n\\t\\tans = ans %mod\\n\\tfor i in range(1,k+1) :\\n\\t\\tans *= modi(i,mod)%mod\\n\\t\\tans  = ans %mod\\n\\tans *= m\\n\\tans = ans %mod\\n\\n\\tans  *= pow(m-1,k,mod)%mod\\n\\tans  = ans%mod\\n\\tprint (ans)\\n\\n\\n\\n\\n__starting_point()\", \"P = 998244353\\ndef C(n, k):\\n    nonlocal P\\n    k = min(k, n-k)\\n    p = 1\\n    for i in range(n, n-k, -1):\\n        p *= i\\n    for i in range(k, 0, -1):\\n        assert(p%i==0)\\n        p //= i\\n    return p%P\\n\\nn, m, k = list(map(int, input().split()))\\n\\nr = C(n-1, k)\\nr = (r*m)%P\\nfor i in range(k):\\n    r = (r*(m-1))%P\\nprint(r)\\n\\n\", \"def fact(n):\\n    q=1;\\n    for i in range(1,n+1):\\n        q*=i\\n    return q\\n\\nn,m,k=input().split()\\nn=int(n)\\nm=int(m)\\nk=int(k)\\ncom=fact(n-1)//(fact(k)*fact(n-1-k))\\ndd=m*((m-1)**k)\\nprint((com*dd) % 998244353)\", \"import sys\\n\\nMOD = 998244353\\n\\nn,m,k = list(map(int, input().strip().split()))\\n\\nmemo = dict()\\n\\ndef C(n,m,k, first):\\n    if n == 0:\\n        if k == 0:\\n            return 1\\n        else:\\n            return 0\\n    if k == 0:\\n        if first:\\n            return m\\n        else:\\n            return 0\\n    \\n    if (n,m,k, first) in memo:\\n        return memo[n,m,k, first]\\n    \\n    vseh = 0\\n\\n    if first:\\n        for i in range(n):\\n            vseh += m*C(i,m,k,False)\\n    else:\\n        for i in range(n):\\n            vseh += (m-1)*C(i,m,k-1,False)\\n    \\n    memo[n,m,k,first] = vseh % MOD\\n    return memo[n,m,k,first]\\n\\ndef C2(n,m,k):\\n    matrika = [[0 for _ in range(n+1)] for _ in range(k+1)]\\n    matrika[0][0] = 1\\n    for j in range(1, k + 1):\\n        acc = 0\\n        for a in range(1, n+1):\\n            acc += (m-1)*matrika[j-1][a-1]\\n            matrika[j][a] = acc % MOD\\n    \\n    result = m*sum(matrika[k][:-1])\\n\\n    return result % MOD\\n\\nprint(C2(n,m,k))\\n\\n\\n    \\n\\n\", \"n, m, k = list(map(int, input().split()))\\nmod = 998244353\\ndp = [[0] * (k + 1) for i in range(n)]\\ndp[0][0] = m\\nfor i in range(1, n):\\n    for j in range(k + 1):\\n        dp[i][j] = dp[i - 1][j]\\n        if j > 0:\\n            dp[i][j] += dp[i - 1][j - 1] * (m - 1)\\n        dp[i][j] %= mod\\nprint(dp[n-1][k])\\n\", \"n, m, k = list(map(int, input().split()))\\nans = 1\\nfor i in range(1, k + 1):\\n    ans *= n - i\\nfor i in range(k, 0, -1):\\n    ans //= i\\nans = ans * m % 998244353\\nfor i in range(k):\\n    ans = ans * (m - 1) % 998244353\\nprint(ans)\\n\", \"Z = 998244353\\n\\n\\ndef ncr(n, r):\\n    num = den = 1\\n    for i in range(r):\\n        num = (num * (n - i)) % Z\\n        den = (den * (i + 1)) % Z\\n\\n    return (num * pow(den, Z - 2, Z)) % Z\\n\\n\\nn, m, k = list(map(int, input().split()))\\n\\nprint((ncr(n - 1, k) * m * pow(m - 1, k, Z)) % Z)\\n\", \"import operator as op\\nfrom functools import reduce\\n\\ndef ncr(z, r):\\n    r = min(r, z-r)\\n    numer = reduce(op.mul, range(z, z-r, -1), 1)\\n    denom = reduce(op.mul, range(1, r+1), 1)\\n    return numer //  denom\\n\\n\\nn,m,k = list(map(int, input().strip().split()))\\nmod = 998244353;\\nif m ==1:\\n    if k==0:\\n        print(1);\\n    else:\\n        print(0);\\nelif n == 1:\\n    print(m)\\nelse:\\n    ans = m * ((m-1)**k)\\n    ans = ans % mod;\\n    c= ncr(n-1,k) % mod\\n    ans = ans * c;\\n    ans = ans % mod;\\n    print(ans)\", \"import math\\n\\nn, m, k = [int(x) for x in input().split()]\\nif k == 0:\\n    ar = m\\nelse:\\n    a = m * (math.factorial(n-1) // (math.factorial(k) * math.factorial(n-1-k))) * ((m-1)**k)\\n    ar = a % 998244353\\nprint(ar)\\n\", \"n, m, k = list(map(int, input().split()))\\nmod = 998244353\\n\\nsame_bricks = n - 1 - k\\ntotal = m # First brick\\n# Different bricks\\nfor i in range(k):\\n\\ttotal *= (m-1)\\n\\ttotal %= mod\\n\\n# Choosing same bricks\\n# times (n-1 choose k)\\nval = 1\\nfor i in range(n - k, n):\\n\\tval *= i\\n\\nfor i in range(1, k+1):\\n\\tval //= i\\n\\ntotal *= val\\ntotal %= mod\\nprint(total)\\n\", \"s=input().split()\\nn,m,k=list(map(int,s))\\nMOD=998244353\\nans=m\\nfor i in range(k):\\n    ans=(ans*(m-1))%MOD\\nif k>n//2:\\n    k=n-1-k\\nfor i in range(1,k+1):\\n    ans=ans*(n-1-k+i)//i\\nprint(ans%MOD)\", \"#      \\nimport collections, atexit, math, sys, bisect \\n\\nsys.setrecursionlimit(1000000)\\ndef getIntList():\\n    return list(map(int, input().split()))    \\n\\ntry :\\n    #raise ModuleNotFoundError\\n    import numpy\\n    def dprint(*args, **kwargs):\\n        #print(*args, **kwargs, file=sys.stderr)\\n        # in python 3.4 **kwargs is invalid???\\n        print(*args,  file=sys.stderr)\\n    dprint('debug mode')\\nexcept Exception:\\n    def dprint(*args, **kwargs):\\n        pass\\n\\n\\n\\ndef e_gcd(a, b ):\\n    if a==0 and b==0:\\n        return -1, 0, 0\\n    if b==0:\\n        return a, 1,0\\n    d, y,x = e_gcd(b, a%b )\\n    y-=  a //b *x\\n    return d , x,y\\n\\ndef m_reverse(a,n):\\n    d,x,y = e_gcd(a,n)\\n    dprint(x,y,a,n)\\n    assert x*a + y*n == d\\n    if d==1:\\n        if x%n<=0:\\n           return x%n+n\\n        else:\\n            return x%n\\n    else:\\n        return -1\\n\\ninId = 0\\noutId = 0\\nif inId>0:\\n    dprint('use input', inId)\\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\\u6807\\u51c6\\u8f93\\u51fa\\u91cd\\u5b9a\\u5411\\u81f3\\u6587\\u4ef6\\nif outId>0:\\n    dprint('use output', outId)\\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\\u6807\\u51c6\\u8f93\\u51fa\\u91cd\\u5b9a\\u5411\\u81f3\\u6587\\u4ef6\\n    atexit.register(lambda :sys.stdout.close())     #idle \\u4e2d\\u4e0d\\u4f1a\\u6267\\u884c atexit\\n\\n    \\nbase = 998244353\\nd = 1233\\nt = m_reverse( d, base)\\ndprint(t)\\nz = t * d % base\\ndprint(z)\\nN, M, K= getIntList()\\n\\n\\n\\nJ = N-1 - K   # same\\n\\nZ = N - J\\ndprint(Z)\\nR = M\\nfor i in range(Z-1):\\n    R *= M-1\\n    R%= base\\ndprint(R)\\nn0 = J\\nm0 = Z\\ndprint(n0,m0)\\n#comb(n0 + m0 -1, m0-1)\\nfor i in range(m0 -1):\\n    g = n0 + m0 -1  -i\\n    R*= g\\n    R%= base\\n\\n\\n\\nfor i in range(2, m0):\\n    t = m_reverse(i,base)\\n    R*=t\\n    R%=base\\n\\nprint(R)\\n    \\n\\n\\n\\n\", \"from operator import mul\\nfrom functools import reduce\\n\\ndef ncr(n, r):\\n    r = min(r, n-r)\\n    numer = reduce(mul, range(n, n-r, -1), 1)\\n    denom = reduce(mul, range(1, r+1), 1)\\n    return numer // denom\\n\\ndef mult(a,b):\\n    return (a*b) % mod\\n\\nn,m,k = map(int, input().split())\\nmod = 998244353\\nans = 1\\nans = mult(ans, (m-1)**k)\\nans = mult(ans, m)\\nans = mult(ans, ncr(n-1, k))\\n\\nprint(ans)\", \"MOD = 998244353\\nn, m, k = list(map(int, input().split()))\\na = [1]\\nfor _ in range(n - 1):\\n\\ta = [sum(x) % MOD for x in zip([0] + a, a + [0])]\\nprint((m * pow(m - 1, k, MOD) * a[k]) % MOD)\\n\", \"n, m, k = map(int, input().split())\\nans = 1\\nfor i in range(k):\\n\\tans *= (n - 1 - i)\\n\\tans //= (i + 1)\\nprint((ans * m * (m - 1) ** k) % 998244353)\", \"n,m,k = map(int, input().split())\\nimport math\\nprint((math.factorial(n-1) // math.factorial(n-k-1) // math.factorial(k) * m * (m-1) ** k) % 998244353)\", \"MOD = 998244353\\nn, m, k = input().split()\\n\\nn = int(n)\\nm = int(m)\\nk = int(k)\\n\\n# Taken from https://www.geeksforgeeks.org/binomial-coefficient-dp-9/\\ndef nCr(n , k):\\n    C = [0 for i in range(k+1)]\\n    C[0] = 1\\n\\n    for i in range(1,n+1):\\n        j = min(i ,k)\\n        while (j>0):\\n            C[j] = C[j] + C[j-1]\\n            j -= 1\\n    return C[k]\\n\\nanswer = m * nCr(n-1, k) * (m-1)**k\\nprint(answer%MOD)\\n\", \"'''input\\n3 2 1\\n6 3 2\\n5 3 0\\n3 3 1\\n3 3 0\\n'''\\nn, m, k = list(map(int, input().split()))\\nMOD  = 998244353\\nans = m * pow(m - 1, k, MOD) % MOD\\n'''\\nfor i in range(k + 1):\\n\\tif i & 1:\\n\\t\\tans -= m * pow(m - 1, k - i, MOD)\\n\\telse:\\n\\t\\tans += m * pow(m - 1, k - i, MOD)\\n'''\\n\\n\\nfor i in range(n - k, n):\\n\\tans = ans * i\\nfor i in range(n - k, n):\\n\\t# print(n - 1 - i)\\n\\tans = ans // (n - i)\\n'''\\nfor i in range(1, k + 1):\\n\\tprint(ans)\\n\\tans = ans * (n - 1 - i) * pow(i, MOD - 2, MOD) % MOD\\n'''\\nprint(ans % MOD)\\n\", \"\\nmod=998244353\\ndef nCrModp(n, r): \\n  \\n    # The array C is going to store last row of \\n    # pascal triangle at the end. And last entry \\n    # of last row is nCr. \\n    C = [0 for i in range(r+1)] \\n  \\n    C[0] = 1 # Top row of Pascal Triangle \\n  \\n    # One by constructs remaining rows of Pascal \\n    # Triangle from top to bottom \\n    for i in range(1, n+1): \\n  \\n        # Fill entries of current row  \\n        # using previous row values \\n        for j in range(min(i, r), 0, -1): \\n  \\n            # nCj = (n - 1)Cj + (n - 1)C(j - 1) \\n            C[j] = (C[j] + C[j-1]) % mod\\n  \\n    return C[r]\\n\\nn,m,k=map(int,input().split())\\nif(m==1 and k>0):\\n    print(0)\\nelse:\\n    ans=m\\n    ans=((ans%mod)*(pow(m-1,k,mod)%mod))%mod\\n    val1=nCrModp(n-1,k)\\n    ans=((ans%mod)*(val1%mod))%mod\\n    print(ans)\", \"from math import factorial\\nn, m, k = list(map(int, input().split()))\\nif k == 0:\\n    print(m)\\nelse:\\n    try:\\n        print(m*(m-1)**k*(factorial(n-1)//(factorial(k)*factorial(n-k-1))) % 998244353)\\n    except:\\n        print(0)\\n\", \"import sys\\nfrom math import ceil, floor, factorial\\nimport operator as op\\nfrom functools import reduce\\n\\ninput = sys.stdin.readline\\n\\ndef ncr(n,r):\\n    f = factorial\\n    return (f(n) // f(r) // f(n-r)) % 998244353\\n\\nn, m, k = map(int, input().split())\\n\\nif k >= n:\\n    print(0)\\n    return\\n\\ncolorings = m\\nfor i in range(k):\\n    colorings *= (m-1)\\n    colorings %= 998244353 \\n\\nprint(int(((ncr(n-1, k) % 998244353) * colorings) % 998244353) % 998244353)\"]",
  "input_output": "{\n  \"inputs\": [\n    \"3 3 0\\n\",\n    \"3 2 1\\n\",\n    \"3 3 2\\n\",\n    \"123 45 67\\n\",\n    \"1234 567 890\\n\",\n    \"2000 23 45\\n\",\n    \"50 2000 40\\n\",\n    \"2000 2 1999\\n\",\n    \"3 1 0\\n\",\n    \"3 1 1\\n\",\n    \"1 1 0\\n\",\n    \"1 534 0\\n\",\n    \"1926 817 0\\n\",\n    \"1999 233 1998\\n\",\n    \"1139 1252 348\\n\",\n    \"1859 96 1471\\n\",\n    \"1987 237 1286\\n\",\n    \"1411 1081 1082\\n\",\n    \"1539 1221 351\\n\",\n    \"259 770 5\\n\",\n    \"387 1422 339\\n\",\n    \"515 1563 110\\n\",\n    \"1939 407 1072\\n\",\n    \"518 518 36\\n\",\n    \"646 1171 131\\n\",\n    \"70 1311 53\\n\",\n    \"1494 155 101\\n\",\n    \"918 1704 848\\n\",\n    \"1046 1844 18\\n\",\n    \"1174 688 472\\n\",\n    \"1894 637 1635\\n\",\n    \"22 1481 21\\n\",\n    \"1446 1030 111\\n\",\n    \"1440 704 520\\n\",\n    \"1569 1548 644\\n\",\n    \"289 393 19\\n\",\n    \"417 1045 383\\n\",\n    \"1841 1185 1765\\n\",\n    \"1969 30 744\\n\",\n    \"1393 874 432\\n\",\n    \"817 1719 588\\n\",\n    \"945 563 152\\n\",\n    \"369 511 235\\n\",\n    \"555 1594 412\\n\",\n    \"2000 1234 1800\\n\",\n    \"1999 333 1000\\n\",\n    \"2000 2000 1999\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n\",\n    \"4\\n\",\n    \"12\\n\",\n    \"212505593\\n\",\n    \"661457723\\n\",\n    \"383618765\\n\",\n    \"461299924\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"534\\n\",\n    \"817\\n\",\n    \"929315320\\n\",\n    \"933447185\\n\",\n    \"33410781\\n\",\n    \"609458581\\n\",\n    \"238077838\\n\",\n    \"938987357\\n\",\n    \"711761505\\n\",\n    \"383877548\\n\",\n    \"971635624\\n\",\n    \"405465261\\n\",\n    \"600327272\\n\",\n    \"200804462\\n\",\n    \"697377585\\n\",\n    \"97784646\\n\",\n    \"229358995\\n\",\n    \"502244233\\n\",\n    \"937340189\\n\",\n    \"189307651\\n\",\n    \"870324282\\n\",\n    \"794075632\\n\",\n    \"954730150\\n\",\n    \"925334150\\n\",\n    \"184294470\\n\",\n    \"517114866\\n\",\n    \"773828348\\n\",\n    \"618963319\\n\",\n    \"676801447\\n\",\n    \"569385432\\n\",\n    \"386567314\\n\",\n    \"520296460\\n\",\n    \"438918750\\n\",\n    \"550745740\\n\",\n    \"101641915\\n\",\n    \"694730459\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1081/C",
  "starter_code": ""
}