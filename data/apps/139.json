{
  "task_id": "APPS/139",
  "problem_id": 139,
  "prompt": "You are given a directed graph consisting of n vertices and m edges (each edge is directed, so it can be traversed in only one direction). You are allowed to remove at most one edge from it.\n\nCan you make this graph acyclic by removing at most one edge from it? A directed graph is called acyclic iff it doesn't contain any cycle (a non-empty path that starts and ends in the same vertex).\n\n\n-----Input-----\n\nThe first line contains two integers n and m (2 \u2264 n \u2264 500, 1 \u2264 m \u2264 min(n(n - 1), 100000)) \u2014 the number of vertices and the number of edges, respectively.\n\nThen m lines follow. Each line contains two integers u and v denoting a directed edge going from vertex u to vertex v (1 \u2264 u, v \u2264 n, u \u2260 v). Each ordered pair (u, v) is listed at most once (there is at most one directed edge from u to v).\n\n\n-----Output-----\n\nIf it is possible to make this graph acyclic by removing at most one edge, print YES. Otherwise, print NO.\n\n\n-----Examples-----\nInput\n3 4\n1 2\n2 3\n3 2\n3 1\n\nOutput\nYES\n\nInput\n5 6\n1 2\n2 3\n3 2\n3 1\n2 1\n4 5\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example you can remove edge $2 \\rightarrow 3$, and the graph becomes acyclic.\n\nIn the second example you have to remove at least two edges (for example, $2 \\rightarrow 1$ and $2 \\rightarrow 3$) in order to make the graph acyclic.",
  "solutions": "[\"n,m = map(int, input().split())\\ng = [[] for i in range(n)]\\nfor _ in range(m):\\n    u,v = map(int, input().split())\\n    g[u-1].append(v-1)\\n\\nst = []\\nvis = [0 for _ in range(n)]\\nnxt = [0 for _ in range(n)]\\nes = set()\\ncycle=False\\nfor i in range(n):\\n    if cycle:\\n        break\\n    if vis[i] != 0:\\n        continue\\n    st = [i]\\n    vis[i] = 1\\n    while len(st) > 0:\\n        v = st[-1]\\n        if nxt[v] < len(g[v]):\\n            u = g[v][nxt[v]]\\n            nxt[v] += 1\\n            if vis[u] == 0 or vis[u] == 2:\\n                vis[u] = 1\\n                st.append(u)\\n            else:\\n                ns = set()\\n                fr = len(st)-1\\n                to = u\\n                while 1:\\n                    ns.add((st[fr], to))\\n                    if st[fr] == u and len(ns) > 1:\\n                        break\\n                    elif st[fr] == u:\\n                        ns.add((to, st[fr]))\\n                        break\\n                    to = st[fr]\\n                    fr -= 1\\n                es = ns\\n                cycle =True\\n                break\\n        else:\\n            vis[v] = 2\\n            del st[-1]\\nif not cycle:\\n    print('YES')\\n    return\\nif len(es) == 50 and n == 500 and m == 100000:\\n    print('NO')\\n    return\\nfor edge in es:\\n    vis = [0 for _ in range(n)]\\n    nxt = [0 for _ in range(n)]\\n    fail = False\\n    for i in range(n):\\n        if vis[i] != 0:\\n            continue\\n        st = [i]\\n        vis[i] = 1\\n        while len(st) > 0:\\n            v = st[-1]\\n            if nxt[v] < len(g[v]):\\n                u = g[v][nxt[v]]\\n                nxt[v] += 1\\n                if v == edge[0] and u == edge[1]:\\n                    continue\\n                if vis[u] == 0 or vis[u] == 2:\\n                    vis[u] = 1\\n                    st.append(u)\\n                else:\\n                    fail = True\\n                    break\\n            else:\\n                vis[v] = 2\\n                del st[-1]\\n    if not fail:\\n        print('YES')\\n        return\\nprint('NO')\", \"n, m = [int(x) for x in input().split()]\\na = [[] for i in range(n)]\\nfor i in range(m):\\n    u, v = [int(x) for x in input().split()]\\n    a[u - 1].append(v - 1)\\n\\ncolor = [0] * n # 0 - white, 1 - grey, 2 - black\\ncycle = []\\nblocked_u, blocked_v = -1, -1\\n\\ndef dfs(u):\\n    nonlocal color\\n    nonlocal cycle\\n    if color[u]:\\n        return\\n    color[u] = 1\\n    for v in a[u]:\\n        if u == blocked_u and v == blocked_v:\\n            continue\\n        if color[v] == 0:\\n            dfs(v)\\n        if color[v] == 1 or cycle:\\n            if not(cycle):\\n                cycle.append(v)\\n            cycle.append(u)\\n            return True\\n    color[u] = 2\\n    return False\\n\\ndef find_cycle():\\n    nonlocal color\\n    nonlocal cycle\\n    color = [0] * n # 0 - white, 1 - grey, 2 - black\\n    cycle = []\\n    for u in range(n):\\n        if dfs(u):\\n            break\\n    result = cycle[::-1]\\n    return {(result[i], result[(i + 1) % len(result)]) for i in range(len(result))}\\n\\ncur = find_cycle()\\nif not(cur):\\n    print('YES')\\n    return\\n\\nfor bu, bv in cur:\\n    blocked_u = bu\\n    blocked_v = bv\\n    new = find_cycle()\\n\\n    if not(new):\\n        print('YES')\\n        return\\n\\nprint('NO')\\n\", \"def dfs(g, u, visited, call_stack):\\n    visited[u] = True\\n    call_stack.add(u)\\n    for v in g[u]:\\n        if v in call_stack:\\n            return [u, v]\\n        if not visited[v]:\\n            d = dfs(g, v, visited, call_stack)\\n            call_stack.discard(v)\\n            if d is not None:\\n                return [u] + d\\n    return None\\n\\n\\ndef find_cycle(g, n):\\n    visited = [False] * n\\n    d = None\\n    for i in range(n):\\n        if not visited[i]:\\n            call_stack = set()\\n            d = dfs(g, i, visited, call_stack)\\n            if d is not None:\\n                break\\n    return d\\n\\n\\ndef __starting_point():\\n    n, m = map(int, input().split())\\n\\n    g = []\\n    for _ in range(n):\\n        g.append([])\\n\\n    for _ in range(m):\\n        u, v = map(int, input().split())\\n        g[u-1].append(v-1)\\n\\n    out = False\\n    c = find_cycle(g, n)\\n    if c:\\n        first_index = c.index(c[-1])\\n        c = c[first_index:]\\n\\n        for i in range(len(c)-1):\\n            if i != 0:\\n                g[c[i-1]].append(c[i])\\n            g[c[i]].remove(c[i+1])\\n            out = out or find_cycle(g, n) is None\\n    else:\\n        out = True\\n\\n    print('YES' if out else 'NO')\\n__starting_point()\", \"cycle_begin, cycle_end = -1, -1\\ng, mark, prev, edges = [], [], [], []\\n\\ndef dfs(u):\\n    nonlocal cycle_begin, cycle_end\\n    mark[u] = 1\\n    for v in g[u]:\\n        if mark[v] == 0:\\n            prev[v] = u\\n            if dfs(v):\\n                return True\\n        elif mark[v] == 1:\\n            cycle_begin = v\\n            cycle_end = u\\n            return True\\n    mark[u] = 2\\n    return False\\n\\ndef dfs2(u):\\n    mark[u] = 1\\n    for v in g[u]:\\n        if v != -1:\\n            if mark[v] == 0:\\n                if dfs2(v):\\n                    return True\\n            elif mark[v] == 1:\\n                return True\\n    mark[u] = 2\\n    return False\\n\\nn, m = list(map(int, input().split()))\\ng = [[] for i in range(n)]\\nmark = [0 for i in range(n)]\\nprev = [-1 for i in range(n)]\\nfor i in range(m):\\n    u, v = list(map(int, input().split()))\\n    u -= 1\\n    v -= 1\\n    g[u].append(v)\\nfor i in range(n):\\n    if mark[i] == 0 and dfs(i):\\n        break\\nif cycle_begin == -1:\\n    print(\\\"YES\\\")\\nelse:\\n    cycle = []\\n    i = cycle_end\\n    while i != cycle_begin:\\n        cycle.append(i)\\n        i = prev[i]\\n    cycle.append(cycle_begin)\\n    cycle.reverse()\\n    edges = []\\n    for i in range(len(cycle) - 1):\\n        edges.append(tuple((cycle[i], cycle[i + 1])))\\n    edges.append(tuple((cycle[len(cycle) - 1], cycle[0])))\\n    can = False\\n    while len(edges) > 0:\\n        f = edges[0][0]\\n        s = edges[0][1]\\n        g[f][g[f].index(s)] = -1\\n        mark = [0 for i in range(n)]\\n        have = False\\n        for i in range(n):\\n            if mark[i] == 0 and dfs2(i):\\n                have = True\\n                break\\n        g[f][g[f].index(-1)] = s\\n        if not have:\\n            can = True\\n            break\\n        edges.pop(0)\\n    if can:\\n        print(\\\"YES\\\")   \\n    else:\\n        print(\\\"NO\\\")\\n\", \"cycle_begin, block_u, block_v = -1, -1, -1\\ng, mark, prev, cycle = [], [], [], []\\n\\n\\ndef dfs(u):\\n    nonlocal cycle_begin\\n    mark[u] = 1\\n    for v in g[u]:\\n        if u == block_u and v == block_v:\\n            continue\\n        if mark[v] == 0:\\n            prev[v] = u\\n            if dfs(v):\\n                return True\\n        elif mark[v] == 1:\\n            prev[v] = u\\n            cycle_begin = u\\n            return True\\n    mark[u] = 2\\n    return False\\n\\n\\nn, m = list(map(int, input().split()))\\n\\ng = [[] for _ in range(n)]\\nmark = [0 for _ in range(n)]\\nprev = [0 for _ in range(n)]\\n\\nfor _ in range(m):\\n    u, v = list(map(int, input().split()))\\n    u -= 1\\n    v -= 1\\n    g[u].append(v)\\n\\nfor i in range(n):\\n    if mark[i] == 0 and dfs(i):\\n        break\\n\\nif cycle_begin == -1:\\n    print(\\\"YES\\\")\\nelse:\\n    u = cycle_begin\\n    while u != cycle_begin or len(cycle) == 0:\\n        cycle.append(u)\\n        u = prev[u]\\n    cycle.append(cycle_begin)\\n    \\n    for u in range(len(cycle) - 1, 0, -1):\\n        block_u = cycle[u]\\n        block_v = cycle[u - 1]\\n        mark = [0 for _ in range(n)]\\n        have = False\\n        for u in range(n):\\n            if mark[u] == 0 and dfs(u):\\n                have = True\\n                break\\n        if not have:\\n            print(\\\"YES\\\")\\n            return\\n\\n    print(\\\"NO\\\")\\n\", \"have = False\\ncycle_begin, block_u, block_v = -1, -1, -1\\ng, mark, cycle = [], [], []\\n\\n\\ndef dfs(u):\\n    nonlocal have, cycle_begin\\n    mark[u] = 1\\n    for v in g[u]:\\n        if u == block_u and v == block_v:\\n            continue\\n        if mark[v] == 0:\\n            if dfs(v):\\n                if have:\\n                    cycle.append(u)\\n                if u == cycle_begin:\\n                    have = False\\n                return True\\n        elif mark[v] == 1:\\n            have = True\\n            cycle_begin = v\\n            cycle.append(u)\\n            return True\\n    mark[u] = 2\\n    return False\\n\\n\\nn, m = list(map(int, input().split()))\\n\\ng = [[] for _ in range(n)]\\nmark = [0 for _ in range(n)]\\n\\nfor _ in range(m):\\n    u, v = list(map(int, input().split()))\\n    u -= 1\\n    v -= 1\\n    g[u].append(v)\\n\\nfor i in range(n):\\n    if mark[i] == 0 and dfs(i):\\n        break\\n\\nif cycle_begin == -1:\\n    print(\\\"YES\\\")\\nelse:\\n    cycle.append(cycle[0])\\n    for u in range(len(cycle) - 1, 0, -1):\\n        block_u = cycle[u]\\n        block_v = cycle[u - 1]\\n        mark = [0 for _ in range(n)]\\n        ok = True\\n        for u in range(n):\\n            if mark[u] == 0 and dfs(u):\\n                ok = False\\n                break\\n        if ok:\\n            print(\\\"YES\\\")\\n            return\\n\\n    print(\\\"NO\\\")\\n\", \"\\n\\ndef my_solve(n, m, graph, mask):\\n\\tif do_dfs_bool(n,graph,mask.copy()):\\n\\t\\tc = get_cyclic(n, graph, mask)\\n\\t\\tfor u,v in c:\\n\\t\\t\\tgraph[u].remove(v)\\n\\t\\t\\tif not do_dfs_bool(n,graph,mask.copy()):\\n\\t\\t\\t\\treturn 'YES'\\n\\t\\t\\tgraph[u].append(v)\\n\\t\\treturn \\\"NO\\\"\\n\\treturn \\\"YES\\\"\\n\\ndef get_cyclic(n, graph, mask):\\n\\tc,v = do_dfs(n,graph,mask)\\n\\tpath = []\\n\\ti = 0\\n\\tbegin = False\\n\\tif c:\\n\\t\\tfor u in c.keys():\\n\\t\\t\\tif c[u] == v:\\n\\t\\t\\t\\tbegin = True\\n\\t\\t\\t\\tpath.append((c[u],u))\\n\\t\\t\\telif begin:\\n\\t\\t\\t\\tpath.append((c[u],u))\\n\\t\\ttmp = list(c.keys())\\n\\t\\tif len(tmp):\\n\\t\\t\\tpath.append((tmp[-1],v))\\n\\treturn path\\n\\ndef do_dfs_bool(n, graph, mask):\\n\\tcolors = [0]*(n+5)\\n\\tfor u in graph.keys():\\n\\t\\tif not u in mask.keys():\\n\\t\\t\\tif dfs_bool(u,graph,mask,colors):\\n\\t\\t\\t\\treturn True\\n\\treturn False\\n\\n\\ndef dfs_bool(u, graph, mask,colors):\\n\\tcolors[u] = 1\\n\\tmask[u] = True\\n\\tfor v in graph[u]:\\n\\t\\tif colors[v] == 1:\\n\\t\\t\\treturn True\\n\\t\\tif colors[v] == 0:\\n\\t\\t\\tif dfs_bool(v,graph,mask,colors):\\t\\t\\t\\t\\n\\t\\t\\t\\treturn True\\n\\tcolors[u] = 2\\n\\treturn False\\n\\ndef do_dfs(n, graph, mask):\\n\\tcolors = [0]*(n+5)\\n\\tc = {}\\n\\tfor u in graph.keys():\\n\\t\\tif not u in mask.keys():\\n\\t\\t\\tc = {}\\n\\t\\t\\tp, v = dfs(u,graph,mask,c,colors)\\n\\t\\t\\tif p and v:\\n\\t\\t\\t\\treturn (p,v)\\n\\n\\ndef dfs(u, graph, mask, c, colors):\\n\\tcolors[u] = 1\\n\\tfor v in graph[u]:\\n\\t\\tif colors[v] == 1:\\n\\t\\t\\treturn (c, v)\\n\\t\\tif colors[v] == 0:\\n\\t\\t\\tc[v] = u\\n\\t\\t\\tp,w = dfs(v,graph,mask,c,colors)\\n\\t\\t\\tif w:\\n\\t\\t\\t\\treturn (p,w)\\n\\tcolors[u] = 2\\n\\tif len(c) > 0:\\n\\t\\tif u in c.keys():\\n\\t\\t\\tdel c[u]\\n\\treturn (c, None)\\n\\ndef test(n, m, edges):\\n\\tgraph = {}\\n\\tmask = {}\\n\\tfor u,v in edges:\\n\\t\\tif u not in graph.keys():\\n\\t\\t\\tgraph[u] = []\\n\\t\\tgraph[u].append(v)\\n\\t\\tif v not in graph.keys():\\n\\t\\t\\tgraph[v] = []\\n\\treturn my_solve(n, m, graph, mask)\\n\\n\\ndef __starting_point():\\n\\tn,m = [int(x) for x in input().split()]\\n\\tedges = []\\n\\tfor i in range(0,m):\\n\\t\\tu,v = [int(x) for x in input().split()]\\n\\t\\tedges.append((u,v))\\n\\tprint(test(n, m, edges))\\n__starting_point()\", \"import sys\\n\\ninput = sys.stdin.readline\\n\\n\\ndef get_input():\\n    n, m = [int(x) for x in input().split(' ')]\\n    digraph = [[] for _ in range(n + 1)]\\n    for _ in range(m):\\n        c1, c2 = [int(x) for x in input().split(' ')]\\n        digraph[c1].append(c2)\\n\\n    return digraph\\n\\n\\ndef dfs(graph, u=-1, v=-1):\\n    n = len(graph)\\n\\n    pi = [None] * n\\n    color = ['white'] * n\\n    for node in range(1, n):\\n        if color[node] == 'white':\\n            cicle = dfs_visit(graph, node, color, pi, u, v)\\n            if cicle is not None:\\n                return cicle\\n    return None\\n\\n\\ndef dfs_visit(graph, root, color, pi, u, v):\\n    stack = [root]\\n\\n    while stack:\\n        current_node = stack[-1]\\n\\n        if color[current_node] != 'white':\\n            stack.pop()\\n            color[current_node] = 'black'\\n            continue\\n\\n        color[current_node] = 'grey'\\n        for adj in graph[current_node]:\\n            if (current_node, adj) == (u, v):\\n                continue\\n\\n            if color[adj] == 'white':\\n                pi[adj] = current_node\\n                stack.append(adj)\\n            elif color[adj] == 'grey':\\n                cicle = [adj]\\n                while current_node != adj:\\n                    cicle.append(current_node)\\n                    current_node = pi[current_node]\\n                cicle.append(adj)\\n                return cicle  \\n    return None\\n\\n\\ndef __starting_point():\\n    digraph = get_input()\\n    cicle = dfs(digraph)\\n    if cicle is None:\\n        print(\\\"YES\\\")\\n    else:\\n        cicle.reverse()\\n        for i in range(len(cicle) - 1):\\n            c = dfs(digraph, cicle[i], cicle[i + 1])\\n            if c is None:\\n                print(\\\"YES\\\")\\n                break\\n        else:\\n            print(\\\"NO\\\")\\n\\n__starting_point()\"]",
  "input_output": "{\n  \"inputs\": [\n    \"3 4\\n1 2\\n2 3\\n3 2\\n3 1\\n\",\n    \"5 6\\n1 2\\n2 3\\n3 2\\n3 1\\n2 1\\n4 5\\n\",\n    \"2 2\\n1 2\\n2 1\\n\",\n    \"7 7\\n1 3\\n3 6\\n3 7\\n5 3\\n6 2\\n6 7\\n7 2\\n\",\n    \"500 50\\n396 340\\n47 341\\n422 140\\n492 209\\n263 248\\n461 300\\n124 495\\n33 6\\n93 384\\n389 182\\n130 297\\n217 329\\n131 136\\n355 94\\n388 275\\n115 368\\n279 462\\n126 285\\n185 287\\n223 221\\n207 167\\n203 127\\n39 245\\n394 444\\n166 99\\n399 328\\n3 276\\n142 325\\n284 153\\n65 3\\n102 5\\n459 168\\n156 17\\n99 162\\n293 194\\n493 198\\n171 356\\n269 155\\n479 37\\n269 336\\n28 183\\n363 43\\n398 45\\n142 68\\n437 301\\n150 353\\n1 211\\n326 340\\n459 14\\n90 441\\n\",\n    \"4 5\\n1 3\\n3 2\\n2 1\\n3 4\\n4 1\\n\",\n    \"5 6\\n1 3\\n2 1\\n3 5\\n4 3\\n5 4\\n3 2\\n\",\n    \"3 4\\n1 2\\n2 1\\n1 3\\n3 1\\n\",\n    \"5 7\\n1 2\\n2 3\\n3 1\\n3 4\\n4 1\\n4 5\\n5 1\\n\",\n    \"4 6\\n1 2\\n2 3\\n3 1\\n3 2\\n3 4\\n4 2\\n\",\n    \"4 5\\n1 2\\n2 3\\n3 4\\n4 1\\n3 1\\n\",\n    \"6 6\\n1 2\\n2 3\\n3 1\\n4 5\\n5 6\\n6 3\\n\",\n    \"4 6\\n2 3\\n3 2\\n3 4\\n4 3\\n4 2\\n2 4\\n\",\n    \"4 5\\n1 2\\n2 3\\n2 4\\n3 1\\n4 1\\n\",\n    \"4 5\\n1 2\\n2 1\\n3 4\\n4 3\\n1 3\\n\",\n    \"7 6\\n2 3\\n3 4\\n4 2\\n5 6\\n6 7\\n7 5\\n\",\n    \"5 6\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n4 2\\n\",\n    \"4 4\\n1 2\\n2 1\\n3 4\\n4 3\\n\",\n    \"7 9\\n1 2\\n2 3\\n1 3\\n3 4\\n3 5\\n5 6\\n6 1\\n6 7\\n7 1\\n\",\n    \"8 7\\n1 2\\n2 3\\n3 4\\n4 1\\n4 5\\n5 6\\n6 3\\n\",\n    \"4 6\\n1 2\\n2 4\\n2 3\\n3 1\\n4 3\\n3 2\\n\",\n    \"5 6\\n1 2\\n2 3\\n3 4\\n4 5\\n4 1\\n5 2\\n\",\n    \"4 5\\n2 4\\n1 2\\n2 1\\n3 4\\n4 3\\n\",\n    \"6 8\\n1 2\\n2 3\\n3 1\\n2 4\\n4 5\\n5 1\\n2 6\\n6 1\\n\",\n    \"6 8\\n1 2\\n2 3\\n3 4\\n4 1\\n3 5\\n5 6\\n6 2\\n1 3\\n\",\n    \"6 7\\n1 2\\n2 5\\n5 6\\n6 1\\n5 4\\n4 3\\n3 2\\n\",\n    \"10 22\\n1 2\\n1 3\\n1 4\\n1 5\\n2 3\\n2 4\\n2 5\\n3 4\\n3 5\\n4 5\\n6 7\\n6 8\\n6 9\\n6 10\\n7 8\\n7 9\\n7 10\\n8 9\\n8 10\\n9 10\\n5 6\\n10 1\\n\",\n    \"4 6\\n1 2\\n2 3\\n3 4\\n4 1\\n2 4\\n3 1\\n\",\n    \"5 7\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n1 3\\n3 5\\n\",\n    \"5 6\\n1 2\\n2 3\\n3 4\\n4 5\\n4 2\\n5 2\\n\",\n    \"4 5\\n2 3\\n3 4\\n4 2\\n2 4\\n3 2\\n\",\n    \"7 8\\n1 2\\n2 3\\n3 4\\n4 5\\n5 2\\n3 6\\n6 7\\n7 2\\n\",\n    \"4 5\\n1 2\\n2 3\\n3 4\\n4 1\\n1 3\\n\",\n    \"4 6\\n1 2\\n2 3\\n3 4\\n4 1\\n2 4\\n4 2\\n\",\n    \"8 9\\n2 6\\n5 6\\n5 2\\n3 5\\n4 5\\n6 4\\n1 2\\n2 8\\n2 3\\n\",\n    \"8 10\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n7 1\\n5 4\\n4 8\\n8 5\\n\",\n    \"6 6\\n1 2\\n2 3\\n3 1\\n4 5\\n5 6\\n6 4\\n\",\n    \"5 8\\n1 4\\n1 5\\n4 2\\n4 3\\n5 2\\n5 3\\n2 1\\n3 1\\n\",\n    \"5 6\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n1 4\\n\",\n    \"4 5\\n1 2\\n2 4\\n2 3\\n3 1\\n4 3\\n\",\n    \"5 8\\n4 3\\n3 1\\n4 1\\n5 1\\n5 2\\n1 4\\n1 3\\n5 3\\n\",\n    \"6 12\\n2 1\\n2 3\\n2 4\\n3 4\\n4 1\\n1 3\\n1 5\\n5 4\\n6 5\\n6 4\\n6 1\\n1 4\\n\",\n    \"6 8\\n1 2\\n2 3\\n3 4\\n1 5\\n5 6\\n6 4\\n4 1\\n4 2\\n\",\n    \"8 11\\n5 1\\n1 2\\n1 6\\n6 2\\n2 3\\n2 7\\n7 3\\n3 4\\n3 8\\n8 4\\n4 1\\n\",\n    \"4 6\\n1 2\\n2 3\\n3 4\\n4 1\\n1 3\\n3 1\\n\",\n    \"5 8\\n1 2\\n1 3\\n1 4\\n2 3\\n3 4\\n3 5\\n5 2\\n5 1\\n\",\n    \"4 5\\n2 1\\n1 3\\n3 2\\n3 4\\n4 1\\n\",\n    \"3 4\\n3 2\\n1 2\\n2 3\\n1 3\\n\",\n    \"11 13\\n1 2\\n2 3\\n3 4\\n4 1\\n1 5\\n5 6\\n6 7\\n7 4\\n3 8\\n8 9\\n9 10\\n10 11\\n11 2\\n\",\n    \"5 8\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n4 1\\n3 5\\n1 3\\n\",\n    \"8 10\\n3 2\\n1 5\\n8 1\\n1 2\\n6 8\\n3 8\\n5 3\\n2 4\\n4 1\\n4 3\\n\",\n    \"10 14\\n3 10\\n10 9\\n9 2\\n8 3\\n4 3\\n4 2\\n1 8\\n7 1\\n6 5\\n2 7\\n6 4\\n5 8\\n10 1\\n8 10\\n\",\n    \"5 6\\n4 2\\n3 5\\n2 3\\n5 4\\n4 5\\n3 4\\n\",\n    \"3 3\\n2 3\\n2 1\\n3 2\\n\",\n    \"9 9\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n6 7\\n7 8\\n8 9\\n9 6\\n\",\n    \"10 15\\n3 9\\n2 3\\n4 10\\n6 4\\n3 10\\n6 10\\n8 6\\n6 2\\n6 7\\n9 4\\n6 3\\n10 7\\n1 3\\n8 1\\n7 3\\n\",\n    \"10 18\\n10 3\\n2 7\\n2 5\\n1 10\\n4 3\\n1 4\\n6 10\\n9 2\\n5 10\\n5 9\\n1 9\\n1 5\\n2 3\\n2 4\\n10 4\\n6 5\\n8 5\\n9 6\\n\",\n    \"10 13\\n3 5\\n1 6\\n9 6\\n5 4\\n4 7\\n10 9\\n8 7\\n5 6\\n2 10\\n9 3\\n2 4\\n6 3\\n3 10\\n\",\n    \"10 16\\n3 6\\n5 6\\n5 4\\n3 2\\n2 10\\n1 7\\n7 4\\n6 2\\n7 3\\n4 6\\n9 2\\n9 7\\n5 2\\n10 9\\n9 4\\n7 8\\n\",\n    \"10 10\\n10 1\\n6 9\\n5 3\\n9 4\\n3 8\\n2 1\\n5 9\\n8 10\\n6 5\\n10 5\\n\",\n    \"5 9\\n1 3\\n1 4\\n1 5\\n2 1\\n2 3\\n2 4\\n3 2\\n5 2\\n5 4\\n\",\n    \"10 18\\n4 10\\n7 2\\n2 1\\n7 5\\n5 6\\n6 8\\n3 9\\n3 10\\n6 9\\n8 7\\n4 3\\n2 10\\n9 5\\n7 3\\n6 4\\n7 10\\n10 5\\n3 2\\n\",\n    \"10 19\\n5 9\\n2 10\\n3 7\\n4 8\\n4 2\\n9 10\\n3 6\\n8 5\\n6 10\\n3 5\\n4 1\\n7 10\\n8 9\\n8 2\\n7 9\\n8 7\\n9 1\\n4 9\\n8 10\\n\",\n    \"5 5\\n1 2\\n2 1\\n3 4\\n3 5\\n4 5\\n\",\n    \"10 17\\n5 6\\n4 9\\n7 1\\n6 10\\n3 10\\n4 10\\n9 3\\n8 1\\n2 4\\n1 9\\n3 7\\n4 7\\n6 2\\n5 4\\n3 8\\n10 9\\n7 10\\n\",\n    \"10 13\\n7 2\\n7 10\\n10 5\\n2 9\\n10 4\\n8 3\\n4 5\\n1 8\\n7 8\\n5 7\\n2 10\\n9 6\\n5 9\\n\",\n    \"6 7\\n1 2\\n3 4\\n4 5\\n4 6\\n5 6\\n6 4\\n6 3\\n\",\n    \"6 8\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 1\\n1 3\\n4 6\\n\",\n    \"10 9\\n7 2\\n10 5\\n9 1\\n1 5\\n4 6\\n1 10\\n6 2\\n10 9\\n5 9\\n\",\n    \"10 14\\n8 2\\n10 6\\n6 1\\n8 10\\n6 2\\n1 10\\n4 7\\n1 7\\n9 1\\n3 6\\n1 4\\n7 6\\n10 4\\n8 4\\n\",\n    \"10 19\\n10 3\\n9 2\\n7 4\\n6 3\\n1 6\\n6 5\\n2 8\\n6 9\\n1 5\\n9 8\\n10 9\\n1 8\\n3 2\\n5 2\\n7 10\\n8 7\\n3 4\\n2 4\\n4 1\\n\",\n    \"10 14\\n10 1\\n8 9\\n7 2\\n8 2\\n7 3\\n7 10\\n2 10\\n6 3\\n4 1\\n6 5\\n7 8\\n10 6\\n1 2\\n8 10\\n\",\n    \"10 19\\n10 9\\n1 2\\n3 6\\n9 6\\n2 6\\n3 7\\n2 10\\n3 8\\n2 9\\n2 8\\n4 7\\n2 7\\n6 7\\n10 5\\n8 1\\n6 10\\n8 5\\n8 6\\n3 2\\n\",\n    \"10 18\\n8 2\\n9 2\\n7 4\\n2 6\\n7 1\\n5 3\\n9 4\\n3 9\\n3 8\\n10 2\\n10 1\\n9 1\\n6 7\\n10 6\\n5 6\\n9 6\\n7 5\\n7 9\\n\",\n    \"8 13\\n3 5\\n6 2\\n5 3\\n8 3\\n5 7\\n6 4\\n5 1\\n7 6\\n3 1\\n7 2\\n4 8\\n4 1\\n3 6\\n\",\n    \"7 7\\n5 1\\n3 7\\n4 3\\n1 5\\n7 5\\n3 6\\n1 6\\n\",\n    \"3 4\\n3 1\\n3 2\\n1 3\\n1 2\\n\",\n    \"5 10\\n1 3\\n3 1\\n2 3\\n1 4\\n2 4\\n2 1\\n5 3\\n5 1\\n4 1\\n3 5\\n\",\n    \"5 6\\n2 1\\n3 2\\n1 2\\n2 3\\n1 5\\n3 1\\n\",\n    \"6 7\\n6 2\\n5 4\\n2 1\\n5 2\\n6 5\\n1 5\\n5 6\\n\",\n    \"9 12\\n1 2\\n2 3\\n2 4\\n4 5\\n3 5\\n5 6\\n6 7\\n6 8\\n7 9\\n8 9\\n9 1\\n3 6\\n\",\n    \"4 6\\n1 2\\n1 3\\n3 4\\n4 2\\n4 1\\n2 3\\n\",\n    \"5 7\\n1 2\\n2 3\\n3 1\\n2 4\\n4 1\\n3 5\\n5 2\\n\",\n    \"7 10\\n1 5\\n6 2\\n2 7\\n6 3\\n5 7\\n1 2\\n3 5\\n4 3\\n5 2\\n7 5\\n\",\n    \"8 11\\n8 4\\n3 6\\n1 2\\n8 1\\n7 2\\n4 3\\n7 4\\n3 1\\n2 6\\n4 5\\n2 3\\n\",\n    \"7 16\\n6 4\\n5 1\\n6 1\\n3 7\\n3 1\\n5 4\\n6 3\\n2 7\\n6 2\\n1 4\\n5 2\\n4 7\\n1 7\\n6 5\\n7 5\\n2 4\\n\",\n    \"7 16\\n1 7\\n4 7\\n2 3\\n5 1\\n6 1\\n5 4\\n3 1\\n4 6\\n2 1\\n6 7\\n4 1\\n2 7\\n3 4\\n3 7\\n7 2\\n6 2\\n\",\n    \"4 7\\n1 2\\n3 4\\n3 2\\n1 4\\n4 1\\n4 2\\n1 3\\n\",\n    \"500 13\\n1 2\\n2 3\\n3 4\\n4 1\\n1 5\\n5 6\\n6 7\\n7 4\\n3 8\\n8 9\\n9 10\\n10 11\\n11 2\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/915/D",
  "starter_code": ""
}