{
  "task_id": "APPS/178",
  "problem_id": 178,
  "prompt": "A telephone number is a sequence of exactly $11$ digits such that its first digit is 8.\n\nVasya and Petya are playing a game. Initially they have a string $s$ of length $n$ ($n$ is odd) consisting of digits. Vasya makes the first move, then players alternate turns. In one move the player must choose a character and erase it from the current string. For example, if the current string 1121, after the player's move it may be 112, 111 or 121. The game ends when the length of string $s$ becomes 11. If the resulting string is a telephone number, Vasya wins, otherwise Petya wins.\n\nYou have to determine if Vasya has a winning strategy (that is, if Vasya can win the game no matter which characters Petya chooses during his moves).\n\n\n-----Input-----\n\nThe first line contains one integer $n$ ($13 \\le n < 10^5$, $n$ is odd) \u2014 the length of string $s$.\n\nThe second line contains the string $s$ ($|s| = n$) consisting only of decimal digits.\n\n\n-----Output-----\n\nIf Vasya has a strategy that guarantees him victory, print YES.\n\nOtherwise print NO.\n\n\n-----Examples-----\nInput\n13\n8380011223344\n\nOutput\nYES\n\nInput\n15\n807345619350641\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the first example Vasya needs to erase the second character. Then Petya cannot erase a character from the remaining string 880011223344 so that it does not become a telephone number.\n\nIn the second example after Vasya's turn Petya can erase one character character 8. The resulting string can't be a telephone number, because there is no digit 8 at all.",
  "solutions": "[\"n, s = int(input()), input()\\ncnt = (n - 11) // 2\\ncnt_8 = len(s[:n - 10].split('8')) - 1\\nif (cnt >= cnt_8):\\n\\tprint (\\\"NO\\\")\\nelse:\\n\\tprint (\\\"YES\\\")\", \"def main():\\n    n = int(input())\\n    arr = list(map(int, input()))\\n    a = arr.count(8)\\n    if a <= (n - 11) // 2:\\n        print(\\\"NO\\\")\\n        return 0\\n    i = -1\\n    cnt = 1 + (n - 11) // 2\\n    while cnt:\\n        i += 1\\n        if arr[i] == 8:\\n            cnt -= 1\\n    if i > n - 11:\\n        print(\\\"NO\\\")\\n        return 0\\n    print(\\\"YES\\\")\\n    return 0\\n\\nmain()\", \"N = int(input())\\nS = input()\\nA, B = 0, 0\\nfor i in range(N-10):\\n    if S[i] == \\\"8\\\":\\n        A += 1\\n    else:\\n        B += 1\\nif A > B:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"from collections import Counter\\n\\nn = int(input())\\ns = list(input())\\n\\nc = Counter(s[:-10])\\nif c['8'] > len(s[:-10]) // 2:\\n\\tprint('YES')\\nelse:\\n\\tprint('NO')\", \"n = int(input())\\ns = input()\\ncnt = 0\\nfor i in range(n - 10):\\n    if s[i] == '8':\\n        cnt += 1\\nif cnt >= ((n - 9) // 2):\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"from sys import *\\nfrom math import *\\nfrom collections import *\\n\\nN = int(input())\\n\\nS = input()\\n\\n\\ne = deque([])\\nn = deque([])\\n\\nfor i, v in enumerate(S):\\n    if v == '8':\\n        e += [i]\\n    else:\\n        n += [i]\\n\\ntodo = (N - 11) // 2\\n\\nfor i in range(todo):\\n    if len(n) != 0:\\n        n.popleft()\\n    else:\\n        e.pop()\\n        \\n    if len(e)!= 0:\\n        e.popleft()\\n    else:\\n        n.pop()\\n\\nif len(e) != 0 and (len(n) == 0 or n[0] > e[0]):\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\\n\\n\", \"n = int(input())\\ns = input()\\nnum = (n - 11) // 2\\nnum2 = 0\\nnum3 = -1\\nfor i in range(n):\\n    if s[i] == \\\"8\\\":\\n        num2 += 1\\n        if num2 == num + 1:\\n            num3 = i\\n            break\\nif num3 == -1 or num3 > num * 2:\\n    print(\\\"NO\\\")\\nelse:\\n    print(\\\"YES\\\")\\n\", \"n = int(input())\\ns = input()\\n\\ncnt = 0\\nfor i in range(n - 10):\\n\\tif s[i] == '8':\\n\\t\\tcnt += 1\\nsteps = (n - 11) // 2\\nif cnt <= steps:\\n\\tprint(\\\"NO\\\")\\nelse:\\n\\tprint(\\\"YES\\\")\", \"n = int(input())\\ns = input()\\nif s[:n-10].count('8')> (n-11)//2:\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"n=int(input())\\ns=input()\\nt=s[:-10]\\ncnt=t.count('8')\\nif len(t)-cnt>=cnt:\\n    print('NO')\\nelse:\\n    print('YES')\", \"def main():\\n    n = int(input())\\n    s = input()\\n    eight = 0\\n    for i in range(n-11+1):\\n        if s[i] == '8':\\n            eight += 1\\n\\n    if eight > (n-11)//2:\\n        print('YES')\\n    else:\\n        print('NO')\\n\\nmain()\\n\", \"n = int(input())\\ns = input()\\n\\ntorem = n - 11\\n\\nif s[:torem+1].count('8') > (torem+1)//2:\\n    print('YES')\\nelse:\\n    print('NO')\\n\", \"n, s = int(input()), input()\\ns = s[:n-10]\\na = s.count('8')\\nb = len(s) - a\\nprint('YES' if a >= b else 'NO')\", \"if (int(input()) - 9) // 2 <= input()[:-10].count('8'):\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"s = int(input())\\nstring = input()\\ncounter = 0\\narray = []\\nfor i in range(len(string)):\\n    if string[i] == '8':\\n        counter += 1\\n        array.append(i)\\nif (s - 11) // 2 >= counter:\\n    print('NO')\\nelif (s - 11) // 2 < counter:\\n    if array[0] > (s - 11) // 2:\\n        print('NO')\\n    elif array[(s - 11) // 2] - ((s - 11) // 2) <= (s - 11) // 2:\\n        print('YES')\\n    elif array[(s - 11) // 2] - ((s - 11) // 2) > (s - 11) // 2:\\n        print('NO')\\nelse:\\n    print('YES')\", \"n = int(input())\\nx = input()\\n\\nr = (n-11)//2\\np = x[:2*r+1]\\nif p.count(\\\"8\\\") >= r+1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"n=int(input())\\ns=input()\\nt=s[:-10]\\ncnt=t.count('8')\\nif len(t)-cnt>cnt:\\n    print('NO')\\nelse:\\n    print('YES')\", \"import sys\\ninput = sys.stdin.readline\\n\\nN=int(input())\\nS=input().strip()\\n\\nP=(N-11)//2\\n\\nfrom collections import deque\\nL=deque(S)\\ncount=0\\n\\nfor j in range(P):\\n    while len(L)!=0 and L[0]==\\\"8\\\":\\n        L.popleft()\\n        count+=1\\n\\n    if len(L)==0:\\n        print(\\\"YES\\\")\\n        return\\n\\n    L.popleft()\\n\\n    while len(L)!=0 and L[0]==\\\"8\\\":\\n        L.popleft()\\n        count+=1\\n\\nif count>P:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\", \"import sys\\nn = int(input())\\ns = input()\\nk = (n - 11) // 2\\nlicz = 0\\nfor i in range(n):\\n\\tif s[i] == '8':\\n\\t\\tlicz += 1\\nif licz <= k:\\n\\tprint(\\\"NO\\\")\\n\\treturn\\nlicz = 0\\ni = -1\\nwhile True:\\n\\ti += 1\\n\\tif s[i] == '8':\\n\\t\\tlicz += 1\\n\\tif licz == k + 1:\\n\\t\\tbreak\\nif i > 2 * k:\\n\\tprint(\\\"NO\\\")\\nelse:\\n\\tprint(\\\"YES\\\")\", \"n = int(input())\\ns = str(input())\\ncount = 0\\np = []\\nfor i in range(n):\\n\\tif s[i] == \\\"8\\\":\\n\\t\\tcount+=1\\n\\t\\tp.append(i)\\nmoves = int((n - 11)/2)\\nif moves >= count:\\n\\tprint(\\\"NO\\\")\\n\\treturn\\nelse:\\n\\tif p[moves] <= 2*moves:\\n\\t\\tprint(\\\"YES\\\")\\n\\telse:\\n\\t\\tprint(\\\"NO\\\")  \\n\\n\", \"input()\\ns=input()\\nnot8=[i for i, c in enumerate(s) if c!='8']\\nis8=[i for i, c in enumerate(s) if c=='8']\\n\\nn=len(s)\\nmoves=(n-11)//2\\n\\nif moves >= len(not8):\\n    print('YES')\\n    raise SystemExit(0)\\nif moves >= len(is8):\\n    print('NO')\\n    raise SystemExit(0)\\n\\nnot8 = not8[moves:]\\nis8 = is8[moves:]\\n\\n# print(not8, is8)\\n\\nif is8[0] < not8[0]:\\n    print('YES')\\n    raise SystemExit(0)\\nelse:\\n    print('NO')\\n    raise SystemExit(0)\\n\", \"''' CODED WITH LOVE BY SATYAM KUMAR '''\\n\\nfrom sys import stdin, stdout\\nimport cProfile, math\\nfrom collections import Counter,defaultdict\\nfrom bisect import bisect_left,bisect,bisect_right\\nimport itertools\\nfrom copy import deepcopy\\nfrom fractions import Fraction\\nimport sys, threading\\nimport operator as op\\nfrom functools import reduce\\nsys.setrecursionlimit(10**6) # max depth of recursion\\nthreading.stack_size(2**27)  # new thread will get stack of such size\\nfac_warmup = False\\nprintHeap = str()\\nmemory_constrained = False\\nP = 10**9+7\\nimport sys\\n\\nclass merge_find:\\n    def __init__(self,n):\\n        self.parent = list(range(n))\\n        self.size = [1]*n\\n        self.num_sets = n\\n        self.lista = [[_] for _ in range(n)]\\n    def find(self,a):\\n        to_update = []\\n        while a != self.parent[a]:\\n            to_update.append(a)\\n            a = self.parent[a]\\n        for b in to_update:\\n            self.parent[b] = a\\n        return self.parent[a]\\n    def merge(self,a,b):\\n        a = self.find(a)\\n        b = self.find(b)\\n        if a==b:\\n            return\\n        if self.size[a]<self.size[b]:\\n            a,b = b,a\\n        self.num_sets -= 1\\n        self.parent[b] = a\\n        self.size[a] += self.size[b]\\n        self.lista[a] += self.lista[b]\\n    def set_size(self, a):\\n        return self.size[self.find(a)]\\n    def __len__(self):\\n        return self.num_sets\\n\\ndef display(string_to_print):\\n    stdout.write(str(string_to_print) + \\\"\\\\n\\\")\\n\\ndef primeFactors(n): #n**0.5 complex \\n    factors = dict()\\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \\n        while n % i== 0: \\n            if i in factors:\\n                factors[i]+=1\\n            else: factors[i]=1\\n            n = n // i \\n    if n>2:\\n        factors[n]=1\\n    return (factors)\\n\\ndef fibonacci_modP(n,MOD):\\n    if n<2: return 1\\n    #print (n,MOD)\\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\\n\\ndef factorial_modP_Wilson(n , p): \\n    if (p <= n): \\n        return 0\\n    res = (p - 1) \\n    for i in range (n + 1, p): \\n        res = (res * cached_fn(InverseEuler,i, p)) % p \\n    return res \\n\\ndef binary(n,digits = 20):\\n    b = bin(n)[2:]\\n    b = '0'*(20-len(b))+b\\n    return b\\n\\ndef isprime(n):\\n    \\\"\\\"\\\"Returns True if n is prime.\\\"\\\"\\\"\\n    if n < 4:\\n        return True\\n    if n % 2 == 0:\\n        return False\\n    if n % 3 == 0:\\n        return False\\n    i = 5\\n    w = 2\\n    while i * i <= n:\\n        if n % i == 0:\\n            return False\\n        i += w\\n        w = 6 - w\\n    return True\\nfactorial_modP = []\\ndef warm_up_fac(MOD):\\n    nonlocal factorial_modP,fac_warmup\\n    if fac_warmup: return\\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\\n    for i in range(2,fac_warmup_size):\\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\\n    fac_warmup = True\\n\\ndef InverseEuler(n,MOD):\\n    return pow(n,MOD-2,MOD)\\n\\ndef nCr(n, r, MOD):\\n    nonlocal fac_warmup,factorial_modP\\n    if not fac_warmup:\\n        warm_up_fac(MOD)\\n        fac_warmup = True\\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\\n\\ndef test_print(*args):\\n    if testingMode:\\n        print(args)\\n\\ndef display_list(list1, sep=\\\" \\\"):\\n    stdout.write(sep.join(map(str, list1)) + \\\"\\\\n\\\")\\n\\ndef display_2D_list(li):\\n    for i in li:\\n        print(i)\\ndef prefix_sum(li):\\n    sm = 0\\n    res = []\\n    for i in li:\\n        sm+=i\\n        res.append(sm)\\n    return res\\n\\ndef get_int():\\n    return int(stdin.readline().strip())\\n\\ndef get_tuple():\\n    return map(int, stdin.readline().split())\\n\\ndef get_list():\\n    return list(map(int, stdin.readline().split()))\\nimport heapq,itertools\\npq = []                         # list of entries arranged in a heap\\nentry_finder = {}               # mapping of tasks to entries\\nREMOVED = '<removed-task>' \\ndef add_task(task, priority=0):\\n    'Add a new task or update the priority of an existing task'\\n    if task in entry_finder:\\n        remove_task(task)\\n    count = next(counter)\\n    entry = [priority, count, task]\\n    entry_finder[task] = entry\\n    heapq.heappush(pq, entry)\\n\\ndef remove_task(task):\\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\\n    entry = entry_finder.pop(task)\\n    entry[-1] = REMOVED\\n\\ndef pop_task():\\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\\n    while pq:\\n        priority, count, task = heapq.heappop(pq)\\n        if task is not REMOVED:\\n            del entry_finder[task]\\n            return task\\n    raise KeyError('pop from an empty priority queue')\\nmemory = dict()\\ndef clear_cache():\\n    nonlocal memory\\n    memory = dict()\\ndef cached_fn(fn, *args):\\n    nonlocal memory\\n    if args in memory:\\n        return memory[args]\\n    else:\\n        result = fn(*args)\\n        memory[args] = result\\n        return result\\n\\ndef ncr (n,r):\\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\\ndef binary_serach(i,li):\\n    #print(\\\"Search for \\\",i)\\n    fn = lambda x: li[x]-x//i\\n    x = -1\\n    b = len(li)\\n    while b>=1:\\n        #print(b,x)\\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\\n            x+=b\\n        b=b//2\\n    return x\\n\\n# -------------------------------------------------------------- MAIN PROGRAM\\nTestCases = False\\ntestingMode = False\\nfac_warmup_size = 10**5+100\\noptimiseForReccursion = True #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\\nfrom math import factorial\\n\\ndef main():\\n    n = get_int()\\n    st = list(input())\\n    x = (n-11)//2\\n    y = x\\n    li = []\\n    for i in st:\\n        if i!='8':\\n            li.append(i)\\n        else:\\n            x-=1\\n            if x==-1:\\n                break\\n    print(\\\"YES\\\") if len(li)<=y else print(\\\"NO\\\")\\n\\n# --------------------------------------------------------------------- END=\\n\\n\\nif TestCases: \\n    for i in range(get_int()): \\n        cProfile.run('main()') if testingMode else main(i) \\nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()\", \"N = int(input())\\nS = input()\\nturns = (N - 11) // 2\\ncnt = 0\\nfor i in range(N - 10):\\n    if S[i] == '8':\\n        cnt += 1\\nif cnt >= turns + 1:\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\", \"# coding: utf-8\\nimport sys\\nfrom heapq import heappush, heappop, heapify\\nsys.setrecursionlimit(int(1e7))\\n\\ndef main():\\n    n = int(input().strip())\\n    s = input().strip()\\n    V = [i for i in range(n) if s[i]!='8']\\n    P = [i for i in range(n) if s[i]=='8']\\n    heapify(V)\\n    heapify(P)\\n    while len(V)+len(P)>11 and len(V)*len(P)>0:\\n        heappop(V)\\n        heappop(P)\\n    yes = len(V)==0 or (len(V)*len(P)>0 and P[0]<V[0])\\n    print('YES' if yes else 'NO')\\n    return\\n\\nwhile 1:\\n    try: main()\\n    except EOFError: break\", \"n = int(input())\\nx = list(input())\\na = (n-11+1)//2\\nb = (n-11)//2\\nfor i,ch in enumerate(x):\\n    if ch == '8':\\n        if b > 0:\\n            b -= 1\\n            x[i] = None\\n    else:\\n        if a > 0:\\n            a -= 1\\n            x[i] = None\\nfor c in x:\\n    if c != None:\\n        if c != '8':\\n            print(\\\"NO\\\")\\n        else:\\n            print(\\\"YES\\\")\\n        break\"]",
  "input_output": "{\n  \"inputs\": [\n    \"13\\n8380011223344\\n\",\n    \"15\\n807345619350641\\n\",\n    \"19\\n8181818181111111111\\n\",\n    \"29\\n88811188118181818118111111111\\n\",\n    \"15\\n980848088815548\\n\",\n    \"13\\n9999999998888\\n\",\n    \"13\\n0000008888888\\n\",\n    \"13\\n2480011223348\\n\",\n    \"17\\n87879887989788999\\n\",\n    \"21\\n123456788888812378910\\n\",\n    \"15\\n008880000000000\\n\",\n    \"15\\n888888888888888\\n\",\n    \"15\\n118388111881111\\n\",\n    \"13\\n8489031863524\\n\",\n    \"17\\n88818818888888888\\n\",\n    \"13\\n8899989999989\\n\",\n    \"13\\n1111111111188\\n\",\n    \"13\\n4366464181897\\n\",\n    \"21\\n888888888888888888888\\n\",\n    \"15\\n778887777777777\\n\",\n    \"13\\n8830011223344\\n\",\n    \"13\\n8888888888848\\n\",\n    \"13\\n1181111111111\\n\",\n    \"13\\n8000000000000\\n\",\n    \"13\\n1885498606803\\n\",\n    \"15\\n008888888888808\\n\",\n    \"15\\n961618782888818\\n\",\n    \"13\\n8789816534772\\n\",\n    \"13\\n8898173131489\\n\",\n    \"13\\n8800000000000\\n\",\n    \"13\\n2808118288444\\n\",\n    \"15\\n880000000000000\\n\",\n    \"13\\n8086296018422\\n\",\n    \"13\\n1841516902093\\n\",\n    \"31\\n0088888888888880000000000088888\\n\",\n    \"13\\n8559882884055\\n\",\n    \"13\\n3348729291920\\n\",\n    \"17\\n00000000088888888\\n\",\n    \"13\\n3388888888888\\n\",\n    \"17\\n11111118888888888\\n\",\n    \"13\\n6831940550586\\n\",\n    \"15\\n008888888888888\\n\",\n    \"13\\n8701234567790\\n\",\n    \"13\\n2822222225888\\n\",\n    \"13\\n0178528856351\\n\",\n    \"13\\n0088888888880\\n\",\n    \"15\\n181888888888888\\n\",\n    \"109\\n8800880880088088880888808880888088800880888088088088888080880000080000800000808008008800080008000888000808880\\n\",\n    \"47\\n08800008800800000088088008800080088800000808008\\n\",\n    \"13\\n2828222222222\\n\",\n    \"95\\n00008080008880080880888888088800008888000888800800000808808800888888088080888808880080808088008\\n\",\n    \"71\\n08880000000000808880808800880000008888808008008080880808088808808888080\\n\",\n    \"41\\n00008080008088080080888088800808808008880\\n\",\n    \"23\\n88338486848889054012825\\n\",\n    \"23\\n11868668827888348121163\\n\",\n    \"13\\n2877892266089\\n\",\n    \"19\\n1845988185966619131\\n\",\n    \"17\\n28681889938480569\\n\",\n    \"19\\n8881328076293351500\\n\",\n    \"13\\n8665978038580\\n\",\n    \"13\\n8896797594523\\n\",\n    \"23\\n79818882846090973951051\\n\",\n    \"19\\n8848893007368770958\\n\",\n    \"21\\n860388889843547436129\\n\",\n    \"13\\n0880080008088\\n\",\n    \"17\\n83130469783251338\\n\",\n    \"13\\n1341126906009\\n\",\n    \"23\\n83848888383730797684584\\n\",\n    \"15\\n488081563941254\\n\",\n    \"21\\n974378875888933268270\\n\",\n    \"13\\n2488666312263\\n\",\n    \"15\\n880082334812345\\n\",\n    \"15\\n348808698904345\\n\",\n    \"15\\n200080200228220\\n\",\n    \"41\\n11111111111111188888888888888812345674901\\n\",\n    \"19\\n5501838801564629168\\n\",\n    \"15\\n000000000000000\\n\",\n    \"23\\n88888888888888888888888\\n\",\n    \"23\\n00000000000000000000000\\n\",\n    \"33\\n888888888880000000000900000000000\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"NO\\n\",\n    \"YES\\n\",\n    \"NO\\n\",\n    \"NO\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1155/B",
  "starter_code": ""
}