{
  "task_id": "APPS/265",
  "problem_id": 265,
  "prompt": "A company of $n$ friends wants to order exactly two pizzas. It is known that in total there are $9$ pizza ingredients in nature, which are denoted by integers from $1$ to $9$.\n\nEach of the $n$ friends has one or more favorite ingredients: the $i$-th of friends has the number of favorite ingredients equal to $f_i$ ($1 \\le f_i \\le 9$) and your favorite ingredients form the sequence $b_{i1}, b_{i2}, \\dots, b_{if_i}$ ($1 \\le b_{it} \\le 9$).\n\nThe website of CodePizza restaurant has exactly $m$ ($m \\ge 2$) pizzas. Each pizza is characterized by a set of $r_j$ ingredients $a_{j1}, a_{j2}, \\dots, a_{jr_j}$ ($1 \\le r_j \\le 9$, $1 \\le a_{jt} \\le 9$) , which are included in it, and its price is $c_j$.\n\nHelp your friends choose exactly two pizzas in such a way as to please the maximum number of people in the company. It is known that a person is pleased with the choice if each of his/her favorite ingredients is in at least one ordered pizza. If there are several ways to choose two pizzas so as to please the maximum number of friends, then choose the one that minimizes the total price of two pizzas.\n\n\n-----Input-----\n\nThe first line of the input contains two integers $n$ and $m$ ($1 \\le n \\le 10^5, 2 \\le m \\le 10^5$) \u2014 the number of friends in the company and the number of pizzas, respectively.\n\nNext, the $n$ lines contain descriptions of favorite ingredients of the friends: the $i$-th of them contains the number of favorite ingredients $f_i$ ($1 \\le f_i \\le 9$) and a sequence of distinct integers $b_{i1}, b_{i2}, \\dots, b_{if_i}$ ($1 \\le b_{it} \\le 9$).\n\nNext, the $m$ lines contain pizza descriptions: the $j$-th of them contains the integer price of the pizza $c_j$ ($1 \\le c_j \\le 10^9$), the number of ingredients $r_j$ ($1 \\le r_j \\le 9$) and the ingredients themselves as a sequence of distinct integers $a_{j1}, a_{j2}, \\dots, a_{jr_j}$ ($1 \\le a_{jt} \\le 9$).\n\n\n-----Output-----\n\nOutput two integers $j_1$ and $j_2$ ($1 \\le j_1,j_2 \\le m$, $j_1 \\ne j_2$) denoting the indices of two pizzas in the required set. If there are several solutions, output any of them. Pizza indices can be printed in any order.\n\n\n-----Examples-----\nInput\n3 4\n2 6 7\n4 2 3 9 5\n3 2 3 9\n100 1 7\n400 3 3 2 5\n100 2 9 2\n500 3 2 9 5\n\nOutput\n2 3\n\nInput\n4 3\n1 1\n1 2\n1 3\n1 4\n10 4 1 2 3 4\n20 4 1 2 3 4\n30 4 1 2 3 4\n\nOutput\n1 2\n\nInput\n1 5\n9 9 8 7 6 5 4 3 2 1\n3 4 1 2 3 4\n1 4 5 6 7 8\n4 4 1 3 5 7\n1 4 2 4 6 8\n5 4 1 9 2 8\n\nOutput\n2 4",
  "solutions": "[\"#  author: ThePonyCoder\\n#  created: 23.06.2019, 21:58\\n#  filename: f.py\\n#  path: C:/Users/User/Desktop/python/Prog/CodeForces/rounds/cf_568/f.py\\n\\nimport os\\n\\n# import random\\n\\n# sys.setrecursionlimit(999999999)\\nimport string\\n\\nfrom math import inf\\nfrom functools import lru_cache\\n\\nif os.getcwd() == 'C:\\\\\\\\Users\\\\\\\\User\\\\\\\\Desktop\\\\\\\\python\\\\\\\\Prog\\\\\\\\CodeForces' \\\\\\n        or os.environ['COMPUTERNAME'] == 'USER145':\\n    import pdb\\n    \\n    import sys\\n    \\n    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)\\n    sys.stdin = open('input.txt', 'r')\\n    sys.stdout = open('output.txt', 'w')\\n    from pprint import pprint\\n    from hypothesis import given, settings\\n    from hypothesis import strategies as st\\n\\n\\ndef ri():\\n    return [int(i) for i in input().split()]\\n\\n\\ndef to_bits(l):\\n    ans = 0\\n    for i in l:\\n        ans |= (1 << i - 1)\\n    return ans\\n\\n\\nuser_masks = [0 for i in range(1 << 10)]\\npizzas = [[] for i in range(1 << 10)]\\n\\n\\n@lru_cache()\\ndef count_sat_users(mask):\\n    ans = 0\\n    cmask = mask\\n    while cmask:\\n        ans += user_masks[cmask]\\n        cmask = (cmask - 1) & mask\\n    return ans\\n\\n\\ndef main():\\n    n, m = ri()\\n    for _ in range(n):\\n        k, *a = ri()\\n        bits = to_bits(a)\\n        user_masks[bits] += 1\\n    \\n    ans = (float(-inf), float(inf), -1, -1)\\n    \\n    for i in range(m):\\n        c, k, *a = ri()\\n        bits = to_bits(a)\\n        pizzas[bits].append((c, i + 1, bits))  # \\u0446\\u0435\\u043d\\u0430, \\u043d\\u043e\\u043c\\u0435\\u0440, \\u043c\\u0430\\u0441\\u043a\\u0430\\n        pizzas[bits].sort()\\n        while len(pizzas[bits]) > 2:\\n            pizzas[bits].pop()\\n    # pprint(pizzas)\\n    \\n    for mask_F in range(1 << 9):\\n        for mask_S in range(1 << 9):\\n            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \\\\\\n                    and mask_F != mask_S:\\n                \\n                mask = mask_F | mask_S\\n                \\n                satisfied_users = count_sat_users(mask)\\n                \\n                f_pizza = next(iter(pizzas[mask_F]))\\n                s_pizza = next(iter(pizzas[mask_S]))\\n                \\n                summary_cost = 0\\n                summary_cost += f_pizza[0]\\n                summary_cost += s_pizza[0]\\n                \\n                ans = max(ans,\\n                          (satisfied_users,\\n                           -summary_cost,\\n                           s_pizza[1],\\n                           f_pizza[1]))\\n                \\n                # bruting all masks\\n                bmask = mask\\n                while bmask:\\n                    satisfied_users += user_masks[bmask]\\n                    bmask = (bmask - 1) & mask\\n            \\n            if len(pizzas[mask_F]) == 2:\\n                satisfied_users = count_sat_users(mask_F)\\n                \\n                it = iter(pizzas[mask_F])\\n                \\n                f_pizza = next(it)\\n                s_pizza = next(it)\\n                summary_cost = 0\\n                summary_cost += f_pizza[0] + s_pizza[0]\\n                ans = max(ans,\\n                          (satisfied_users,\\n                           -summary_cost,\\n                           s_pizza[1],\\n                           f_pizza[1]))\\n            \\n            if len(pizzas[mask_S]) == 2:\\n                satisfied_users = count_sat_users(mask_S)\\n                \\n                it = iter(pizzas[mask_S])\\n                \\n                f_pizza = next(it)\\n                s_pizza = next(it)\\n                summary_cost = 0\\n                summary_cost += f_pizza[0] + s_pizza[0]\\n                ans = max(ans,\\n                          (satisfied_users,\\n                           -summary_cost,\\n                           s_pizza[1],\\n                           f_pizza[1]))\\n    \\n    aans = [ans[2],ans[3]]\\n    aans.sort()\\n    print(*aans, sep=' ')\\n\\n\\nmain()\\n\", \"import sys\\n\\ndef popcount(i):\\n    assert 0 <= i < 0x100000000\\n    i = i - ((i >> 1) & 0x55555555)\\n    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\\n    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\\n\\n\\nN, M = list(map(int, sys.stdin.readline().split()))\\ntable = [0]*(2**9)\\nfor _ in range(N):\\n    S = tuple(map(int, sys.stdin.readline().split()))\\n    table[sum(2**(a-1) for a in S[1:])] += 1\\n\\ndp = [0]*(2**9)\\nfor s in range(2**9):\\n    ppc = popcount(s)\\n    res = table[s]\\n    t = s&(s-1)\\n    for _ in range(2**ppc - 1):\\n        res += table[t]\\n        t = (t-1)&s\\n    dp[s] = res                        \\n\\ntable = [False]*(2**9)\\ncost = [[] for _ in range(2**9)]\\nidx = [[] for _ in range(2**9)]\\nfor i in range(M):\\n    T = tuple(map(int, sys.stdin.readline().split()))\\n    x = sum(2**(a-1) for a in T[2:])\\n    table[x] = True\\n    cost[x].append(T[0])\\n    idx[x].append(i+1)\\n\\nminidx = [cost[x].index(min(cost[x])) if cost[x] else -1 for x in range(2**9)]\\nmincost = [10**10]*(2**9)\\nmincostidx = [(0, 0) for _ in range(2**9)]\\nreachable = [False]*(2**9)\\nfor i in range(2**9):\\n    if not table[i]:\\n        continue\\n    for j in range(2**9):\\n        if not table[j]:\\n            continue\\n        reachable[i|j] = True\\n        if i != j:\\n            mi = min(cost[i])\\n            mj = min(cost[j])\\n            if mincost[i|j] > mi + mj:\\n                mincost[i|j] = mi + mj\\n                mincostidx[i|j] = (idx[i][minidx[i]], idx[j][minidx[j]])\\nctr = -1\\ncandi = []\\nfor i in range(2**9):\\n    if not reachable[i]:\\n        continue\\n    if ctr > dp[i]:\\n        continue\\n    elif ctr == dp[i]:\\n        candi.append(i)\\n    else:\\n        ctr = dp[i]\\n        candi = [i]\\n\\nans = 10**11\\nAns = (-1, -1)\\nfor c in candi:\\n    if table[c] and len(cost[c]) > 1:\\n        D = cost[c][:]\\n        res = min(D)\\n        a = D.index(res)\\n        D.remove(res)\\n        r = min(D)\\n        b = D.index(r)\\n        if cost[c][b] != r:\\n            b += 1\\n        if a == b:\\n            b += 1\\n        res += r\\n        if ans > res:\\n            ans = res\\n            Ans = (idx[c][a], idx[c][b])\\n    if ans > mincost[c]:\\n        ans = mincost[c]\\n        Ans = mincostidx[c]\\nprint(*Ans)\\n\", \"from sys import stdin, stdout\\nimport itertools\\n\\nn, m = list(map(int, stdin.readline().split()))\\n\\nfriends = [0]*512\\nexists = [0]*512\\ncosts_min = [0]*512\\ncosts_2 = [0]*512\\nindex_min = [0]*512\\nindex_2 = [0]*512\\n\\n\\ncount_friends = [0]*512\\n\\ndef top_to_idx(top):\\n    ans = 0\\n    for t in top:\\n        ans += 1 << (t-1)\\n    return ans\\n\\ndef idx_to_top(idx):\\n    ans = []\\n    for i in range(9):\\n        if idx & (1 << i):\\n            ans.append(i+1)\\n    return ans\\n\\nfor i in range(n):\\n    top = list(map(int, stdin.readline().split()))[1:]\\n    friends[top_to_idx(top)] += 1\\n\\n#print(friends)\\n\\ndef subset(i, j):\\n    for s in range(9):\\n        if i & (1 << s) and not (j & (1 << s)):\\n            return False\\n    return True\\n\\nfor i in range(512):\\n    for j in range(512):\\n        if subset(j, i):\\n            count_friends[i] += friends[j]\\n\\n#print(count_friends)\\n\\nfor i in range(m):\\n    pizza = list(map(int, stdin.readline().split()))\\n    top_idx = top_to_idx(pizza[2:])\\n    cost = pizza[0]\\n    exists[top_idx] = True\\n    if costs_min[top_idx] == 0 or cost < costs_min[top_idx]:\\n        costs_2[top_idx] = costs_min[top_idx]\\n        index_2[top_idx] = index_min[top_idx]\\n        costs_min[top_idx] = cost\\n        index_min[top_idx] = i+1\\n    elif costs_2[top_idx] == 0 or cost < costs_2[top_idx]:\\n        costs_2[top_idx] = cost\\n        index_2[top_idx] = i+1\\n\\nbest_matches = -1\\nbest_cost = -1\\nbest = None\\nfor p1 in range(512):\\n    for p2 in range(p1, 512):\\n        if not exists[p1] or not exists[p2]:\\n            continue\\n        if p1 == p2 and index_2[p1] == 0:\\n            continue\\n        p = p1 | p2\\n    #    print(idx_to_top(p1 | p2))\\n        matches = count_friends[p]\\n     #   print(matches)\\n        cost = costs_min[p1] + costs_min[p2] if p1 != p2 else costs_min[p1] + costs_2[p2]\\n        if best_matches == -1 or matches > best_matches or (matches == best_matches and cost < best_cost):\\n            best = (index_min[p1], index_min[p2]) if p1 != p2 else (index_min[p1], index_2[p2])\\n            best_matches = matches\\n            best_cost = cost\\n\\n#print(best_matches)\\n#print(best_cost)\\nprint(best[0], best[1])\\n    \\n\", \"import  sys\\nimport  math\\n#input=sys.stdin.readline\\n#sys.setrecursionlimit(1000000)\\nI=lambda : list(map(int,input().split()))\\nma =int(10000000000000000)\\nn,m=map(int,input().split())\\na=[ma]*(515);a1=[ma]*(515);fr=[0]*(515);pos=[0]*(515)\\nfor i in range(n):\\n    b=I()\\n    x=int(0)\\n    for j in range(1,b[0]+1):\\n        b[j]-=1\\n        x|=(1<<b[j])\\n    fr[x]+=1\\n\\nmin1=int(ma)\\nmax1=int(0)\\nind,ind1=int(),int()\\nfor i in range(m):\\n    b=I()\\n    x=int(0)\\n    for j in range(2,b[1]+2):\\n        b[j]-=1\\n        x|=(1<<b[j])\\n    if a[x]!=ma:\\n        if fr[x]>max1:\\n            max1=fr[x]\\n            min1=a[x]+b[0]\\n            ind=pos[x]\\n            ind1=i+1\\n        elif fr[x]==max1:\\n            if b[0]+a[x]<min1:\\n                min1=b[0]+a[x]\\n                ind=pos[x]\\n                ind1=i+1\\n    if a[x]>b[0]:\\n        a[x]=b[0]\\n        pos[x]=i+1\\n\\n\\nfor i in range(1,512):\\n    for j in range(1,512):\\n        if i==j or  a[i]==ma or a[j]==ma:\\n            continue\\n        k=i|j\\n        cnt=int(0)\\n        while k>0:\\n            cnt+=fr[k]\\n            k=(k-1)&(i|j)\\n        if cnt>max1:\\n            ind=pos[i]\\n            ind1=pos[j]\\n            max1=cnt\\n            min1=a[i]+a[j]\\n        if cnt==max1:\\n            if a[i]+a[j]<min1:\\n                ind=pos[i]\\n                ind1=pos[j]\\n            min1=min(min1,a[i]+a[j])\\n\\nprint(ind,ind1,sep=\\\" \\\")\", \"import  sys\\nimport  math\\ninput=sys.stdin.readline\\n#sys.setrecursionlimit(1000000)\\nI=lambda : list(map(int,input().split()))\\nma =int(10000000000000000)\\nn,m=map(int,input().split())\\na=[ma]*(515);a1=[ma]*(515);fr=[0]*(515);pos=[0]*(515)\\nfor i in range(n):\\n    b=I()\\n    x=int(0)\\n    for j in range(1,b[0]+1):\\n        b[j]-=1\\n        x|=(1<<b[j])\\n    fr[x]+=1\\n\\nmin1=int(ma)\\nmax1=int(0)\\nind,ind1=int(),int()\\nfor i in range(m):\\n    b=I()\\n    x=int(0)\\n    for j in range(2,b[1]+2):\\n        b[j]-=1\\n        x|=(1<<b[j])\\n    if a[x]!=ma:\\n        if fr[x]>max1:\\n            max1=fr[x]\\n            min1=a[x]+b[0]\\n            ind=pos[x]\\n            ind1=i+1\\n        elif fr[x]==max1:\\n            if b[0]+a[x]<min1:\\n                min1=b[0]+a[x]\\n                ind=pos[x]\\n                ind1=i+1\\n    if a[x]>b[0]:\\n        a[x]=b[0]\\n        pos[x]=i+1\\n\\n\\nfor i in range(1,512):\\n    for j in range(1,512):\\n        if i==j or  a[i]==ma or a[j]==ma:\\n            continue\\n        k=i|j\\n        cnt=int(0)\\n        while k>0:\\n            cnt+=fr[k]\\n            k=(k-1)&(i|j)\\n        if cnt>max1:\\n            ind=pos[i]\\n            ind1=pos[j]\\n            max1=cnt\\n            min1=a[i]+a[j]\\n        if cnt==max1:\\n            if a[i]+a[j]<min1:\\n                ind=pos[i]\\n                ind1=pos[j]\\n            min1=min(min1,a[i]+a[j])\\n\\nprint(ind,ind1,sep=\\\" \\\")\", \"import  sys\\nimport  math\\ninput=sys.stdin.readline\\n#sys.setrecursionlimit(1000000)\\n#I=lambda : list(map(int,input().split()))\\nma =int(10000000000000000)\\nn,m=map(int,input().split())\\na=[ma]*(515);a1=[ma]*(515);fr=[0]*(515);pos=[0]*(515)\\nfor i in range(n):\\n    b=list(map(int,input().split()))\\n    x=int(0)\\n    for j in range(1,b[0]+1):\\n        b[j]-=1\\n        x|=(1<<b[j])\\n    fr[x]+=1\\n\\nmin1=int(ma)\\nmax1=int(0)\\nind,ind1=int(),int()\\nfor i in range(m):\\n    b=list(map(int,input().split()))\\n    x=int(0)\\n    for j in range(2,b[1]+2):\\n        b[j]-=1\\n        x|=(1<<b[j])\\n    if a[x]!=ma:\\n        if fr[x]>max1:\\n            max1=fr[x]\\n            min1=a[x]+b[0]\\n            ind=pos[x]\\n            ind1=i+1\\n        elif fr[x]==max1:\\n            if b[0]+a[x]<min1:\\n                min1=b[0]+a[x]\\n                ind=pos[x]\\n                ind1=i+1\\n    if a[x]>b[0]:\\n        a[x]=b[0]\\n        pos[x]=i+1\\n\\n\\nfor i in range(1,512):\\n    for j in range(1,512):\\n        if i==j or  a[i]==ma or a[j]==ma:\\n            continue\\n        k=i|j\\n        cnt=int(0)\\n        while k>0:\\n            cnt+=fr[k]\\n            k=(k-1)&(i|j)\\n        if cnt>max1:\\n            ind=pos[i]\\n            ind1=pos[j]\\n            max1=cnt\\n            min1=a[i]+a[j]\\n        if cnt==max1:\\n            if a[i]+a[j]<min1:\\n                ind=pos[i]\\n                ind1=pos[j]\\n            min1=min(min1,a[i]+a[j])\\n\\nprint(ind,ind1,sep=\\\" \\\")\"]",
  "input_output": "{\n  \"inputs\": [\n    \"3 4\\n2 6 7\\n4 2 3 9 5\\n3 2 3 9\\n100 1 7\\n400 3 3 2 5\\n100 2 9 2\\n500 3 2 9 5\\n\",\n    \"4 3\\n1 1\\n1 2\\n1 3\\n1 4\\n10 4 1 2 3 4\\n20 4 1 2 3 4\\n30 4 1 2 3 4\\n\",\n    \"1 5\\n9 9 8 7 6 5 4 3 2 1\\n3 4 1 2 3 4\\n1 4 5 6 7 8\\n4 4 1 3 5 7\\n1 4 2 4 6 8\\n5 4 1 9 2 8\\n\",\n    \"1 2\\n8 5 2 7 4 3 6 9 1\\n1 3 9 2 3\\n1 7 7 8 6 4 9 5 2\\n\",\n    \"1 5\\n9 9 8 7 6 5 4 3 2 1\\n3 4 1 2 3 4\\n1 4 5 6 7 8\\n4 4 1 3 5 7\\n10 4 2 4 6 8\\n5 4 1 9 2 8\\n\",\n    \"1 2\\n8 5 3 9 8 6 7 4 1\\n1 7 3 8 2 6 5 7 9\\n1 7 3 2 5 6 8 7 4\\n\",\n    \"1 2\\n2 4 2\\n2 1 3\\n2 2 3 2\\n\",\n    \"1 2\\n9 2 8 7 6 3 4 1 5 9\\n3 6 4 3 1 7 5 9\\n4 2 1 9\\n\",\n    \"1 3\\n2 8 6\\n1 3 6 7 9\\n1 3 6 4 3\\n1 5 7 4 1 3 8\\n\",\n    \"1 3\\n5 6 1 9 3 2\\n3 6 1 4 5 7 3 9\\n1 1 6\\n2 1 2\\n\",\n    \"1 3\\n3 9 4 6\\n4 3 6 1 8\\n1 6 3 2 4 7 9 1\\n2 6 8 6 9 5 1 2\\n\",\n    \"1 4\\n4 9 7 1 5\\n1 8 8 1 9 6 5 7 3 2\\n1 2 3 2\\n1 3 8 2 1\\n1 5 1 4 8 6 7\\n\",\n    \"1 4\\n3 2 9 1\\n1 6 3 1 5 8 9 7\\n2 2 2 6\\n1 1 7\\n3 1 9\\n\",\n    \"1 4\\n6 5 4 7 1 6 9\\n4 5 8 2 9 5 6\\n2 8 3 8 1 6 7 5 9 2\\n4 4 1 5 7 2\\n1 4 8 4 6 2\\n\",\n    \"1 5\\n6 2 6 3 4 8 9\\n1 8 5 3 9 7 6 2 1 4\\n1 4 1 3 6 8\\n1 2 8 7\\n1 1 1\\n1 8 1 3 8 2 5 7 9 4\\n\",\n    \"1 5\\n4 2 5 9 4\\n2 1 2\\n1 5 2 8 1 9 3\\n3 3 1 4 8\\n2 5 1 9 7 4 3\\n1 2 5 2\\n\",\n    \"1 5\\n7 1 4 2 6 3 8 9\\n2 9 9 7 5 4 6 3 8 2 1\\n1 8 8 3 7 9 2 4 6 1\\n2 9 1 8 3 5 4 7 2 9 6\\n5 3 3 9 2\\n2 8 1 8 4 9 2 3 6 5\\n\",\n    \"2 2\\n8 5 1 4 2 3 8 7 6\\n4 6 8 2 9\\n1 1 5\\n1 5 4 5 8 7 6\\n\",\n    \"2 2\\n2 3 6\\n1 1\\n1 5 3 8 9 1 6\\n1 3 1 7 8\\n\",\n    \"2 2\\n9 4 1 3 9 6 5 7 8 2\\n8 6 1 4 7 3 5 9 8\\n1 2 7 5\\n1 5 1 9 4 7 3\\n\",\n    \"1 2\\n1 2\\n1000000000 1 1\\n1000000000 1 1\\n\",\n    \"2 4\\n4 2 5 8 6\\n6 6 2 9 5 3 7\\n1 7 4 8 5 9 6 2 3\\n1 3 5 4 6\\n1 9 3 1 5 8 6 9 7 2 4\\n1 6 5 4 9 8 7 6\\n\",\n    \"2 4\\n7 7 3 1 4 5 8 2\\n5 8 4 1 6 7\\n2 6 8 2 6 7 1 4\\n1 5 7 3 4 9 1\\n3 5 8 7 1 5 4\\n2 6 4 9 1 8 2 3\\n\",\n    \"2 4\\n5 5 1 4 2 7\\n6 8 7 2 5 6 9\\n5 2 5 8\\n1 5 8 1 2 3 7\\n3 7 8 2 9 6 3 7 5\\n5 2 6 3\\n\",\n    \"2 5\\n7 7 4 2 1 9 3 5\\n4 9 7 5 2\\n1 6 6 5 9 3 1 8\\n1 8 2 5 7 9 6 8 1 3\\n1 5 4 5 3 7 8\\n1 9 4 3 6 5 2 8 7 1 9\\n1 8 2 1 9 5 6 7 3 8\\n\",\n    \"2 5\\n5 9 7 3 1 4\\n5 5 1 6 2 8\\n1 5 5 6 1 3 2\\n1 5 7 4 2 1 3\\n3 3 7 1 5\\n2 8 1 9 2 4 6 3 7 5\\n1 4 5 7 4 9\\n\",\n    \"2 5\\n8 9 5 6 1 4 2 8 7\\n3 7 9 3\\n3 5 5 8 4 6 9\\n1 2 7 5\\n1 5 6 2 9 5 1\\n5 8 3 6 4 2 9 1 7 5\\n5 8 2 1 5 8 3 4 9 6\\n\",\n    \"3 2\\n9 5 9 2 1 3 8 7 6 4\\n8 9 3 2 6 4 7 5 8\\n9 6 5 2 1 8 3 9 4 7\\n1 1 4\\n1 4 3 2 1 4\\n\",\n    \"3 2\\n7 7 3 6 9 2 5 8\\n1 6\\n8 3 8 5 4 9 6 7 2\\n1 7 8 9 2 4 7 3 1\\n3 5 3 5 9 7 6\\n\",\n    \"3 2\\n6 8 5 7 1 4 2\\n5 8 7 9 6 3\\n1 5\\n5 2 7 2\\n1 6 9 8 2 4 3 5\\n\",\n    \"3 3\\n1 9\\n6 4 9 5 7 8 1\\n3 5 8 3\\n1 2 7 4\\n1 2 5 9\\n1 8 5 7 9 1 4 3 2 6\\n\",\n    \"3 3\\n8 4 7 1 2 6 8 9 3\\n2 9 5\\n1 7\\n3 8 7 3 2 6 9 1 4 8\\n2 4 1 6 7 8\\n1 5 3 4 1 9 6\\n\",\n    \"3 3\\n3 8 1 4\\n1 5\\n2 5 9\\n4 3 4 2 9\\n5 8 7 9 3 4 6 8 1 2\\n1 7 4 1 5 3 8 2 7\\n\",\n    \"3 4\\n8 3 5 1 8 6 2 4 9\\n1 4\\n3 2 7 6\\n1 4 2 1 3 5\\n1 1 9\\n1 1 7\\n1 3 7 1 9\\n\",\n    \"3 4\\n2 1 2\\n1 8\\n8 2 9 3 4 1 8 6 5\\n3 7 5 6 7 9 4 3 8\\n2 3 1 9 7\\n3 1 2\\n1 9 7 6 8 4 3 9 1 5 2\\n\",\n    \"3 4\\n5 3 8 7 4 1\\n4 4 3 6 7\\n5 5 7 3 6 4\\n3 5 5 1 7 3 9\\n5 8 7 1 8 6 3 9 4 2\\n3 7 2 5 6 8 4 7 3\\n4 9 8 9 3 6 5 2 7 4 1\\n\",\n    \"3 5\\n2 8 9\\n7 7 8 9 3 1 6 4\\n7 3 4 7 5 1 8 6\\n1 4 6 1 4 9\\n1 2 2 6\\n1 3 8 6 1\\n1 8 5 6 7 2 3 8 4 1\\n1 1 4\\n\",\n    \"3 5\\n5 6 9 5 1 8\\n4 3 5 4 6\\n7 9 5 4 2 8 7 1\\n1 7 9 4 2 5 7 1 8\\n3 6 4 7 5 6 3 9\\n2 6 7 6 5 4 2 3\\n2 5 2 5 9 4 8\\n3 1 9\\n\",\n    \"3 5\\n8 4 7 2 5 8 3 6 1\\n8 9 5 3 7 8 1 2 6\\n8 3 8 7 6 2 1 9 4\\n1 2 5 2\\n5 8 2 6 5 7 9 3 1 8\\n4 7 1 5 7 8 3 2 6\\n2 4 6 3 1 7\\n1 4 8 1 3 4\\n\",\n    \"4 2\\n9 8 4 6 7 5 3 2 1 9\\n4 8 4 9 7\\n7 6 4 5 9 2 3 1\\n9 9 2 7 8 5 3 1 6 4\\n1 3 8 6 9\\n1 1 5\\n\",\n    \"4 2\\n7 8 5 2 6 3 1 9\\n9 5 3 9 6 2 7 1 8 4\\n9 8 3 5 2 1 9 6 4 7\\n3 8 6 1\\n2 2 2 7\\n1 2 8 6\\n\",\n    \"4 2\\n1 4\\n4 7 8 6 9\\n5 8 7 4 3 9\\n2 6 1\\n1 9 7 1 6 3 8 4 9 2 5\\n4 5 9 8 2 1 3\\n\",\n    \"4 3\\n2 3 2\\n5 3 6 4 9 5\\n7 4 8 2 3 9 6 5\\n8 3 2 7 1 4 8 6 9\\n1 3 3 6 5\\n1 8 9 5 2 6 7 3 8 1\\n1 7 1 2 7 5 4 6 8\\n\",\n    \"4 3\\n9 9 2 7 6 3 4 5 1 8\\n7 4 9 8 3 2 6 7\\n1 9\\n1 4\\n2 1 1\\n1 4 8 1 2 7\\n2 2 2 7\\n\",\n    \"4 3\\n3 2 6 1\\n3 2 8 4\\n8 2 1 7 5 8 4 9 6\\n3 2 6 4\\n1 5 5 4 9 7 8\\n4 4 1 7 4 6\\n3 7 7 6 4 8 2 3 5\\n\",\n    \"4 4\\n5 2 5 8 3 4\\n5 7 5 2 4 9\\n9 4 9 5 7 1 2 8 6 3\\n5 2 5 9 4 3\\n1 1 7\\n1 3 3 1 6\\n1 1 5\\n1 1 6\\n\",\n    \"4 4\\n3 8 3 5\\n6 4 6 9 8 1 7\\n5 7 2 4 3 1\\n4 6 8 5 2\\n2 7 4 9 5 3 8 6 7\\n2 8 6 5 9 8 3 7 4 1\\n3 7 5 2 1 6 8 4 7\\n2 9 4 7 1 3 8 6 9 2 5\\n\",\n    \"4 4\\n1 4\\n9 7 3 1 9 2 6 8 5 4\\n5 3 2 6 7 4\\n1 3\\n3 6 5 8 4 1 2 7\\n2 6 1 8 6 2 7 3\\n5 5 4 5 6 3 9\\n4 3 9 6 5\\n\",\n    \"4 5\\n2 5 1\\n8 2 9 3 6 4 7 1 8\\n2 9 8\\n2 6 3\\n1 7 4 9 6 8 5 1 3\\n1 6 7 5 4 2 8 6\\n1 3 5 1 4\\n1 5 5 6 9 1 2\\n1 3 8 2 5\\n\",\n    \"4 5\\n5 6 7 8 5 3\\n3 2 5 8\\n3 8 9 1\\n1 1\\n1 2 2 6\\n1 3 3 2 6\\n2 4 3 1 6 8\\n1 4 2 8 4 3\\n1 2 3 8\\n\",\n    \"4 5\\n3 1 6 7\\n7 7 4 2 1 8 5 6\\n3 6 3 4\\n5 4 1 2 7 3\\n5 2 5 3\\n3 6 9 1 6 2 7 4\\n4 8 5 7 2 6 3 1 4 9\\n3 5 8 3 9 7 4\\n1 2 5 2\\n\",\n    \"5 2\\n8 2 5 8 3 6 1 9 4\\n3 3 1 8\\n2 5 3\\n9 8 9 5 6 7 1 2 3 4\\n6 6 1 8 5 9 4\\n1 6 4 5 7 9 6 3\\n1 4 9 7 2 1\\n\",\n    \"5 2\\n2 4 5\\n5 6 4 1 9 3\\n9 8 2 7 5 4 3 9 1 6\\n1 6\\n5 7 3 6 5 8\\n2 3 3 1 8\\n2 9 7 5 9 1 6 4 2 8 3\\n\",\n    \"5 2\\n1 9\\n5 3 6 4 8 9\\n9 7 4 8 2 3 6 1 5 9\\n1 7\\n1 6\\n5 5 6 3 5 1 4\\n2 8 9 5 1 6 8 2 7 3\\n\",\n    \"5 3\\n2 6 9\\n5 2 9 4 1 3\\n6 2 5 4 9 7 1\\n4 8 1 2 4\\n6 8 5 9 3 7 1\\n1 1 4\\n1 6 2 7 9 8 3 1\\n1 3 7 2 1\\n\",\n    \"5 3\\n9 6 1 2 9 3 5 8 4 7\\n2 7 3\\n4 9 7 4 5\\n9 8 1 4 3 5 6 7 2 9\\n1 8\\n2 5 2 7 8 4 9\\n1 2 3 4\\n2 5 5 6 7 4 2\\n\",\n    \"5 3\\n3 8 5 3\\n5 2 5 1 8 7\\n2 3 7\\n8 9 1 2 8 7 5 3 4\\n4 8 7 9 4\\n3 8 5 4 7 2 3 9 8 6\\n4 1 4\\n3 8 2 8 5 7 3 4 6 1\\n\",\n    \"5 4\\n5 8 9 5 4 1\\n6 1 4 3 2 8 9\\n5 6 4 8 5 1\\n6 1 7 4 3 5 9\\n6 8 5 3 7 1 2\\n1 7 4 9 6 7 1 2 8\\n1 8 7 8 5 1 4 3 9 2\\n1 7 3 5 1 7 8 6 9\\n1 3 8 6 7\\n\",\n    \"5 4\\n3 7 9 1\\n1 7\\n3 1 8 2\\n4 5 4 8 2\\n1 3\\n1 2 2 8\\n2 2 9 5\\n2 6 7 2 3 5 9 6\\n3 9 5 7 4 2 8 9 3 6 1\\n\",\n    \"5 4\\n6 5 7 1 9 3 4\\n4 3 8 1 7\\n6 4 2 5 7 6 3\\n4 6 1 4 3\\n7 9 2 6 5 3 7 4\\n5 5 2 6 3 8 9\\n5 1 8\\n2 8 5 4 8 2 7 1 6 3\\n5 5 1 8 6 7 3\\n\",\n    \"5 5\\n8 5 3 8 4 1 9 7 6\\n4 6 7 8 2\\n4 8 4 1 3\\n1 7\\n9 9 4 7 6 5 8 3 1 2\\n1 5 8 2 4 5 3\\n1 9 2 6 9 5 8 4 3 1 7\\n1 8 1 6 2 7 9 5 4 3\\n1 3 7 9 6\\n1 7 6 9 2 1 5 8 7\\n\",\n    \"5 5\\n6 5 8 4 2 9 7\\n5 4 7 9 8 2\\n4 7 4 9 8\\n5 1 2 3 6 9\\n7 3 4 8 1 5 7 6\\n1 2 5 6\\n3 6 6 1 5 2 9 3\\n2 2 9 4\\n1 9 6 9 3 1 5 7 4 2 8\\n2 6 5 4 8 7 2 9\\n\",\n    \"5 5\\n9 7 3 2 9 4 6 1 5 8\\n3 1 9 8\\n4 1 3 8 9\\n5 7 5 6 9 3\\n8 5 1 4 3 7 9 2 8\\n5 7 1 4 2 5 3 7 6\\n4 2 8 2\\n4 6 9 8 4 6 1 5\\n3 6 6 3 8 9 1 4\\n1 6 5 1 4 7 9 2\\n\",\n    \"1 2\\n1 1\\n1000000000 1 1\\n1000000000 1 1\\n\",\n    \"2 3\\n5 9 5 7 4 3\\n1 2\\n1 8 2 7 8 4 1 3 6 5\\n3 9 7 8 4 9 3 2 6 5 1\\n1 4 2 4 8 9\\n\",\n    \"2 3\\n3 3 5 7\\n3 1 9 4\\n4 2 3 6\\n2 4 8 2 6 9\\n5 8 4 8 2 1 9 6 7 3\\n\",\n    \"2 3\\n2 5 4\\n9 9 6 3 2 8 4 5 1 7\\n1 7 9 4 1 6 8 2 5\\n1 6 1 9 3 8 5 4\\n1 1 3\\n\",\n    \"1 2\\n1 1\\n5 1 1\\n6 1 1\\n\",\n    \"1 2\\n1 1\\n5 1 1\\n5 1 1\\n\",\n    \"1 3\\n1 1\\n6 1 2\\n5 1 1\\n5 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"2 3\\n\",\n    \"1 2\\n\",\n    \"2 4\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 3\\n\",\n    \"2 3\\n\",\n    \"2 3\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"2 4\\n\",\n    \"1 2\\n\",\n    \"4 5\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 3\\n\",\n    \"1 2\\n\",\n    \"2 3\\n\",\n    \"1 4\\n\",\n    \"1 5\\n\",\n    \"2 5\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 3\\n\",\n    \"1 3\\n\",\n    \"1 2\\n\",\n    \"2 4\\n\",\n    \"1 3\\n\",\n    \"1 4\\n\",\n    \"1 3\\n\",\n    \"2 5\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"2 3\\n\",\n    \"1 2\\n\",\n    \"2 3\\n\",\n    \"1 2\\n\",\n    \"1 4\\n\",\n    \"2 3\\n\",\n    \"1 2\\n\",\n    \"1 3\\n\",\n    \"3 4\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 3\\n\",\n    \"1 2\\n\",\n    \"1 4\\n\",\n    \"1 3\\n\",\n    \"1 2\\n\",\n    \"1 4\\n\",\n    \"4 5\\n\",\n    \"1 2\\n\",\n    \"1 3\\n\",\n    \"2 3\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"1 2\\n\",\n    \"2 3\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1185/F",
  "starter_code": ""
}