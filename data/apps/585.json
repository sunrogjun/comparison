{
  "task_id": "APPS/585",
  "problem_id": 585,
  "prompt": "You are given two arrays $a_1, a_2, \\dots , a_n$ and $b_1, b_2, \\dots , b_m$. Array $b$ is sorted in ascending order ($b_i < b_{i + 1}$ for each $i$ from $1$ to $m - 1$).\n\nYou have to divide the array $a$ into $m$ consecutive subarrays so that, for each $i$ from $1$ to $m$, the minimum on the $i$-th subarray is equal to $b_i$. Note that each element belongs to exactly one subarray, and they are formed in such a way: the first several elements of $a$ compose the first subarray, the next several elements of $a$ compose the second subarray, and so on.\n\nFor example, if $a = [12, 10, 20, 20, 25, 30]$ and $b = [10, 20, 30]$ then there are two good partitions of array $a$:   $[12, 10, 20], [20, 25], [30]$;  $[12, 10], [20, 20, 25], [30]$. \n\nYou have to calculate the number of ways to divide the array $a$. Since the number can be pretty large print it modulo 998244353.\n\n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5$)\u00a0\u2014 the length of arrays $a$ and $b$ respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le 10^9$)\u00a0\u2014 the array $a$.\n\nThe third line contains $m$ integers $b_1, b_2, \\dots , b_m$ ($1 \\le b_i \\le 10^9; b_i < b_{i+1}$)\u00a0\u2014 the array $b$.\n\n\n-----Output-----\n\nIn only line print one integer \u2014 the number of ways to divide the array $a$ modulo 998244353.\n\n\n-----Examples-----\nInput\n6 3\n12 10 20 20 25 30\n10 20 30\n\nOutput\n2\n\nInput\n4 2\n1 3 3 7\n3 7\n\nOutput\n0\n\nInput\n8 2\n1 2 2 2 2 2 2 2\n1 2\n\nOutput\n7",
  "solutions": "[\"import sys\\ninput = sys.stdin.readline\\nn,m=map(int,input().split())\\na=list(map(int,input().split()))\\nb=list(map(int,input().split()))\\nmod=998244353\\nsol=1\\ni=n-1\\nj=m-1\\nwhile sol>0 and j>=0:\\n    goal=b[j]\\n    s=0\\n    r=False\\n    while i>=0 and a[i]>=goal:\\n        if r:\\n            s+=1\\n        else:\\n            if a[i]==goal:\\n                r=True\\n                s=1\\n        i-=1\\n    if j==0:\\n        s=min(s,1)\\n        if i>=0:\\n            s=0\\n    sol*=s\\n    sol%=mod\\n    j-=1\\nprint(sol)\", \"n, m = list(map(int, input().split()))\\na = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\n\\nMOD = 998244353\\n\\nout = 1\\n\\nfirst = -1\\ncurr = m - 1\\n\\nfor i in range(n - 1, -1 ,-1):\\n    while a[i] < b[curr]:\\n        if first > -1:\\n            out *= (first - i)\\n            out %= MOD\\n        else:\\n            out = 0\\n        first = -1\\n        curr -= 1\\n        \\n        if curr < 0:\\n            out = 0\\n            break\\n    if a[i] == b[curr] and first == -1:\\n        first = i\\n\\nif curr == 0 and first != -1:\\n    print(out)\\nelse:\\n    print(0)\\n\", \"n,m=map(int,input().split())\\na=list(map(int,input().split()))\\nb=list(map(int,input().split()))\\n\\nM=[a[i] for i in range(n)]\\nfor i in range(n-2,-1,-1):\\n    M[i]=min(M[i],M[i+1])\\n\\nres=1\\nmod=998244353\\nval=b[m-1]\\nid=n-1\\ncount=m-1\\nl,r=-1,-1\\nwhile count and id>-1:\\n    if M[id]>val:\\n        id-=1\\n    elif M[id]==val:\\n        if r==-1:\\n            r=id\\n        id-=1\\n    elif val>M[id]:\\n        l=id+1\\n        res*=max((r-l+1),0)\\n        res%=mod\\n        count-=1\\n        r=-1\\n        l=-1\\n        val=b[count]\\n\\nif count:\\n    res=0\\n    print(res)\\nelse:\\n    check=min(a[i] for i in range(id+1))\\n    if check==b[0]:\\n        print(res)\\n    else:\\n        print(0)\", \"MOD = 998244353\\nn, m = list(map(int, input().split()))\\nd = dict()\\na = [0] + list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nfor i in range(m):\\n    d[b[i]] = i\\nc = [-1] * m\\nfor i, x in enumerate(a):\\n    if x in d:\\n        c[d[x]] = i\\nidx = n\\nans = 1\\nfor i in range(m - 1, -1, -1):\\n    while b[i] <= a[idx]:\\n        idx -= 1\\n    if c[i] <= idx:\\n        print(0)\\n        return\\n    if i > 0:\\n        ans *= c[i] - idx\\n    elif idx > 0:\\n        print(0)\\n        return\\n    ans %= MOD\\nprint(ans)\\n\", \"from collections import defaultdict as dd\\nfrom collections import deque\\nimport bisect\\nimport heapq\\n\\ndef ri():\\n    return int(input())\\n\\ndef rl():\\n    return list(map(int, input().split()))\\n\\n\\ndef solve():\\n    n, m = rl()\\n    A = rl()\\n    B = rl()\\n    mod = 998244353\\n    if A[0] < B[0]:\\n        print(0)\\n        return\\n\\n    # ptr = len(B) - 1\\n    # streak = 0\\n    # answer = 1\\n    # _min = A[-1]\\n    # for a in A[::-1]:\\n        # _min = min(_min, a)\\n        # if _min == B[ptr]:\\n            # streak += 1\\n        # elif _min < B[ptr]:\\n            # ptr -= 1\\n            # if _min < B[ptr]:\\n                # print (0)\\n                # return\\n    mins = dd(int)\\n    _min = A[-1]\\n    for a in A[::-1]:\\n        _min = min(_min, a)\\n        mins[_min] += 1\\n\\n    if _min != B[0]:\\n        print(0)\\n        return\\n\\n    answer = 1\\n    for b in B[1:]:\\n        if mins[b] == 0:\\n            print(0)\\n            return\\n        else:\\n            answer = (answer * mins[b]) % mod\\n\\n    print (answer)\\n\\n\\n\\n\\n\\n\\nmode = 'S'\\n\\nif mode == 'T':\\n    t = ri()\\n    for i in range(t):\\n        solve()\\nelse:\\n    solve()\\n\", \"import sys\\nn,m=map(int,input().split())\\na=list(map(int,input().split()))\\nb=list(map(int,input().split()))\\nlast=[]\\ni=n-1\\nj=m-1\\nMOD=998244353\\nfailflag=0\\nwhile j>=0 and i>=0:\\n    r=b[j]\\n    while i>=0:\\n        if a[i]==r:\\n            last.append(i)\\n            break\\n        if a[i]<r:\\n            failflag=1\\n            break\\n        i-=1\\n    if i<0:\\n        break\\n    j-=1\\nlast.reverse()\\nif len(last)!=m:\\n    print(0)\\n    return\\nfor i in range(last[0]):\\n    if a[i]<b[0]:\\n        failflag=1\\nif failflag==1:\\n    print(0)\\n    return\\nans=1\\nfor i in range(1,m):\\n    for j in range(last[i],last[i-1]-1,-1):\\n        if a[j]<b[i]:\\n            break\\n    ans=((last[i]-j)*ans)%MOD\\nprint(ans)\", \"import sys\\n# import math\\n# from collections import deque\\n# import heapq\\n# from math import inf\\n# from math import gcd\\n\\n# print(help(deque))\\n# 26\\npprint = lambda s: print(' '.join(map(str, s)))\\ninput = lambda: sys.stdin.readline().strip()\\nipnut = input\\n# n,m = map(int, input().split())\\n# n = int(input())\\n#\\nn,m = map(int,input().split())\\na = list(map(int,input().split()))\\nb = list(map(int,input().split()))\\nmod = 998244353\\nsuf_min = [(10000000000,-1)]\\na_r = list(reversed(a))\\nfor i in range(n):\\n    if a_r[i]<suf_min[-1][0]:\\n        suf_min.append((a_r[i],n-i-1))\\n    else:\\n        suf_min.append(suf_min[-1])\\nsuf_min.reverse()\\n\\nif suf_min[0][0]!=b[0]:\\n    print(0)\\n    return\\nans = 1\\ndef bin(a):\\n    l = 0\\n    r = n+1\\n    while r-l>1:\\n        m = (r+l)//2\\n        if suf_min[m][0]>a:\\n            r = m\\n        else:\\n            l = m\\n    return l\\nfor k in range(m-1):\\n    j= bin(b[k+1])\\n    if suf_min[j][0]!=b[k+1]:\\n        print(0)\\n        return\\n    ans = (ans*(suf_min[j][1]-suf_min[bin(b[k+1]-1)][1]))%mod\\nprint(ans)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"6 3\\n12 10 20 20 25 30\\n10 20 30\\n\",\n    \"4 2\\n1 3 3 7\\n3 7\\n\",\n    \"8 2\\n1 2 2 2 2 2 2 2\\n1 2\\n\",\n    \"18 10\\n8 1 2 3 4 9 9 5 1 6 6 7 8 6 2 9 10 7\\n1 2 3 4 5 6 7 8 9 10\\n\",\n    \"1 1\\n1000000000\\n1000000000\\n\",\n    \"1 1\\n1\\n1\\n\",\n    \"5 1\\n7 10 3 11 3\\n3\\n\",\n    \"5 1\\n7 10 3 11 2\\n3\\n\",\n    \"10 1\\n1 1 1 1 1 1 1 1 1 1\\n1\\n\",\n    \"2 3\\n1 3\\n1 2 3\\n\",\n    \"1 5\\n1\\n1 2 3 4 1000000000\\n\",\n    \"9 9\\n3 4 5 6 7 8 9 10 11\\n3 4 5 6 7 8 9 10 11\\n\",\n    \"3 2\\n2 2 3\\n1 2\\n\",\n    \"5 2\\n2 1 2 3 2\\n1 3\\n\",\n    \"1 1\\n2\\n1\\n\",\n    \"6 3\\n12 10 20 20 15 30\\n10 20 30\\n\",\n    \"2 2\\n10 7\\n5 7\\n\",\n    \"3 3\\n2 5 6\\n1 5 6\\n\",\n    \"1 1\\n3\\n2\\n\",\n    \"2 3\\n2 3\\n1 2 3\\n\",\n    \"3 2\\n2 2 8\\n1 2\\n\",\n    \"10 5\\n9 8 7 6 5 6 7 8 9 10\\n6 7 8 9 10\\n\",\n    \"20 5\\n8 8 2 5 2 1 5 3 6 5 5 4 5 6 3 5 5 7 3 7\\n1 3 4 5 7\\n\",\n    \"5 5\\n2 3 4 5 6\\n1 2 3 4 5\\n\",\n    \"24 3\\n4 12 3 14 2 7 12 7 11 3 5 10 14 1 6 12 13 4 1 5 5 9 8 6\\n1 5 8\\n\",\n    \"1 1\\n5\\n3\\n\",\n    \"39 3\\n4 8 12 9 19 4 2 21 20 15 6 7 4 13 10 4 10 4 22 22 12 11 10 14 5 2 11 20 15 16 14 18 1 3 4 19 4 6 15\\n1 3 4\\n\",\n    \"1 2\\n2\\n1 2\\n\",\n    \"7 2\\n2 2 3 2 3 4 3\\n2 4\\n\",\n    \"5 4\\n1 5 3 10 15\\n1 5 10 15\\n\",\n    \"6 3\\n12 20 20 25 10 30\\n7 10 30\\n\",\n    \"6 3\\n12 20 20 25 10 30\\n10 30 35\\n\",\n    \"4 2\\n3 2 6 2\\n2 6\\n\",\n    \"10 4\\n1 6 1 4 8 4 4 6 5 1\\n1 6 7 9\\n\",\n    \"47 2\\n6 2 5 1 1 9 10 7 8 6 10 8 5 10 3 5 1 7 1 1 10 8 2 4 3 9 4 6 2 8 3 5 3 8 6 7 5 4 6 6 5 3 8 2 10 6 3\\n1 9\\n\",\n    \"71 4\\n9 9 6 9 8 2 10 9 2 5 10 1 9 7 5 6 4 9 3 7 3 8 5 3 4 10 5 9 9 1 2 1 10 1 10 8 2 9 2 2 8 8 2 4 10 1 6 9 7 2 7 5 1 1 8 6 7 9 5 6 8 2 3 4 3 1 3 7 2 7 4\\n1 2 3 7\\n\",\n    \"77 22\\n7 2 4 8 10 7 5 7 9 7 5 6 2 9 10 1 5 4 5 8 6 9 3 1 8 1 10 9 6 7 7 1 5 3 6 4 9 10 7 8 2 3 10 10 9 9 2 9 1 9 7 3 2 4 7 7 1 1 10 4 2 2 8 3 2 9 9 9 5 6 7 1 10 8 3 9 1\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\\n\",\n    \"5 2\\n2 3 4 5 6\\n1 4\\n\",\n    \"6 1\\n2 2 2 2 2 4\\n1\\n\",\n    \"6 3\\n12 10 20 20 5 30\\n10 20 30\\n\",\n    \"6 3\\n12 10 20 20 10 30\\n7 10 30\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n\",\n    \"0\\n\",\n    \"7\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"3\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1366/E",
  "starter_code": ""
}