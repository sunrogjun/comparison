{
  "task_id": "APPS/292",
  "problem_id": 292,
  "prompt": "Amr bought a new video game \"Guess Your Way Out!\". The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height h. The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node. \n\nLet's index all the leaf nodes from the left to the right from 1 to 2^{h}. The exit is located at some node n where 1 \u2264 n \u2264 2^{h}, the player doesn't know where the exit is so he has to guess his way out!\n\nAmr follows simple algorithm to choose the path. Let's consider infinite command string \"LRLRLRLRL...\" (consisting of alternating characters 'L' and 'R'). Amr sequentially executes the characters of the string using following rules:  Character 'L' means \"go to the left child of the current node\";  Character 'R' means \"go to the right child of the current node\";  If the destination node is already visited, Amr skips current command, otherwise he moves to the destination node;  If Amr skipped two consecutive commands, he goes back to the parent of the current node before executing next command;  If he reached a leaf node that is not the exit, he returns to the parent of the current node;  If he reaches an exit, the game is finished. \n\nNow Amr wonders, if he follows this algorithm, how many nodes he is going to visit before reaching the exit?\n\n\n-----Input-----\n\nInput consists of two integers h, n (1 \u2264 h \u2264 50, 1 \u2264 n \u2264 2^{h}).\n\n\n-----Output-----\n\nOutput a single integer representing the number of nodes (excluding the exit node) Amr is going to visit before reaching the exit by following this algorithm.\n\n\n-----Examples-----\nInput\n1 2\n\nOutput\n2\nInput\n2 3\n\nOutput\n5\nInput\n3 6\n\nOutput\n10\nInput\n10 1024\n\nOutput\n2046\n\n\n-----Note-----\n\nA perfect binary tree of height h is a binary tree consisting of h + 1 levels. Level 0 consists of a single node called root, level h consists of 2^{h} nodes called leaves. Each node that is not a leaf has exactly two children, left and right one. \n\nFollowing picture illustrates the sample test number 3. Nodes are labeled according to the order of visit.\n\n[Image]",
  "solutions": "[\"h, n = list(map(int, input().split()))\\nc, m = 0, 2 ** h\\nr = 0\\nwhile m > 1:\\n    if c == 0:\\n        if n > m // 2:\\n            r += m - 1\\n            n -= m // 2\\n            c = 1 - c\\n    else:\\n        if n > m // 2:\\n            n -= m // 2\\n        else:\\n            r += m - 1\\n            c = 1 - c\\n    c = 1 - c\\n    r += 1\\n    m //= 2\\n    #print(c, m, r, n)\\nprint(r)\\n\", \"\\\"\\\"\\\"\\nCodeforces Contest 287 Div 2 Problem C\\n\\nAuthor  : chaotic_iak\\nLanguage: Python 3.4.2\\n\\\"\\\"\\\"\\n\\n################################################### SOLUTION\\n\\ndef main():\\n    h,n = read()\\n    n -= 1\\n    n = bin(n)[2:]\\n    n = \\\"0\\\" * (h-len(n)) + n\\n\\n    s = \\\"\\\"\\n    for i in range(h):\\n        if i and n[i-1] == \\\"0\\\":\\n            s += \\\"1\\\" if n[i] == \\\"0\\\" else \\\"0\\\"\\n        else:\\n            s += n[i]\\n\\n    ct = 0\\n    for i in range(h):\\n        ct += 1\\n        if s[i] == \\\"1\\\": ct += 2**(h-i)-1\\n    print(ct)\\n\\n#################################################### HELPERS\\n\\n\\n\\ndef read(mode=2):\\n    # 0: String\\n    # 1: List of strings\\n    # 2: List of integers\\n    inputs = input().strip()\\n    if mode == 0: return inputs\\n    if mode == 1: return inputs.split()\\n    if mode == 2: return list(map(int, inputs.split()))\\n\\ndef write(s=\\\"\\\\n\\\"):\\n    if s is None: s = \\\"\\\"\\n    if isinstance(s, list): s = \\\" \\\".join(map(str, s))\\n    s = str(s)\\n    print(s, end=\\\"\\\")\\n\\nwrite(main())\", \"height, n = list(map(int, input().split()))\\n\\ns = height\\nreverted = False\\nfor h in range(height-1, -1, -1):\\n\\n    if n > 2**h:\\n        more = True\\n        n -= 2**h\\n    else:\\n        more = False\\n\\n    if more ^ reverted:\\n        s += (2 * 2**h - 1)\\n\\n    reverted = not more\\n\\nprint (s)\\n\", \"h,n=list(map(int,input().split()))\\np=1<<(h-1)\\ni=r=0\\nn-=1\\nwhile h:\\n\\tr+=1\\n\\tif n>=p:j=1;n-=p\\n\\telse:j=0\\n\\tif j^i:r+=p+p-1\\n\\telse:i=1-i\\n\\tp>>=1\\n\\th-=1\\nprint(r)\\n\", \"def summ(x):\\n    ret=1\\n    acc=1\\n    while(acc<=x):\\n        ret+=acc\\n        acc*=2\\n    return ret\\n\\nh,n=list(map(int,input().split()))\\n\\nans = 1\\nlvl = 0\\ncur = 'L'\\namnt = 2**h\\nwhile(1):\\n    if(lvl==h):\\n        break\\n    if(cur=='L'):\\n        if(n<=amnt//2):\\n            amnt//=2\\n            cur='R'\\n            ans+=1\\n            lvl+=1\\n        else:\\n            amnt//=2\\n            n-=amnt\\n            cur='L'\\n            ans+=summ(amnt)\\n            lvl+=1\\n    else:\\n        if(n<=amnt//2):\\n            amnt//=2\\n            cur='R'\\n            ans+=summ(amnt)\\n            lvl+=1\\n        else:\\n            amnt//=2\\n            n-=amnt\\n            cur='L'\\n            ans+=1\\n            lvl+=1\\nprint(ans-1)\\n\", \"H, N = [int(i) for i in input().split()]\\n\\nresult = 0\\nside = 0\\nfor h in range(H, 0, -1):\\n    result += 1\\n    if side ^ (N > 1 << (h - 1)):\\n        result += (1 << h) - 1\\n    else:\\n        side ^= 1\\n    if N > 1 << (h - 1):\\n        N -= 1 << (h - 1)\\n    \\nprint(result)\\n\", \"h,n = map(int, input().split(' '))\\nans = 0\\nleft = True\\nfor i in range(h) :\\n    ch = h-i\\n    half = 2**(ch-1)\\n    \\n    if n <= half :\\n        if left :\\n            ans += 1\\n            left = False\\n            continue\\n        else :\\n            ans += half*2\\n            left = False\\n            continue\\n    else :\\n        if left :\\n            ans += half*2\\n            left = True\\n            n -= half\\n        else :\\n            ans += 1\\n            left = True\\n            n -= half\\nprint(ans)\", \"line = input().split()\\n\\nh = int(line[0])\\nn = int(line[1])\\n\\nlast = 1\\nth = 2 ** h\\nans = 1\\nl = 1\\nr = th\\nwhile th > 0:\\n    mid = (l + r) // 2\\n    if n <= mid:\\n        if last == 1:\\n            ans += 1\\n        else:\\n            ans += th\\n        last = 0\\n        r = mid\\n    else:\\n        if last == 0:\\n            ans += 1\\n        else:\\n            ans += th\\n        last = 1\\n        l = mid + 1\\n    th = th // 2\\n\\nprint(str(ans - 2))\\n\", \"def ans():\\n    h, n= [int(i) for i in input().split()]\\n    div= 2**(h- 1)\\n    mystr= \\\"\\\"\\n    for i in range(h):\\n        #print(div)\\n        if n> div:\\n            mystr+= \\\"G\\\"\\n            div+= 2**(h- i- 2)\\n        else:\\n            mystr+= \\\"L\\\"\\n            div-= 2**(h- i- 2)\\n    \\n    #print(mystr)\\n    if mystr[0]== \\\"L\\\":\\n        ans= 1\\n    elif mystr[0]== \\\"G\\\":\\n        ans= 2**h\\n    for i in range(len(mystr)- 1):\\n        if mystr[i+ 1]== mystr[i]:\\n            ans+= 2**(h- i- 1)\\n        else:\\n            ans+= 1\\n    \\n    print(ans)\\n        \\n    \\n    \\n    return\\nans()\", \"h,n = list(map(int,input().split()))\\nl = 1; r = 2**h\\nans = 0\\nnow = 'l'\\nfor i in range(h,0,-1):\\n    if n < (l+r)/2 and now == 'l':\\n        now = 'r'\\n        r -= 2**(i-1)\\n        ans += 1\\n    elif n < (l+r)/2 and now == 'r':\\n        r -= 2**(i-1)\\n        ans += 2**i\\n    elif n > (l+r)/2 and now == 'l':\\n        l += 2**(i-1)\\n        ans += 2**i\\n    else:\\n        now = 'l'\\n        l += 2**(i-1)\\n        ans += 1\\nprint(ans)\\n\", \"__author__ = 'Konrad Strack'\\n\\n\\ndef command_gen():\\n    while True:\\n        yield 'L'\\n        yield 'R'\\n\\n\\ndef solve():\\n    h, n = [int(x) for x in input().split()]\\n\\n    leaves = 2 ** h\\n\\n    path = []\\n    left, right = 1, leaves\\n    for i in range(h):\\n        middle = (left + right) // 2\\n        if n <= middle:\\n            path.append('L')\\n            right = middle\\n        else:\\n            path.append('R')\\n            left = middle + 1\\n\\n    command = command_gen()\\n    sum = 0\\n    hi = h\\n    for p in path:\\n        cmd = next(command)\\n\\n        if p != cmd:\\n            sum += 2 ** hi - 1\\n            next(command)\\n        hi -= 1\\n\\n    sum += len(path)\\n    print(sum)\\n\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"h, n = map(int, input().split())\\nt = bin(n-1)[2:]\\nt = '0'*(h-len(t))+t\\nres = 0\\nflag = True\\nfor i in range(h):\\n\\tif(t[i] == ('1' if flag else '0')):\\n\\t\\tres += 2**(h-i)\\n\\telse:\\n\\t\\tflag = not flag\\n\\t\\tres += 1\\nprint(res)\", \"h, n = map(int, input().split())\\n\\ntotal = 2 ** (h + 1) - 1\\n\\nsum_v = 0\\nrange_v = (0, 2 ** h - 1)\\nprev_r = range_v\\nx = n - 1\\nleft = False\\ncurr_h = 0\\n\\n\\ndef in_range(r, x):\\n    return r[0] <= x <= r[1]\\n\\n\\ndef range_width(r):\\n    return r[1] - r[0] + 1\\n\\n\\ndef update_range(r, l):\\n    w = range_width(r) // 2\\n    st = r[0] if l else r[0] + w\\n    return st, st + w - 1\\n\\n#print(\\\"X \\\", x)\\nwhile range_width(range_v) != 0:\\n    left = not left\\n    #print(range_v)\\n\\n    tmp = range_v\\n    if in_range(range_v, x):\\n        range_v = update_range(range_v, left)\\n        sum_v += 1\\n        curr_h += 1\\n        #print(\\\"+ 1\\\")\\n    else:\\n        range_v = update_range(prev_r, left)\\n        sum_v += 2 ** (h - curr_h + 1) - 1\\n        #print(\\\"+ \\\", 2 ** (h - curr_h + 1) - 1)\\n\\n    prev_r = tmp\\n\\nprint(sum_v - 1)\", \"import math\\ns = 'LRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLR'\\n(h, n) = [int(x) for x in input().split()]\\nn = 2**(h)-1+n\\nleft = 2**h\\nright = 2**(h+1)-1\\npath = []\\nfor i in range(h):\\n    center = (right+left)/2\\n    if n>center:\\n        path.append('R')\\n        left = math.ceil(center)\\n    else:\\n        path.append('L')\\n        right = int(center)\\n\\ncost = 1\\nfor i in range(len(path)):\\n    if s[i] != path[i]:\\n        cost += 2**(h-i)-1+1\\n        s = s[:i]+s[i+1:]\\n    else:\\n        cost += 1\\nprint(cost-1)\\n\", \"h, n = list(map(int, input().split()))\\nh -= 1\\nn -= 1\\nl = 0\\nr = 2 << h\\nll = True\\nans = 0\\ni = 0\\nwhile r - l > 1:\\n    m = (l + r) // 2\\n    if ll == (n < m):\\n        ans += 1\\n    else:\\n        ans += 1 << (h - i + 1)\\n    if n < m:\\n        r = m\\n        ll = False\\n    else:\\n        l = m;\\n        ll = True\\n    i += 1\\nprint(ans)\\n\", \"h,n = list(map(int,input().split()))\\nz = 2\\nz1 = 1\\np = 0\\nr = 0\\nh2 = 0\\nh3 = 2**h\\nwhile p < h:\\n    if n <= h2 +  h3 // z and r == 0:\\n        z1 += 1\\n        z *= 2\\n        r = 1\\n    elif n > h2 + h3 // z and r == 0:\\n        h2 += h3 // z\\n        z1 += 2**(h-p)\\n        z *= 2\\n        r = 0\\n    elif n <= h2 +  h3 // z and r == 1:\\n        z1 += 2**(h-p)\\n        z *= 2\\n        r = 1\\n    elif n > h2 +  h3 // z and r == 1:\\n        h2 += h3 // z\\n        z1 += 1\\n        z *= 2\\n        r = 0\\n    p += 1\\nprint(z1 - 1)\\n\", \"h, n = (int(x) for x in input().split())\\nleftPlus, rightPlus = 1, 2**h\\nanswer = 1\\ncurLevel = 0\\ndelim = 2**(h - 1)\\nwhile curLevel != h:\\n\\th -= 1\\n\\tif n <= delim:\\n\\t\\tanswer += leftPlus\\n\\t\\tleftPlus, rightPlus = max(rightPlus // 2, leftPlus // 2), 1\\n\\t\\tdelim -= 2**(h - 1)\\n\\t\\t# print (\\\"L\\\", answer)\\n\\telse:\\n\\t\\tanswer += rightPlus\\n\\t\\tleftPlus, rightPlus = 1, max(rightPlus // 2, leftPlus // 2)\\n\\t\\tdelim += 2**(h - 1)\\n\\t\\t# print (\\\"R\\\", answer)\\t\\nprint (answer - 1)\", \"import math\\n\\ndef is_left_son(num):\\n    if num == num // 2 * 2:\\n        return True\\n    else:\\n        return False\\n\\ndef bin_search(place, depth):\\n    answer = \\\"\\\"\\n    length = 2 ** depth\\n    while length > 1:\\n        if place > length / 2:\\n            answer += \\\"R\\\"\\n            place -= length / 2\\n        else:\\n            answer += \\\"L\\\"\\n        length = length / 2\\n    return answer\\n\\ndef traverse(depth, route):\\n    answer = 0\\n    cur_vert = 1\\n    cur_dir = \\\"L\\\"\\n    while route:\\n        if route[0] == \\\"R\\\":\\n            cur_vert = cur_vert * 2 + 1\\n        else:\\n            cur_vert = cur_vert * 2\\n        if cur_dir == route[0]:\\n            answer += 1\\n        else:\\n            answer += 2**depth\\n        depth -= 1\\n        route = route[1:]\\n        cur_dir = \\\"R\\\" if is_left_son(cur_vert) else \\\"L\\\"\\n    return answer\\n    \\nh, n = (int(x) for x in input().split())\\namount_visited = 0\\ncur_pos = 1        \\nprint(traverse(h, bin_search(n, h)))\\n    \\n\", \"\\n\\n\\nh, n = list(map(int, input().split()))\\nh += 1\\n\\nmoves = []\\n\\nresult = h - 1\\n\\nn += (2**(h-1)) - 1\\n\\nwhile n != 1:\\n    if n % 2 == 1:\\n        moves.append(1)\\n    else:\\n        moves.append(0)\\n    n //= 2\\n\\nindex_on_list = 0\\n\\nch = 1\\n\\nwhile len(moves) > 0:\\n    if moves[-1] != index_on_list % 2:\\n        result += (2**(h-ch)) - 1\\n    else:\\n        moves.pop()\\n        ch += 1\\n\\n    index_on_list += 1\\n\\nprint(result)\\n\\n\\n\\n\", \"import sys\\ndef main():\\n    rdl = list(map(int,input().split()))\\n    obx(rdl[0],rdl[1],0,1)\\ndef obx(lvl, ind, kl, current):\\n    if lvl ==0:\\n        print(int(kl))\\n        return\\n    all = 0\\n    for i in range(lvl+1):\\n        all += 2**i\\n    all -= 1\\n\\n    if ind > (2**(lvl))/2:\\n        if current == 1:\\n            kl += all / 2 + 1\\n        else: \\n            kl += 1\\n            current *= -1\\n        obx(lvl-1,ind-(2**lvl)/2,kl,current)\\n    else: \\n        if current == -1:\\n            kl += all/2+1\\n        else: \\n            kl += 1\\n            current *= -1\\n        obx(lvl-1,ind,kl,current)\\n        \\nmain()\", \"def main():\\n\\th, n = (list(map(int, input().split())))\\n\\tc, m = 0, 2 ** h\\n\\tr = 0\\n\\twhile m > 1:\\n\\t\\tif c == 0:\\n\\t\\t\\tif n > (m//2):\\n\\t\\t\\t\\tr += m - 1\\n\\t\\t\\t\\tn -= m//2\\n\\t\\t\\t\\tc = 1 - c\\n\\t\\telse:\\n\\t\\t\\tif n > m//2:\\n\\t\\t\\t\\tn -= m//2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr += m - 1\\n\\t\\t\\t\\tc = 1 - c\\n\\t\\tc = 1 - c\\n\\t\\tr += 1\\n\\t\\tm //= 2\\n\\tprint(r)\\n\\n\\n\\n\\n\\t\\n\\ndef __starting_point():\\n\\tmain()\\n\\n\\n__starting_point()\", \"h, n = [int(_) for _ in input().split()]\\nstart = 1\\nend = 2 ** h\\nlast = \\\"l\\\"\\nans = 0\\nfor i in range(h):\\n    mid = (start + end) // 2\\n    if n <= mid:\\n        end = mid\\n        if last == 'l':\\n            last = 'r'\\n            ans += 1\\n        else:\\n            ans += 2 ** (h - i)\\n    else:\\n        start = mid\\n        if last == 'r':\\n            last = 'l'\\n            ans += 1\\n        else:\\n            ans += 2 ** (h - i)\\n\\nprint(ans)\\n\", \"h,n=input().split(' ')\\nh=int(h)\\nn=int(n)\\ns='l'\\nans=0\\nfor i in range(h,0,-1):\\n if n>pow(2,i-1):\\n     if s=='l':\\n       ans+=pow(2,i)\\n     else:\\n       ans+=1\\n     s='l'\\n     n-=pow(2,i-1)\\n else:\\n     if s=='r':\\n         ans+=pow(2,i)\\n     else:\\n         ans+=1;\\n     s='r'\\nprint (ans)\\n\", \"def n_of_nodes(h):\\n    result = 0\\n    for i in range(h):\\n        result += 2 ** i\\n    return result\\n\\nh, n = tuple(map(int, input().split()))\\n\\nway = \\\"\\\"\\nt = h\\nwhile t:\\n    if n % 2:\\n        way = \\\"L\\\" + way\\n        n //= 2\\n        n += 1\\n    else:\\n        way = \\\"R\\\" + way\\n        n //= 2\\n    t -= 1\\n\\nanswer = 1\\ncurrent = \\\"L\\\"\\nt = h\\nfor i in way:\\n    if i == current:\\n        answer += 1\\n        if current == \\\"L\\\":\\n            current = \\\"R\\\"\\n        else:\\n            current = \\\"L\\\"\\n    else:\\n        answer += n_of_nodes(t) + 1\\n    t -= 1\\n\\nprint(answer - 1)\\n\", \"h, n = map(int, input().split())\\nans = h\\nn = n - 1 + (1 << h)\\nfor i in range(1, h+1):\\n    if not ( ((n & (1 << i)) == 0) ^ (n & (1 << (i-1)) == 0 )):\\n        ans += (1 << i) - 1\\nprint(ans)\"]",
  "input_output": "{\n  \"inputs\": [\n    \"1 2\\n\",\n    \"2 3\\n\",\n    \"3 6\\n\",\n    \"10 1024\\n\",\n    \"10 577\\n\",\n    \"11 550\\n\",\n    \"19 12783\\n\",\n    \"28 72803174\\n\",\n    \"39 457181784666\\n\",\n    \"12 955\\n\",\n    \"13 154\\n\",\n    \"14 2334\\n\",\n    \"15 15512\\n\",\n    \"16 21395\\n\",\n    \"17 80239\\n\",\n    \"18 153276\\n\",\n    \"20 589266\\n\",\n    \"21 1687606\\n\",\n    \"24 14428281\\n\",\n    \"29 113463931\\n\",\n    \"1 1\\n\",\n    \"3 8\\n\",\n    \"31 1819651953\\n\",\n    \"33 2599588275\\n\",\n    \"38 262402936512\\n\",\n    \"4 13\\n\",\n    \"40 615535158153\\n\",\n    \"42 1042128038474\\n\",\n    \"45 17519319833295\\n\",\n    \"46 34999315964173\\n\",\n    \"49 295606900104348\\n\",\n    \"50 905353992267944\\n\",\n    \"3 5\\n\",\n    \"4 14\\n\",\n    \"6 40\\n\",\n    \"7 31\\n\",\n    \"8 19\\n\",\n    \"10 359\\n\",\n    \"11 349\\n\",\n    \"13 4796\\n\",\n    \"20 742273\\n\",\n    \"22 3343393\\n\",\n    \"24 3543583\\n\",\n    \"25 678676\\n\",\n    \"27 109473899\\n\",\n    \"29 19827102\\n\",\n    \"8 204\\n\",\n    \"30 414940886\\n\",\n    \"32 3786259360\\n\",\n    \"35 31233562499\\n\",\n    \"38 99361414961\\n\",\n    \"9 43\\n\",\n    \"40 874338951117\\n\",\n    \"33 2696188969\\n\",\n    \"35 12080044014\\n\",\n    \"12 2715\\n\",\n    \"29 524109003\\n\",\n    \"50 1\\n\",\n    \"50 1125899906842624\\n\",\n    \"50 562949953421312\\n\",\n    \"50 844424930131968\\n\",\n    \"50 375299968947542\\n\"\n  ],\n  \"outputs\": [\n    \"2\",\n    \"5\",\n    \"10\",\n    \"2046\",\n    \"1345\",\n    \"408\",\n    \"503251\",\n    \"50649698\",\n    \"830699159852\",\n    \"2871\",\n    \"7770\",\n    \"9440\",\n    \"14926\",\n    \"2899\",\n    \"177237\",\n    \"328766\",\n    \"1505684\",\n    \"3522472\",\n    \"26969983\",\n    \"347736449\",\n    \"1\",\n    \"14\",\n    \"3412135549\",\n    \"1357401405\",\n    \"519008349260\",\n    \"27\",\n    \"1572205271927\",\n    \"3195908899134\",\n    \"17381304930499\",\n    \"34646522010881\",\n    \"820858833984106\",\n    \"1871650493613618\",\n    \"11\",\n    \"26\",\n    \"88\",\n    \"95\",\n    \"205\",\n    \"91\",\n    \"1057\",\n    \"10298\",\n    \"1182599\",\n    \"7009189\",\n    \"10865127\",\n    \"31527640\",\n    \"209022797\",\n    \"478963048\",\n    \"422\",\n    \"372407442\",\n    \"8003335020\",\n    \"60951693197\",\n    \"28342263489\",\n    \"391\",\n    \"1800799608767\",\n    \"505562011\",\n    \"2415167450\",\n    \"4185\",\n    \"1052258991\",\n    \"1125899906842623\",\n    \"2251799813685246\",\n    \"562949953421312\",\n    \"1407374883553280\",\n    \"50\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/507/C",
  "starter_code": ""
}