{
  "task_id": "APPS/56",
  "problem_id": 56,
  "prompt": "Mary has just graduated from one well-known University and is now attending celebration party. Students like to dream of a beautiful life, so they used champagne glasses to construct a small pyramid. The height of the pyramid is n. The top level consists of only 1 glass, that stands on 2 glasses on the second level (counting from the top), then 3 glasses on the third level and so on.The bottom level consists of n glasses.\n\nVlad has seen in the movies many times how the champagne beautifully flows from top levels to bottom ones, filling all the glasses simultaneously. So he took a bottle and started to pour it in the glass located at the top of the pyramid.\n\nEach second, Vlad pours to the top glass the amount of champagne equal to the size of exactly one glass. If the glass is already full, but there is some champagne flowing in it, then it pours over the edge of the glass and is equally distributed over two glasses standing under. If the overflowed glass is at the bottom level, then the champagne pours on the table. For the purpose of this problem we consider that champagne is distributed among pyramid glasses immediately. Vlad is interested in the number of completely full glasses if he stops pouring champagne in t seconds.\n\nPictures below illustrate the pyramid consisting of three levels. [Image] [Image] \n\n\n-----Input-----\n\nThe only line of the input contains two integers n and t (1 \u2264 n \u2264 10, 0 \u2264 t \u2264 10 000)\u00a0\u2014 the height of the pyramid and the number of seconds Vlad will be pouring champagne from the bottle.\n\n\n-----Output-----\n\nPrint the single integer\u00a0\u2014 the number of completely full glasses after t seconds.\n\n\n-----Examples-----\nInput\n3 5\n\nOutput\n4\n\nInput\n4 8\n\nOutput\n6\n\n\n\n-----Note-----\n\nIn the first sample, the glasses full after 5 seconds are: the top glass, both glasses on the second level and the middle glass at the bottom level. Left and right glasses of the bottom level will be half-empty.",
  "solutions": "[\"n, t = list(map(int,input().split()))\\ng = [[0.0] * i for i in range(1,n+1)]\\n\\n\\nfor _ in range(t):\\n    g[0][0] += 1.0\\n    for i in range(n):\\n        for j in range(i+1):\\n            spill = max(0, g[i][j] - 1.0)\\n            g[i][j] -= spill\\n            if i < n - 1:\\n                g[i + 1][j] += spill / 2\\n                g[i + 1][j + 1] += spill / 2\\n    if g[n-1][0] == 1.0:\\n        break\\n\\ncnt = 0\\nfor i in range(n):\\n    for j in range(i + 1):\\n        if g[i][j] == 1.0:\\n            cnt += 1\\nprint(cnt)\\n\", \"n, T = list(map(int, input().split()))\\na = [[0 for _ in range(n)] for __ in range(n)]\\nfor t in range(T):\\n    i, j = 0, 0\\n    a[i][j] += 1024\\n    for i in range(n - 1):\\n        for j in range(i + 1):\\n            if a[i][j] > 1024:\\n                diff = a[i][j] - 1024\\n                a[i][j] = 1024\\n                a[i + 1][j] += diff//2\\n                a[i + 1][j + 1] += diff//2\\n                if (diff % 2 != 0):\\n                    raise RuntimeError('whut')\\nans = 0\\nfor i in range(n):\\n    for j in range(i + 1):\\n        if a[i][j] >= 1024:\\n            ans += 1\\nprint(ans)\\n\", \"n, t = map(int, input().split())\\n\\nt = min(2000, t)\\nL = [ [0.0]*n for i in range(n) ]\\nfor _ in range(t) :\\n    L[0][0] += 1.0\\n    for i in range(n-1) :\\n        for j in range(i+1) :\\n            if L[i][j] > 1.0 :\\n                x = (L[i][j] - 1.0) / 2\\n                L[i+1][j] += x\\n                L[i+1][j+1] += x\\n                L[i][j] = 1.0\\n\\nans = 0\\nfor i in range(n) :\\n    for j in range(i+1) :\\n        if L[i][j] > 0.9999999999 :\\n            ans += 1\\n\\nprint(ans)\", \"n, t = map(int, input().split())\\n\\na = [[None]] + [[0] * i for i in range(1, n + 1)]\\n\\nc = 2 ** (n + 1)\\n\\nfor _ in range(t):\\n\\ta[1][0] += c\\n\\tfor i in range(1, n + 1):\\n\\t\\tfor j in range(i):\\n\\t\\t\\tif a[i][j] > c:\\n\\t\\t\\t\\tdiff = a[i][j] - c\\n\\t\\t\\t\\ta[i][j] = c\\n\\t\\t\\t\\tif i < n:\\n\\t\\t\\t\\t\\ta[i + 1][j] += diff // 2\\n\\t\\t\\t\\t\\ta[i + 1][j + 1] += diff // 2\\n\\nfull = 0\\nfor i in range(1, n + 1):\\n\\tfor j in range(i):\\n\\t\\tfull += (a[i][j] == c)\\n\\nprint(full)\", \"n,t = [int(x) for x in input().split()]\\ncurr = [t]\\nfill = 0\\n\\nwhile sum(curr)>0 and len(curr)<=n:\\n    nex = [0]*(len(curr)+1)\\n    for i in range(len(curr)):\\n        if curr[i]>=1:\\n            fill+=1\\n            flow = curr[i]-1\\n            nex[i]+=flow/2\\n            nex[i+1]+=flow/2\\n    curr = nex\\n\\nprint(fill)\\n\", \"n,t = list(map(int,input().split()))\\nmatrix = [ [0]*i for i in range(1,n+1)]\\nnorma = 2**n\\nfor time in range(t):\\n    matrix[0][0] += norma\\n    for i in range(n):\\n        for j in range(i+1):\\n            if matrix[i][j]>norma:\\n                many = matrix[i][j] - norma\\n                if i+1!=n:\\n                    matrix[i+1][j]+=many//2\\n                    matrix[i+1][j+1]+=many//2\\n                matrix[i][j] = norma\\ncounter = 0\\nfor i in range(n):\\n    for j in range(i+1):\\n        if matrix[i][j] == norma:\\n            counter+=1\\nprint(counter)\\n#print(matrix)\\n\", \"import sys,math\\n\\n\\nres=[0]\\nn,m=map(int,input().split())\\nz=[]\\nneed=0\\nfor i in range(1,n+1):\\n    need+=i\\nfor i in range(1,n+1):\\n    z.append([0]*i)\\nfor i in range(1,m+1):\\n    z[0][0]+=2\\n    for i in range(n-1):\\n        for j in range(i+1):\\n            if z[i][j]>=2:\\n                h=z[i][j]-2\\n                z[i+1][j]+=h/2\\n                z[i+1][j+1]+=h/2\\n                z[i][j]=2\\n    for j in range(n):\\n        if z[-1][j]>=2:\\n            z[-1][j]=2\\n        \\ns=0\\nfor i in range(n):\\n    s+=z[i].count(2)\\nprint(s)\", \"\\ndef __starting_point():\\n    #n, m = list(map(int, input().split()))\\n    n, t = map(int, input().split())\\n    A = [[0] * 11 for _ in range(11)]\\n    ans = 0\\n    A[0][0] = t\\n    for i in range(n):\\n        for j in range(i + 1):\\n            if A[i][j] >= 1:\\n                A[i + 1][j] += (A[i][j] - 1) / 2\\n                A[i + 1][j + 1] += (A[i][j] - 1) / 2\\n                A[i][j] = 1\\n                ans += 1\\n    print(ans)\\n__starting_point()\", \"n,t = list(map(int, input().split()))\\n\\\"\\\"\\\"t = 10000\\nfor n in range(10,11):\\n    T = [[-1 for _ in range(i)] for i in range(1,n+1)]\\n    G = [[0 for _ in range(i)] for i in range(1,n+2)]\\n    for i in range(t):\\n        G[0][0] += 1000000000000\\n        for j in range(n):\\n            for l in range(j+1):\\n                if G[j][l] >= 1000000000000:\\n                    G[j+1][l] += (G[j][l]-1000000000000)//2\\n                    G[j+1][l+1] += (G[j][l]-1000000000000)//2\\n                    G[j][l] = 1000000000000\\n                    if T[j][l] == -1:\\n                        T[j][l] = i\\n    print(T)\\nint(input())\\\"\\\"\\\"\\nR = [[0], [2, 2], [6, 4, 6], [14, 8, 8, 14], [30, 13, 10, 13, 30], [62, 21, 15, 15, 21, 62], [126, 36, 21, 18, 21, 36, 126], [254, 62, 30, 23, 23, 30, 62, 254], [510, 104, 45, 31, 27, 31, 45, 104, 510], [1022, 181, 68, 40, 33, 33, 40, 68, 181, 1022]]\\n\\n\\n\\nC = [0 for _ in range(10001)]\\nfor i in range(n):\\n    for j in range(i+1):\\n        C[R[i][j]] += 1\\nfor i in range(1,10001):\\n    C[i] += C[i-1]\\nif t:\\n    print(C[t-1])\\nelse:\\n    print(0)\\n\", \"read = lambda: list(map(int, input().split()))\\nn, t = read()\\na = [[0] * 20 for i in range(20)]\\nb = [[0] * 20 for i in range(20)]\\nfor k in range(t):\\n    for i in range(n):\\n        for j in range(n):\\n            b[i][j] = 0\\n    b[0][0] = 1\\n    for s in range(n):\\n        for i in range(s + 1):\\n            j = s - i\\n            a[i][j] += b[i][j]\\n            if a[i][j] > 1:\\n                r = a[i][j] - 1\\n                a[i][j] = 1\\n                b[i + 1][j] += r / 2\\n                b[i][j + 1] += r / 2\\ncnt = 0\\nfor i in range(n):\\n    for j in range(n):\\n        cnt += int(a[i][j] == 1)\\nprint(cnt)\\n\", \"n, t = list(map(int,input().split()))\\nbo = [[0.0]*(n+1) for i in range(n+1)]\\nwhile t > 0:\\n    bo[0][0] += 1\\n    for i in range(n):\\n        for j in range(0,i+1):\\n            if bo[i][j] > 1.0:\\n                temp = (bo[i][j] - 1)/ 2\\n                bo[i][j] = 1.0\\n                bo[i+1][j] += temp\\n                bo[i+1][j+1] += temp\\n    t -= 1\\n\\nnum = 0\\nfor i in range(n):\\n    for j in range(0,i+1):\\n        if bo[i][j] >= 1.0:\\n            num += 1\\nprint(num)\\n\", \"n, t = list(map(int, input().split()))\\n\\nm = [[0]*11 for i in range(11)]\\n\\neps = 1e-6\\n\\nfor l in range(t):\\n    m[0][0] += 1.0\\n    for i in range(n):\\n        for j in range(i+1):\\n            if m[i][j] - eps > 1.0:\\n                should_end = False\\n                delta = m[i][j] - 1.0\\n                m[i][j] = 1.0\\n                m[i+1][j] += delta / 2.0\\n                m[i+1][j+1] += delta / 2.0\\n    # print(l)\\n    # for k in m:\\n    #     print(k)\\n\\nansw = 0\\nfor i in range(n):\\n    for j in range(n):\\n        if abs(m[i][j] - 1.0) <= eps:\\n            answ += 1\\n\\nprint(answ)\\n\", \"from decimal import Decimal\\n\\nRESULT = 0\\n\\n\\nclass Glass:\\n    def __init__(self):\\n        self.left = None\\n        self.right = None\\n        self.amount = Decimal(0)\\n        self.is_calculated = False\\n\\n    def add_wine(self, amount):\\n        extra_amount = self.amount + amount - Decimal(1)\\n        if extra_amount > 0:\\n            self.amount = Decimal(1)\\n            if self.left is not None:\\n                self.left.add_wine(extra_amount / Decimal(2))\\n            if self.right is not None:\\n                self.right.add_wine(extra_amount / Decimal(2))\\n        else:\\n            self.amount += amount\\n\\n\\ndef calculate(glass: Glass):\\n    if glass.is_calculated:\\n        return\\n\\n    nonlocal RESULT\\n    if glass.amount == Decimal(1):\\n        RESULT += 1\\n    glass.is_calculated = True\\n\\n    if glass.left is not None:\\n        calculate(glass.left)\\n    if glass.right is not None:\\n        calculate(glass.right)\\n\\nn, t = list(map(int, input().split()))\\n\\na = []\\n\\nfor _ in range(n):\\n    a.append([])\\n\\nfor i in range(n, 0, -1):\\n    # a[i-1].extend([Glass()] * i)\\n    for _ in range(i):\\n        a[i-1].append(Glass())\\n    if i != n:\\n        for j, g in enumerate(a[i-1]):\\n            g.left = a[i][j]\\n            g.right = a[i][j+1]\\n\\na[0][0].add_wine(t)\\n\\ncalculate(a[0][0])\\n\\nprint(RESULT)\\n\", \"n, t = map(int,input().split())\\nm = (n+1)*n//2\\na = [0]*((n+1)*n//2)\\nnext = [-1]*((n+1)*n//2)\\nnow = 1\\nlayer = 1\\nfor i in range(m-n):\\n    next[i] = (now, now+1)\\n    if layer*(layer+1)//2 == i+1:\\n        layer += 1\\n        now = layer*(layer+1)//2-1\\n    now += 1\\nfor i in range(t):\\n    a[0]+=1024\\n    for j in range(0, m):\\n        if a[j] > 1024:\\n            if next[j] == -1:\\n                a[j] = 1024\\n            else:\\n                a[next[j][0]] += (a[j]-1024)//2\\n                a[next[j][1]] += (a[j]-1024)//2\\n                a[j] = 1024\\nres = 0\\nfor i in range(m):\\n    if a[i] >= 1024:\\n        res += 1\\nprint(res)\", \"s = input().split()\\nn, t = int(s[0]), int(s[1])\\na = [0 for i in range(110)]\\n\\n\\ndef balance(x, d):\\n\\tif a[x] <= 1.0 or d == n:\\n\\t\\treturn\\n\\telse:\\n\\t\\tp = (a[x] - 1.0) / 2\\n\\t\\ta[x] = 1\\n\\t\\ta[x+n] += p\\n\\t\\ta[x+1] += p\\n\\t\\tbalance(x+n, d+1)\\n\\t\\tbalance(x+1, d+1)\\n\\t\\n\\na[0] += t\\nbalance(0, 1)\\n\\t\\nans = 0\\nfor i in range(100):\\n\\tif a[i] >= 1:\\n\\t\\tans += 1\\n\\t\\t\\nprint(ans)\", \"n,t=list(map(int,input().split()))\\nans=0\\nz=[[0 for i in range(n+1)] for i in range(n+1)]\\ne=[[0 for i in range(n+1)] for i in range(n+1)]\\nb=[[0 for i in range(n+1)] for i in range(n+1)]\\nfor it in range(t):\\n    z[0][0]+=1\\n    if (ans>=n*(n+1)//2):\\n        break\\n    for i in range(n):\\n        for j in range(i+1):\\n           if z[i][j]>=1:\\n               if (b[i][j]==0):\\n                   ans+=1\\n               b[i][j]=1\\n               e[i][j]=z[i][j]-1\\n               z[i][j]=1\\n               z[i+1][j]+=e[i][j]/2\\n               z[i+1][j+1]+=e[i][j]/2\\n               e[i][j]=0\\nprint(ans)\\n\", \"n,t=list(map(int,input().split()))\\not=0\\na=[];b=[];c=[]\\nfor i in range(n+1):\\n    a.append([])\\n    b.append([])\\n    c.append([])\\n    for j in range(n+1):\\n        a[i].append(0)\\n        b[i].append(0)\\n        c[i].append(0)    \\nfor ii in range(1,t+1):\\n    a[0][0]+=1\\n    if (ot>=(n*n+n)//2):\\n        break\\n    for i in range(n):\\n        for j in range(i+1):\\n           if a[i][j]>=1:\\n               if not(c[i][j]):\\n                   ot+=1\\n               c[i][j]=1\\n               b[i][j]=a[i][j]-1\\n               a[i][j]=1\\n               a[i+1][j]+=b[i][j]/2\\n               b[i][j]=b[i][j]/2*2\\n               a[i+1][j+1]+=b[i][j]/2\\n               b[i][j]=0\\nprint(ot)\\n\", \"def cuenta_uno(va):\\n    resp = 0\\n    for f in range(n):\\n        resp += va[f].count(1)\\n    return resp\\n#------------------------------------------\\n# Programa principal\\n#------------------------------------------\\nn, t = input().split(' ')\\nn, t = [int(n), int(t)]\\n#n, t = [3, 5]\\n#print(n, t)\\nva = [[0 for i in range(n + 1)] for i in range(n)]\\nch = [0 for i in range(n + 1)]\\n#escribe_matriz(va)\\n\\nmax = 0\\nfor i in range(n + 1):\\n    max += i\\n\\n# ciclo de segundos virtiendo vino\\nc1 = 1\\nwhile c1 <= t and cuenta_uno(va) < max:\\n#for c1 in range(t):\\n    # poner la champa\\u00f1a\\n    ch = [0 for i in range(n + 1)]\\n    ch[0] = 1\\n    i_va = 0\\n    while sum(ch) > 0 and i_va < n and cuenta_uno(va) <= 55:\\n        #poner el vino en la i_va fila de vasos\\n        for ct in range(n):\\n            va[i_va][ct] += ch[ct]\\n        #el vino que sobre divide en 2 y pasa a los dos vasos inmediatamente inferiores\\n        ch = [0 for i in range(n + 1)]\\n        for ct in range(n):\\n            if va[i_va][ct] > 1:\\n                ch[ct] += (va[i_va][ct] - 1) / 2\\n                ch[ct + 1] += (va[i_va][ct] - 1) / 2\\n                va[i_va][ct] = 1\\n        i_va += 1\\n    #escribe_matriz(va)\\n    #print (\\\"c1 = \\\", c1, \\\" i_va=\\\", i_va, \\\"cuenta_uno\\\", cuenta_uno(va), \\\" ch=\\\", ch)\\n    c1 += 1\\n#escribe_matriz(va)\\nprint(cuenta_uno(va))\\n\", \"inin=input().split(' ')\\nn=int(inin[0])\\nt=int(inin[1])\\n\\nmat=[]\\nfor i in range(n+2):\\n\\tmat.append([0.0]*(n+2))\\n\\n# def add(i,j,amt):\\n# \\tif i>=n or j<0 or j>=n:\\n# \\t\\treturn\\n# \\tmat[i][j]+=amt\\n# \\tif mat[i][j]>1:\\n# \\t\\tover=mat[i][j]-1\\n# \\t\\tmat[i][j]-=over\\n# \\t\\tadd(i+1,j,over/2)\\n# \\t\\tadd(i+1,j+1,over/2)\\n\\nfor time in range(t):\\n\\t# add(0,0,1)\\n\\tmat[1][1]+=1.0\\n\\tfor i in range(1,n+1):\\n\\t\\tfor j in range(1,i+1):\\n\\t\\t\\tif mat[i][j]>1.0:\\n\\t\\t\\t\\tover=mat[i][j]-1.0\\n\\t\\t\\t\\tmat[i+1][j]+=over/2\\n\\t\\t\\t\\tmat[i+1][j+1]+=over/2\\n\\t\\t\\t\\tmat[i][j]=1.0\\n\\nresult=0\\nfor i in range(1,n+1):\\n\\t\\tfor j in range(1,i+1):\\n\\t\\t\\tif mat[i][j]>=1.0:\\n\\t\\t\\t\\tresult+=1\\nprint(result)\\n\\n# for line in mat:\\n# \\t# print(line)\\n# \\tfor b in line:\\n# \\t\\tprint(str(b),end='\\\\t')\\n# \\tprint()\\n\", \"from copy import deepcopy\\ndef main():\\n    n, k = list(map(int, input().split()))\\n    arr = [\\n        [1],\\n        [0.5, 0.5],\\n        [0.25, 0.5, 0.25],\\n        [0.125, 0.375, 0.375, 0.125],\\n        [0.0625, 0.25, 0.375, 0.25, 0.0625],\\n        [0.03125, 0.15625, 0.3125, 0.3125, 0.15625, 0.03125],\\n        [0.015625, 0.09375, 0.234375, 0.3125, 0.234375, 0.09375, 0.015625],\\n        [0.0078125, 0.0546875, 0.1640625, 0.2734375, 0.2734375, 0.1640625, 0.0546875, 0.0078125],\\n        [0.00390625, 0.03125, 0.109375, 0.21875, 0.2734375, 0.21875, 0.109375, 0.03125, 0.00390625],\\n        [0.001953125, 0.017578125, 0.0703125, 0.1640625, 0.24609375, 0.24609375, 0.1640625, 0.0703125, 0.017578125, 0.001953125]\\n    ]\\n    opyramid = [\\n        [1],\\n        [0, 0],\\n        [0, 0, 0],\\n        [0, 0, 0, 0],\\n        [0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n    ]\\n    finish_times = [\\n        [1],\\n        [0, 0],\\n        [0, 0, 0],\\n        [0, 0, 0, 0],\\n        [0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0, 0, 0],\\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n    ]\\n    opyramid[0][0] = 1\\n    countarr = [0, 1]\\n    for x in range(2, 10001):\\n        opyramid[0][0] += 1\\n        for y in range(1, len(opyramid)):\\n            opyramid[y][0] += max(opyramid[y - 1][0] - 1, 0) * 0.5\\n            opyramid[y - 1][0] -= max(opyramid[y - 1][0] - 1, 0) * 0.5\\n            for z in range(1, y):\\n                opyramid[y][z] += max(opyramid[y - 1][z - 1] - 1, 0) + \\\\\\n                    max(opyramid[y - 1][z] - 1, 0) * 0.5\\n                opyramid[y - 1][z - 1] -= max(opyramid[y - 1][z - 1] - 1, 0)\\n                opyramid[y - 1][z] -= max(opyramid[y - 1][z] - 1, 0) * 0.5\\n            opyramid[y][y] += max(opyramid[y - 1][y - 1] - 1, 0)\\n            opyramid[y - 1][y - 1] -= max(opyramid[y - 1][y - 1] - 1, 0)\\n        # print(opyramid)\\n        count = 0\\n        for x in range(n):\\n            for y in opyramid[x]:\\n                if y >= 1:\\n                    count += 1\\n        countarr.append(count)\\n    print(countarr[k])\\n\\n    # arr = [\\n    #     [1],\\n    #     [0.5, 0.5],]\\n    # for x in range(3, 11):\\n    #     na = []\\n    #     for y in range(x - 2):\\n    #         na.append(arr[-1][y]*0.5 + arr[-1][y + 1]*0.5)\\n    #     arr.append([arr[-1][0] * 0.5] + na + [arr[-1][-1] * 0.5])\\n    # print(arr)\\n    # #     [1, 2, 1],\\n    # #     [1, 3, 3, 1],\\n    # #     [1, 4, 6, 4, 1],\\n    # #     [1, 5, 10, 10, 5, 1],\\n    # #     [1, 6, 15, 20, 15, 6, 1],\\n    # #     [1, 7, 21, 35, 35, 21, 7, 1],\\n    # #     [1, 8, 28, 56, 70, 56, 28, 8, 1]]\\n\\n    # # arr = [\\n    # #     [1],\\n    # #     [1, 1],\\n    # #     [1, 2, 1],\\n    # #     [1, 3, 3, 1],\\n    # #     [1, 4, 6, 4, 1],\\n    # #     [1, 5, 10, 10, 5, 1],\\n    # #     [1, 6, 15, 20, 15, 6, 1],\\n    # #     [1, 7, 21, 35, 35, 21, 7, 1],\\n    # #     [1, 8, 28, 56, 70, 56, 28, 8, 1]]\\n\\n    # # print(arr)\\n\\nmain()\\n\", \"def push(graph, pos, level):\\n    if graph[pos] > 1:\\n        over = graph[pos] - 1\\n        graph[pos] = 1\\n        if level + pos < numberofglasses:\\n            graph[level + pos] += over / 2\\n        if level + pos + 1 < numberofglasses:\\n            graph[level + pos + 1] += over / 2\\n        if level + pos < numberofglasses:\\n            push(graph, level + pos, level + 1)\\n        if level + pos + 1 < numberofglasses:\\n            push(graph, level + pos + 1, level + 1)\\n\\n\\nn, t = map(int, input().split())\\ntable = dict()\\ncurrent = 0\\nfor i in range(1, 11):\\n    current += i\\n    table[i] = current\\ngraph = [0] * table[n]\\nnumberofglasses = table[n]\\ngraph[0] = t\\npush(graph, 0, 1)\\ncounter = 0\\nfor elem in graph:\\n    if elem == 1:\\n        counter += 1\\nprint(counter)\", \"from fractions import Fraction\\n\\ninp = input().split()\\nN, T = int(inp[0]), int(inp[1])\\n\\nif T is 0:\\n    print(0)\\n    return\\n\\ndp = []\\nfor r in range(N + 1):\\n    dp.append([Fraction(0) for _ in range(N + 1)])\\n\\ndp[0][0] = Fraction(T)\\nfor r in range(N):\\n    for c in range(r + 1):\\n        if dp[r][c] >= Fraction(1):\\n            dp[r + 1][c + 0] += (dp[r][c] - Fraction(1)) / Fraction(2);\\n            dp[r + 1][c + 1] += (dp[r][c] - Fraction(1)) / Fraction(2);\\n\\ncnt = 0\\nfor r in range(N):\\n    for c in range(r + 1):\\n        if dp[r][c] >= Fraction(1):\\n            cnt += 1\\n\\nprint(cnt)\\n\", \"def push(graph, pos, level):\\n    if graph[pos] > 1:\\n        over = graph[pos] - 1\\n        graph[pos] = 1\\n        if level + pos < numberofglasses:\\n            graph[level + pos] += over / 2\\n        if level + pos + 1 < numberofglasses:\\n            graph[level + pos + 1] += over / 2\\n        if level + pos < numberofglasses:\\n            push(graph, level + pos, level + 1)\\n        if level + pos + 1 < numberofglasses:\\n            push(graph, level + pos + 1, level + 1)\\n\\n\\nn, t = map(int, input().split())\\ntable = dict()\\ncurrent = 0\\nfor i in range(1, 11):\\n    current += i\\n    table[i] = current\\ngraph = [0] * table[n]\\nnumberofglasses = table[n]\\n\\ngraph[0] += t\\npush(graph, 0, 1)\\ncounter = 0\\nfor elem in graph:\\n    if elem == 1:\\n        counter += 1\\nprint(counter)\", \"n, t = list(map(int, input().split()))\\ntotal = sum(range(1, n+1))\\nl = [[0] * i for i in range(1, n+1)]\\nmax_d = sum(range(1, n+1))\\nd = 0\\n\\ndef f(l, lvl, i, inc):\\n    if lvl >= len(l) or i >= len(l[lvl]):\\n        return\\n    if l[lvl][i] < 1:\\n        tmp = l[lvl][i] + inc\\n        if tmp > 1:\\n            inc = tmp - 1\\n            l[lvl][i] = 1\\n        else:\\n            l[lvl][i] += inc\\n            inc = 0\\n    if inc == 0:\\n        return\\n    inc /= 2\\n    lvl += 1\\n    f(l, lvl, i, inc)\\n    f(l, lvl, i+1, inc)\\n        \\ndef count(l):\\n    ans = 0\\n    for i in range(len(l)):\\n        for j in range(len(l[i])):\\n            if l[i][j] >= 1:\\n                ans += 1\\n    return ans\\n\\nf(l, 0, 0, t)\\n\\nprint(count(l))\\n\\n    \\n\\n\", \"n, t = map(int, input().split())\\na = [0] * (n + 1)\\nfor i in range(n + 1):\\n    a[i] = [0] * (i + 1)\\nfor i in range(t):\\n    a[0][0] += 1\\n    for j in range(n):\\n        for k in range(j + 1):\\n            if a[j][k] > 1:\\n                a[j + 1][k] += (a[j][k] - 1) / 2\\n                a[j + 1][k + 1] += (a[j][k] - 1) / 2\\n                a[j][k] = 1\\nres = 0\\n\\nfor j in range(n):\\n    for k in range(j + 1):\\n        if a[j][k] == 1:\\n            res += 1\\n\\nprint(res)\"]",
  "input_output": "{\n  \"inputs\": [\n    \"3 5\\n\",\n    \"4 8\\n\",\n    \"1 1\\n\",\n    \"10 10000\\n\",\n    \"1 10000\\n\",\n    \"10 1\\n\",\n    \"1 0\\n\",\n    \"10 0\\n\",\n    \"10 1022\\n\",\n    \"10 1023\\n\",\n    \"10 1024\\n\",\n    \"1 2\\n\",\n    \"1 200\\n\",\n    \"7 128\\n\",\n    \"8 198\\n\",\n    \"2 2\\n\",\n    \"2 3\\n\",\n    \"2 4\\n\",\n    \"2 100\\n\",\n    \"2 10000\\n\",\n    \"3 7\\n\",\n    \"3 6\\n\",\n    \"3 8\\n\",\n    \"3 12\\n\",\n    \"3 1\\n\",\n    \"4 15\\n\",\n    \"4 14\\n\",\n    \"4 10\\n\",\n    \"4 16\\n\",\n    \"4 999\\n\",\n    \"4 9\\n\",\n    \"5 31\\n\",\n    \"5 30\\n\",\n    \"5 28\\n\",\n    \"5 25\\n\",\n    \"5 15\\n\",\n    \"5 32\\n\",\n    \"5 9999\\n\",\n    \"5 4\\n\",\n    \"5 9\\n\",\n    \"5 14\\n\",\n    \"6 63\\n\",\n    \"6 62\\n\",\n    \"6 61\\n\",\n    \"6 52\\n\",\n    \"6 31\\n\",\n    \"6 32\\n\",\n    \"6 39\\n\",\n    \"6 15\\n\",\n    \"6 14\\n\",\n    \"6 10\\n\",\n    \"6 4\\n\",\n    \"6 7653\\n\",\n    \"7 127\\n\",\n    \"6 64\\n\",\n    \"7 126\\n\",\n    \"7 125\\n\",\n    \"7 120\\n\",\n    \"7 98\\n\",\n    \"7 110\\n\",\n    \"7 65\\n\",\n    \"7 63\\n\",\n    \"7 15\\n\",\n    \"7 3\\n\",\n    \"7 1\\n\",\n    \"7 83\\n\",\n    \"7 214\\n\",\n    \"8 2555\\n\",\n    \"8 257\\n\",\n    \"8 256\\n\",\n    \"8 255\\n\",\n    \"8 254\\n\",\n    \"8 253\\n\",\n    \"8 251\\n\",\n    \"8 240\\n\",\n    \"8 128\\n\",\n    \"8 127\\n\",\n    \"8 100\\n\",\n    \"8 1\\n\",\n    \"8 0\\n\",\n    \"8 10000\\n\",\n    \"8 94\\n\",\n    \"8 33\\n\",\n    \"9 10000\\n\",\n    \"9 513\\n\",\n    \"9 512\\n\",\n    \"9 511\\n\",\n    \"9 510\\n\",\n    \"9 255\\n\",\n    \"9 256\\n\",\n    \"9 254\\n\",\n    \"9 253\\n\",\n    \"9 200\\n\",\n    \"9 100\\n\",\n    \"9 150\\n\",\n    \"10 9999\\n\",\n    \"10 1025\\n\",\n    \"10 1021\\n\",\n    \"10 512\\n\",\n    \"10 689\\n\",\n    \"10 754\\n\",\n    \"10 985\\n\",\n    \"10 255\\n\",\n    \"10 256\\n\",\n    \"10 254\\n\",\n    \"10 153\\n\",\n    \"10 2\\n\",\n    \"10 3\\n\",\n    \"10 5\\n\",\n    \"10 63\\n\",\n    \"10 64\\n\",\n    \"10 126\\n\",\n    \"10 127\\n\",\n    \"10 128\\n\",\n    \"10 55\\n\",\n    \"10 9\\n\",\n    \"10 37\\n\",\n    \"10 68\\n\",\n    \"3 4\\n\",\n    \"7 23\\n\",\n    \"1 3\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n\",\n    \"6\\n\",\n    \"1\\n\",\n    \"55\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"53\\n\",\n    \"55\\n\",\n    \"55\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"28\\n\",\n    \"34\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"6\\n\",\n    \"4\\n\",\n    \"6\\n\",\n    \"6\\n\",\n    \"1\\n\",\n    \"10\\n\",\n    \"8\\n\",\n    \"8\\n\",\n    \"10\\n\",\n    \"10\\n\",\n    \"8\\n\",\n    \"15\\n\",\n    \"13\\n\",\n    \"13\\n\",\n    \"13\\n\",\n    \"13\\n\",\n    \"15\\n\",\n    \"15\\n\",\n    \"3\\n\",\n    \"8\\n\",\n    \"11\\n\",\n    \"21\\n\",\n    \"19\\n\",\n    \"19\\n\",\n    \"19\\n\",\n    \"19\\n\",\n    \"19\\n\",\n    \"19\\n\",\n    \"13\\n\",\n    \"11\\n\",\n    \"8\\n\",\n    \"3\\n\",\n    \"21\\n\",\n    \"28\\n\",\n    \"21\\n\",\n    \"26\\n\",\n    \"26\\n\",\n    \"26\\n\",\n    \"26\\n\",\n    \"26\\n\",\n    \"26\\n\",\n    \"26\\n\",\n    \"13\\n\",\n    \"3\\n\",\n    \"1\\n\",\n    \"26\\n\",\n    \"28\\n\",\n    \"36\\n\",\n    \"36\\n\",\n    \"36\\n\",\n    \"36\\n\",\n    \"34\\n\",\n    \"34\\n\",\n    \"34\\n\",\n    \"34\\n\",\n    \"34\\n\",\n    \"34\\n\",\n    \"32\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"36\\n\",\n    \"32\\n\",\n    \"26\\n\",\n    \"45\\n\",\n    \"45\\n\",\n    \"45\\n\",\n    \"45\\n\",\n    \"43\\n\",\n    \"43\\n\",\n    \"43\\n\",\n    \"41\\n\",\n    \"41\\n\",\n    \"41\\n\",\n    \"37\\n\",\n    \"41\\n\",\n    \"55\\n\",\n    \"55\\n\",\n    \"53\\n\",\n    \"53\\n\",\n    \"53\\n\",\n    \"53\\n\",\n    \"53\\n\",\n    \"51\\n\",\n    \"51\\n\",\n    \"49\\n\",\n    \"47\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"4\\n\",\n    \"41\\n\",\n    \"41\\n\",\n    \"45\\n\",\n    \"47\\n\",\n    \"47\\n\",\n    \"37\\n\",\n    \"8\\n\",\n    \"33\\n\",\n    \"41\\n\",\n    \"3\\n\",\n    \"20\\n\",\n    \"1\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/676/B",
  "starter_code": ""
}