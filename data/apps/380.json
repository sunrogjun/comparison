{
  "task_id": "APPS/380",
  "problem_id": 380,
  "prompt": "There are three points marked on the coordinate plane. The goal is to make a simple polyline, without self-intersections and self-touches, such that it passes through all these points. Also, the polyline must consist of only segments parallel to the coordinate axes. You are to find the minimum number of segments this polyline may consist of.\n\n\n-----Input-----\n\nEach of the three lines of the input contains two integers. The i-th line contains integers x_{i} and y_{i} ( - 10^9 \u2264 x_{i}, y_{i} \u2264 10^9)\u00a0\u2014 the coordinates of the i-th point. It is guaranteed that all points are distinct.\n\n\n-----Output-----\n\nPrint a single number\u00a0\u2014 the minimum possible number of segments of the polyline.\n\n\n-----Examples-----\nInput\n1 -1\n1 1\n1 2\n\nOutput\n1\n\nInput\n-1 -1\n-1 3\n4 3\n\nOutput\n2\n\nInput\n1 1\n2 3\n3 2\n\nOutput\n3\n\n\n\n-----Note-----\n\nThe variant of the polyline in the first sample: [Image] The variant of the polyline in the second sample: $1$ The variant of the polyline in the third sample: $\\because$",
  "solutions": "[\"a, b = list(map(int, input().split(' ')))\\nc, d = list(map(int, input().split(' ')))\\ne, f = list(map(int, input().split(' ')))\\nx=[[a, b],[c,d],[e,f]]\\nx.sort()\\na, b, c, d, e, f = x[0][0], x[0][1], x[1][0], x[1][1], x[2][0], x[2][1]\\nif (a==c==e or b==d==f):\\n    print(1)\\n    quit()\\n\\nif a == c:\\n    if b<f<d:\\n        print(3)\\n        quit()\\n    print(2)\\n    quit()\\n\\nif c == e:\\n    if (d<b<f):\\n        print(3)\\n        quit()\\n    print(2)\\n    quit()\\n\\nif b == d:\\n    print(2)\\n    quit()\\n\\nif d == f:\\n    print(2)\\n    quit()\\n\\nif b == f:\\n    if a<c<e:\\n        print(3)\\n        quit()\\n    print(2)\\n    quit()\\n\\nprint(3)\\nquit()\\n\", \"A = [int(x) for x in input().split()]\\nB = [int(x) for x in input().split()]\\nC = [int(x) for x in input().split()]\\n\\ndef out(value):\\n    print(value)\\n    return\\n\\nif A[0] == B[0] and B[0] == C[0]:\\n    out(1)\\n\\nif A[1] == B[1] and B[1] == C[1]:\\n    out(1)\\n\\nimport itertools\\n\\nX = A\\nY = B\\nZ = C\\nfor p in itertools.permutations([X, Y, Z]):\\n    A = p[0]\\n    B = p[1]\\n    C = p[2]\\n    if A[0] == B[0] and (C[1] <= min(A[1], B[1]) or C[1] >= max(A[1], B[1])):\\n        out(2)\\n    if A[1] == B[1] and (C[0] <= min(A[0], B[0]) or C[0] >= max(A[0], B[0])):\\n        out(2)\\n\\nout(3)\\n\", \"ax, ay = list(map(int, input().split()))\\nbx, by = list(map(int, input().split()))\\ncx, cy = list(map(int, input().split()))\\nif (ax == bx == cx)or(ay == by == cy):\\n    ans = 1\\nelif (ax == bx)and((cy <= min(ay, by))or(cy >= max(ay, by))):\\n    ans = 2\\nelif (ax == cx)and((by <= min(ay, cy))or(by >= max(ay, cy))):\\n    ans = 2\\nelif (cx == bx)and((ay <= min(cy, by))or(ay >= max(cy, by))):\\n    ans = 2\\nelif (ay == by)and((cx <= min(ax, bx))or(cx >= max(ax, bx))):\\n    ans = 2\\nelif (ay == cy)and((bx <= min(ax, cx))or(bx >= max(ax, cx))):\\n    ans = 2\\nelif (cy == by)and((ax <= min(cx, bx))or(ax >= max(cx, bx))):\\n    ans = 2\\nelse:\\n    ans = 3\\nprint(ans)\\n\", \"read = lambda: list(map(int, input().split()))\\nx1, y1 = read()\\nx2, y2 = read()\\nx3, y3 = read()\\nans = 3\\nf1 = y1 == y2 and ((x3 >= x2 and x3 >= x1) or (x3 <= x2 and x3 <= x1))\\nf2 = y2 == y3 and ((x1 >= x2 and x1 >= x3) or (x1 <= x2 and x1 <= x3))\\nf3 = y1 == y3 and ((x2 >= x3 and x2 >= x1) or (x2 <= x1 and x2 <= x3))\\nf4 = x1 == x2 and ((y3 >= y2 and y3 >= y1) or (y3 <= y2 and y3 <= y1))\\nf5 = x2 == x3 and ((y1 >= y2 and y1 >= y3) or (y1 <= y2 and y1 <= y3))\\nf6 = x1 == x3 and ((y2 >= y3 and y2 >= y1) or (y2 <= y1 and y2 <= y3))\\nif f1 or f2 or f3 or f4 or f5 or f6: ans = 2\\nif x1 == x2 == x3 or y1 == y2 == y3: ans = 1\\nprint(ans)\\n\", \"#!/usr/bin/env python3\\n\\nx1, y1 = input().split()\\nx2, y2 = input().split()\\nx3, y3 = input().split()\\nx1, y1, x2, y2, x3, y3 = int(x1), int(y1), int(x2), int(y2), int(x3), int(y3)\\n\\ndef ans(p1, p2, p3):\\n\\tx1, y1 = p1\\n\\tx2, y2 = p2\\n\\tx3, y3 = p3\\n\\t# x,x    x\\n\\t# x  x   x\\n\\tif (x1 == x2 == x3): return 1\\n\\n\\t#  x  x\\n\\t#  x\\n\\tif (x1, y1) == (x2, y3): \\n\\t\\treturn 2\\n\\n\\tif y1 == y2:\\n\\t\\tif x1 < x3 < x2: \\n\\t\\t\\t# x   x\\n\\t\\t\\t#   x  \\n\\t\\t\\treturn 3\\n\\t\\tif x2 < x3 < x1:\\n\\t\\t\\treturn 3\\n\\t\\telse:\\n\\t\\t\\t# \\t  x x\\n\\t\\t\\t# x\\n\\t\\t\\treturn 2\\n\\n\\treturn 3\\n\\np1 = (x1, y1)\\np2 = (x2, y2)\\np3 = (x3, y3)\\n\\nt1 = (y1, x1)\\nt2 = (y2, x2)\\nt3 = (y3, x3)\\nprint(min(\\n\\tans(p1, p2, p3),\\n\\tans(p1, p3, p2),\\n\\tans(p2, p1, p3),\\n\\tans(p2, p3, p1),\\n\\tans(p3, p1, p2),\\n\\tans(p3, p2, p1),\\n\\tans(t1, t2, t3),\\n\\tans(t1, t3, t2),\\n\\tans(t2, t1, t3),\\n\\tans(t2, t3, t1),\\n\\tans(t3, t1, t2),\\n\\tans(t3, t2, t1)\\n))\", \"p = [0]*3\\nq = [0]*3\\n\\nsum = 0\\n\\na1,b1 = list(map(int, input().split()))\\na2,b2 = list(map(int, input().split()))\\nif a1 == a2:\\n    p[0] = 1\\nif b1 == b2:\\n    q[0] = 1\\na3,b3 = list(map(int, input().split()))    \\nif a1 == a3:\\n    p[1] = 1\\nif b1 == b3:\\n    q[1] = 1\\nif a2 == a3:\\n    p[2] = 1\\nif b2 == b3:\\n    q[2] = 1\\n\\nsum = 0\\nfor i in range(3):\\n    sum += p[i] + q[i]\\n\\nif sum == 0:\\n    print(3)\\nelif sum == 3:\\n    print(1)\\nelif sum == 2:\\n    print(2)\\nelse:\\n    if q[1] + q[2] + q[0] == 1:\\n        b1 = a1\\n        b2 = a2\\n        b3 = a3\\n        p[0] = q[0]\\n        p[1] = q[1]\\n        p[2] = q[2]\\n\\n    if p[0] == 1 and (b3 > max(b1,b2) or b3 < min(b1,b2)):\\n        print(2)\\n    elif p[1] == 1 and (b2 > max(b1,b3) or b2 < min(b1,b3)):\\n        print(2)\\n    elif p[2] == 1 and (b1 > max(b2,b3) or b1 < min(b2,b3)):\\n        print(2)\\n    else:\\n        print(3)\\n        \\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n                \\n\", \"read = lambda: list(map(int, input().split()))\\n\\ndef test(a, b, c):\\n\\tif a > b:\\n\\t\\ta, b = b, a\\n\\tif not (a <= c <= b):\\n\\t\\treturn -1\\n\\treturn 1 if c == a or c == b else 0\\n\\ndef main():\\n\\ta = [tuple(read()) for _ in range(3)]\\n\\tif a[0][0] == a[1][0] == a[2][0] or a[0][1] == a[1][1] == a[2][1]:\\n\\t\\treturn 1\\n\\tfor i in range(3):\\n\\t\\tfor j in range(i + 1, 3):\\n\\t\\t\\tif a[i][0] != a[j][0] and a[i][1] != a[j][1]:\\n\\t\\t\\t\\tk = 3 ^ i ^ j\\n\\t\\t\\t\\tx = test(a[i][0], a[j][0], a[k][0])\\n\\t\\t\\t\\ty = test(a[i][1], a[j][1], a[k][1])\\n\\t\\t\\t\\tif min(x, y) >= 0 and max(x, y) == 1:\\n\\t\\t\\t\\t\\treturn 2\\n\\treturn 3\\n\\nprint(main())\\n\", \"x = [0 for i in range(3)]\\ny = [0 for i in range(3)]\\nmark = [False, False, False]\\nmark1 = [False, False, False]\\nfor i in range(3):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nxp = []\\nyp = []\\nfor i in range(3):\\n    for j in range(i + 1, 3):\\n        if x[i] == x[j]:\\n            xp.append([i, j])\\n            mark[i] = True\\n            mark[j] = True\\n        if y[j] == y[i]:\\n            yp.append([i, j])\\n            mark1[i] = True\\n            mark1[j] = True            \\nif len(xp) == 3 or len(yp) == 3:\\n    print(1)\\nelif len(xp) == 1:\\n    if not mark[0]:\\n        if y[0] >= max(y[1], y[2]) or y[0] <= min(y[1], y[2]):\\n            print(2)\\n        else:\\n            print(3)\\n    elif not mark[1]:\\n        if y[1] >= max(y[0], y[2]) or y[1] <= min(y[0], y[2]):\\n            print(2)\\n        else:\\n            print(3)\\n    if not mark[2]:\\n        if y[2] >= max(y[1], y[0]) or y[2] <= min(y[1], y[0]):\\n            print(2)\\n        else:\\n            print(3)    \\n        \\nelif len(yp) == 1:\\n    if not mark1[0]:\\n        if x[0] >= max(x[1], x[2]) or x[0] <= min(x[1], x[2]):\\n            print(2)\\n        else:\\n            print(3)\\n    elif not mark1[1]:\\n        if x[1] >= max(x[0], x[2]) or x[1] <= min(x[0], x[2]):\\n            print(2)\\n        else:\\n            print(3)\\n    if not mark1[2]:\\n        if x[2] >= max(x[1], x[0]) or x[2] <= min(x[1], x[0]):\\n            print(2)\\n        else:\\n            print(3)    \\nelse:\\n    print(3)\\n\", \"\\nxs , ys = input().split(\\\" \\\")\\nx1 = int(xs)\\ny1 = int(ys)\\n\\nxs , ys = input().split(\\\" \\\")\\nx2 = int(xs)\\ny2 = int(ys)\\n\\nxs , ys = input().split(\\\" \\\")\\nx3 = int(xs)\\ny3 = int(ys)\\n\\n\\ndef check ( a , b , c ) :\\n  if a < b and b < c :\\n    return 3\\n  if c < b and b < a :\\n    return 3\\n  return 2\\n\\nif x1 == x2 == x3 or y1 == y2 == y3 :\\n  print ( 1 )\\n  return  \\n\\nif x2 == x3 :\\n  print ( check ( y2 , y1 , y3 ) )\\n  return\\nif x1 == x3 :\\n  print ( check ( y1 , y2 , y3 ) )\\n  return\\nif x1 == x2 :\\n  print ( check ( y1 , y3 , y2 ) )\\n  return\\n\\nif y2 == y3 :\\n  print ( check ( x2 , x1 , x3 ) )\\n  return\\nif y1 == y3 :\\n  print ( check ( x1 , x2 , x3 ) )\\n  return\\nif y1 == y2 :\\n  print ( check ( x1 , x3 , x2 ) )\\n  return\\n\\n\\n  \\nprint ( 3 ) \", \"#!/usr/bin/env python3\\nimport operator\\nfrom itertools import islice\\nimport math\\n\\n\\ndef all_on_same_line(points):\\n    return all(x == points[0][0] for x, y in points) or all(y == points[0][1] for x, y in points)\\n\\n\\ndef all_on_different_lines(points):\\n    return len(set(x for x, y in points)) == len(points) and len(set(y for x, y in points)) == len(points)\\n\\n\\ndef has_two_points_with_same_x_coord(points):\\n    return len(set(x for x, y in points)) == 2\\n\\n\\ndef get_common_x(points):\\n    xs = [x for x, y in points]\\n    for xx in set(x for x, y in points):\\n        if xs.count(xx) == 2:\\n            return xx\\n\\ndef get_common_y(points):\\n    ys = [y for x, y in points]\\n    for yy in set(y for x, y in points):\\n        if ys.count(yy) == 2:\\n            return yy\\n\\n\\ndef main():\\n    points = [(int(x), int(y)) for x, y in (input().split() for _ in range(3))]\\n    if all_on_same_line(points):\\n        print(1)\\n    elif all_on_different_lines(points):\\n        print(3)\\n    else:\\n        if has_two_points_with_same_x_coord(points):\\n            y = get_common_x(points)\\n            points = sorted(points, key=lambda p: p[0] == y)\\n            if min(points[1][1], points[2][1]) < points[0][1] <  max(points[1][1], points[2][1]):\\n                print(3)\\n            else:\\n                print(2)\\n        else:\\n            y = get_common_y(points)\\n            points = sorted(points, key=lambda p: p[1] == y)\\n            if min(points[1][0], points[2][0]) < points[0][0] <  max(points[1][0], points[2][0]):\\n                print(3)\\n            else:\\n                print(2)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"a = list(map(int, input().split()))\\nb = list(map(int, input().split()))\\nc = list(map(int, input().split()))\\n\\nif (a[0] == b[0] and b[0] == c[0]) or (a[1] == b[1] and b[1] == c[1]):\\n    print(1)\\n    return\\n\\nif (a[0] == b[0] and ((c[1] >= a[1] and c[1] >= b[1]) or (c[1] <= a[1] and c[1] <= b[1]))) or \\\\\\n   (a[0] == c[0] and ((b[1] >= a[1] and b[1] >= c[1]) or (b[1] <= a[1] and b[1] <= c[1]))) or \\\\\\n   (c[0] == b[0] and ((a[1] >= c[1] and a[1] >= b[1]) or (a[1] <= b[1] and a[1] <= c[1]))) or \\\\\\n   (a[1] == b[1] and ((c[0] >= a[0] and c[0] >= b[0]) or (c[0] <= a[0] and c[0] <= b[0]))) or \\\\\\n   (a[1] == c[1] and ((b[0] >= a[0] and b[0] >= c[0]) or (b[0] <= a[0] and b[0] <= c[0]))) or \\\\\\n   (b[1] == c[1] and ((a[0] >= c[0] and a[0] >= b[0]) or (a[0] <= b[0] and a[0] <= c[0]))):\\n    print(2)\\n    return\\n\\nprint(3)\", \"ps = [tuple(int(x) for x in input().split()) for _ in range(3)]\\nps.sort()\\nxa, ya = ps[0]\\nxb, yb = ps[1]\\nxc, yc = ps[2]\\nif xa == xb:\\n    if xc == xa:\\n        print(1)\\n    elif yc <= ya or yb <= yc:\\n            print(2)\\n    else:\\n        print(3)\\nelif ya == yb:\\n    if yc == ya:\\n        print(1)\\n    else:\\n        print(2)\\nelif ya < yb:\\n    if xb == xc or yb == yc:\\n        print(2)\\n    else:\\n        print(3)\\nelse:\\n    if yb == yc or (xb == xc and yc <= ya):\\n        print(2)\\n    else:\\n        print(3)\\n\", \"x1,y1 = map(int,input().split())\\nx2,y2 = map(int,input().split())\\nx3,y3 = map(int,input().split())\\ndef det(x0,y0,x1,y1):\\n    return x0*y1\\n\\n\\nif x1==x2==x3 or y1==y2==y3:\\n    print(1)\\n    quit()\\nelif       (y1==y2 and ((x3<=x1 and x3<=x2) or (x3>=x1 and x3>=x2)))\\\\\\n        or (y1==y3 and ((x2<=x1 and x2<=x3) or (x2>=x1 and x2>=x3)))\\\\\\n        or (y2==y3 and ((x1<=x2 and x1<=x3) or (x1>=x2 and x1>=x3)))\\\\\\n        or (x1==x2 and ((y3<=y1 and y3<=y2) or (y3>=y1 and y3>=y2)))\\\\\\n        or (x1==x3 and ((y2<=y1 and y2<=y3) or (y2>=y1 and y2>=y3)))\\\\\\n        or (x2==x3 and ((y1<=x2 and y1<=y3) or (y1>=y2 and y1>=y3))):\\n    print(2)\\n    quit()\\n\\nelse:\\n    print(3)\", \"p = [tuple(map(int, input().split())) for i in range(3)]\\nif p[0][0] == p[1][0] and p[1][0] == p[2][0] or p[0][1] == p[1][1] and p[1][1] == p[2][1]:\\n     print(1)\\n     return\\np.sort()\\nif p[0][0] == p[1][0]:\\n     print(3 if p[2][1] in range(min(p[0][1], p[1][1]) + 1, max(p[0][1], p[1][1])) else 2)\\n     return\\nif p[1][0] == p[2][0]:\\n     print(3 if p[0][1] in range(min(p[1][1], p[2][1]) + 1, max(p[1][1], p[2][1])) else 2)\\n     return\\np = sorted((y, x) for (x, y) in p)\\nif p[0][0] == p[1][0]:\\n     print(3 if p[2][1] in range(min(p[0][1], p[1][1]) + 1, max(p[0][1], p[1][1])) else 2)\\n     return\\nif p[1][0] == p[2][0]:\\n     print(3 if p[0][1] in range(min(p[1][1], p[2][1]) + 1, max(p[1][1], p[2][1])) else 2)\\n     return\\nprint(3)\", \"points = [tuple(int(x) for x in input().split()) for _ in range(3)]\\npoints.sort()\\np1, p2, p3 = points\\n\\nif (p1[0] == p2[0] and p2[0] == p3[0]) or (p1[1] == p2[1] and p2[1] == p3[1]):\\n    print(1)\\nelif p1[0] == p2[0]:\\n    if min(p1[1], p2[1]) < p3[1] < max(p1[1], p2[1]):\\n        print(3)\\n    else:\\n        print(2)\\nelif p2[0] == p3[0]:\\n    if min(p2[1], p3[1]) < p1[1] < max(p2[1], p3[1]):\\n        print(3)\\n    else:\\n        print(2)\\nelse:\\n    points.sort(key=lambda p: p[1])\\n    if p1[1] == p2[1]:\\n        if min(p1[0], p2[0]) < p3[0] < max(p1[0], p2[0]):\\n            print(3)\\n        else:\\n            print(2)\\n    elif p2[1] == p3[1]:\\n        if min(p2[0], p3[0]) < p1[0] < max(p1[0], p2[0]):\\n            print(3)\\n        else:\\n            print(2)\\n    else:\\n        print(3)\\n\", \"#!/usr/bin/env python3\\n# -*- coding: utf-8 -*-\\n\\nimport time\\n\\nx = []\\ny = []\\n\\nfor i in range(3):\\n    (a, b)   = (int(i) for i in input().split())\\n    x.append(a)\\n    y.append(b)\\n\\nif len(set(x)) == 2:\\n    (x, y) = (y, x)\\n\\na = [ [x[i], y[i]] for i in range(3) ]\\na = sorted(a)\\n\\nstart = time.time()\\n\\nif (a[0][0] == a[1][0] and a[1][0] == a[2][0]) or (a[0][1] == a[1][1] and a[1][1] == a[2][1]):\\n    print(1)\\nelif a[0][0] == a[1][0] or a[1][0] == a[2][0] or a[0][1] == a[1][1] or a[1][1] == a[2][1] :\\n    print(2)\\nelse:\\n    print(3)\\n\\nfinish = time.time()\\n#print(finish - start)\\n\", \"#! /usr/bin/env python\\n# -*- coding: utf-8 -*-\\n# vim:fenc=utf-8\\n#\\n# Copyright \\u00a9 2016 missingdays <missingdays@missingdays>\\n#\\n# Distributed under terms of the MIT license.\\n\\n\\\"\\\"\\\"\\n\\n\\\"\\\"\\\"\\n\\ndef calc(x1, y1, x2, y2, x3, y3):\\n    if x1 == x2 == x3 or y1 == y2 == y3:\\n        return 1\\n\\n    if x2 == x3 or y2 == y3:\\n        x1, x3 = x3, x1\\n        y1, y3 = y3, y1\\n    if x1 == x3 or y1 == y3:\\n        x2, x3 = x3, x2\\n        y2, y3 = y3, y2\\n\\n    if x1 == x2:\\n        if y1 < y3 < y2 or y2 < y3 < y1:\\n            return 3\\n        else:\\n            return 2\\n\\n    if y1 == y2:\\n        if x1 < x3 < x2 or x2 < x3 < x1:\\n            return 3\\n        else:\\n            return 2\\n\\n    return 3    \\n\\nx1, y1 = [int(i) for i in input().split()]\\nx2, y2 = [int(i) for i in input().split()]\\nx3, y3 = [int(i) for i in input().split()]\\n\\nprint(calc(x1, y1, x2, y2, x3, y3))\\n\", \"import math\\nonsegment = lambda x, y, z: min(y,z) <= x <= max(y,z)\\noninterval = lambda x, y, z: min(y,z) < x < max(y,z)\\ndef inrectangle(p0, p1, p2):\\n    return oninterval(p0[0], p1[0], p2[0]) and oninterval(p0[1], p1[1], p2[1])\\ndef onborder(p0, p1, p2):\\n    return onsegment(p0[0], p1[0], p2[0]) and onsegment(p0[1], p1[1], p2[1]) and not inrectangle(p0, p1, p2)\\npoints = []\\nfor i in range(3):\\n    points.append(tuple(int(x) for x in input().split()))\\npoints.sort()\\nif (all((point[0] == points[0][0] for point in points)) or\\n    all((point[1] == points[0][1] for point in points))):\\n    print(1)\\nelif points[0][1] == points[2][1]:\\n    print(3 if points[0][0] < points[1][0] < points[2][0] else 2)\\nelif onborder(points[1], points[0], points[2]) or onborder(points[2], points[0], points[1]) or onborder(points[0], points[1], points[2]):\\n    print(2)\\nelse:\\n    print(3)\\n\", \"x1, y1 = list(map(int, input().split()))\\nx2, y2 = list(map(int, input().split()))\\nx3, y3 = list(map(int, input().split()))\\nxs = [x1, x2, x3]\\nys = [y1, y2, y3]\\nycount = 1\\nxcount = 1\\nfor i in range(3):\\n\\txcount = max(xcount, xs.count(xs[i]))\\n\\tycount = max(ycount, ys.count(ys[i]))\\nret = 3\\nif xcount == 3 or ycount == 3:\\n\\tprint(1)\\nelif xcount == 2 or ycount == 2:\\n\\tif xcount == 2:\\n\\t\\tfor i in range(2):\\n\\t\\t\\tfor j in range(i+1, 3):\\n\\t\\t\\t\\tif xs[i] == xs[j]:\\n\\t\\t\\t\\t\\ta = i\\n\\t\\t\\t\\t\\tb = j\\n\\t\\tfor i in range(3):\\n\\t\\t\\tif i != a and i != b:\\n\\t\\t\\t\\tc = i\\n\\t\\tif ys[a] < ys[c] < ys[b] or ys[a] > ys[c] > ys[b]:\\n\\t\\t\\tret = 3\\n\\t\\telse:\\n\\t\\t\\tret = 2\\n\\tif ycount == 2:\\n\\t\\tfor i in range(2):\\n\\t\\t\\tfor j in range(i+1, 3):\\n\\t\\t\\t\\tif ys[i] == ys[j]:\\n\\t\\t\\t\\t\\ta = i\\n\\t\\t\\t\\t\\tb = j\\n\\t\\tfor i in range(3):\\n\\t\\t\\tif i != a and i != b:\\n\\t\\t\\t\\tc = i\\n\\t\\tif xs[a] < xs[c] < xs[b] or xs[a] > xs[c] > xs[b]:\\n\\t\\t\\tret = min(ret, 3)\\n\\t\\telse:\\n\\t\\t\\tret = min(ret, 2)\\n\\tprint(ret)\\nelse:\\n\\tprint(ret)\\n\\n\", \"x = [0, 0, 0]\\ny = [0, 0, 0]\\n\\ndef bet(a, b, c):\\n    return a <= c <= b or b <= c <= a\\n\\ndef f(i, j, k):\\n    return (x[k] == x[i] or x[k] == x[j]) and bet(y[i], y[j], y[k]) or (y[k] == y[i] or y[k] == y[j]) and bet(x[i], x[j], x[k])\\n\\nfor i in range(3):\\n    xi, yi = list(map(int, input().split()))\\n    x[i] = xi\\n    y[i] = yi\\n\\nif (x[0] == x[1] == x[2] or y[0] == y[1] == y[2]):\\n    print(1)\\nelif f(0, 1, 2) or f(0, 2, 1) or f(1, 2, 0):\\n    print(2)\\nelse:\\n    print(3)\\n\", \"def is_parallel(p1, p2):\\n    if p1[0] == p2[0]:\\n        return 1\\n    if p1[1] == p2[1]:\\n        return 2\\n    return 0\\n\\na = [list(map(int, input().split())) for _ in range(3)]\\n\\nall_the_same = is_parallel(a[0], a[1]) == is_parallel(a[1], a[2]) == is_parallel(a[0], a[2])\\nfirst_and_second = is_parallel(a[0], a[1])\\nif all_the_same:\\n    if first_and_second != 0:\\n        print(1)\\n        return\\n    else:\\n        print(3)\\nelse:\\n    new_points = []\\n\\n    for i in range(3):\\n        if is_parallel(a[i], a[(i+1) % 3]):\\n            for j in range(3):\\n                new_points.append(a[(i + j) % 3])\\n            break\\n\\n    if len(new_points) == 0:\\n        print(3)\\n        return\\n\\n    if is_parallel(*new_points[:2]) == 2:\\n        for i in range(3):\\n            new_points[i][0], new_points[i][1] = new_points[i][1], new_points[i][0]\\n\\n    if new_points[0][1] > new_points[1][1]:\\n        new_points[0], new_points[1] = new_points[1], new_points[0]\\n\\n    if new_points[2][1] <= new_points[0][1] <= new_points[1][1]:\\n        print(2)\\n    elif new_points[0][1] <= new_points[1][1] <= new_points[2][1]:\\n        print(2)\\n    else:\\n        print(3)\", \"#!/usr/bin/env python3\\n\\nfrom collections import namedtuple\\nfrom itertools   import permutations\\n\\nPoint = namedtuple(\\\"Point\\\", \\\"x y\\\")\\n\\ntry:\\n    while True:\\n        p = [Point(*list(map(int, input().split()))) for i in range(3)]\\n        a, b, c = p\\n        if a.x == b.x == c.x or a.y == b.y == c.y:\\n            print(1)\\n        else:\\n            for a, b, c in permutations(p):\\n                if a.x == b.x and not a.y < c.y < b.y and not b.y < c.y < a.y:\\n                    print(2)\\n                    break\\n                if a.y == b.y and not a.x < c.x < b.x and not b.x < c.x < a.x:\\n                    print(2)\\n                    break\\n            else:\\n                print(3)\\n\\nexcept EOFError:\\n    pass\\n\", \"x1,y1 = map(int,input().split())\\nx2,y2 = map(int,input().split())\\nx3,y3 = map(int,input().split())\\nif x1==x2==x3 or y1==y2==y3:\\n    print(1)\\n    quit()\\nelif  (y1==y2 and ((x3<=x1 and x3<=x2) or (x3>=x1 and x3>=x2)))\\\\\\n        or (y1==y3 and ((x2<=x1 and x2<=x3) or (x2>=x1 and x2>=x3)))\\\\\\n        or (y2==y3 and ((x1<=x2 and x1<=x3) or (x1>=x2 and x1>=x3)))\\\\\\n        or (x1==x2 and ((y3<=y1 and y3<=y2) or (y3>=y1 and y3>=y2)))\\\\\\n        or (x1==x3 and ((y2<=y1 and y2<=y3) or (y2>=y1 and y2>=y3)))\\\\\\n        or (x2==x3 and ((y1<=x2 and y1<=y3) or (y1>=y2 and y1>=y3))):\\n    print(2)\\n    quit()\\nelse:print(3)\", \"x = [0] * 3\\ny = [0] * 3\\nfor i in range(3):\\n    x[i], y[i] = map(int,input().split())\\n\\nif x[0] == x[1] == x[2] or y[0] == y[1] == y[2]:\\n    print(1)\\nelif x[0] == x[1] and (y[2]>=max(y[0],y[1]) or y[2]<=min(y[0],y[1])): print(2)\\nelif x[0] == x[2] and (y[1]>=max(y[0],y[2]) or y[1]<=min(y[0],y[2])): print(2)\\nelif x[1] == x[2] and (y[0]>=max(y[1],y[2]) or y[0]<=min(y[1],y[2])): print(2)\\nelif y[0] == y[1] and (x[2]>=max(x[0],x[1]) or x[2]<=min(x[0],x[1])): print(2)\\nelif y[0] == y[2] and (x[1]>=max(x[0],x[2]) or x[1]<=min(x[0],x[2])): print(2)\\nelif y[1] == y[2] and (x[0]>=max(x[1],x[2]) or x[0]<=min(x[1],x[2])): print(2)\\n\\nelse: print(3)\", \"p1 = list(map(int, input().split()))\\np2 = list(map(int, input().split()))\\np3 = list(map(int, input().split()))\\np = [p1, p2, p3]\\nif (p1[0]==p2[0] and p2[0]==p3[0]) or (p1[1]==p2[1] and p2[1]==p3[1]):\\n\\tprint(1)\\nelse:\\n\\tfor i in range(3):\\n\\t\\tfor j in range(3):\\n\\t\\t\\tfor k in range(3):\\n\\t\\t\\t\\tif (i != j) and (j!=k) and(i!=k):\\n\\t\\t\\t\\t\\t#print(i,j,k)\\n\\t\\t\\t\\t\\tfor z in range(2):\\n\\t\\t\\t\\t\\t\\tz2 = 1-z\\n\\t\\t\\t\\t\\t\\tif (p[i][z] == p[j][z]) and not(min(p[i][z2],p[j][z2]) < p[k][z2] < max(p[i][z2],p[j][z2])):\\n\\t\\t\\t\\t\\t\\t\\tprint(2)\\n\\t\\t\\t\\t\\t\\t\\treturn\\n\\tprint(3)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"1 -1\\n1 1\\n1 2\\n\",\n    \"-1 -1\\n-1 3\\n4 3\\n\",\n    \"1 1\\n2 3\\n3 2\\n\",\n    \"1000000000 -1000000000\\n1000000000 1000000000\\n-1000000000 -1000000000\\n\",\n    \"-510073119 -991063686\\n583272581 -991063686\\n623462417 -991063686\\n\",\n    \"-422276230 -422225325\\n-422276230 -544602611\\n-282078856 -544602611\\n\",\n    \"127447697 -311048187\\n-644646254 135095006\\n127447697 135095006\\n\",\n    \"-609937696 436598127\\n-189924209 241399893\\n-883780251 296798182\\n\",\n    \"-931665727 768789996\\n234859675 808326671\\n-931665727 879145023\\n\",\n    \"899431605 238425805\\n899431605 339067352\\n940909482 333612216\\n\",\n    \"143495802 -137905447\\n-922193757 -660311216\\n-922193757 659147504\\n\",\n    \"-759091260 362077211\\n-759091260 123892252\\n-79714253 226333388\\n\",\n    \"-495060442 -389175621\\n79351129 -146107545\\n-495060442 59059286\\n\",\n    \"-485581506 973584319\\n-762068259 670458753\\n-485581506 -661338021\\n\",\n    \"-865523810 66779936\\n-865523810 879328244\\n551305309 495319633\\n\",\n    \"-985816934 85994062\\n490801388 171721095\\n-985816934 265995176\\n\",\n    \"-322848128 276304614\\n-228010033 -361111909\\n-137761352 276304614\\n\",\n    \"648743183 -329867260\\n680098341 -988370978\\n594847608 -988370978\\n\",\n    \"-636111887 -755135651\\n-411477790 -755135651\\n-540985255 -808506689\\n\",\n    \"-280166733 -215262264\\n-257537874 640677716\\n-288509263 640677716\\n\",\n    \"158219297 -796751401\\n464911767 780525998\\n25054022 780525998\\n\",\n    \"-76151678 894169660\\n125930178 -434000890\\n259457432 894169660\\n\",\n    \"403402592 55070913\\n-703565711 55070913\\n-141194091 -66977045\\n\",\n    \"-485970125 725016060\\n-972748484 -602121312\\n183987969 -602121312\\n\",\n    \"-494824697 -964138793\\n-494824697 671151995\\n-24543485 877798954\\n\",\n    \"-504439520 685616264\\n-575788481 178485261\\n-575788481 -998856787\\n\",\n    \"446038601 -598441655\\n446038601 -781335731\\n-446725217 -862937359\\n\",\n    \"443336387 317738308\\n-731455437 682073969\\n443336387 -487472781\\n\",\n    \"-954908844 156002304\\n-954908844 507051490\\n-377680300 878914758\\n\",\n    \"437180709 -829478932\\n-775395571 -605325538\\n-775395571 298582830\\n\",\n    \"791725263 -592101263\\n791725263 -401786481\\n953501658 -699705540\\n\",\n    \"621619191 -223521454\\n621619191 -746436580\\n-886355353 -920817120\\n\",\n    \"353770247 742032246\\n391091420 742032246\\n113505964 105784687\\n\",\n    \"-386452587 -689699105\\n-51244121 425743943\\n736584134 425743943\\n\",\n    \"-354329375 -222798859\\n-636793392 28344958\\n989602966 -222798859\\n\",\n    \"439039590 -419754858\\n-16966935 -979701468\\n276072230 -979701468\\n\",\n    \"-160622039 260994846\\n-981120537 -453711571\\n-899331084 260994846\\n\",\n    \"755966021 -977934315\\n-693932164 -977934315\\n780740735 341305212\\n\",\n    \"997183648 -430699196\\n555277138 -34246328\\n962365828 -34246328\\n\",\n    \"394482565 -5842724\\n-120921456 -5842724\\n474336847 -666083693\\n\",\n    \"451140644 -552066345\\n451140644 97091285\\n643901618 -552066345\\n\",\n    \"-397991545 510063044\\n347795937 510063044\\n-397991545 944965447\\n\",\n    \"361702696 891912906\\n742864513 891912906\\n361702696 616808838\\n\",\n    \"950548287 766404840\\n995400182 976310818\\n950548287 976310818\\n\",\n    \"512806478 -76305905\\n51445888 -189759697\\n512806478 -189759697\\n\",\n    \"134061442 -132620069\\n-215253638 -132620069\\n134061442 112298311\\n\",\n    \"-225194635 772128906\\n-9640584 -636384130\\n-9640584 772128906\\n\",\n    \"976530519 -932140580\\n418643692 -845327922\\n976530519 -845327922\\n\",\n    \"-960958311 -757098377\\n-960958311 -153001649\\n-960958311 567188828\\n\",\n    \"487214658 518775922\\n487214658 -869675495\\n487214658 -106351878\\n\",\n    \"58011742 175214671\\n-853914900 175214671\\n-245334045 175214671\\n\",\n    \"306134424 46417066\\n-503106271 46417066\\n-286564055 46417066\\n\",\n    \"150098962 830455428\\n-70279563 -160635038\\n-721135733 -627254059\\n\",\n    \"-664035427 -710202693\\n527339005 -8499215\\n414350757 -966228511\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"3\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"3\\n\",\n    \"3\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/617/D",
  "starter_code": ""
}