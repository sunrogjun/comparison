{
  "task_id": "APPS/428",
  "problem_id": 428,
  "prompt": "Our bear's forest has a checkered field. The checkered field is an n \u00d7 n table, the rows are numbered from 1 to n from top to bottom, the columns are numbered from 1 to n from left to right. Let's denote a cell of the field on the intersection of row x and column y by record (x, y). Each cell of the field contains growing raspberry, at that, the cell (x, y) of the field contains x + y raspberry bushes.\n\nThe bear came out to walk across the field. At the beginning of the walk his speed is (dx, dy). Then the bear spends exactly t seconds on the field. Each second the following takes place:  Let's suppose that at the current moment the bear is in cell (x, y).  First the bear eats the raspberry from all the bushes he has in the current cell. After the bear eats the raspberry from k bushes, he increases each component of his speed by k. In other words, if before eating the k bushes of raspberry his speed was (dx, dy), then after eating the berry his speed equals (dx + k, dy + k).  Let's denote the current speed of the bear (dx, dy) (it was increased after the previous step). Then the bear moves from cell (x, y) to cell (((x + dx - 1)\u00a0mod\u00a0n) + 1, ((y + dy - 1)\u00a0mod\u00a0n) + 1).  Then one additional raspberry bush grows in each cell of the field. \n\nYou task is to predict the bear's actions. Find the cell he ends up in if he starts from cell (sx, sy). Assume that each bush has infinitely much raspberry and the bear will never eat all of it.\n\n\n-----Input-----\n\nThe first line of the input contains six space-separated integers: n, sx, sy, dx, dy, t (1 \u2264 n \u2264 10^9;\u00a01 \u2264 sx, sy \u2264 n;\u00a0 - 100 \u2264 dx, dy \u2264 100;\u00a00 \u2264 t \u2264 10^18).\n\n\n-----Output-----\n\nPrint two integers \u2014 the coordinates of the cell the bear will end up in after t seconds.\n\n\n-----Examples-----\nInput\n5 1 2 0 1 2\n\nOutput\n3 1\nInput\n1 1 1 -1 -1 2\n\nOutput\n1 1\n\n\n-----Note-----\n\nOperation a\u00a0mod\u00a0b means taking the remainder after dividing a by b. Note that the result of the operation is always non-negative. For example, ( - 1)\u00a0mod\u00a03 = 2.\n\nIn the first sample before the first move the speed vector will equal (3,4) and the bear will get to cell (4,1). Before the second move the speed vector will equal (9,10) and he bear will get to cell (3,1). Don't forget that at the second move, the number of berry bushes increased by 1.\n\nIn the second sample before the first move the speed vector will equal (1,1) and the bear will get to cell (1,1). Before the second move, the speed vector will equal (4,4) and the bear will get to cell (1,1). Don't forget that at the second move, the number of berry bushes increased by 1.",
  "solutions": "[\"#Simple non-optimized class of matrices. Used with small dense matrices.\\nimport functools\\nimport itertools\\nimport math\\n\\nclass NotAMatrixError(Exception):\\n    pass\\n\\nclass MatrixSizeError(Exception):\\n    def __init__(self, s1, s2):\\n        print('sizes do not match : ', s1, ', ', s2)\\n\\nclass NotSquareError(Exception):\\n    pass\\n\\nclass Matrix(list):\\n    def __init__(self, L):\\n        if type(L) == type(self):\\n            self = L\\n            return\\n        n = len(L)\\n        m = len(L[0])\\n        for i in range(n):\\n            if len(L[i]) != m:\\n                raise NotAMatrixError()\\n        list.__init__(self, L)\\n        self.n = n\\n        self.m = m\\n        self.degrees = []\\n    def check_size(self, M, mode):\\n        n, m = len(M), len(M[0])\\n        for i in range(n):\\n            if len(M[i]) != m:\\n                raise NotAMatrixError()\\n        \\n        if mode == 'add' and (self.n != n or self.m != m):\\n            raise MatrixSizeError((self.n, self.m), (n,m))\\n        if mode == 'lul' and self.m != n:\\n            print(self.m, n, self.m != n)\\n            raise MatrixSizeError((self.n, self.m), (n,m))\\n    def __add__(self, M):\\n        self.check_size(M, mode = 'add')\\n        return Matrix([[self[i][j]+M[i][j] for j in range(self.m)]for i in range(self.n)])\\n    def __iadd__(self, M):\\n        self.check_size(M, mode = 'add')\\n        for i in range(self.n):\\n            for j in range(self,m):\\n                self[i][j] += M[i][j]\\n    def __mul__(self, M):\\n        self.check_size(M, mode = 'mul')\\n        l = len(M[0])\\n        return Matrix([[sum(self[i][k]*M[k][j] for k in range(self.m))\\n                 for j in range(l)] for i in range(self.n)])\\n    def issquare(self):\\n        return self.n == self.m\\n    def primary(self):\\n        if self.n != self.m:\\n            raise NotSquareError()\\n        return Matrix([[int(i==j) for j in range(self.m)] for i in range(self.n)])\\n    def __pow__(self, n):\\n        if self.n != self.m:\\n            raise NotSquareError()\\n        if n == 0:\\n            return self.primary()\\n        elif n == 1:\\n            return self\\n        if len(self.degrees) == 0:\\n            self.degrees.append(self*self)\\n        for i in range(n.bit_length() - len(self.degrees) - 1):\\n            self.degrees.append(self.degrees[-1] * self.degrees[-1])\\n        s = [(n>>i)&1 for i in range(1,n.bit_length())]\\n        res = functools.reduce(lambda x,y:x*y, itertools.compress(self.degrees, s))\\n        return res*self if n%2 else res \\n    def drop_degrees(self):\\n        self.degrees.clear()\\n\\nclass Remainder(int):\\n    def __new__(self, n, p):\\n        obj = int.__new__(self, n%p)\\n        obj.p = p\\n        return obj\\n    def __mul__(self, m): return Remainder(int.__mul__(self, m), self.p)\\n    def __add__(self, m): return Remainder(int.__add__(self, m), self.p)\\n    def __sub__(self, m): return Remainder(int.__sub__(self, m), self.p)\\n    def __rmul__(self, m): return Remainder(int.__rmul__(self, m), self.p)\\n    def __radd__(self, m): return Remainder(int.__radd__(self, m), self.p)\\n    def __rsub__(self, m): return Remainder(int.__rsub__(self, m), self.p)\\n    def __neg__(self): return Remainder(int.__neg__(self), self.p)\\n    def __pow__(self, m): return Remainder(int.__pow__(self, m, self.p), self.p)\\n\\ndef solve(n, sx, sy, dx, dy, t):\\n    o, l, j = Remainder(0, n), Remainder(1, n), Remainder(2, n)\\n    N = [[j, l, l, o, l, o],\\n         [l, j, o, l, l, o],\\n         [l, l, l, o, l, o],\\n         [l, l, o, l, l, o],\\n         [o, o, o, o, l, l],\\n         [o, o, o, o, o, l]]\\n    M = Matrix(N)\\n    sx, sy, dx, dy = [Remainder(x, n) for x in [sx, sy, dx, dy]]\\n    v = Matrix([[sx], [sy], [dx], [dy], [o], [l]])\\n    return M ** t * v\\n\\nn, sx, sy, dx, dy, t = [int(x) for x in input().split()]\\nans = solve(n, sx, sy, dx, dy, t)\\nprint(int(ans[0][0] - 1) + 1, int(ans[1][0] - 1) + 1)\\n\", \"mod, sx, sy, dx, dy, t = list(map(int, input().split()))\\nclass Matrix():\\n    def __init__(self, n):\\n        self.n = n\\n        self.a = [[0] * n for _ in range(n)]\\n\\n    def __mul__(self, b):\\n        res = Matrix(self.n)\\n        for i in range(self.n):\\n            for j in range(self.n):\\n                for k in range(self.n):\\n                    res.a[i][j] += self.a[i][k] * b.a[k][j] % mod\\n                    res.a[i][j] %= mod\\n        return res\\n\\n    def __pow__(self, e):\\n        res = Matrix(self.n)\\n        for i in range(self.n):\\n            res.a[i][i] = 1\\n        tmp = self\\n        while e:\\n            if e & 1:\\n                res = res * tmp\\n            e >>= 1\\n            tmp = tmp * tmp\\n        return res\\nM = Matrix(6)\\nM.a = [[2, 1, 1, 0, 1, 2],\\n       [1, 2, 0, 1, 1, 2],\\n       [1, 1, 1, 0, 1, 2],\\n       [1, 1, 0, 1, 1, 2],\\n       [0, 0, 0, 0, 1, 1],\\n       [0, 0, 0, 0, 0, 1]]\\nsx -= 1\\nsy -= 1\\nr = M ** t\\nf = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % mod + 1\\nprint(f(0), f(1))\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"5 1 2 0 1 2\\n\",\n    \"1 1 1 -1 -1 2\\n\",\n    \"1 1 1 1 1 0\\n\",\n    \"2 2 1 -2 -2 5\\n\",\n    \"1000000000 1 1 1 1 1000000000000000000\\n\",\n    \"1000000000 1 2 -100 -100 1\\n\",\n    \"3 2 2 -100 -100 2\\n\",\n    \"1000000000 1000000000 1000000000 100 -100 1000000000000000000\\n\",\n    \"907122235 107269653 309181328 26 -64 242045007473044676\\n\",\n    \"804 658 177 -95 37 9\\n\",\n    \"2 1 1 31 -74 2712360435504330\\n\",\n    \"230182675 73108597 42152975 -72 -8 93667970058209518\\n\",\n    \"487599125 469431740 316230350 -77 57 18\\n\",\n    \"1710 654 941 -81 -37 1281183940\\n\",\n    \"568980902 147246752 87068387 -17 58 677739653\\n\",\n    \"38 10 36 19 30 4054886\\n\",\n    \"546978166 115293871 313560296 -33 54 215761558342792301\\n\",\n    \"323544442 39059198 2970015 92 17 98\\n\",\n    \"321575625 2929581 31407414 -40 -44 920902537044\\n\",\n    \"5928 1508 4358 75 -4 794927060433551549\\n\",\n    \"7310962 7564 6333485 -45 41 81980903005818\\n\",\n    \"224 81 30 57 -13 8363\\n\",\n    \"75081054 91 47131957 -94 -54 5588994022550344\\n\",\n    \"185144 100489 52 32 -21 5752324832726786\\n\",\n    \"61728 24280 17963 -19 81 652432745607745078\\n\",\n    \"25699863 23288611 24796719 -45 46 437606836\\n\",\n    \"475875319 333393831 284835031 22 7 90332975949346\\n\",\n    \"372903 106681 40781 54 -40 6188704\\n\",\n    \"923 452 871 -95 -55 273135237285890\\n\",\n    \"672939 589365 391409 -54 -70 205083640\\n\",\n    \"560010572 4172512 514044248 -78 13 97386\\n\",\n    \"717485513 5935 3 -5 -67 28\\n\",\n    \"138971202 137695723 48931985 -28 -3 68901440898766\\n\",\n    \"910958510 60 98575 38 -99 97880\\n\",\n    \"67163467 36963416 50381 -49 -12 76558237\\n\",\n    \"557911547 9 460221236 -58 -96 74518856\\n\",\n    \"85 37 69 30 47 131\\n\",\n    \"852525230 538352221 97088953 -12 98 9197937568\\n\",\n    \"885849694 703278210 46391 33 23 965949118732\\n\",\n    \"976890548 675855343 988 -11 46 796041265897304\\n\",\n    \"108774060 15274597 430014 -85 -94 6\\n\",\n    \"2 2 2 -36 94 9429569334\\n\",\n    \"713835677 404390162 67429 -91 10 178697004637242062\\n\",\n    \"620330674 603592488 3 38 94 34309127789188\\n\",\n    \"95 70 7 -36 -100 5\\n\",\n    \"900854530 82 7 30 -88 6797628981503799\\n\",\n    \"147834 6 2565 15 -35 166779\\n\",\n    \"642762664 588605882 1 -47 82 8\\n\",\n    \"122740849 8646067 70003215 -100 -80 70\\n\",\n    \"73221379 4311914 992324 65 -40 705623357422685593\\n\"\n  ],\n  \"outputs\": [\n    \"3 1\",\n    \"1 1\",\n    \"1 1\",\n    \"1 2\",\n    \"168318977 168318977\",\n    \"999999904 999999905\",\n    \"1 1\",\n    \"969796608 969796608\",\n    \"23731316 525833901\",\n    \"270 173\",\n    \"1 1\",\n    \"34918692 197804272\",\n    \"320939970 167740992\",\n    \"1568 945\",\n    \"150920864 281916196\",\n    \"18 36\",\n    \"353006839 497349709\",\n    \"105890973 69794440\",\n    \"320222592 65760999\",\n    \"4973 5148\",\n    \"5246110 6302893\",\n    \"130 205\",\n    \"6742019 52104963\",\n    \"56326 173503\",\n    \"3174 1169\",\n    \"24072870 13015404\",\n    \"441571464 288459461\",\n    \"161485 86089\",\n    \"563 142\",\n    \"503747 218115\",\n    \"11882888 530616750\",\n    \"71683921 71676253\",\n    \"110585553 85995539\",\n    \"304849180 291538135\",\n    \"23368224 65407811\",\n    \"246089810 106240697\",\n    \"74 38\",\n    \"84737577 321684009\",\n    \"16593182 13087113\",\n    \"652954007 789518296\",\n    \"98184736 83340099\",\n    \"1 1\",\n    \"244834060 560206120\",\n    \"200990066 258175045\",\n    \"85 82\",\n    \"66039616 641057009\",\n    \"54423 144570\",\n    \"355500874 409658689\",\n    \"80795619 19413318\",\n    \"62692638 21726334\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/385/E",
  "starter_code": ""
}