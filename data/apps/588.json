{
  "task_id": "APPS/588",
  "problem_id": 588,
  "prompt": "E869120 is initially standing at the origin (0, 0) in a two-dimensional plane.\nHe has N engines, which can be used as follows:\n - When E869120 uses the i-th engine, his X- and Y-coordinate change by x_i and y_i, respectively. In other words, if E869120 uses the i-th engine from coordinates (X, Y), he will move to the coordinates (X + x_i, Y + y_i).\n - E869120 can use these engines in any order, but each engine can be used at most once. He may also choose not to use some of the engines.\nHe wants to go as far as possible from the origin.\nLet (X, Y) be his final coordinates. Find the maximum possible value of \\sqrt{X^2 + Y^2}, the distance from the origin.\n\n-----Constraints-----\n - 1 \\leq N \\leq 100\n - -1 \\ 000 \\ 000 \\leq x_i \\leq 1 \\ 000 \\ 000\n - -1 \\ 000 \\ 000 \\leq y_i \\leq 1 \\ 000 \\ 000\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nx_1 y_1\nx_2 y_2\n : :\nx_N y_N\n\n-----Output-----\nPrint the maximum possible final distance from the origin, as a real value.\nYour output is considered correct when the relative or absolute error from the true answer is at most 10^{-10}.\n\n-----Sample Input-----\n3\n0 10\n5 -5\n-5 -5\n\n-----Sample Output-----\n10.000000000000000000000000000000000000000000000000\n\nThe final distance from the origin can be 10 if we use the engines in one of the following three ways:\n - Use Engine 1 to move to (0, 10).\n - Use Engine 2 to move to (5, -5), and then use Engine 3 to move to (0, -10).\n - Use Engine 3 to move to (-5, -5), and then use Engine 2 to move to (0, -10).\nThe distance cannot be greater than 10, so the maximum possible distance is 10.",
  "solutions": "[\"import numpy as np\\n\\nn=int(input())\\nxy=[]\\nfor i in range(n):\\n    xy.append(list(map(int,input().split())))\\n\\ndef naiseki(a,b):\\n    if (a[0]*b[0]+a[1]*b[1])>0.0:\\n        return True\\n    else:\\n        return False\\n    \\nans=0\\n\\nfor i in range(1001):\\n    xl=np.cos(np.pi*2.0*i/1000.0)\\n    yl=np.sin(np.pi*2.0*i/1000.0)\\n    x=0\\n    y=0\\n    for j in range(n):\\n        if naiseki([xl,yl],xy[j]):\\n            x+=xy[j][0]\\n            y+=xy[j][1]\\n    ans=max(ans,np.sqrt(x**2+y**2))\\nprint(ans)\\n\", \"# \\u51f8\\u5305 Monotone Chain O(nlogn)\\n# \\u53c2\\u8003: https://matsu7874.hatenablog.com/entry/2018/12/17/025713\\ndef get_convex_hull(points):\\n    def det(p, q):\\n        return p[0] * q[1] - p[1] * q[0]\\n    def sub(p, q):\\n        return (p[0] - q[0], p[1] - q[1])\\n    points.sort()\\n    ch = []\\n    for p in points:\\n        while len(ch) > 1:\\n            v_cur = sub(ch[-1], ch[-2])\\n            v_new = sub(p, ch[-2])\\n            if det(v_cur, v_new) > 0:\\n                break\\n            ch.pop()\\n        ch.append(p)\\n    t = len(ch)\\n    for p in points[-2::-1]:\\n        while len(ch) > t:\\n            v_cur = sub(ch[-1], ch[-2])\\n            v_new = sub(p, ch[-2])\\n            if det(v_cur, v_new) > 0:\\n                break\\n            ch.pop()\\n        ch.append(p)\\n    return ch[:-1]\\nN = int(input())\\nXY = [list(map(int, input().split())) for _ in range(N)]\\nps = [(0, 0)]\\nfor x, y in XY:\\n    ps_new = ps[:]\\n    for x_, y_ in ps:\\n        ps_new.append((x+x_, y+y_))\\n    ps = get_convex_hull(ps_new)\\nans = 0\\nfor x, y in ps:\\n    ans = max(ans, x*x+y*y)\\nprint(ans ** 0.5)\", \"import sys\\nimport math\\nfrom collections import deque\\n\\ninput = sys.stdin.readline\\n\\n\\ndef solve(n, x_y_list):\\n    radians = [(math.atan2(y, x), x, y) for x, y in x_y_list]\\n    radians.sort()\\n    radians = radians + radians\\n\\n    max_square_distance = 0\\n    for start in range(n):\\n        sum_x = sum_y = 0\\n        for i in range(n):\\n            _, x, y = radians[start + i]\\n            sum_x += x\\n            sum_y += y\\n            square_distance = sum_x ** 2 + sum_y ** 2\\n            if max_square_distance < square_distance:\\n                max_square_distance = square_distance\\n    return math.sqrt(max_square_distance)\\n\\n\\ndef __starting_point():\\n    n = int(input())\\n    x_y_list = [tuple(map(int, input().split())) for _ in range(n)]\\n\\n    answer = solve(n, x_y_list)\\n    print(answer)\\n\\n__starting_point()\", \"from cmath import phase\\n\\nN, *XY = map(int, open(0).read().split())\\n\\nXY = sorted((complex(x, y) for x, y in zip(*[iter(XY)] * 2)), key=phase)\\nXY += XY\\n\\nprint(max(abs(sum(XY[i:j])) for i in range(2 * N + 1) for j in range(2 * N + 1) if j - i <= N))\", \"\\nN = int(input())\\n\\nsxy41 = []\\nsxy23 = []\\n\\nfor i in range(N):\\n    \\n    x,y = list(map(int,input().split()))\\n\\n    if x == 0 and y >= 0:\\n\\n        s = float(\\\"inf\\\")\\n\\n    elif x == 0 and y < 0:\\n\\n        s = -1 * float(\\\"inf\\\")\\n\\n    else:\\n\\n        s = y / x\\n\\n    if x >= 0:\\n        sxy41.append([s,x,y])\\n    else:\\n        sxy23.append([s,x,y])\\n\\nsxy41.sort()\\nsxy23.sort()\\n\\nsxy = []\\n\\nfor i in sxy41:\\n    sxy.append(i)\\nfor i in sxy23:\\n    sxy.append(i)\\n\\nans = 0\\n\\n\\nfor i in range(N):\\n\\n    for j in range(i):\\n\\n        nowx = 0\\n        nowy = 0\\n\\n        for k in range(i-j+1):\\n\\n            k += j\\n\\n            nowx += sxy[k][1]\\n            nowy += sxy[k][2]\\n\\n        ans = max(ans,(nowx ** 2 + nowy ** 2) ** 0.5)\\n\\n\\nsxy = []\\n\\nfor i in sxy23:\\n    sxy.append(i)\\nfor i in sxy41:\\n    sxy.append(i)\\n\\n\\nfor i in range(N):\\n\\n    for j in range(i+1):\\n\\n        nowx = 0\\n        nowy = 0\\n\\n        for k in range(i-j+1):\\n\\n            k += j\\n\\n            nowx += sxy[k][1]\\n            nowy += sxy[k][2]\\n\\n        ans = max(ans,(nowx ** 2 + nowy ** 2) ** 0.5)\\n\\nprint (ans)\\n\\n        \\n\", \"import sys\\nfrom operator import itemgetter\\nimport math\\n\\nsys.setrecursionlimit(10 ** 8)\\n\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N = int(input())\\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\\n\\n    txy = []\\n    for x, y in XY:\\n        t = math.atan2(x, y)\\n        txy.append([t, x, y])\\n\\n    txy.sort()\\n\\n    ans = 0\\n    for i in range(N):\\n        tmpx = 0\\n        tmpy = 0\\n        for j in range(N):\\n            tmpx += txy[(i + j) % N][1]\\n            tmpy += txy[(i + j) % N][2]\\n            ans = max(ans, math.sqrt(tmpx ** 2 + tmpy ** 2))\\n\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\nN = int(input())\\nn = 1000\\n\\nx = [None] * N\\ny = [None] * N\\nfor i in range(N):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(n):\\n    theta = (2 * math.pi / n) * i\\n    tmp_x = 0\\n    tmp_y = 0\\n    for j in range(N):\\n        if x[j] * math.cos(theta) + y[j] * math.sin(theta) > 0:\\n            tmp_x += x[j]\\n            tmp_y += y[j]\\n    if tmp_x**2 + tmp_y**2 > ans**2:\\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\\n\\nprint(ans)\\n\", \"from collections import defaultdict,deque\\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\\nsys.setrecursionlimit(10**8)\\nINF = float('inf')\\nmod = 10**9+7\\neps = 10**-7\\ndef inp(): return int(sys.stdin.readline())\\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\\ndef inpl_str(): return list(sys.stdin.readline().split())\\n\\nN = inp()\\npoints = []\\n\\nfor _ in range(N):\\n    x,y = inpl()\\n    t = math.atan2(y,x)\\n    points.append((t,x,y))\\n\\npoints.sort()\\n\\nans = 0\\nfor s,[theta,x,y] in enumerate(points):\\n    tmpx = tmpy = 0\\n    for t in range(s,s+N):\\n        _,tx,ty = points[t%N]\\n        tmpx += tx\\n        tmpy += ty\\n        ans = max(ans,tmpx**2 + tmpy**2)\\n\\nprint((math.sqrt(ans)))\\n\", \"import sys\\nfrom operator import itemgetter\\nimport math\\n\\nsys.setrecursionlimit(10 ** 8)\\n\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N = int(input())\\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\\n\\n    txy = []\\n    for x, y in XY:\\n        t = math.atan2(y, x)\\n        txy.append([t, x, y])\\n\\n    txy.sort()\\n\\n    ans = 0\\n    for i in range(N):\\n        tmpx = 0\\n        tmpy = 0\\n        for j in range(N):\\n            tmpx += txy[(i + j) % N][1]\\n            tmpy += txy[(i + j) % N][2]\\n            ans = max(ans, math.sqrt(tmpx ** 2 + tmpy ** 2))\\n\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"import math\\ndef arg(x,y):\\n  if x==0:\\n    if y>0:\\n      return math.pi/2\\n    else:\\n      return 3*math.pi/2\\n  else:\\n    if x>0:\\n      return math.atan(y/x)\\n    else:\\n      return math.atan(y/x)+math.pi\\nn=int(input())\\nA=[]\\nfor i in range(n):\\n  x,y=map(int,input().split())\\n  if x==0 and y==0:\\n    continue\\n  A.append([arg(x,y),x,y])\\n  A.append([arg(x,y)+2*math.pi,x,y])\\nA=sorted(A)\\nn=len(A)//2\\nans=0\\nfor i in range(n):#\\u59cb\\u70b9\\n  for j in range(1,n+1):#\\u9023\\u7d9a\\u6570\\n    X=0\\n    Y=0\\n    for k in range(i,i+j):\\n      X=X+A[k][1]\\n      Y=Y+A[k][2]\\n    d=(X**2+Y**2)**(1/2)\\n    if d>ans:\\n      ans=d\\nprint(ans)\", \"import sys\\nfrom math import *\\n\\nsys.setrecursionlimit(10 ** 6)\\n\\ndef main():\\n    n = int(input())\\n    en = []\\n    n0 = n\\n    for _ in range(n0):\\n        x, y = list(map(int, input().split()))\\n        if (x, y) == (0, 0):\\n            n -= 1\\n            continue\\n        en.append([atan2(y, x), x, y])\\n    en.sort()\\n#    print(en)\\n\\n    ans = 0\\n    for l in range(n):\\n        sx = sy = 0\\n        arg_l = en[l][0]\\n        r = l\\n        for _ in range(n):\\n            if (en[r][0] - arg_l) % (2 * pi) > pi: break\\n            sx += en[r][1]\\n            sy += en[r][2]\\n            ans = max(ans, (sx ** 2 + sy ** 2))\\n            r = (r + 1) % n\\n    print((ans ** 0.5))\\n\\nmain()\\n\", \"import sys\\nimport numpy as np\\nimport math\\ndef input(): return sys.stdin.readline().rstrip()\\n\\n\\ndef main():\\n    n = int(input())\\n    engine = np.zeros((n, 3))\\n    for i in range(n):\\n        engine[i][0], engine[i][1] = map(int, input().split())\\n        engine[i][2] = math.atan2(engine[i][1], engine[i][0])\\n    engines = engine[np.argsort(engine[:, 2])]\\n    sumen = sum(engines)\\n    ans = sumen[0]**2+sumen[1]**2\\n    for i in range(n):\\n        for j in range(i, n):\\n            sump=sum(engines[i:j+1])\\n            ans=max(ans,sump[0]**2+sump[1]**2,(sump[0]-sumen[0])**2+(sump[1]-sumen[1])**2)\\n    print(math.sqrt(ans))\\n\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import math\\n\\nN=int(input())\\nP=[list(map(int,input().split())) for i in range(N)]\\n\\ndef div2(x,y):\\n    if x>0:\\n        return (1,y/x)\\n    elif x<0:\\n        return (-1,y/x)\\n    else:\\n        if y>0:\\n            return (-1,-float(\\\"inf\\\"))\\n        else:\\n            return (1,-float(\\\"inf\\\"))\\n\\nP.sort(key=lambda x:div2(x[0],x[1]))\\n\\nANS=0\\n\\nfor i in range(N):\\n    for j in range(i,N):\\n        x0=y0=0\\n        x1=y1=0\\n\\n        for k in range(N):\\n            if i<=k<=j:\\n                x0+=P[k][0]\\n                y0+=P[k][1]\\n            else:\\n                x1+=P[k][0]\\n                y1+=P[k][1]\\n\\n        ANS=max(ANS,x0**2+y0**2,x1**2+y1**2)\\n\\nprint((math.sqrt(ANS)))\\n\", \"ii = lambda : int(input())\\nmi = lambda : map(int,input().split())\\nli = lambda : list(map(int,input().split()))\\n\\nn = ii()\\nimport math\\na = []\\nfor i in range(n):\\n    x,y = mi()\\n    x += 1e-15\\n    theta = math.degrees(math.atan2(y,x))\\n    a.append([theta,x,y])\\na.sort()\\na2 = list(a)\\na = a + a2\\nimport numpy as np\\nx = []\\ny = []\\nfor i in range(len(a)):\\n    x.append(a[i][1])\\n    y.append(a[i][2])\\nx = np.array(x)\\ny = np.array(y)\\nxsum = np.cumsum(x)\\nysum = np.cumsum(y)\\nans = 0\\nfor i in range(1,n+1):\\n    for k in range(i,n+i):\\n        xtmp = xsum[k] - xsum[i-1]\\n        ytmp = ysum[k] - ysum[i-1]\\n        tmp = (xtmp**2 + ytmp**2) ** 0.5\\n        ans = max(ans,tmp)\\nprint(ans)\", \"from itertools import combinations\\nfrom cmath import phase\\nN = int(input())\\nXY = [complex(*list(map(int, input().split()))) for _ in range(N)]\\nXY.sort(key=phase)\\nXY += XY\\nprint((max(abs(sum(XY[i:j])) for i, j in combinations(list(range(N*2+1)), 2) if j-i<=N)))\\n\", \"from math import atan2, pi\\n\\nN = int(input())\\nengines = []\\ntotal_X = total_Y = 0\\nfor i in range(N):\\n  x, y = map(int, input().split())\\n  engines.append((atan2(y, x), x, y)) # (theta, x, y)\\n  total_X += x\\n  total_Y += y\\n\\nengines.sort()\\nans2 = 0\\nl = r = 0\\nX = engines[0][1]\\nY = engines[0][2]\\n\\nfor l in range(N):\\n  theta = engines[l][0]\\n  xl, yl = engines[l][1:]\\n  while r + 1 - l < N \\\\\\n      and (theta <= engines[(r+1)%N][0] < theta+pi \\\\\\n           or theta <= engines[(r+1)%N][0]+2*pi < theta+pi):\\n    r += 1\\n    X += engines[r%N][1]\\n    Y += engines[r%N][2]\\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2)\\n  while r + 1 - l < N \\\\\\n      and (theta <= engines[(r+1)%N][0] <= theta+pi \\\\\\n           or theta <= engines[(r+1)%N][0]+2*pi <= theta+pi):\\n    r += 1\\n    X += engines[r%N][1]\\n    Y += engines[r%N][2]\\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2)\\n  X -= xl\\n  Y -= yl\\n\\nprint(ans2 ** 0.5)\", \"from math import atan2, hypot\\n\\ndef solve():\\n    N = int(input())\\n    engines = [tuple(map(int, input().split())) for _ in range(N)]\\n\\n    engines.sort(key=lambda x: atan2(x[1], x[0]))\\n\\n    ans = 0\\n    for L in range(N):\\n        for R in range(L, L+N):\\n            x, y = 0, 0\\n            for i in range(L, R+1):\\n                i %= N\\n                dx, dy = engines[i]\\n                x, y = x+dx, y+dy\\n            dist = hypot(x, y)\\n            if dist > ans:\\n                ans = dist\\n\\n    print(ans)\\n\\n\\nsolve()\\n\", \"n=int(input())\\nxy=[tuple(map(int,input().split())) for _ in range(n)]\\nimport numpy as np\\ne=(1,0)\\nxyz=[]\\nk=0\\nfor x,y in xy:\\n  if x==0 and y==0:continue\\n  k+=1\\n  l=np.linalg.norm((x,y))\\n  z=np.inner((x/l,y/l),e)\\n  theta = np.rad2deg(np.arccos(z))\\n  if y<0:\\n    theta=360-theta\\n  xyz.append((x,y,theta))\\nxyz.sort(key=lambda x:x[2])\\n\\n\\ntx,ty=0,0\\nc=[(0,0)]\\nfor x,y,z in xyz:\\n  tx+=x\\n  ty+=y\\n  c.append((tx,ty))\\nfor x,y,z in xyz:\\n  tx+=x\\n  ty+=y\\n  c.append((tx,ty))\\n\\nans=0\\nfor i in range(k):\\n  for j in range(k):\\n    x=c[i+j+1][0]-c[i][0]\\n    y=c[i+j+1][1]-c[i][1]\\n    ans=max(ans,(x**2+y**2)**0.5)\\nprint(ans)\\n\", \"import math\\nN=int(input())\\nengines = tuple((complex(*map(int, input().split())) for _ in range(N)))\\nengines = sorted(list((engine, math.atan2(engine.imag, engine.real))for engine in engines if engine != 0), key=lambda x:x[1])\\nN=len(engines)\\nif N == 0:\\n    print(0)\\nelse:\\n    total = sum(engine[0] for engine in engines)\\n    head_index = max(i if engines[i][0].imag < 0 else -1 for i in range(N))\\n    tail_index = 0\\n    tmp = sum(engines[i][0] for i in range(tail_index,head_index+1))\\n    maximum = max(abs(tmp), abs(total - tmp))\\n\\n    while True:\\n        if head_index < N-1:\\n            if (engines[head_index+1][0]/engines[tail_index][0]).imag >= 0:\\n                head_index += 1\\n            else:\\n                tail_index += 1\\n        else:\\n            if (engines[0][0]/engines[tail_index][0]).imag < 0:\\n                tail_index += 1\\n            else:\\n                break\\n        tmp = sum(engines[i][0] for i in range(tail_index,head_index+1))\\n        maximum = max(maximum, abs(tmp), abs(total - tmp))\\n\\n    print(maximum)\", \"from cmath import phase\\n\\nN, *XY = map(int, open(0).read().split())\\n\\nXY = sorted((complex(x, y) for x, y in zip(*[iter(XY)] * 2)), key=phase)\\nXY += XY\\n\\n\\nans = 0\\nfor i in range(2 * N + 1):\\n    for j in range(2 * N + 1):\\n        if j - i <= N:\\n            ans = max(ans, abs(sum(XY[i:j])))\\n\\nprint(ans)\", \"import cmath\\nimport math\\n\\nN = int(input())\\npc = []\\nfor i in range(N):\\n  x, y = list(map(int, input().split()))\\n  c = x + y*1j\\n  p = cmath.phase(c)\\n  pc.append([p, c])\\npc = sorted(pc, key=lambda x: x[0])\\n\\nps = [pc[i][0] for i in range(N)]\\ncs = [pc[i][1] for i in range(N)]\\n\\ndef L(i, j, N):\\n  if i<j:\\n    return list(range(i, j))\\n  else:\\n    return list(range(0, j)) + list(range(i+1, N))\\n\\ns = 0\\nm = 0\\n\\nfor start in range(N):\\n  for end in range(N):\\n    s = 0\\n    #print(start,end,N,L(start,end,N))\\n    for k in L(start,end,N):\\n      s += cs[k]\\n    m = max(m, abs(s))\\ns = 0\\nfor k in range(N):\\n  s += cs[k]\\n  m = max(m, abs(s))\\nprint(m)\\n\", \"import math\\nn = int(input())\\nxy = []\\nfor i in range(n):\\n    x, y = [int(item) for item in input().split()]\\n    if x == 0 and y == 0:\\n        rad = 0.0\\n    elif x == 0:\\n        if y > 0:\\n            rad = math.pi / 2.0\\n        elif y < 0:\\n            rad = -math.pi / 2.0\\n    else:\\n        rad = math.atan2(y, x)\\n    deg = math.degrees(rad)\\n    xy.append((deg, x, y))\\n\\nxy.sort()\\nxy2 = xy[:]\\nfor i, (d, x, y) in enumerate(xy):\\n    xy2.append((d+360.0, x, y))\\n    if i == 0:\\n        xy2.append((d+720.0, x, y))\\nxy2.sort()\\n\\nans = 0.0\\nfor i in range(n):\\n    for j in range(i+1, i+n+1):\\n        x = 0.0; y = 0.0\\n        for k in range(i, j):\\n            x += xy2[k][1]\\n            y += xy2[k][2]\\n        d = math.hypot(x, y)\\n        ans = max(ans, d)\\n\\nprint(ans)\", \"import sys\\nsys.setrecursionlimit(10**7)\\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\\ndef LS(): return sys.stdin.readline().split()\\ndef II(): return int(sys.stdin.readline())\\ndef SI(): return sys.stdin.readline().strip()\\nINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\nimport math\\n\\ndef main(): \\n    N = II()\\n    engines = []\\n    for _ in range(N):\\n        x, y = LI()\\n        angle = math.atan2(y, x)\\n        engines.append((x,y,angle))\\n\\n    # \\u504f\\u89d2\\u30bd\\u30fc\\u30c8\\n    engines.sort(key=lambda x: x[2])\\n\\n    dist_max = 0\\n    # \\u5404\\u30a8\\u30f3\\u30b8\\u30f3\\u3092\\u5148\\u982d\\u306b\\u3001\\u305d\\u3053\\u304b\\u3089 pi \\u306e\\u7bc4\\u56f2\\u306b\\u3042\\u308b\\u30a8\\u30f3\\u30b8\\u30f3\\u3092\\u3059\\u3079\\u3066\\u7528\\u3044\\u3066\\u9032\\u884c\\u3057\\u3001\\u8ddd\\u96e2\\u3092\\u7b97\\u51fa\\u3059\\u308b\\u3002\\n    cnt = -1\\n    for x1, y1, angle1 in engines:\\n        cnt += 1\\n        if angle1 <= 0:\\n            search_criteria = lambda x: True if angle1 <= x < angle1+math.pi else False\\n        else:\\n            search_criteria = lambda x: True if (angle1 <= x) or (x < angle1-math.pi) else False\\n        # search_criteria = lambda x, y: True if x1*x + y1*y > 0 else False\\n\\n        x_sum = 0\\n        y_sum = 0\\n        for x, y, angle in engines[cnt:] + engines[:cnt]:\\n            if search_criteria(angle):\\n            # if search_criteria(x, y):\\n                x_sum += x\\n                y_sum += y\\n            dist_max = max(dist_max, math.sqrt(x_sum**2 + y_sum**2))\\n    \\n    print(dist_max)\\n\\nmain()\", \"import sys\\nfrom math import atan2, pi\\n\\nn = int(input())\\nangles = []\\nengines = []\\npi2 = 2 * pi\\nfor i, line in enumerate(sys.stdin):\\n    x, y = list(map(int, line.split()))\\n    angle = atan2(y, x)\\n    angles.append((angle, i))  # -pi~pi\\n    angles.append((angle + pi2, i))  # pi~3pi\\n    engines.append(x + y * 1j)\\nangles.sort()\\n\\nr = 0\\ntmp = 0\\ntotal = sum(engines)\\nans = 0\\nfor l in range(n):\\n    angle, i = angles[l]\\n    limit = angle + pi - 1e-9\\n    while angles[r][0] < limit:\\n        tmp += engines[angles[r][1]]\\n        r += 1\\n    ans = max(ans, abs(tmp), abs(total - tmp))\\n    tmp -= engines[i]\\nprint(ans)\\n\", \"N=int(input())\\nfrom cmath import phase\\nXY=sorted([list(map(int,input().split())) for i in range(N)],key=lambda x: phase(x[0]+x[1]*1j))\\nXY+=XY\\nans=0\\nfor l in range(N):\\n    a=[0,0]\\n    for r in range(l,min(2*N,l+N)):\\n        a[0]+=XY[r][0]\\n        a[1]+=XY[r][1]\\n        ans=max(ans,abs(a[0]+a[1]*1j))\\nprint(ans)\", \"\\nimport math\\nN = int(input())\\nXY = [list(map(int,input().split())) for _ in  range(N)]\\nfor i in range(N):\\n    XY[i].append(math.atan2(XY[i][1],XY[i][0]))\\n\\nXY.sort(key = lambda x:x[2])\\nans = 0\\ntmp = [0,0]\\nruisekiwa_x = [0] * N\\nruisekiwa_y = [0] * N\\nruisekiwa_x[0] = XY[0][0]\\nruisekiwa_y[0] = XY[0][1]\\n\\nfor i in range(1,N):\\n    ruisekiwa_x[i] = ruisekiwa_x[i-1] + XY[i][0]\\n    ruisekiwa_y[i] = ruisekiwa_y[i-1] + XY[i][1]\\n    \\nans = 0\\nfor i in range(N):\\n    for j in range(i,N):\\n        if i>0: \\n            tmp[0] = ruisekiwa_x[j] - ruisekiwa_x[i-1]\\n            tmp[1] = ruisekiwa_y[j] - ruisekiwa_y[i-1]\\n        else:\\n            tmp[0] = ruisekiwa_x[j] \\n            tmp[1] = ruisekiwa_y[j] \\n            \\n            \\n        ans = max(ans,math.sqrt(tmp[0]*tmp[0] + tmp[1]*tmp[1]))\\nfor i in range(N):\\n    if XY[i][2] < 0:\\n        XY[i][2] = -math.pi-XY[i][2]\\n    else:\\n        XY[i][2] = math.pi - XY[i][2]\\n        \\n\\nXY.sort(key = lambda x:x[2])\\nruisekiwa_x = [0] * N\\nruisekiwa_y = [0] * N\\nruisekiwa_x[0] = XY[0][0]\\nruisekiwa_y[0] = XY[0][1]\\n\\nfor i in range(1,N):\\n    ruisekiwa_x[i] = ruisekiwa_x[i-1] + XY[i][0]\\n    ruisekiwa_y[i] = ruisekiwa_y[i-1] + XY[i][1]\\n    \\nfor i in range(N):\\n    for j in range(i,N):\\n        if i>0: \\n            tmp[0] = ruisekiwa_x[j] - ruisekiwa_x[i-1]\\n            tmp[1] = ruisekiwa_y[j] - ruisekiwa_y[i-1]\\n        else:\\n            tmp[0] = ruisekiwa_x[j] \\n            tmp[1] = ruisekiwa_y[j] \\n            \\n            \\n        ans = max(ans,math.sqrt(tmp[0]*tmp[0] + tmp[1]*tmp[1]))\\n        \\nprint(ans)\\n\\n\", \"import cmath\\nimport math\\nn=int(input())\\na=[]\\nb=[]\\n#\\u504f\\u89d2\\u30bd\\u30fc\\u30c8\\u306e\\u65b9\\u304c\\u697d\\nfor i in range(n):\\n    x,y=list(map(int,input().split()))\\n    a.append(complex(x,y))\\n    b.append(cmath.phase(a[i]))\\n#a.sort(key=cmath.phase)\\nma=0\\n#math.pi\\u306b\\u6ce8\\u610f\\nfor i in range(n):\\n    z=a[i]\\n    c=b[i]-math.pi/2\\n    d=b[i]+math.pi/2\\n    l=max([c,-math.pi])\\n    r=min([d,math.pi])\\n    #(0,0)\\u306e\\u6642\\u306f\\u504f\\u89d2\\u304c0\\u306b\\u306a\\u3063\\u3066\\u3057\\u307e\\u3046\\u3057\\u3001\\u9664\\u304f\\n    #\\u3042\\u3068\\u306f-pi\\u3068pi\\u3069\\u3063\\u3061\\u306b\\u306a\\u308b\\u304b\\u2192pi\\u306b\\u306a\\u308b\\n    if a[i]!=complex(0,0):\\n        for j in range(n):\\n            if j!=i:\\n                #\\u5883\\u754c\\u6761\\u4ef6\\u306e\\u5834\\u5408\\u5206\\u3051\\u304c\\u3080\\u305a\\u3044\\n                if l<=b[j]<=r or (c<=-math.pi and c+2*math.pi<=b[j]<=math.pi) or (d>=math.pi and -math.pi<=b[j]<=d-2*math.pi):\\n                    z+=a[j]\\n    ma=max([abs(z),ma])\\nm=0\\n#math.pi\\u306b\\u6ce8\\u610f\\nfor i in range(n):\\n    if a[i]!=complex(0,0):\\n        za,zb=complex(0,0),complex(0,0)\\n        for j in range(n):\\n            p=cmath.phase(a[j]/a[i])\\n            if -math.pi<=p<=0:\\n                za+=a[j]\\n            if 0<=p<=math.pi:\\n                zb+=a[j]\\n        m=max([m,abs(za),abs(zb)])\\n        if i!=n-1 and a[i]+a[i+1]!=0:\\n            zc,zd=complex(0,0),complex(0,0)\\n            for j in range(n):\\n                p=cmath.phase(a[j]/((a[i]+a[i+1])/2))\\n                if -math.pi<=p<=0:\\n                    zc+=a[j]\\n                if 0<=p<=math.pi:\\n                    zd+=a[j]\\n            m=max([m,abs(zc),abs(zd)])\\n\\nprint((max([m,ma])))\\n\", \"import numpy as np\\nN = int(input())\\nX = []\\nY = []\\nfor _ in range(N):\\n    x, y = map(int, input().split())\\n    X.append(x)\\n    Y.append(y)\\nX = np.array(X)\\nY = np.array(Y)\\ntheta = np.arctan2(X, Y)\\nindex = theta.argsort()\\nX = X[index]\\nY = Y[index]\\nX = np.tile(X, 2)\\nY = np.tile(Y, 2)\\nXcum = X.cumsum()\\nYcum = Y.cumsum()\\nans = (Ycum-Ycum[:, None])**2+(Xcum-Xcum[:, None])**2\\nm = 0\\nfor i in range(N*2):\\n    m = max(m, ans[i, i:i+N+1].max())\\nprint(m**0.5)\", \"# -*- coding: utf-8 -*-\\nimport math\\n\\n\\n\\ndef main():\\n    N = int(input())\\n    E = []\\n    for i in range(N):\\n        x, y = list(map(int,input().split()))\\n        E.append((math.atan2(y,x),x,y))\\n    E = sorted(E) * 2\\n\\n    answer = 0\\n    for i in range(N):\\n        x = 0\\n        y = 0\\n        for j in range(i, i+N):\\n            x += E[j][1]\\n            y += E[j][2]\\n            answer = max(answer, x * x + y * y)\\n\\n    answer = math.sqrt(answer)\\n    print(answer)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from math import atan2, pi\\n\\nN = int(input())\\nengines = []\\ntotal_X = total_Y = 0\\nfor i in range(N):\\n  x, y = map(int, input().split())\\n  engines.append((atan2(y, x), x, y)) # (theta, x, y)\\n  total_X += x\\n  total_Y += y\\n\\nengines.sort()\\nans2 = 0\\nl = r = 0\\nX = engines[0][1]\\nY = engines[0][2]\\n\\nfor l in range(N):\\n  theta = engines[l][0]\\n  xl, yl = engines[l][1:]\\n  # l\\u756a\\u76ee\\u306e\\u30d9\\u30af\\u30c8\\u30eb\\u306e\\u5fae\\u5c0f\\u89d2\\u5c0f\\u3055\\u3044\\u3068\\u3053\\u308d\\u306b\\u5883\\u754c\\u9762\\u3092\\u8a2d\\u5b9a\\n  while r + 1 - l < N \\\\\\n      and (theta <= engines[(r+1)%N][0] < theta+pi \\\\\\n           or theta <= engines[(r+1)%N][0]+2*pi < theta+pi):\\n    r += 1\\n    X += engines[r%N][1]\\n    Y += engines[r%N][2]\\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2) # \\u5883\\u754c\\u9762\\u306e\\u4e21\\u9762\\u3092\\u30c1\\u30a7\\u30c3\\u30af\\n  # l\\u756a\\u76ee\\u306e\\u30d9\\u30af\\u30c8\\u30eb\\u4e01\\u5ea6(\\u5fae\\u5c0f\\u89d2\\u5927\\u304d\\u3044\\u3068\\u3053\\u308d)\\u306b\\u5883\\u754c\\u9762\\u3092\\u8a2d\\u5b9a\\n  while r + 1 - l < N \\\\\\n      and (theta <= engines[(r+1)%N][0] <= theta+pi \\\\\\n           or theta <= engines[(r+1)%N][0]+2*pi <= theta+pi):\\n    r += 1\\n    X += engines[r%N][1]\\n    Y += engines[r%N][2]\\n  ans2 = max(ans2, X**2+Y**2, (total_X-X)**2+(total_Y-Y)**2) # \\u5883\\u754c\\u9762\\u306e\\u4e21\\u9762\\u3092\\u30c1\\u30a7\\u30c3\\u30af\\n  X -= xl\\n  Y -= yl\\n\\nprint(ans2 ** 0.5)\", \"L = 10**10\\n\\nN = int(input())\\nx, y = zip(*(map(int, input().split()) for _ in range(N)))\\n\\nresult = 0\\nfor i in range(N):\\n    for b in [-1, 1]:\\n        for s, t in [(y[i], -x[i]), (-y[i], x[i])]:\\n            s, t = L * s - b * t, b * s + L * t\\n            X = 0\\n            Y = 0\\n            for j in range(N):\\n                if x[j] * s + y[j] * t > 0:\\n                    X += x[j]\\n                    Y += y[j]\\n            result = max(result, (X**2 + Y**2)**0.5)\\nprint(result)\", \"import sys\\nfrom operator import itemgetter\\nimport math\\n\\nsys.setrecursionlimit(10 ** 8)\\n\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N = int(input())\\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\\n\\n    ans = 0\\n\\n    # x\\n    # plus, plus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if x > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif x == 0 and y > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # x\\n    # plus, minus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if x > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif x == 0 and y < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # x\\n    # minus, plus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if x < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif x == 0 and y > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # x\\n    # minus, minus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if x < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif x == 0 and y < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # y\\n    # plus, plus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if y > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif y == 0 and x > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # y\\n    # plus, minus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if y < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif y == 0 and x > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # y\\n    # minus, plus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if y > 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif y == 0 and x < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    # y\\n    # minus, minus\\n    tmp = [0, 0]\\n    for x, y in XY:\\n        if y < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n        elif y == 0 and x < 0:\\n            tmp[0] += x\\n            tmp[1] += y\\n\\n    ans = max(ans, math.sqrt(tmp[0] ** 2 + tmp[1] ** 2))\\n\\n    for i, (x, y) in enumerate(XY):\\n        if x == 0:\\n            katamuki = 0\\n            katamuki2 = float(\\\"inf\\\")\\n        else:\\n            katamuki = y / x\\n            if y == 0:\\n                katamuki2 = float(\\\"inf\\\")\\n            else:\\n                katamuki2 = -(x / y)\\n        plus = [0, 0]\\n        minus = [0, 0]\\n        plus2 = [0, 0]\\n        minus2 = [0, 0]\\n        for j, (xx, yy) in enumerate(XY):\\n            if i == j:\\n                continue\\n            if yy > katamuki * xx:\\n                plus[0] += xx\\n                plus[1] += yy\\n            else:\\n                minus[0] += xx\\n                minus[1] += yy\\n\\n            if katamuki2 == float(\\\"inf\\\"):\\n                if xx > 0:\\n                    plus2[0] += xx\\n                    plus2[1] += yy\\n                else:\\n                    minus2[0] += xx\\n                    minus2[1] += yy\\n            else:\\n                if yy > katamuki2 * xx:\\n                    plus2[0] += xx\\n                    plus2[1] += yy\\n                else:\\n                    minus2[0] += xx\\n                    minus2[1] += yy\\n\\n        ans = max(ans, math.sqrt(plus[0] ** 2 + plus[1] ** 2))\\n        ans = max(ans, math.sqrt(minus[0] ** 2 + minus[1] ** 2))\\n        ans = max(ans, math.sqrt(plus2[0] ** 2 + plus2[1] ** 2))\\n        ans = max(ans, math.sqrt(minus2[0] ** 2 + minus2[1] ** 2))\\n        ans = max(ans, math.sqrt((plus[0] + x) ** 2 + (plus[1] + y) ** 2))\\n        ans = max(ans, math.sqrt((minus[0] + x) ** 2 + (minus[1] + y) ** 2))\\n        ans = max(ans, math.sqrt((plus2[0] + x) ** 2 + (plus2[1] + y) ** 2))\\n        ans = max(ans, math.sqrt((minus2[0] + x) ** 2 + (minus2[1] + y) ** 2))\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from math import atan2, pi\\n\\nn = int(input())\\ne = []\\n\\nfor _ in range(n):\\n    x, y = list(map(int, input().split()))\\n    r = atan2(y, x)\\n    if r < 0:\\n        r += pi * 2\\n    e.append([r, x, y])\\n\\ne.sort()\\n\\nans = 0\\nfor i in range(n):\\n    e.append([e[i][0] + pi * 2, e[i][1], e[i][2]])\\n    ans = max(ans, (e[i][1] ** 2 + e[i][2] ** 2) ** 0.5)\\n\\nif n == 1:\\n    print(ans)\\n    return\\n\\nfor L in range(n):\\n    x = e[L][1]\\n    y = e[L][2]\\n    for R in range(L+1, L+n):\\n        x += e[R][1]\\n        y += e[R][2]\\n        ans = max(ans, (x ** 2 + y ** 2) ** 0.5)\\n\\nprint(ans)\\n\", \"import sys\\nfrom itertools import accumulate, combinations\\nfrom math import atan2\\nread = sys.stdin.read\\n\\nN, *xy = map(int, read().split())\\nxy = sorted(zip(*[iter(xy)] * 2), key=lambda x: atan2(x[1], x[0]))\\nxy = [(0, 0)] + xy\\n\\nxy *= 2\\nxy = list(zip(*map(list, map(accumulate, zip(*xy)))))\\nanswer = 0\\n\\nfor n in range(N + 1):\\n    for i, j in combinations(range(n, n + N + 1), 2):\\n        x1, y1 = xy[i]\\n        x2, y2 = xy[j]\\n        candidate = (x1 - x2) ** 2 + (y1 - y2) ** 2\\n        if candidate > answer:\\n            answer = candidate\\n\\nprint(answer ** 0.5)\", \"from math import atan2, pi, sqrt\\nfrom operator import itemgetter\\nimport sys\\ninput = sys.stdin.readline\\n\\nn = int(input())\\np = []\\nxa = ya = 0\\nfor i in range(n):\\n    x, y = list(map(int, input().split()))\\n    angle = atan2(y, x)\\n    p.append((x, y, angle))\\n    p.append((x, y, angle + 2 * pi))\\n    xa += x\\n    ya += y\\n\\np.sort(key=itemgetter(2))\\n\\nr = 0\\nans = 0\\nxs = ys = 0\\nfor l in range(n):\\n    while p[r][2] < p[l][2] + pi:\\n        xs += p[r][0]\\n        ys += p[r][1]\\n        r += 1\\n\\n    ans = max(ans, sqrt(xs**2 + ys**2), sqrt((xa - xs)**2 + (ya - ys)**2))\\n\\n    xs -= p[l][0]\\n    ys -= p[l][1]\\n\\nprint(ans)\\n\", \"# \\u8907\\u7d20\\u6570\\u7248\\n\\n# \\u51f8\\u5305 Monotone Chain O(nlogn)\\n# \\u53c2\\u8003: https://matsu7874.hatenablog.com/entry/2018/12/17/025713\\ndef get_convex_hull(points):\\n    def det(p, q):\\n        return (p.conjugate()*q).imag\\n    points.sort(key=lambda x: (x.real, x.imag))\\n    ch = []\\n    for p in points:\\n        while len(ch) > 1:\\n            v_cur = ch[-1]-ch[-2]\\n            v_new = p-ch[-2]\\n            if det(v_cur, v_new) > 0:\\n                break\\n            ch.pop()\\n        ch.append(p)\\n    t = len(ch)\\n    for p in points[-2::-1]:\\n        while len(ch) > t:\\n            v_cur = ch[-1]-ch[-2]\\n            v_new = p-ch[-2]\\n            if det(v_cur, v_new) > 0:\\n                break\\n            ch.pop()\\n        ch.append(p)\\n    return ch[:-1]\\n\\n\\nN = int(input())\\nXY = [complex(*list(map(int, input().split()))) for _ in range(N)]\\nps = [complex(0, 0)]\\nfor p in XY:\\n    ps_new = ps[:]\\n    for p_ in ps:\\n        ps_new.append(p+p_)\\n    ps = get_convex_hull(ps_new)\\nans = 0\\nfor p in ps:\\n    ans = max(ans, abs(p))\\nprint(ans)\\n\", \"def f_f():\\n    import numpy as np\\n\\n    n = int(input())\\n    x, y = np.array([input().split() for _ in range(n)], dtype=\\\"int64\\\").T\\n\\n    a = np.arctan2(x, y)\\n    i = a.argsort()\\n    x, y, a = x[i], y[i], a[i]\\n\\n    x, y = np.concatenate([x, x]), np.concatenate([y, y])\\n    a = np.concatenate([a, a+2*np.pi])\\n\\n    xcs, ycs = x.cumsum(), y.cumsum()\\n    items = np.arange(1, n+1)[None,:]\\n    l = np.arange(n)[:,None]\\n\\n    dx = xcs[l+items-1]-xcs[l]+x[l]\\n    dy = ycs[l+items-1]-ycs[l]+y[l]\\n\\n    print(((dx*dx+dy*dy).max()**0.5))\\n\\ndef __starting_point():\\n    f_f()\\n\\n__starting_point()\", \"def solve():\\n    from math import atan2, degrees, hypot\\n    n = int(input())\\n    txy = []\\n    sx, sy = 0, 0\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        theta_0 = degrees(atan2(b, a))\\n        sx += a\\n        sy += b\\n        txy.append((theta_0, a, b))\\n    txy.sort()\\n    ans = hypot(sx, sy)\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            tx, ty = 0, 0\\n            for k in range(i, j):\\n                theta, x, y = txy[k]\\n                tx += x\\n                ty += y\\n                ans = max(ans, hypot(tx, ty))\\n                ans = max(ans, hypot(sx - tx, sy - ty))\\n    print(ans)\\n\\nsolve()\\n\", \"import numpy as np\\nN = int(input())\\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\\nth = np.arctan2(XY[:,1],XY[:,0])\\nXY = XY[th.argsort()]\\nans = 0\\nn = np.linalg.norm\\nSxy = np.vstack((np.zeros(2),np.cumsum(XY,axis=0)))\\nfor i in range(N):\\n    for j in range(i+1,i+N+1):\\n        r = n(Sxy[min(j,N)]-Sxy[i] + Sxy[max(0,j-N)])\\n        ans = max(ans,r)\\nprint(ans)\", \"from math import hypot, atan2\\n\\nN = int(input())\\nengines = [tuple(map(int, input().split())) for _ in range(N)]\\n\\nengines.sort(key=lambda z: atan2(z[1], z[0]))\\n\\nans = 0\\nfor L in range(N):\\n    for R in range(N):\\n        if L <= R:\\n            x, y = list(map(sum, list(zip(*engines[L:R+1]))))\\n        else:\\n            x, y = list(map(sum, list(zip(*(engines[:R+1]+engines[L:])))))\\n        dist = hypot(x, y)\\n        ans = max(ans, dist)\\n\\nprint(ans)\\n\", \"# -*- coding: utf-8 -*-\\n\\nimport sys\\nfrom math import atan2, degrees, hypot\\n\\ndef input(): return sys.stdin.readline().strip()\\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\\ndef ceil(x, y=1): return int(-(-x // y))\\ndef INT(): return int(input())\\ndef MAP(): return list(map(int, input().split()))\\ndef LIST(): return list(map(int, input().split()))\\ndef Yes(): print('Yes')\\ndef No(): print('No')\\ndef YES(): print('YES')\\ndef NO(): print('NO')\\nsys.setrecursionlimit(10 ** 9)\\nINF = float('inf')\\nMOD = 10 ** 9 + 7\\nEPS = 10 ** -9\\n\\nN = INT()\\n\\ndegs = []\\nXY = []\\nfor i in range(N):\\n    x, y = MAP()\\n    XY.append((x, y))\\n    deg = degrees(atan2(y, x))\\n    if deg < 0:\\n        # \\u8ca0\\u306e\\u6570\\u306a\\u3089\\u6642\\u8a08\\u56de\\u308a\\u5074\\u306b\\u3042\\u308b\\u306e\\u3067\\u9006\\u5411\\u304d\\u306b\\u3059\\u308b\\n        deg += 360\\n    degs.append((deg, i))\\n# \\u89d2\\u5ea6\\u3067\\u30bd\\u30fc\\u30c8\\ndegs.sort()\\n# 2\\u5468\\u76ee\\u3092\\u3064\\u3051\\u308b\\ndegs += [(deg+360, i) for deg, i in degs]\\n\\nans = 0\\nfor i in range(N):\\n    deg, idx = degs[i]\\n    xsm, ysm = XY[idx]\\n    ans = max(ans, hypot(xsm, ysm))\\n    j = i + 1\\n    # \\u59cb\\u70b9\\u304b\\u3089180\\u5ea6\\u672a\\u6e80\\u306e\\u65b9\\u5411\\u306b\\u5411\\u304b\\u3046\\u3082\\u306e\\u3092\\u5168\\u3066\\u8ffd\\u52a0\\u3057\\u306a\\u304c\\u3089\\u6700\\u5927\\u3092\\u53d6\\u308b\\n    while degs[j][0] < deg+180:\\n        _, idx = degs[j]\\n        x, y = XY[idx]\\n        xsm += x\\n        ysm += y\\n        ans = max(ans, hypot(xsm, ysm))\\n        j += 1\\nprint(ans)\\n\", \"import itertools\\nN = int(input())\\nXY = [[int(_) for _ in input().split()] for _ in range(N)]\\nxy1 = []\\nxy2 = []\\nxy3 = []\\nxy4 = []\\nfor x, y in XY:\\n    if x >= 0:\\n        if y >= 0:\\n            xy1 += [[x, y]]\\n        else:\\n            xy4 += [[x, y]]\\n    else:\\n        if y >= 0:\\n            xy2 += [[x, y]]\\n        else:\\n            xy3 += [[x, y]]\\nxy1.sort(key=lambda xy: float('inf') if xy[0] == 0 else xy[1] / xy[0])\\nxy2.sort(key=lambda xy: xy[1] / xy[0])\\nxy3.sort(key=lambda xy: xy[1] / xy[0])\\nxy4.sort(key=lambda xy: -float('inf') if xy[0] == 0 else xy[1] / xy[0])\\nXY = xy1 + xy2 + xy3 + xy4\\nN = len(XY)\\nXY *= 2\\nacc = list(\\n    itertools.accumulate(XY, func=lambda a, b: [a[0] + b[0], a[1] + b[1]]))\\nans = 0\\nfor i in range(N):\\n    for j in range(i + 1, i + N + 1):\\n        x = acc[j][0] - acc[i][0]\\n        y = acc[j][1] - acc[i][1]\\n        ans = max(ans, x**2 + y**2)\\nprint((ans**0.5))\\n\", \"import cmath\\nimport math\\n\\nN = int(input())\\npc = []\\nfor i in range(N):\\n  x, y = map(int, input().split())\\n  c = x + y*1j\\n  p = cmath.phase(c)\\n  pc.append([p, c])\\npc = sorted(pc, key=lambda x: x[0])\\n\\nps = [pc[i][0] for i in range(N)]\\ncs = [pc[i][1] for i in range(N)]\\n\\ndef L(i, j, N):\\n  if i<j:\\n    return list(range(i, j))\\n  else:\\n    return list(range(0, j)) + list(range(i+1, N))\\n\\ns = 0\\nm = 0\\n\\nfor start in range(N):\\n  for end in range(N):\\n    s = 0\\n    #print(start,end,N,L(start,end,N))\\n    for k in L(start,end,N):\\n      s += cs[k]\\n    m = max(m, abs(s))\\ns = 0\\nfor k in range(N):\\n  s += cs[k]\\n  m = max(m, abs(s))\\nprint(m)\", \"import math\\nn=int(input())\\nl=[list(map(int,input().split())) for i in range(n)]\\nfor i in range(n):\\n  x=math.degrees(math.atan2(l[i][1], l[i][0]))\\n  l[i]=[x,l[i][0],l[i][1]]\\nl.sort()\\nL=l+l\\nansL=[]\\nfor i in range(n):\\n  for j in range(i,n+i):\\n    ctx=0;cty=0\\n    for k in range(i,j+1):\\n      ctx+=L[k][1]\\n      cty+=L[k][2]\\n    ansL.append((ctx**2+cty**2)**0.5)\\nprint(max(ansL))\", \"import sys\\nfrom heapq import heappop, heappush\\nfrom operator import itemgetter\\nfrom collections import deque, defaultdict, Counter\\nfrom bisect import bisect_left, bisect_right\\ninput = sys.stdin.readline\\nsys.setrecursionlimit(10 ** 7)\\nMOD = 10**9 + 7\\nINF = float('inf')\\n\\nimport math\\n\\ndef sol():\\n    N = int(input())\\n    engine = [tuple(map(int, input().split())) for _ in range(N)]\\n\\n    ans = 0\\n\\n    for direct in range(0, 1000):\\n        direct = 2 * math.pi / 999 * direct\\n        u, v = math.cos(direct), math.sin(direct)\\n\\n        length = [0, 0]\\n        for x, y in engine:\\n            if u * x + v * y >= 0:\\n                length[0] += x\\n                length[1] += y\\n\\n        ans = max(ans, length[0]**2 + length[1]**2)\\n\\n    print(ans**0.5)\\n\\nsol()\", \"import numpy as np\\nN = int(input())\\nXY =  np.array([list(map(int,input().split())) for _ in [0]*N])\\nth = np.arctan2(XY[:,1],XY[:,0])\\nXY = XY[th.argsort()]\\nans = 0\\nfor i in range(N):\\n    for j in range(i+1,i+N+1):\\n        r = np.linalg.norm(XY[i:j].sum(axis=0)+XY[:max(0,j-N)].sum(axis=0))\\n        ans = max(ans,r)\\nprint(ans)\", \"import math\\nN = int(input())\\nn = 72\\n\\nx = [None] * N\\ny = [None] * N\\nfor i in range(N):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(n):\\n    theta = (2 * math.pi / n) * i\\n    c = math.cos(theta)\\n    s = math.sin(theta)\\n    tmp_x = 0\\n    tmp_y = 0\\n    for j in range(N):\\n        if x[j] * c + y[j] * s > 0:\\n            tmp_x += x[j]\\n            tmp_y += y[j]\\n    if tmp_x**2 + tmp_y**2 > ans**2:\\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\\n\\nprint(ans)\\n\", \"import sys\\nfrom operator import itemgetter\\nimport math\\n\\nsys.setrecursionlimit(10 ** 8)\\n\\ninput = sys.stdin.readline\\n\\n\\ndef main():\\n    N = int(input())\\n    XY = [[int(x) for x in input().split()] for _ in range(N)]\\n\\n    ans = 0\\n\\n    for i, (x, y) in enumerate(XY):\\n        if x == 0:\\n            katamuki =  1 / (10 ** 7)\\n            katamuki2 =  - 1 / (10 ** 7)\\n        else:\\n            katamuki = y / x + 1 / (10 ** 7)\\n            katamuki2 = y / x - 1 / (10 ** 7)\\n        plus = [0, 0]\\n        minus = [0, 0]\\n        plus2 = [0, 0]\\n        minus2 = [0, 0]\\n        for j, (xx, yy) in enumerate(XY):\\n            if yy > katamuki * xx:\\n                plus[0] += xx\\n                plus[1] += yy\\n            else:\\n                minus[0] += xx\\n                minus[1] += yy\\n\\n            if yy > katamuki2 * xx:\\n                plus2[0] += xx\\n                plus2[1] += yy\\n            else:\\n                minus2[0] += xx\\n                minus2[1] += yy\\n\\n        ans = max(ans, math.sqrt(plus[0] ** 2 + plus[1] ** 2))\\n        ans = max(ans, math.sqrt(minus[0] ** 2 + minus[1] ** 2))\\n        ans = max(ans, math.sqrt(plus2[0] ** 2 + plus2[1] ** 2))\\n        ans = max(ans, math.sqrt(minus2[0] ** 2 + minus2[1] ** 2))\\n\\n    print(ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n = int(input())\\nfrom cmath import phase\\nxy = sorted([list(map(int,input().split())) for i in range(n)],key=lambda x: phase(x[0]+x[1]*1j))\\n#x+yi\\u306eargument[-pi,pi]\\u306e\\u5c0f\\u3055\\u3044\\u65b9\\u304b\\u3089\\u9806\\u306b\\u4e26\\u3079\\u308b\\nxy += xy\\n#\\u540c\\u3058\\u3082\\u306e\\u3092\\u8907\\u88fd\\nans = 0\\nfor l in range(n):\\n    a = [0,0] # \\u6700\\u5f8c\\u306b\\u305f\\u3069\\u308a\\u7740\\u304f\\u5ea7\\u6a19\\n    for r in range(l,min(2*n,l+n)):#l\\u756a\\u76ee\\u542b\\u3081l\\u304b\\u3089n\\u500b\\u306b\\u3064\\u3044\\u3066\\n        a[0] += xy[r][0]\\n        a[1] += xy[r][1]\\n        ans = max(ans,abs(a[0]+a[1]*1j))\\nprint(ans) \", \"import numpy as np\\n\\nn=int(input())\\n\\ndef div2(x,y):\\n    if x>0:\\n        return (1,y/x)\\n    elif x<0:\\n        return (-1,y/x)\\n    else:\\n        if y>0:\\n            return (-1,-float(\\\"inf\\\"))\\n        else:\\n            return (1,-float(\\\"inf\\\"))\\n    \\n\\nL=[list(map(int,input().split())) for i in range(n)]\\n\\nL.sort(key=lambda x:div2(x[0],x[1]))\\n\\nm=0\\nfor i in range(n):\\n    for j in range(i,n):\\n        x0=y0=0\\n        x1=y1=0\\n        for k in range(n):\\n            if i<=k<=j:\\n                x0+=L[k][0]\\n                y0+=L[k][1]\\n            else:\\n                x1+=L[k][0]\\n                y1+=L[k][1]\\n        m=max(m,x0**2+y0**2,x1**2+y1**2)\\n\\nprint('{:.12f}'.format(np.sqrt(m)))\", \"import sys\\n\\nimport math\\nimport numpy as np\\n\\ndef main():\\n    n = int(input())\\n    vec = [tuple(map(int, input().split())) for i in range(n)]\\n    vec.sort(key=lambda x: math.atan2(x[1], x[0]))\\n\\n    maxx = 0\\n    for i in range(n):\\n        for j in range(1, n+1):\\n            now = [0, 0]\\n            for k in range(j):\\n                idx = (i + k) % n\\n                now[0] += vec[idx][0]\\n                now[1] += vec[idx][1]\\n            maxx = max(maxx, now[0]*now[0] + now[1]*now[1])\\n\\n    print((math.sqrt(maxx)))\\n    return 0\\n\\ndef __starting_point():\\n    return(main())\\n\\n__starting_point()\", \"import math\\nn = int(input())\\nl = [list(map(int,input().split())) for i in range(n)]\\nl.sort(key=lambda x: math.atan2(x[1],x[0]))\\nl += l\\nans = 0\\nfor i in range(n):\\n    x = y = 0\\n    for j in range(n):\\n        nx,ny = l[i+j]\\n        x += nx\\n        y += ny\\n        ans = max(ans,(x**2+y**2)**0.5)\\nprint(ans)\", \"import itertools\\nfrom math import atan2, sqrt\\n\\nN = int(input())\\nA = [t for _ in range(N) if (t := tuple(map(int, input().split()))) != (0, 0)]\\n\\nA.sort(key=lambda x: atan2(x[1], x[0]))\\n\\n# \\u5411\\u304d\\u304c\\u540c\\u3058\\u30a8\\u30f3\\u30b8\\u30f3\\u306f\\uff11\\u3064\\u306b\\u307e\\u3068\\u3081\\u308b\\nAx, Ay = [], []\\nfor _, v in itertools.groupby(A, key=lambda x: atan2(x[1], x[0])):\\n    sx, sy = 0, 0\\n    for vx, vy in v:\\n        sx += vx\\n        sy += vy\\n    Ax.append(sx)\\n    Ay.append(sy)\\n\\nNu = len(Ax)\\n\\nAx = [0] + list(itertools.accumulate(Ax * 2))\\nAy = [0] + list(itertools.accumulate(Ay * 2))\\n\\nans = 0\\nfor i in range(Nu + 1):\\n    for j in range(i + 1, min(i + Nu + 1, 2 * Nu + 1)):\\n        ans = max(ans, (Ax[j] - Ax[i]) ** 2 + (Ay[j] - Ay[i]) ** 2)\\n\\nprint((sqrt(ans)))\\n\", \"from math import atan2, pi, sqrt\\nfrom operator import itemgetter\\n# import sys\\n# input = sys.stdin.readline\\n\\nn = int(input())\\np = []\\nxa = ya = 0\\nfor i in range(n):\\n    x, y = list(map(int, input().split()))\\n    angle = atan2(y, x)\\n    p.append((x, y, angle))\\n    p.append((x, y, angle + 2 * pi))\\n    xa += x\\n    ya += y\\n\\np.sort(key=itemgetter(2))\\n\\nr = 0\\nans = 0\\nxs = ys = 0\\nfor l in range(n):\\n    while p[r][2] < p[l][2] + pi:\\n        xs += p[r][0]\\n        ys += p[r][1]\\n        r += 1\\n\\n    ans = max(ans, sqrt(xs**2 + ys**2), sqrt((xa - xs)**2 + (ya - ys)**2))\\n\\n    xs -= p[l][0]\\n    ys -= p[l][1]\\n\\nprint(ans)\\n\", \"import numpy as np\\nn = int(input())\\nxy = np.array([list(map(int, input().split())) for _ in range(n)]).T\\nans = 0\\nL = np.angle(xy[0]+xy[1]*1j)\\nA = sorted([[j, xy[0][i], xy[1][i]] for i, j in enumerate(L)])\\nA = [i[1:] for i in A]\\nA = np.array(A*2)\\nfor i in range(n):\\n  for j in range(i+1, i+n+1):\\n    S = A[i:j]\\n    t = S.sum(axis=0)\\n    ans = max(ans, np.hypot(*t))\\nprint(ans)\", \"# \\u7121\\u7406\\u3084\\u308a0.1\\u5ea6\\u305a\\u3064\\u884c\\u5148\\u3092\\u56de\\u3059\\u3002\\n\\nimport math\\nimport numpy as np\\n\\nn = int(input())\\n\\neng_list = []\\n\\nfor _ in range(n):\\n    a = np.array(list(map(int, input().split())))\\n    eng_list.append(a)\\n\\n# \\u89d2\\u5ea6\\nangles = []\\n\\nfor i in range(n):\\n    cos = (np.dot(eng_list[i], np.array([0, 1]))/(np.linalg.norm(eng_list[i])))\\n    angle = math.degrees(math.acos(cos))\\n    if eng_list[i][0] < 0:\\n        angle = 360 - angle\\n    angles.append(angle)\\n\\n\\ndef hantei(a, b):\\n    coss = np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b))\\n    if coss > 1:\\n        coss = 1.0\\n    elif coss < -1:\\n        coss = -1.0\\n    angg = math.degrees(math.acos(coss))\\n    if angg < 90.0001:\\n        return True\\n    else:\\n        return False\\n\\n\\ndef distance(a):\\n    dis = np.linalg.norm(a)\\n    return dis\\n\\npitch = 1 # \\u89d2\\u5ea6\\ndist = []\\n\\nfor ikisaki in np.arange(0, 360, pitch):\\n    dist_location = np.array([0, 0])\\n    for j in eng_list:\\n        i = np.array([math.cos(math.radians(ikisaki)), math.sin(math.radians(ikisaki))])\\n        if hantei(i, j):\\n            dist_location = dist_location + j\\n    dist.append(distance(dist_location))\\n\\nprint((max(dist)))\\n\", \"n = int(input())\\npi = 3.141592653589793238462643383279\\nxy = [list(map(int, input().split())) for _ in range(n)]\\nimport math\\n\\natan = [math.atan2(x[0], x[1]) for x in xy]\\nd = []\\n\\n\\ndef hoge(a):\\n    ret = 0\\n    if a % (2*pi) < pi:\\n        ret = (a % pi)\\n    elif a % (2*pi)  > pi:\\n        ret = (a % pi)-pi\\n    else:\\n        ret = (a)\\n    #assert pi <= ret <= pi, 'range over'\\n    return ret  # -pi <= a <= pi\\n\\n\\ndef seikika(A):\\n    ret = []\\n    for a in A:\\n        ret.append(hoge(a))\\n    return ret\\n\\n\\ngyoukaku = atan.copy()\\ngyoukaku.extend(seikika([a + pi for a in atan]))\\nM=60\\nfor m in range(M):\\n    gyoukaku.extend(seikika([a + pi*(2*pi/M*m) for a in atan]))\\n\\n\\ndef dist(xy):\\n    xx = sum([x[0] for x in xy])\\n    yy = sum([y[1] for y in xy])\\n    return (xx ** 2 + yy ** 2) ** 0.5\\n\\n\\nfor g in gyoukaku:\\n    anglist = seikika([hoge(a - g) for a in atan])\\n    anglist = seikika(anglist)\\n    finalxy = []\\n    for i in range(n):\\n        if -pi / 2 -0.000001 <= anglist[i] <= pi / 2+0.000001:\\n            finalxy.append(xy[i])\\n    d.append(dist(finalxy))\\n\\nprint((max(d)))\\n\", \"import math\\n\\nn = int(input())\\nXY = [list(map(int,input().split())) for i in range(n)]\\n\\nXY.sort(key=lambda x: math.atan2(x[1],x[0]))\\nXY += XY\\n\\nans = 0\\nfor i in range(n):\\n    x = 0\\n    y = 0\\n    for j in range(n):\\n        nx,ny = XY[i+j]\\n        x += nx\\n        y += ny\\n        ans = max(ans,(x**2+y**2)**0.5)\\nprint(ans)\", \"from itertools import combinations\\nfrom cmath import phase\\n\\nN, *XY = map(int, open(0).read().split())\\n\\nXY = sorted((complex(x, y) for x, y in zip(*[iter(XY)] * 2)), key=phase)\\nXY += XY\\n\\n\\nans = 0\\nfor i, j in combinations(range(2 * N + 1), 2):\\n    if j - i <= N:\\n        ans = max(ans, abs(sum(XY[i:j])))\\n\\nprint(ans)\", \"import numpy as np\\nN = int(input())\\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\\nth = np.arctan2(XY[:,1],XY[:,0])\\nXY = XY[th.argsort()]\\nans = 0\\nn = np.linalg.norm\\ns = np.sum\\nfor i in range(N):\\n    for j in range(i+1,i+N+1):\\n        r = n(s(XY[i:j],axis=0)+s(XY[:max(0,j-N)],axis=0))\\n        ans = max(ans,r)\\nprint(ans)\", \"def f_engines():\\n    import math\\n    N = int(input())\\n    # 2\\u03c0\\u3092\\u307e\\u305f\\u3050\\u3088\\u3046\\u306a\\u30d9\\u30af\\u30c8\\u30eb\\u306e\\u9078\\u3073\\u65b9\\u3092\\u697d\\u306b\\u3059\\u308b\\u305f\\u3081\\u3001\\u8981\\u7d20\\u6570\\u30922\\u500d\\n    Engines = sorted([[int(i) for i in input().split()] for j in range(N)],\\n                     key=lambda x: math.atan2(x[1], x[0])) * 2\\n\\n    ans = 0\\n    for head in range(N):\\n        # \\u4ed6\\u306e\\u4eba\\u306e\\u63d0\\u51fa\\u306b\\u306f1\\u91cd\\u30eb\\u30fc\\u30d7\\u306e\\u3082\\u306e\\u3082\\u3042\\u308b\\u304c\\u3001\\u305d\\u308c\\u3067\\u3044\\u3044\\u7406\\u5c48\\u304c\\u308f\\u304b\\u3089\\u306a\\u3044\\n        for tail in range(head, head + N):\\n            x, y = 0, 0\\n            for i in range(head, tail + 1):\\n                dx, dy = Engines[i]\\n                x += dx\\n                y += dy\\n            ans = max(ans, x * x + y * y)\\n    return math.sqrt(ans)\\n\\nprint(f_engines())\", \"import numpy as np\\n\\nn = int(input())\\nx,y = np.array([list(map(int,input().split())) for _ in range(n)]).T\\n\\n# \\u5185\\u7a4d\\u304c0\\u4ee5\\u4e0a\\u304b\\u3069\\u3046\\u304b\\ndef isin90deg(v1, v2):\\n    if np.dot(v1, v2) >= 0 : return 1\\n    else: return 0\\n\\n# \\u5185\\u7a4d\\u304c0\\u304b\\u3069\\u3046\\u304b\\ndef is90deg(v1, v2):\\n    if np.dot(v1, v2) == 0 : return 1\\n    else: return 0\\n\\nans = []\\nfor i in range(n):\\n    # tangent-vector, normal-vector\\n    tv, nv1 = np.array([x[i],y[i]]), np.array([y[i],-x[i]])\\n    nv2 = - nv1\\n    # tv\\u304b\\u3089\\u6642\\u8a08\\u56de\\u308a180\\u5ea6\\u30a8\\u30ea\\u30a2\\u306b\\u304a\\u3051\\u308b\\u30d9\\u30af\\u30c8\\u30eb\\u548c\\u3092\\u8003\\u3048\\u308b\\n    # \\u305f\\u3060\\u3057\\u3001tv\\u306b\\u5e73\\u884c\\u306a\\u30d9\\u30af\\u30c8\\u30eb\\u7fa4\\uff08posi/nega\\uff09\\u3060\\u3051\\u4f8b\\u5916\\u51e6\\u7406\\n    for nv in [nv1, nv2]:\\n        sum,posi,nega = np.array([0,0]), np.array([0,0]), np.array([0,0])\\n        for j in range(n):\\n            v = np.array([x[j],y[j]])\\n            if isin90deg(v,nv): sum += v\\n            if is90deg(v,nv) and isin90deg(v,tv): posi += v\\n            if is90deg(v,nv) and not isin90deg(v,tv): nega += v\\n        # \\u30e6\\u30fc\\u30af\\u30ea\\u30c3\\u30c9\\u8ddd\\u96e2\\n        ans.append(np.linalg.norm(sum, ord=2))\\n        ans.append(np.linalg.norm(sum - posi, ord=2))\\n        ans.append(np.linalg.norm(sum - nega, ord=2))\\n\\nprint((max(ans)))\\n\\n\\n\", \"def solve():\\n    from math import atan2, degrees, hypot\\n    n = int(input())\\n    txy = []\\n    sx, sy = 0, 0\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        theta_0 = degrees(atan2(b, a))\\n        sx += a\\n        sy += b\\n        txy.append([theta_0, a, b])\\n    txy.sort()\\n    ans = hypot(sx, sy)\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            tx, ty = 0, 0\\n            for k in range(i, j):\\n                theta, x, y = txy[k]\\n                tx += x\\n                ty += y\\n                ans = max(ans, hypot(tx, ty))\\n                ans = max(ans, hypot(sx - tx, sy - ty))\\n    print(ans)\\n\\nsolve()\\n\", \"import math\\nN = int(input())\\nn = 1000\\n\\nx = [None] * N\\ny = [None] * N\\nfor i in range(N):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(n):\\n    theta = (2 * math.pi / n) * i\\n    c = math.cos(theta)\\n    s = math.sin(theta)\\n    tmp_x = 0\\n    tmp_y = 0\\n    for j in range(N):\\n        if x[j] * c + y[j] * s > 0:\\n            tmp_x += x[j]\\n            tmp_y += y[j]\\n    if tmp_x**2 + tmp_y**2 > ans**2:\\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\\n\\nprint(ans)\\n\", \"import math\\nN = int(input())\\nX = []\\nfor _ in range(N):\\n    x, y = list(map(int, input().split()))\\n    X.append((math.atan2(x, y), x, y))\\n\\nX = sorted(X) * 2\\nm = 0\\nfor i in range(N):\\n    sx = sy = 0\\n    for j in range(i, i + N):\\n        sx += X[j][1]; sy += X[j][2]\\n        d = sx ** 2 + sy ** 2\\n        m = max(m, d)\\n\\nprint((m**0.5))\\n\", \"import sys\\ninput = sys.stdin.readline\\nimport math\\n# \\u30ad\\u30e5\\u30fc(FIFO)\\nfrom collections import deque\\nfrom operator import itemgetter\\n\\n\\nN = int(input())\\nXY1 = []\\nXY2 = []\\nfor _ in range(N):\\n    x, y = map(int, input().split())\\n    theta = math.atan2(y, x)\\n    if y == 0 and x < 0:\\n        theta -= 2*math.pi\\n    if theta < 0:\\n        XY1.append((x, y, theta))\\n    else:\\n        XY2.append((x, y, theta))\\n\\nXY1.sort(key=itemgetter(2))\\nXY2.sort(key=itemgetter(2))\\n\\nq1 = deque()\\nq2 = deque()\\nfor xy1 in XY1:\\n    q1.append(xy1)\\nfor xy2 in XY2:\\n    q2.append(xy2)\\n\\nans = 0\\nfor _ in range(N+4):\\n    px, py = 0, 0\\n    mx, my = 0, 0\\n    for xy1 in q1:\\n        px += xy1[0]\\n        py += xy1[1]\\n    for xy2 in q2:\\n        mx += xy2[0]\\n        my += xy2[1]\\n    dp = math.sqrt(px**2+py**2)\\n    if dp > ans:\\n        ans = dp\\n    dm = math.sqrt(mx**2+my**2)\\n    if dm > ans:\\n        ans = dm\\n    \\n    if len(q1) == 0:\\n        xy2 = q2.popleft()\\n        q1.append(xy2)\\n    elif len(q2) == 0:\\n        xy1 = q1.popleft()\\n        q2.append(xy1)\\n    else:\\n        xy1 = q1[0]\\n        xy2 = q2[0]\\n        theta1 = xy1[2]\\n        theta2 = xy2[2]\\n        if theta1 + math.pi < theta2:\\n            q1.popleft()\\n            q2.append((xy1[0], xy1[1], theta1+2*math.pi))\\n        else:\\n            q2.popleft()\\n            q1.append((xy2[0], xy2[1], theta2))\\n\\nprint(ans)\", \"import math\\nn = int(input())\\na = [list(map(int,input().split())) for _ in range(n)]\\nans = 0\\nfor x in range(-20,21):\\n    for y in range(-20,21):\\n        sx = 0\\n        sy = 0\\n        for v in a:\\n            if v[0]*x+v[1]*y>0:\\n                sx+=v[0]\\n                sy+=v[1]\\n        ans = max(ans,math.sqrt(sx*sx+sy*sy))\\nprint(ans)\", \"from math import hypot\\n\\nN = int(input())\\nengines = [tuple(map(int, input().split())) for _ in range(N)]\\n\\ndef dot(x1, y1, x2, y2):\\n    return x1*x2 + y1*y2\\ndef cross(x1, y1, x2, y2):\\n    return x1*y2 - y1*x2\\n\\ndef getDistMax(xBase, yBase):\\n    x1s, y1s, x2s, y2s = [], [], [], []\\n    x, y = 0, 0\\n    for dx, dy in engines:\\n        d = dot(xBase, yBase, dx, dy)\\n        if d > 0:\\n            x, y = x+dx, y+dy\\n        elif d == 0:\\n            c = cross(xBase, yBase, dx, dy)\\n            if c > 0:\\n                x1s.append(dx)\\n                y1s.append(dy)\\n            else:\\n                x2s.append(dx)\\n                y2s.append(dy)\\n    ans = max(hypot(x, y), hypot(x+sum(x1s), y+sum(y1s)), hypot(x+sum(x2s), y+sum(y2s)))\\n    return ans\\n\\nans = 0\\nfor x, y in engines:\\n    ds = []\\n    ds.append(getDistMax( x,  y))\\n    ds.append(getDistMax(-y,  x))\\n    ds.append(getDistMax(-x, -y))\\n    ds.append(getDistMax( y, -x))\\n    ans = max(ans, max(ds))\\n\\nprint(ans)\\n\", \"from math import atan2\\nn = int(input())\\nl = [list(map(int, input().split())) for _ in range(n)]\\nl.sort(key=lambda x: atan2(x[1], x[0]))\\nans = 0\\nfor lp in range(n):\\n    for rg in range(n):\\n        lf = lp\\n        x, y = l[lf]\\n        lf += 1\\n        if lf == n:\\n            lf = 0\\n        while lf != rg:\\n            x += l[lf][0]\\n            y += l[lf][1]\\n            lf += 1\\n            if lf == n:\\n                lf = 0\\n        ans = max(ans, (x ** 2 + y ** 2) ** .5)\\nprint(ans)\\n\", \"import math\\n\\nN = int(input())\\nV = []\\nfor _ in range(N):\\n    V.append([ int(n) for n in input().split() ])\\n\\nR2 = 0\\nfor i in range(100):\\n    theta = 2*math.pi * i / 100\\n    a, b = math.cos(theta), math.sin(theta)\\n    X, Y = 0, 0\\n    for x, y in V:\\n        if a*x+b*y > 0:\\n            X += x\\n            Y += y\\n    r2 = X**2+Y**2\\n    if r2 > R2:\\n        R2 = r2\\n\\nprint(math.sqrt(R2))\", \"import numpy as np\\n\\nN = int(input())\\nXY =  np.array([list(map(int,input().split())) for _ in [0]*N])\\n\\nans = 0\\nfor m in range(100):\\n    th = 2*np.pi*m/100\\n    r = np.array([np.cos(th),np.sin(th)])\\n    check = XY.dot(r)>=0\\n    ans = max(ans,np.linalg.norm(np.sum(XY[check],axis=0)))\\nprint(ans)\\n\", \"import math\\nN = int(input())\\nn = 72\\n\\nx = [None] * N\\ny = [None] * N\\nfor i in range(N):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(n):\\n    theta = (2 * math.pi / n) * i\\n    c = math.cos(theta)\\n    s = math.sin(theta)\\n    tmp_x = 0\\n    tmp_y = 0\\n    for j in range(N):\\n        if x[j] * c + y[j] * s > 0:\\n            tmp_x += x[j]\\n            tmp_y += y[j]\\n    if tmp_x**2 + tmp_y**2 > ans**2:\\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\\n\\nprint(ans)\\n\", \"import math\\nimport os\\nimport sys\\n\\nif os.getenv(\\\"LOCAL\\\"):\\n    sys.stdin = open(\\\"_in.txt\\\", \\\"r\\\")\\n\\nsys.setrecursionlimit(2147483647)\\nINF = float(\\\"inf\\\")\\nIINF = 10 ** 18\\nMOD = 10 ** 9 + 7\\n\\nN = int(sys.stdin.readline())\\nXY = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\\n\\n\\ndef calc(bx, by):\\n    base = math.atan2(bx, by)\\n\\n    d1 = []\\n    d2 = []\\n    for x, y in XY:\\n        deg = (math.atan2(x, y) - base) % (math.pi * 2)\\n        if deg < math.pi:\\n            d1.append((x, y))\\n        else:\\n            d2.append((x, y))\\n\\n    x1 = 0\\n    y1 = 0\\n    x2 = 0\\n    y2 = 0\\n    for x, y in d1:\\n        x1 += x\\n        y1 += y\\n    for x, y in d2:\\n        x2 += x\\n        y2 += y\\n\\n    return max(math.sqrt(x1 ** 2 + y1 ** 2), math.sqrt(x2 ** 2 + y2 ** 2))\\n\\n\\nans = 0\\nfor x, y in XY:\\n    ans = max(ans, calc(x, y))\\nprint(ans)\\n\", \"import cmath\\n\\nN = int(input())\\nXY = []\\nfor _ in range(N):\\n    x, y = list(map(int, input().split()))\\n    XY.append(x + y * 1j)\\n\\nXY.sort(key=lambda x: cmath.phase(x))\\n\\nans = 0\\nfor i in range(N):\\n    for j in range(N):\\n        if i <= j:\\n            ans = max(ans, abs(sum(XY[i:j + 1])))\\n        elif i > j:\\n            ans = max(ans, abs(sum(XY[:j + 1] + XY[i:])))\\n\\nprint(ans)\\n\", \"from math import sqrt\\nn = int(input())\\nclass Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n        return\\n    def __lt__(self, p2):\\n        return self.quadrant() < p2.quadrant() or self.quadrant() == p2.quadrant() and self.x * p2.y - self.y * p2.x > 0\\n    def __repr__(self):\\n        return repr((self.x, self.y))\\n    def __add__(self, p2):\\n        return Point(self.x+p2.x, self.y+p2.y)\\n    def __sub__(self, p2):\\n        return Point(self.x-p2.x, self.y-p2.y)\\n    def quadrant(self):\\n        if self.x > 0 and self.y >= 0:\\n            return 1\\n        elif self.y > 0:\\n            return 2\\n        elif self.x < 0:\\n            return 3\\n        else:\\n            return 4\\n    def square(self):\\n        return self.x ** 2 + self.y ** 2\\n\\nxy = [Point(xi, yi) for xi, yi in (list(map(int, input().split())) for _ in range(n)) if not xi == yi == 0]\\n\\n\\ncur_point = sum((p for p in xy if p.y > 0 or p.y == 0 and p.x >= 0), Point(0, 0))\\n\\ninv = list(Point(-p.x, -p.y) for p in xy)\\nxy.extend(inv)\\nxy.sort()\\n\\nmx = cur_point.square()\\nfor p in xy:\\n    cur_point -= p\\n    mx = max(mx, cur_point.square())\\n\\nprint((sqrt(mx)))\\n\", \"from math import atan2, sqrt\\n\\ndef main():\\n    n = int(input())\\n    engines = [list(map(int, input().split())) for _ in range(n)]\\n    for i in range(n):\\n        rad = atan2(engines[i][1], engines[i][0])\\n        engines[i].append(rad)\\n    engines.sort(key=lambda x: x[2])\\n    ans = 0\\n    for k in range(1, n+1):\\n        for i in range(n):\\n            x_sum, y_sum = 0, 0\\n            for j in range(i, i+k):\\n                p = j%n\\n                x_sum += engines[p][0]\\n                y_sum += engines[p][1]\\n            tmp = x_sum**2 + y_sum**2\\n            if ans < tmp:\\n                ans = tmp\\n    print(sqrt(ans))\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\", \"import sys\\nfrom itertools import accumulate, combinations\\nfrom math import atan2\\nread = sys.stdin.read\\n\\nN, *xy = map(int, read().split())\\nxy = sorted(zip(*[iter(xy)] * 2), key=lambda x: atan2(x[1], x[0]))\\nxy = [(0, 0)] + xy\\n\\nxy *= 2\\nxy = list(zip(*map(list, map(accumulate, zip(*xy)))))\\nanswer = 0\\n\\nfor i, j in combinations(range(2 * N + 2), 2):\\n    if j - i <= N:\\n        x1, y1 = xy[i]\\n        x2, y2 = xy[j]\\n        candidate = (x1 - x2) ** 2 + (y1 - y2) ** 2\\n        if candidate > answer:\\n            answer = candidate\\n\\nprint(answer ** 0.5)\", \"# Engines\\nimport cmath\\nimport math\\nN = int(input())\\nEngines = []\\nans = 0\\n\\nsumx, sumy = 0, 0\\nfor _ in range(N):\\n    x, y = map(int, input().split())\\n    z = complex(x, y)\\n    arg_deg = cmath.phase(z)\\n    sumx += x\\n    sumy += y\\n    Engines.append((arg_deg, x, y))\\nans = max(ans, math.hypot(sumx, sumy))\\nEngines.sort()\\nfor i in range(N):\\n    for j in range(i, N):\\n        sub_x = 0\\n        sub_y = 0\\n        for k in range(i, j+1):\\n            deg, dx, dy = Engines[k]\\n            sub_x += dx\\n            sub_y += dy\\n        ans = max(ans, math.hypot(sub_x, sub_y))\\n        ans = max(ans, math.hypot(sumx-sub_x, sumy-sub_y))\\nprint(ans)\", \"import math\\n\\nn = int(input())\\nP = []\\n#very small \\u3067WA\\u306a\\u306e\\u3067\\u3001r\\u3067\\u5272\\u3063\\u3066\\u304b\\u3051\\u76f4\\u3059\\u306e\\u3092\\u3084\\u3081\\u3066\\u307f\\u308b\\n#atan\\u3092\\u4f7f\\u3063\\u3066\\u307f\\u308b\\n#0\\u307e\\u305f\\u3044\\u3060\\u3068\\u304d\\u304c\\u304a\\u304b\\u3057\\u3044\\u304b\\nfor i in range(n):\\n    x, y = list(map(int, input().split( )))\\n    rad = math.atan2(x, y)\\n    P.append([rad, x, y])\\n\\nP.sort()\\nP = P + P \\n\\n\\nx0 = 0\\ny0 = 0\\n\\nmx = 0\\n\\nfor i in range(n):\\n    vx = 0\\n    vy = 0\\n    for j in range(n):\\n        vx += P[i+j][1]\\n        vy += P[i+j][2]\\n        v = vx**2 + vy**2\\n        mx = max(v,mx)\\nprint((math.sqrt(mx)))\\n\", \"from math import atan2, pi, sqrt\\nn = int(input())\\np = []\\nxa = ya = 0\\nfor i in range(n):\\n    x, y = list(map(int, input().split()))\\n    angle = atan2(y, x)\\n    p.append((x, y, angle))\\n    p.append((x, y, angle + 2 * pi))\\n    xa += x\\n    ya += y\\n\\np.sort(key=lambda x: x[2])\\n\\nr = 0\\nans = 0\\nxs = ys = 0\\nfor l in range(n):\\n    while p[r][2] < p[l][2] + pi:\\n        xs += p[r][0]\\n        ys += p[r][1]\\n        r += 1\\n\\n    ans = max(ans, sqrt(xs**2 + ys**2), sqrt((xa - xs)**2 + (ya - ys)**2))\\n\\n    xs -= p[l][0]\\n    ys -= p[l][1]\\n\\nprint(ans)\\n\", \"#\\u89e3\\u8aac\\u89e3\\u6cd5\\nn = int(input())\\nxp = []\\nxm = []\\nyp = []\\nym = []\\nfor _ in range(n):\\n  x,y = map(int,input().split())\\n  if x == 0:\\n    if y == 0:\\n      n -= 1\\n    elif y > 0:\\n      yp.append([0,x,y])\\n    else:\\n      ym.append([0,x,y])\\n  elif x > 0:\\n    xp.append([y/x,x,y])\\n  else:\\n    xm.append([y/x,x,y])\\nxp.sort()\\nxm.sort()\\nxy = xp + yp + xm + ym\\ncan = []\\nfor i in range(-n,0):\\n  for j in range(i+1,i+n+1):\\n    X = 0\\n    Y = 0\\n    for k in range(i,j):\\n      x,y = xy[k][1],xy[k][2]\\n      X += x\\n      Y += y\\n    can.append(X**2+Y**2)\\nif n == 0:\\n  print(0)\\nelse:\\n  print(max(can)**.5)\", \"from math import atan2\\nn=int(input())\\nl=[list(map(int,input().split())) for i in range(n)]\\nl.sort(key=lambda x:atan2(x[1],x[0]))\\nans=0\\nfor i in range(n):\\n    x,y=0,0\\n    for j in range(n):\\n        x1,y1=l[(i+j)%n]\\n        x+=x1\\n        y+=y1\\n        ans=max(x**2+y**2,ans)\\nprint(ans**0.5)\", \"import sys\\nfrom math import atan2, pi\\n\\nn = int(input())\\nangles = []\\nengines = []\\npi2 = 2 * pi\\nfor i, line in enumerate(sys.stdin):\\n    x, y = list(map(int, line.split()))\\n    angle = atan2(y, x)\\n    angles.append((angle, i))  # -pi~pi\\n    angles.append((angle + pi2, i))  # pi~3pi\\n    engines.append(x + y * 1j)\\nangles.sort()\\n\\nr = 0\\ntmp = 0\\ntotal = sum(engines)\\nans = 0\\nfor l in range(n):\\n    angle, i = angles[l]\\n    limit = angle + pi\\n    while angles[r][0] < limit:\\n        tmp += engines[angles[r][1]]\\n        r += 1\\n    ans = max(ans, abs(tmp), abs(total - tmp))\\n    tmp -= engines[i]\\nprint(ans)\\n\", \"import math\\n \\nN = int(input())\\nV = []\\nfor _ in range(N):\\n    V.append([ int(n) for n in input().split() ])\\n \\nR2 = 0\\nfor i in range(100): \\n    theta = 2 * math.pi * i / 100  \\n    a, b = math.cos(theta), math.sin(theta)  ### a=cos\\u03b8\\u3001b=sin\\u03b8\\u3000\\uff08\\u03b8=2\\u03c0*i/100\\uff09 \\n    X, Y = 0, 0\\n    for x, y in V: ### xi \\u3068 yi \\u3092\\u53d6\\u308a\\u51fa\\u3059\\n        if a*x+b*y > 0: ### \\u6b63\\u306e\\u6570\\u306a\\u3089\\u3070\\n            X += x\\n            Y += y\\n    r2 = X**2+Y**2\\n    if r2 > R2:\\n        R2 = r2\\n \\nprint(math.sqrt(R2))\", \"import numpy as np\\nN = int(input())\\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\\nth = np.arctan2(XY[:,1],XY[:,0])\\nXY = XY[th.argsort()]\\nans = 0\\nn = np.linalg.norm\\nSxy = np.vstack((np.zeros(2),np.cumsum(XY,axis=0)))\\ni=0\\nj=1\\npr = 0\\nwhile i<N:\\n        r = n(Sxy[min(j,N)]-Sxy[i] + Sxy[max(0,j-N)])\\n        if r>=pr and j<i+N+1 : j+=1\\n        else:\\n            i += 1\\n            j = max(j-1,i+1)\\n            r = 0\\n        ans = max(ans,r)\\n        pr = r\\nprint(ans)\", \"from math import hypot,atan2\\nN = int(input())\\nXY = [tuple(map(int,input().split())) for i in range(N)]\\nxy = sorted(XY, key=lambda x:atan2(x[1],x[0]))\\nxy += xy\\n\\nans = 0\\nfor i in range(N):\\n    sx = sy = 0\\n    for j in range(N):\\n        x,y = xy[i+j]\\n        sx += x\\n        sy += y\\n        d = hypot(sx,sy)\\n        if d > ans:\\n            ans = d\\nprint(ans)\", \"#\\u89e3\\u8aac\\u89e3\\u6cd5\\nn = int(input())\\nxp = []\\nxm = []\\nyp = []\\nym = []\\nfor _ in range(n):\\n  x,y = map(int,input().split())\\n  if x == 0:\\n    if y == 0:\\n      n -= 1\\n    elif y > 0:\\n      yp.append([0,x,y])\\n    else:\\n      ym.append([0,x,y])\\n  elif x > 0:\\n    xp.append([y/x,x,y])\\n  else:\\n    xm.append([y/x,x,y])\\nxp.sort()\\nxm.sort()\\nxy = xp + yp + xm + ym\\ncan = []\\nfor i in range(-n,0):\\n  X = 0\\n  Y = 0\\n  for j in range(i+1,i+n+1):\\n    x,y = xy[j][1],xy[j][2]\\n    X += x\\n    Y += y\\n    can.append(X**2+Y**2)\\nif n == 0:\\n  print(0)\\nelse:\\n  print(max(can)**.5)\", \"import math\\nN = int(input())\\nn = 60\\n\\nx = [None] * N\\ny = [None] * N\\nfor i in range(N):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(n):\\n    theta = (2 * math.pi / n) * i\\n    c = math.cos(theta)\\n    s = math.sin(theta)\\n    tmp_x = 0\\n    tmp_y = 0\\n    for j in range(N):\\n        if x[j] * c + y[j] * s > 0:\\n            tmp_x += x[j]\\n            tmp_y += y[j]\\n    if tmp_x**2 + tmp_y**2 > ans**2:\\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\\n\\nprint(ans)\\n\", \"import math\\nN = int(input())\\nX = []\\nfor _ in range(N):\\n    x, y = list(map(int, input().split()))\\n    X.append((math.atan2(y, x), x, y))\\n\\nX = sorted(X) * 2\\nma = 0\\nfor i in range(N):\\n    sx = sy = 0\\n    for j in range(i, i + N):\\n        sx += X[j][1]; sy += X[j][2]\\n        d = sx ** 2 + sy ** 2\\n        ma = max(ma, d)\\n\\nprint((ma**0.5))\\n\", \"from math import*\\ndef main():\\n\\n    n = int(input())\\n    ab = [list(map(int, input().split())) for _ in [0]*n]\\n    k = 10000\\n    ans2 = 0\\n    for i in range(k):\\n        t = 2*i*pi/k\\n        s = sin(t)\\n        c = cos(t)\\n        ans = [0, 0]\\n        for a, b in ab:\\n            if a*s+b*c >= 0:\\n                ans[0] += a\\n                ans[1] += b\\n        ans2 = max(ans2, ans[0]**2+ans[1]**2)\\n    print((ans2**0.5))\\n\\n\\nmain()\\n\", \"def solve():\\n    from math import atan2, pi, hypot\\n    n = int(input())\\n    txy = []\\n    sx, sy = 0, 0\\n    for i in range(n):\\n        a, b = list(map(int, input().split()))\\n        theta_0 = atan2(b, a)\\n        sx += a\\n        sy += b\\n        txy.append((theta_0, a, b))\\n    txy.sort()\\n    ans = hypot(sx, sy)\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            tx, ty = 0, 0\\n            for k in range(i, j):\\n                theta, x, y = txy[k]\\n                tx += x\\n                ty += y\\n                ans = max(ans, hypot(tx, ty))\\n                ans = max(ans, hypot(sx - tx, sy - ty))\\n    print(ans)\\n\\nsolve()\\n\", \"import math\\n\\nn = int(input())\\nxy = [list(map(int, input().split())) for i in range(n)]\\nargs = sorted([(math.atan2(y,x),x,y) for x,y in xy])\\nans = 0\\nfor key,(sarg,sx,sy) in enumerate(args):\\n  tmpx,tmpy = sx,sy\\n  dist = tmpx**2 + tmpy**2\\n  for arg,x,y in args[key+1:]:\\n    tmpx += x\\n    tmpy += y\\n    tmp = tmpx**2 + tmpy**2\\n    if tmp < dist:\\n      break\\n    else:\\n      dist = tmp\\n  for arg,x,y in args[:key]:\\n    tmpx += x\\n    tmpy += y\\n    tmp = tmpx**2 + tmpy**2\\n    if tmp < dist:\\n      break\\n    else:\\n      dist = tmp\\n  ans = max(ans,dist)\\nprint(math.sqrt(ans))\", \"import numpy as np\\nN = int(input())\\nXY = np.array([list(map(int,input().split())) for _ in [0]*N])\\nth = np.arctan2(XY[:,1],XY[:,0])\\nXY = XY[th.argsort()]\\nans = 0\\nn = np.linalg.norm\\nfor i in range(N):\\n    for j in range(i+1,i+N+1):\\n        r = n(XY[i:j].sum(axis=0)+XY[:max(0,j-N)].sum(axis=0))\\n        ans = max(ans,r)\\nprint(ans)\", \"import math\\nN = int(input())\\nX = []\\nfor _ in range(N):\\n    x, y = map(int, input().split())\\n    X.append((math.atan2(x, y), x, y))\\n\\nX = sorted(X) * 2\\nma = 0\\nfor i in range(N):\\n    sx = sy = 0\\n    for j in range(i, i + N):\\n        sx += X[j][1]; sy += X[j][2]\\n        d = sx ** 2 + sy ** 2\\n        ma = max(ma, d)\\n\\nprint(ma**0.5)\", \"import math\\nN = int(input())\\nn = 100\\n\\nx = [None] * N\\ny = [None] * N\\nfor i in range(N):\\n    x[i], y[i] = list(map(int, input().split()))\\n\\nans = 0\\nfor i in range(n):\\n    theta = (2 * math.pi / n) * i\\n    c = math.cos(theta)\\n    s = math.sin(theta)\\n    tmp_x = 0\\n    tmp_y = 0\\n    for j in range(N):\\n        if x[j] * c + y[j] * s > 0:\\n            tmp_x += x[j]\\n            tmp_y += y[j]\\n    if tmp_x**2 + tmp_y**2 > ans**2:\\n        ans = math.sqrt(tmp_x**2 + tmp_y**2)\\n\\nprint(ans)\\n\", \"import math\\nN = int(input())\\nxy = []\\nfor i in range(N):\\n  x, y = map(int, input().split())\\n  xy += [(x, y, math.atan2(y,x))]\\nxy.sort(key=lambda val:val[2])\\nx_accum = [0]\\ny_accum = [0]\\nfor i in range(N):\\n  x_accum += [x_accum[-1] + xy[i][0]]\\n  y_accum += [y_accum[-1] + xy[i][1]]\\n  \\nans = 0\\nfor i in range(N+1):\\n  for j in range(i,N+1):\\n    ans = max(ans,  math.hypot(x_accum[j]-x_accum[i] ,y_accum[j]-y_accum[i]))\\n    ans = max(ans,  math.hypot(x_accum[-1] -x_accum[j]+x_accum[i] ,y_accum[-1]-y_accum[j]+y_accum[i]))\\nprint(ans)\"]",
  "input_output": "{\"inputs\": [\"3\\n0 10\\n5 -5\\n-5 -5\\n\", \"5\\n1 1\\n1 0\\n0 1\\n-1 0\\n0 -1\\n\", \"5\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\", \"3\\n0 0\\n0 1\\n1 0\\n\", \"1\\n90447 91000\\n\", \"2\\n96000 -72000\\n-72000 54000\\n\", \"10\\n1 2\\n3 4\\n5 6\\n7 8\\n9 10\\n11 12\\n13 14\\n15 16\\n17 18\\n19 20\\n\", \"10\\n1 0\\n0 -1\\n1 1\\n-1 0\\n-1 0\\n-1 0\\n1 -1\\n-1 -1\\n1 1\\n0 1\\n\", \"91\\n-1 0\\n-1 1\\n0 -1\\n-1 1\\n1 1\\n1 1\\n0 0\\n-1 0\\n-1 0\\n1 1\\n1 0\\n0 1\\n0 0\\n1 -1\\n0 1\\n0 0\\n-1 -1\\n-1 -1\\n0 1\\n1 -1\\n1 1\\n-1 -1\\n1 0\\n1 1\\n-1 -1\\n1 1\\n0 0\\n0 0\\n-1 1\\n0 -1\\n1 -1\\n1 -1\\n1 0\\n1 0\\n0 -1\\n0 -1\\n-1 -1\\n-1 -1\\n-1 1\\n0 -1\\n1 0\\n-1 1\\n-1 -1\\n1 0\\n0 1\\n1 -1\\n-1 0\\n0 0\\n0 -1\\n-1 0\\n0 -1\\n1 0\\n-1 1\\n0 -1\\n1 0\\n0 -1\\n-1 1\\n0 0\\n-1 1\\n0 0\\n1 0\\n-1 0\\n-1 1\\n1 1\\n-1 -1\\n1 1\\n0 0\\n1 -1\\n1 0\\n-1 0\\n-1 -1\\n-1 0\\n-1 1\\n-1 0\\n-1 0\\n1 1\\n1 -1\\n1 0\\n1 1\\n1 1\\n1 1\\n1 -1\\n-1 0\\n1 -1\\n0 1\\n1 1\\n-1 1\\n1 0\\n0 0\\n-1 -1\\n1 0\\n\", \"100\\n0 0\\n0 -1\\n0 -1\\n1 0\\n-1 0\\n0 0\\n0 1\\n-1 -1\\n1 1\\n0 1\\n0 1\\n1 -1\\n1 1\\n-1 -1\\n0 -1\\n0 0\\n0 0\\n0 -1\\n1 1\\n0 1\\n0 0\\n0 0\\n-1 -1\\n-1 -1\\n1 -1\\n-1 1\\n1 -1\\n1 1\\n1 0\\n-1 0\\n-1 1\\n-1 1\\n1 -1\\n1 -1\\n-1 0\\n1 0\\n1 1\\n-1 -1\\n1 0\\n0 0\\n0 1\\n-1 -1\\n1 0\\n1 0\\n-1 0\\n-1 1\\n1 -1\\n-1 1\\n1 0\\n-1 1\\n-1 1\\n1 -1\\n0 0\\n1 0\\n1 1\\n0 1\\n1 0\\n0 1\\n0 1\\n1 -1\\n0 0\\n0 1\\n1 0\\n0 -1\\n-1 0\\n1 0\\n-1 1\\n0 -1\\n0 1\\n0 -1\\n1 0\\n0 -1\\n0 1\\n1 0\\n1 -1\\n1 -1\\n-1 -1\\n1 -1\\n1 -1\\n1 -1\\n1 1\\n0 -1\\n0 0\\n1 -1\\n0 1\\n-1 1\\n-1 0\\n1 -1\\n-1 1\\n-1 -1\\n-1 1\\n1 -1\\n0 -1\\n-1 -1\\n1 1\\n-1 0\\n-1 1\\n1 0\\n-1 1\\n1 0\\n\", \"10\\n0 0\\n-5 7\\n0 0\\n-13 4\\n-6 6\\n5 8\\n-1 -8\\n14 5\\n4 9\\n8 7\\n\", \"94\\n-12 -3\\n10 -15\\n-5 -14\\n-6 -1\\n-2 3\\n-15 12\\n12 -9\\n-2 -12\\n-13 8\\n-12 14\\n-15 11\\n3 11\\n-9 0\\n1 -8\\n-5 -6\\n-8 10\\n-3 -13\\n0 -15\\n-3 -12\\n6 -14\\n-11 4\\n-8 15\\n14 -8\\n-5 -5\\n-11 3\\n13 2\\n5 7\\n15 -7\\n4 -3\\n4 9\\n-13 3\\n-14 3\\n4 9\\n9 14\\n-11 11\\n-4 -14\\n15 -12\\n-7 10\\n-9 -7\\n1 -12\\n-6 -6\\n11 5\\n-9 7\\n10 -8\\n1 -2\\n1 -5\\n4 5\\n-15 -1\\n-3 5\\n9 0\\n-8 -12\\n-3 -7\\n15 14\\n-1 -5\\n-3 9\\n-6 7\\n-1 3\\n-2 8\\n9 1\\n-15 1\\n14 -9\\n-2 -15\\n12 -2\\n-15 1\\n6 5\\n-6 1\\n-2 -7\\n-13 -7\\n1 3\\n13 8\\n-7 9\\n-9 -6\\n14 -1\\n6 14\\n-9 13\\n-7 6\\n-14 -1\\n-6 0\\n0 12\\n-15 9\\n8 8\\n0 10\\n-13 1\\n8 7\\n15 11\\n-4 -3\\n-5 10\\n-7 15\\n-11 8\\n-15 12\\n-12 -13\\n0 1\\n10 5\\n-5 11\\n\", \"100\\n-13 2\\n0 0\\n-15 13\\n-6 0\\n2 2\\n10 -13\\n15 -12\\n-2 2\\n-5 -14\\n-2 1\\n8 13\\n-1 13\\n-14 -2\\n-5 -11\\n-12 -2\\n-10 12\\n14 -9\\n-7 -13\\n-14 7\\n3 1\\n-8 3\\n-3 -3\\n8 0\\n5 4\\n-7 -9\\n-7 1\\n2 2\\n-2 -14\\n-2 4\\n0 -2\\n3 13\\n-4 -13\\n-4 -9\\n3 -12\\n9 -9\\n15 -14\\n15 -3\\n11 0\\n11 -14\\n2 -4\\n-8 -8\\n-12 0\\n-9 15\\n-1 15\\n-4 7\\n-2 10\\n13 -7\\n-3 15\\n1 4\\n15 13\\n9 -5\\n1 -9\\n9 -14\\n4 12\\n-13 9\\n5 10\\n13 2\\n-9 2\\n-7 13\\n-1 -10\\n2 -13\\n5 3\\n-11 -2\\n9 -1\\n11 7\\n15 2\\n15 -9\\n11 9\\n5 -2\\n-9 1\\n10 -15\\n-11 -10\\n-6 -5\\n-10 -9\\n1 -6\\n-9 -13\\n14 -11\\n7 -11\\n-15 -6\\n15 -2\\n-14 -9\\n12 4\\n11 -12\\n-4 -9\\n8 -1\\n-4 -6\\n-4 12\\n-15 -9\\n1 -14\\n6 -8\\n-3 11\\n-11 -9\\n1 0\\n4 6\\n9 13\\n0 -9\\n14 10\\n13 -12\\n-11 -10\\n-11 4\\n\", \"10\\n0 0\\n-695640 383072\\n-639436 -350815\\n766188 -825681\\n-825158 -972852\\n-600675 301738\\n-455417 -353299\\n642193 -516901\\n-840015 938151\\n-162948 4401\\n\", \"97\\n0 0\\n-628814 788981\\n449497 -614352\\n-722726 543829\\n629242 742280\\n180389 -298182\\n-50328 -449177\\n-391161 991246\\n-884476 628553\\n-273571 348092\\n66262 855149\\n-211626 187581\\n309740 396482\\n68488 -622089\\n359213 666441\\n553716 661936\\n-563360 -331285\\n-855448 -448402\\n-710445 873295\\n773064 -628028\\n108170 498826\\n181042 164387\\n-477299 -353876\\n-133330 -223939\\n-176225 367112\\n713645 -322840\\n-733523 -827478\\n-536632 -469247\\n-708766 -5571\\n-857357 -156573\\n-666891 -307663\\n-541675 -268492\\n-876123 -916231\\n277105 291214\\n19765 -625375\\n226105 541309\\n-809172 -315443\\n17429 -238730\\n364338 -432608\\n-576574 -119917\\n404368 -852002\\n784572 569404\\n-107393 798320\\n-650924 -217284\\n506100 455229\\n-134119 -804191\\n117287 452058\\n439816 883761\\n327831 574527\\n-511925 -423561\\n-661476 125085\\n75420 177610\\n276763 -492677\\n337806 -289576\\n304378 584372\\n-48285 -415125\\n-280804 -488235\\n35218 -816385\\n978684 33764\\n39407 -717493\\n16998 -366373\\n254077 -362242\\n-62254 -465005\\n541456 752742\\n-266817 -204391\\n-330596 91937\\n545865 -376615\\n774399 502674\\n-128127 916867\\n-694798 74989\\n-37075 -669881\\n480612 -457785\\n-431542 35542\\n547924 -686478\\n973294 743338\\n234113 -784301\\n388726 997830\\n-668642 666098\\n11207 -527702\\n-470037 457788\\n836224 -135034\\n374451 488210\\n-910257 -897161\\n-916524 853241\\n-143709 -347054\\n-781840 -775737\\n298380 983636\\n-72427 -24275\\n492853 -614188\\n279611 626700\\n-25329 -782159\\n587722 -233243\\n-851734 -645286\\n914469 830545\\n762824 265497\\n-45830 4712\\n439418 884850\\n\", \"100\\n0 0\\n574501 913529\\n-891332 -490063\\n-328235 181082\\n-745920 -419669\\n307694 669839\\n652520 -682004\\n483077 -217376\\n997010 -524488\\n540323 158157\\n225205 763441\\n-734942 -610285\\n-158333 -996661\\n384506 138683\\n498215 -441781\\n713506 -724244\\n-190826 -285959\\n-249944 -412128\\n-490345 -741313\\n-577283 561978\\n-793452 -6715\\n-987217 983820\\n-108981 259379\\n-729662 -559841\\n-659461 518541\\n-152876 -114874\\n23296 202924\\n-715222 -587854\\n649266 961859\\n-381857 -84050\\n-866404 -886175\\n767581 38368\\n484091 239011\\n-916344 243908\\n-489641 -545054\\n-149556 432789\\n-8349 -197879\\n817186 547056\\n847757 -754949\\n224033 -434292\\n57189 -608840\\n-411218 -89971\\n968277 -941992\\n-435938 138588\\n751200 413199\\n-123827 714482\\n-589174 148238\\n-423192 619188\\n-777678 280938\\n-726562 -8244\\n-847159 -417637\\n580971 436376\\n-603023 766740\\n-612140 -90446\\n-23039 644887\\n351941 -312746\\n-308413 995452\\n-808906 816398\\n729771 -921103\\n219010 833144\\n402325 531835\\n-117779 505178\\n-891478 693659\\n911982 403192\\n-385344 382839\\n-598189 -972241\\n-451888 -949436\\n537 611967\\n29662 -475950\\n-324282 -50647\\n782331 -655507\\n653404 -236070\\n-758586 786772\\n-583061 667530\\n-10133 92290\\n-447045 -7778\\n575212 155688\\n430066 -233766\\n173668 -744815\\n736742 288098\\n56480 1156\\n426594 -31244\\n663871 495230\\n-826913 727851\\n448796 -29464\\n-84503 432870\\n2643 -57540\\n127702 267501\\n-915316 -937312\\n90647 987983\\n148283 -808294\\n39062 -31415\\n-104733 -735131\\n876612 950089\\n-986792 688987\\n296810 690101\\n377383 904886\\n688837 396297\\n96152 700341\\n-328414 -523395\\n\", \"95\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\", \"41\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n784703 -347761\\n\", \"100\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n249448 761604\\n\", \"13\\n547896 -610830\\n419136 -467280\\n269064 -299970\\n488400 -544500\\n133200 -148500\\n424464 -473220\\n76368 -85140\\n848928 -946440\\n747696 -833580\\n162504 -181170\\n-743256 828630\\n-13320 14850\\n-31080 34650\\n\", \"46\\n111379 24511\\n281517 61953\\n-981363 -215967\\n313089 68901\\n46481 10229\\n391142 86078\\n152598 33582\\n-898048 -197632\\n-394650 -86850\\n237667 52303\\n-400789 -88201\\n961192 211528\\n-950668 -209212\\n426222 93798\\n-463933 -102097\\n-44727 -9843\\n632317 139153\\n-20171 -4439\\n-858583 -188947\\n692830 152470\\n-482350 -106150\\n-830519 -182771\\n-884893 -194737\\n239421 52689\\n-581451 -127959\\n111379 24511\\n-435869 -95921\\n-933128 -205352\\n8770 1930\\n747204 164436\\n-602499 -132591\\n-738434 -162506\\n-616531 -135679\\n-149090 -32810\\n-295549 -65041\\n-864722 -190298\\n-446393 -98237\\n353431 77779\\n-626178 -137802\\n-882262 -194158\\n-875246 -192614\\n411313 90517\\n-775268 -170612\\n-598114 -131626\\n-64021 -14089\\n-621793 -136837\\n\", \"100\\n-88618 74812\\n-540720 456480\\n-899698 759532\\n-212533 179422\\n921477 -777918\\n-307159 259306\\n-339452 286568\\n-505423 426682\\n-658627 556018\\n-150200 126800\\n236565 -199710\\n190003 -160402\\n-33044 27896\\n216288 -182592\\n-755506 637804\\n-84863 71642\\n657876 -555384\\n880923 -743682\\n-770526 650484\\n-613567 517978\\n-500166 422244\\n751 -634\\n291388 -245992\\n679655 -573770\\n554238 -467892\\n799064 -674576\\n-683410 576940\\n596294 -503396\\n-168975 142650\\n313167 -264378\\n-527953 445702\\n736731 -621954\\n-520443 439362\\n-696928 588352\\n-308661 260574\\n-123915 104610\\n-641354 541436\\n891437 -752558\\n-723213 610542\\n689418 -582012\\n-250083 211122\\n-890686 751924\\n757008 -639072\\n-509178 429852\\n474632 -400688\\n-808076 682184\\n24032 -20288\\n361982 -305588\\n699932 -590888\\n-164469 138846\\n-782542 660628\\n-252336 213024\\n245577 -207318\\n-348464 294176\\n-313918 265012\\n-714201 602934\\n775032 -654288\\n-630840 532560\\n815586 -688524\\n978553 -826102\\n458861 -387374\\n-553487 467258\\n995826 -840684\\n-943256 796304\\n-174983 147722\\n-407042 343628\\n524949 -443166\\n527202 -445068\\n416805 -351870\\n370243 -312562\\n-888433 750022\\n281625 -237750\\n-154706 130604\\n810329 -684086\\n720209 -608006\\n-844875 713250\\n823847 -695498\\n334195 -282130\\n416805 -351870\\n-524949 443166\\n-369492 311928\\n199766 -168644\\n-898947 758898\\n-872662 736708\\n371745 -313830\\n-655623 553482\\n-951517 803278\\n-65337 55158\\n-438584 370256\\n-623330 526220\\n566254 -478036\\n473881 -400054\\n-865152 730368\\n959027 -809618\\n-980055 827370\\n-635346 536364\\n-766771 647314\\n460363 -388642\\n-821594 693596\\n884678 -746852\\n\", \"25\\n-22132 -24068\\n-332483 -361567\\n-873711 -950139\\n-235404 -255996\\n-506521 -550829\\n-786692 -855508\\n-385298 -419002\\n-436604 -474796\\n-885783 -963267\\n-755506 -821594\\n-728344 -792056\\n-727841 -791509\\n-591528 -643272\\n-107642 -117058\\n-142349 -154801\\n-640319 -696331\\n-417490 -454010\\n-626738 -681562\\n-702188 -763612\\n-450688 -490112\\n-865160 -940840\\n-473826 -515274\\n-289728 -315072\\n-654906 -712194\\n-650379 -707271\\n\", \"61\\n855672 -90368\\n914454 -96576\\n756288 -79872\\n638724 -67456\\n260580 -27520\\n88476 -9344\\n768408 -81152\\n93324 -9856\\n109080 -11520\\n531462 -56128\\n293910 -31040\\n506616 -53504\\n423594 -44736\\n985356 -104064\\n454500 -48000\\n449652 -47488\\n303606 -32064\\n570852 -60288\\n10302 -1088\\n839916 -88704\\n549642 -58048\\n181194 -19136\\n43632 -4608\\n978690 -103360\\n163014 -17216\\n972024 -102656\\n204828 -21632\\n172104 -18176\\n521160 -55040\\n958692 -101248\\n610848 -64512\\n131502 -13888\\n652056 -68864\\n519948 -54912\\n441168 -46592\\n210282 -22208\\n205434 -21696\\n800526 -84544\\n566610 -59840\\n406626 -42944\\n896880 -94720\\n505404 -53376\\n644784 -68096\\n80598 -8512\\n51510 -5440\\n463590 -48960\\n18180 -1920\\n941118 -99392\\n775074 -81856\\n715686 -75584\\n296940 -31360\\n307848 -32512\\n981114 -103616\\n624180 -65920\\n627210 -66240\\n555096 -58624\\n842946 -89024\\n104838 -11072\\n21210 -2240\\n448440 -47360\\n155136 -16384\\n\", \"100\\n-62558 -455059\\n-78926 -574123\\n-122264 -889372\\n-29760 -216480\\n-91884 -668382\\n-122636 -892078\\n-134168 -975964\\n-17670 -128535\\n-127782 -929511\\n-74524 -542102\\n-104470 -759935\\n-133362 -970101\\n-93124 -677402\\n-16368 -119064\\n-19530 -142065\\n-82336 -598928\\n-87358 -635459\\n-7750 -56375\\n-114390 -832095\\n-51956 -377938\\n-134168 -975964\\n-63178 -459569\\n-5332 -38786\\n-28706 -208813\\n-98952 -719796\\n-43462 -316151\\n-14074 -102377\\n-73904 -537592\\n-90830 -660715\\n-54870 -399135\\n-11842 -86141\\n-116312 -846076\\n-91078 -662519\\n-82646 -601183\\n-63302 -460471\\n-25110 -182655\\n-90458 -658009\\n-46376 -337348\\n-90830 -660715\\n-133238 -969199\\n-113770 -827585\\n-58280 -423940\\n-115630 -841115\\n-22506 -163713\\n-89156 -648538\\n-1922 -13981\\n-136896 -995808\\n-62372 -453706\\n-32984 -239932\\n-30194 -219637\\n-111290 -809545\\n-34038 -247599\\n-93868 -682814\\n-35464 -257972\\n-58094 -422587\\n-56110 -408155\\n-17918 -130339\\n-112406 -817663\\n-47306 -344113\\n-3596 -26158\\n-126294 -918687\\n-121458 -883509\\n-7192 -52316\\n-69502 -505571\\n-51894 -377487\\n-12276 -89298\\n-20274 -147477\\n-31124 -226402\\n-61194 -445137\\n-110112 -800976\\n-1116 -8118\\n-59520 -432960\\n-108996 -792858\\n-83266 -605693\\n-115692 -841566\\n-46128 -335544\\n-75516 -549318\\n-89900 -653950\\n-105090 -764445\\n-372 -2706\\n-101308 -736934\\n-68944 -501512\\n-123752 -900196\\n-116064 -844272\\n-33170 -241285\\n-15748 -114554\\n-87172 -634106\\n-73470 -534435\\n-47554 -345917\\n-23188 -168674\\n-135780 -987690\\n-90334 -657107\\n-12338 -89749\\n-80290 -584045\\n-39866 -289993\\n-53630 -390115\\n-131564 -957022\\n-126976 -923648\\n-8804 -64042\\n-6262 -45551\\n\", \"85\\n0 0\\n-844794 547439\\n0 0\\n-334644 -143218\\n-409063 -178276\\n-406251 48270\\n-712506 -412099\\n-777884 527671\\n-567011 -389520\\n-657986 -561775\\n-960538 -640997\\n-515226 -430490\\n-423434 -218783\\n-593241 555784\\n-760243 653902\\n-854326 -449516\\n-337692 -22903\\n-648240 214928\\n-516538 470600\\n-176549 121612\\n-908604 -244141\\n-579472 391716\\n-776107 443405\\n-719777 431056\\n-899690 -359534\\n-86595 -72217\\n-484428 80593\\n-819581 -591319\\n-447545 287324\\n-562673 -103494\\n-631222 -176668\\n-854431 518284\\n-475510 34867\\n-981029 914692\\n-139490 -82546\\n-866610 355971\\n-714128 304823\\n-306085 -206948\\n-350129 177968\\n-333816 -70968\\n-672536 -645269\\n-675267 -596647\\n-729581 36421\\n-911293 -467908\\n-514843 -385448\\n-663702 -669972\\n-825226 730806\\n-567601 -70343\\n-997507 -527627\\n-897824 -427248\\n-846037 -604249\\n-978728 -529641\\n-801109 443095\\n-570422 198878\\n-432898 264102\\n-833878 -574449\\n-900470 433515\\n-222625 -219224\\n-937367 -152343\\n-939680 -759517\\n-487256 -94828\\n-693423 -652057\\n-977266 282341\\n-329546 -14146\\n-740006 545250\\n-783284 -394130\\n-670099 -229185\\n-858767 41965\\n-701983 652713\\n-688090 -290143\\n-429210 28398\\n-864463 -417868\\n-875192 -576135\\n-244402 14075\\n-667297 460593\\n-941028 -556035\\n-490652 -299616\\n-972677 -923967\\n-350512 -52088\\n-667158 354381\\n-502847 43623\\n-968189 -40748\\n-840160 606474\\n-339411 -22227\\n-700415 -344462\\n\", \"100\\n-630503 633883\\n-161138 982018\\n-149521 53489\\n-502584 515871\\n-617445 442508\\n-493529 480927\\n-105719 590672\\n-183715 475612\\n-579136 768448\\n-665386 409284\\n-62474 810539\\n-520519 878383\\n-752315 382833\\n-107649 382561\\n-690972 777270\\n-344929 545429\\n-236124 509970\\n-157981 31190\\n-380658 530243\\n-121126 965809\\n-120108 868073\\n-86387 235360\\n-348241 437764\\n-683385 939167\\n-503844 687165\\n-807584 343259\\n-738911 442331\\n-57354 223417\\n-453457 729892\\n-635948 677818\\n-229284 967469\\n-547333 450187\\n-665104 430143\\n-780411 736370\\n-962808 211787\\n-646742 38730\\n-207513 356690\\n-510590 596682\\n-935367 358412\\n-685473 503724\\n-177457 267259\\n-436371 536761\\n-487561 959458\\n-108501 129869\\n-273065 866810\\n-471893 554341\\n-804035 717688\\n-453075 655036\\n-957510 851482\\n-664906 229201\\n-783785 728831\\n-182377 597382\\n-698184 938763\\n-597589 18259\\n-487172 634605\\n-917528 755971\\n-22805 359774\\n-364007 512778\\n-933066 180432\\n-995755 243260\\n-236640 92747\\n-886354 879228\\n-480826 600142\\n-641705 273822\\n-64574 12563\\n-263103 35332\\n-227495 509182\\n-391220 113480\\n-786663 389621\\n-479729 968995\\n-65904 830005\\n-561375 97363\\n-308572 718939\\n-703590 741766\\n-702305 103225\\n-140093 73574\\n-53823 55230\\n-172479 290711\\n-575129 683488\\n-726847 577146\\n-515992 149485\\n-624381 23676\\n-72380 941040\\n-438922 973633\\n-564995 52606\\n-759049 866215\\n-904538 787655\\n-409909 610986\\n-763643 239360\\n-202050 318582\\n-995161 381119\\n-929887 388667\\n-131836 386218\\n-227546 410811\\n-642968 429087\\n-255123 217404\\n-824843 810939\\n-618622 436238\\n-183146 355013\\n-331566 809396\\n\", \"63\\n-680827 -798598\\n267434 -160968\\n-126285 -699928\\n330908 -270449\\n-896633 -663896\\n13139 -819079\\n32614 -658520\\n-875969 236216\\n-497099 73955\\n-398296 -802923\\n-896415 -899805\\n92141 -975343\\n-834379 105464\\n-38150 -245119\\n314042 -167358\\n-889406 -853741\\n-433872 -632933\\n330520 -239888\\n581555 -221433\\n977978 -972452\\n-47716 -544884\\n-498334 -842376\\n-984637 -932584\\n-452632 -372345\\n-59896 -951286\\n-56747 -136633\\n-977687 -680590\\n-947115 237975\\n858658 -611078\\n-969362 -306445\\n527639 -967180\\n-55662 -157870\\n-360676 -620879\\n-961639 -389199\\n-978375 218133\\n-382489 -151416\\n-612223 58568\\n-322820 -467769\\n969385 -886828\\n812847 -589928\\n-181357 -216216\\n-142303 -124550\\n926195 -401885\\n530684 -897002\\n482053 -779027\\n-182652 -366401\\n-950540 -445471\\n432624 -703724\\n366007 -710354\\n83124 -344492\\n952732 -458189\\n638202 -536683\\n-976864 39756\\n-599508 38000\\n-883191 -924957\\n925398 -667234\\n-774189 193889\\n-827921 -901256\\n-497999 -279738\\n-979694 357408\\n-488014 -113265\\n493715 -881121\\n950841 -640585\\n\", \"100\\n0 0\\n-333657 722128\\n49016 86265\\n-347832 620086\\n-421547 -157473\\n-377247 206942\\n-992049 285293\\n-25997 437816\\n955243 524291\\n-482395 274674\\n979758 855542\\n-553487 4557\\n-687983 262282\\n-99984 994315\\n-805738 384198\\n-808776 -291010\\n-606906 945701\\n-702952 638018\\n325916 677999\\n-348606 20020\\n-173322 871276\\n-645465 961676\\n-464811 400442\\n865768 452282\\n797093 949978\\n-823636 -301497\\n306851 818723\\n-279416 177203\\n223135 633735\\n-818915 -189024\\n-371577 52877\\n429143 975008\\n30835 280886\\n772466 522039\\n809400 679877\\n143301 680645\\n240512 750723\\n-45067 228562\\n-502798 648469\\n818106 606616\\n873888 830440\\n-169156 214795\\n-625026 -233286\\n-250595 291627\\n-257189 798224\\n-584744 -251998\\n495795 790238\\n524881 935513\\n149008 253768\\n-119283 146816\\n-49680 152974\\n557481 761395\\n-188839 250049\\n276993 382632\\n-275927 526933\\n766790 920949\\n320793 821733\\n-730251 54190\\n-441998 527427\\n-604197 -73514\\n43238 419716\\n38661 472462\\n-761799 70331\\n69860 600675\\n866875 511818\\n-685612 473637\\n-557557 643977\\n-505414 929065\\n-520231 622732\\n121330 128070\\n-355809 7868\\n459078 824690\\n826589 684755\\n-420040 676324\\n988854 889871\\n26584 910536\\n758626 724364\\n-409396 -65002\\n683705 805844\\n-449510 541823\\n127 95814\\n479817 294376\\n-335951 331689\\n50936 634722\\n-664325 930350\\n493307 300203\\n-721516 96193\\n398568 715798\\n97082 874417\\n-473851 178244\\n-576545 349833\\n-554934 565604\\n-415800 579154\\n239803 565844\\n320823 151373\\n-597474 859145\\n66039 890541\\n-693848 706839\\n-880485 293473\\n804647 564490\\n\", \"59\\n0 0\\n804365 441522\\n-685049 -751533\\n522613 262381\\n-939083 -666012\\n-696212 -626115\\n0 0\\n-518125 -812861\\n351395 263494\\n-629320 -955619\\n420613 216131\\n971598 841995\\n668523 703814\\n-586157 -319552\\n700841 901386\\n882939 780440\\n780747 712278\\n418602 699893\\n237436 442104\\n-870106 -480336\\n483984 534206\\n-810613 -997526\\n882560 382998\\n-983418 -441763\\n-704833 -951992\\n446921 634889\\n717243 285899\\n702120 837564\\n360499 299553\\n-486844 -504721\\n-495723 -966940\\n422943 252087\\n-559883 -650739\\n796420 421308\\n710081 900858\\n-641778 -470327\\n-318033 -363744\\n728110 690033\\n653007 981811\\n261908 231975\\n-710388 -816257\\n157237 64112\\n-587908 -908950\\n-969122 -363608\\n-676463 -292293\\n-785391 -527076\\n359472 394083\\n746511 886528\\n392304 357498\\n556228 535732\\n628917 995606\\n780578 879774\\n512319 646248\\n-255619 -429234\\n-372996 -171437\\n198028 404444\\n-164078 -118727\\n274803 280919\\n548048 912631\\n\", \"100\\n0 0\\n-462569 205638\\n-892131 803588\\n-494314 248488\\n847577 -537569\\n-753846 345387\\n-171341 327402\\n338858 -630563\\n-605536 903714\\n411391 -916699\\n453324 -454362\\n979455 -464142\\n517375 -247159\\n941145 -561067\\n-837603 846355\\n-418618 750486\\n-325710 407194\\n-933384 793942\\n-907619 907840\\n-578705 597654\\n266234 -626597\\n837867 -922218\\n-494427 845925\\n817547 -958108\\n824038 -747795\\n577956 -322752\\n629013 -321922\\n-670531 714556\\n-442185 338971\\n829207 -634486\\n97456 -107784\\n225180 -111078\\n929469 -524904\\n911058 -894075\\n452562 -877219\\n-321995 340686\\n-479196 457128\\n-915784 925426\\n-795581 356184\\n-908432 748822\\n-576239 395018\\n-788057 581192\\n-517154 861973\\n559951 -936791\\n-416928 188594\\n-932210 498274\\n890444 -693950\\n444785 -404207\\n522178 -617430\\n561469 -783994\\n-723101 358027\\n864565 -849036\\n-848324 970976\\n-873782 544812\\n543204 -480749\\n260582 -625680\\n-749893 472770\\n-387065 186860\\n454608 -932975\\n907124 -844283\\n-895852 397831\\n850889 -599945\\n767210 -786394\\n-859005 868389\\n-293712 492965\\n-848076 462120\\n-478918 372861\\n318459 -287928\\n607521 -962915\\n-831786 493429\\n-360371 168448\\n-174830 113008\\n-933581 695832\\n-379699 369081\\n286995 -464839\\n-329816 668326\\n-735814 432724\\n615082 -942854\\n-595393 996934\\n-545771 514965\\n-188470 170404\\n-918591 517551\\n251542 -409112\\n623716 -714706\\n-234198 257585\\n345268 -724088\\n836250 -546359\\n-291155 407486\\n-891829 511101\\n-379661 476797\\n499906 -458788\\n595829 -670269\\n-478602 427179\\n-959807 522548\\n-300365 705726\\n-784645 676298\\n641495 -967822\\n-551784 975723\\n-404030 816586\\n-370338 567279\\n\", \"3\\n0 921616\\n798143 -460808\\n-798143 -460808\\n\", \"5\\n0 942019\\n895913 291100\\n553705 -762109\\n-553705 -762109\\n-895913 291100\\n\", \"12\\n0 922584\\n461292 798981\\n798981 461292\\n922584 0\\n798981 -461292\\n461292 -798981\\n0 -922584\\n-461292 -798981\\n-798981 -461292\\n-922584 0\\n-798981 461292\\n-461292 798981\\n\", \"49\\n0 921164\\n117796 913601\\n233657 891037\\n345682 853842\\n452031 802627\\n550958 738233\\n640838 661718\\n720195 574336\\n787727 477525\\n842324 372872\\n883090 262097\\n909356 147018\\n920691 29525\\n916907 -88453\\n898068 -204978\\n864483 -318138\\n816703 -426074\\n755513 -527013\\n681917 -619299\\n597125 -701417\\n502527 -772017\\n399678 -829940\\n290266 -874236\\n176088 -904177\\n59019 -919271\\n-59019 -919271\\n-176088 -904177\\n-290266 -874236\\n-399678 -829940\\n-502527 -772017\\n-597125 -701417\\n-681917 -619299\\n-755513 -527013\\n-816703 -426074\\n-864483 -318138\\n-898068 -204978\\n-916907 -88453\\n-920691 29525\\n-909356 147018\\n-883090 262097\\n-842324 372872\\n-787727 477525\\n-720195 574336\\n-640838 661718\\n-550958 738233\\n-452031 802627\\n-345682 853842\\n-233657 891037\\n-117796 913601\\n\", \"90\\n0 916411\\n63926 914179\\n127540 907493\\n190533 896385\\n252597 880911\\n313431 861145\\n372738 837183\\n430229 809143\\n485624 777161\\n538653 741392\\n589058 702012\\n636593 659211\\n681026 613199\\n722142 564199\\n759739 512451\\n793635 458205\\n823665 401728\\n849681 343294\\n871559 283187\\n889190 221700\\n902489 159133\\n911391 95791\\n915853 31982\\n915853 -31982\\n911391 -95791\\n902489 -159133\\n889190 -221700\\n871559 -283187\\n849681 -343294\\n823665 -401728\\n793635 -458206\\n759739 -512451\\n722142 -564199\\n681026 -613199\\n636593 -659211\\n589058 -702012\\n538653 -741392\\n485624 -777161\\n430229 -809143\\n372738 -837183\\n313431 -861145\\n252597 -880911\\n190533 -896385\\n127540 -907493\\n63926 -914179\\n0 -916411\\n-63926 -914179\\n-127540 -907493\\n-190533 -896385\\n-252597 -880911\\n-313431 -861145\\n-372738 -837183\\n-430229 -809143\\n-485624 -777161\\n-538653 -741392\\n-589058 -702012\\n-636593 -659211\\n-681026 -613199\\n-722142 -564199\\n-759739 -512451\\n-793635 -458205\\n-823665 -401728\\n-849681 -343294\\n-871559 -283187\\n-889190 -221700\\n-902489 -159133\\n-911391 -95791\\n-915853 -31982\\n-915853 31982\\n-911391 95791\\n-902489 159133\\n-889190 221700\\n-871559 283187\\n-849681 343294\\n-823665 401728\\n-793635 458206\\n-759739 512451\\n-722142 564199\\n-681026 613199\\n-636593 659211\\n-589058 702012\\n-538653 741392\\n-485624 777161\\n-430229 809143\\n-372738 837183\\n-313431 861145\\n-252597 880911\\n-190533 896385\\n-127540 907493\\n-63926 914179\\n\", \"82\\n0 976405\\n74963 976405\\n150815 976405\\n228488 976405\\n309002 976405\\n393527 976405\\n483449 976405\\n580478 976405\\n686788 976405\\n805235 976405\\n939696 976405\\n976405 870169\\n976405 744281\\n976405 632313\\n976405 530952\\n976405 437715\\n976405 350683\\n976405 268321\\n976405 189363\\n976405 112721\\n976405 37426\\n976405 -37426\\n976405 -112721\\n976405 -189363\\n976405 -268321\\n976405 -350683\\n976405 -437715\\n976405 -530952\\n976405 -632313\\n976405 -744281\\n976405 -870169\\n939696 -976405\\n805235 -976405\\n686788 -976405\\n580478 -976405\\n483449 -976405\\n393527 -976405\\n309002 -976405\\n228488 -976405\\n150815 -976405\\n74963 -976405\\n0 -976405\\n-74963 -976405\\n-150815 -976405\\n-228488 -976405\\n-309002 -976405\\n-393527 -976405\\n-483449 -976405\\n-580478 -976405\\n-686788 -976405\\n-805235 -976405\\n-939696 -976405\\n-976405 -870169\\n-976405 -744281\\n-976405 -632313\\n-976405 -530952\\n-976405 -437715\\n-976405 -350683\\n-976405 -268321\\n-976405 -189363\\n-976405 -112721\\n-976405 -37426\\n-976405 37426\\n-976405 112721\\n-976405 189363\\n-976405 268321\\n-976405 350683\\n-976405 437715\\n-976405 530952\\n-976405 632313\\n-976405 744281\\n-976405 870169\\n-939696 976405\\n-805235 976405\\n-686788 976405\\n-580478 976405\\n-483449 976405\\n-393527 976405\\n-309002 976405\\n-228488 976405\\n-150815 976405\\n-74963 976405\\n\", \"95\\n0 951594\\n63029 951594\\n126614 951594\\n191329 951594\\n257792 951594\\n326683 951594\\n398780 951594\\n474993 951594\\n556418 951594\\n644405 951594\\n740655 951594\\n847369 951594\\n951594 935988\\n951594 819565\\n951594 715708\\n951594 621707\\n951594 535505\\n951594 455498\\n951594 380408\\n951594 309192\\n951594 240976\\n951594 175012\\n951594 110635\\n951594 47242\\n951594 -15736\\n951594 -78851\\n951594 -142664\\n951594 -207756\\n951594 -274758\\n951594 -344373\\n951594 -417408\\n951594 -494813\\n951594 -577740\\n951594 -667617\\n951594 -766253\\n951594 -876004\\n905524 -951594\\n792542 -951594\\n691374 -951594\\n599495 -951594\\n514977 -951594\\n436308 -951594\\n362277 -951594\\n291888 -951594\\n224301 -951594\\n158793 -951594\\n94717 -951594\\n31480 -951594\\n-31480 -951594\\n-94717 -951594\\n-158793 -951594\\n-224301 -951594\\n-291888 -951594\\n-362277 -951594\\n-436308 -951594\\n-514977 -951594\\n-599495 -951594\\n-691374 -951594\\n-792542 -951594\\n-905524 -951594\\n-951594 -876004\\n-951594 -766253\\n-951594 -667617\\n-951594 -577740\\n-951594 -494813\\n-951594 -417408\\n-951594 -344373\\n-951594 -274758\\n-951594 -207756\\n-951594 -142664\\n-951594 -78851\\n-951594 -15736\\n-951594 47242\\n-951594 110635\\n-951594 175012\\n-951594 240976\\n-951594 309192\\n-951594 380408\\n-951594 455498\\n-951594 535505\\n-951594 621707\\n-951594 715708\\n-951594 819565\\n-951594 935988\\n-847369 951594\\n-740655 951594\\n-644405 951594\\n-556418 951594\\n-474993 951594\\n-398780 951594\\n-326683 951594\\n-257792 951594\\n-191329 951594\\n-126614 951594\\n-63029 951594\\n\", \"100\\n0 945792\\n59504 945792\\n119481 945792\\n180419 945792\\n242838 945792\\n307306 945792\\n374466 945792\\n445056 945792\\n519954 945792\\n600218 945792\\n687158 945792\\n782427 945792\\n888158 945792\\n945792 888158\\n945792 782427\\n945792 687158\\n945792 600218\\n945792 519954\\n945792 445056\\n945792 374466\\n945792 307306\\n945792 242838\\n945792 180419\\n945792 119481\\n945792 59504\\n945792 0\\n945792 -59504\\n945792 -119481\\n945792 -180419\\n945792 -242838\\n945792 -307306\\n945792 -374466\\n945792 -445056\\n945792 -519954\\n945792 -600218\\n945792 -687158\\n945792 -782427\\n945792 -888158\\n888158 -945792\\n782427 -945792\\n687158 -945792\\n600218 -945792\\n519954 -945792\\n445056 -945792\\n374466 -945792\\n307306 -945792\\n242838 -945792\\n180419 -945792\\n119481 -945792\\n59504 -945792\\n0 -945792\\n-59504 -945792\\n-119481 -945792\\n-180419 -945792\\n-242838 -945792\\n-307306 -945792\\n-374466 -945792\\n-445056 -945792\\n-519954 -945792\\n-600218 -945792\\n-687158 -945792\\n-782427 -945792\\n-888158 -945792\\n-945792 -888158\\n-945792 -782427\\n-945792 -687158\\n-945792 -600218\\n-945792 -519954\\n-945792 -445056\\n-945792 -374466\\n-945792 -307306\\n-945792 -242838\\n-945792 -180419\\n-945792 -119481\\n-945792 -59504\\n-945792 0\\n-945792 59504\\n-945792 119481\\n-945792 180419\\n-945792 242838\\n-945792 307306\\n-945792 374466\\n-945792 445056\\n-945792 519954\\n-945792 600218\\n-945792 687158\\n-945792 782427\\n-945792 888158\\n-888158 945792\\n-782427 945792\\n-687158 945792\\n-600218 945792\\n-519954 945792\\n-445056 945792\\n-374466 945792\\n-307306 945792\\n-242838 945792\\n-180419 945792\\n-119481 945792\\n-59504 945792\\n\", \"2\\n2 3\\n2 -3\\n\", \"2\\n3 2\\n-3 2\\n\"], \"outputs\": [\"10.000000000000000000000000000000000000000000000000\\n\", \"2.828427124746190097603377448419396157139343750753\\n\", \"21.213203435596425732025330863145471178545078130654\\n\", \"1.414213562373095048801688724209698078569671875376\\n\", \"128303.000000000000000000000000000000000000000000000000\\n\", \"120000.000000000000000000000000000000000000000000000000\\n\", \"148.660687473185055226120082139313966514489855137208\\n\", \"4.472135954999579392818347337462552470881236719223\\n\", \"36.138621999185303745108713193495121527298513390738\\n\", \"42.953463189829059463318803693101226101390533508871\\n\", \"46.529560496527366188940693029050722642156737887578\\n\", \"474.723077172365826414511993362018842389958238502515\\n\", \"467.898493265366264953519251262707764664115891270876\\n\", \"4219580.574220262475304433473530912581431581483032534312\\n\", \"24868884.660420237672207359063340835411552069496531228920\\n\", \"27092028.899265647284162256413522830145436089722813008724\\n\", \"0.000000000000000000000000000000000000000000000000\\n\", \"35190720.872777386172542564997597466967891481946582882272\\n\", \"80141434.821195957921324434334918121310805322029210289978\\n\", \"6166763.716183392087660000701588718582451421464590415298\\n\", \"17731622.142461980627169473717181360059537082703562534972\\n\", \"39203167.502698146138226203372683789204572948741439544286\\n\", \"19633064.467250139399466818607091226319130245420203992133\\n\", \"29364938.960576301528257422888042130614537671558191530639\\n\", \"50211793.128449465880462929445915123419949789426105994068\\n\", \"54336536.383522220232356241738008810697603008855580184834\\n\", \"68975369.155521364269998361702120629088208000898831517087\\n\", \"30231680.203827838189181222795507174907272400870912707407\\n\", \"48247099.166540758981842365255493304827095744034675590840\\n\", \"26980442.131536781026383393519225253770001498803864663211\\n\", \"46189336.782034931054446924834191649619048713699651477996\\n\", \"921616.113852725558994680424514892240690638903023000332\\n\", \"1524219.000000000000000000000000000000000000000000000000\\n\", \"3564590.500177544938186935889960459288939226797472558606\\n\", \"14370026.000000000000000000000000000000000000000000000000\\n\", \"26258581.001626496877294216848735127029515732503186465405\\n\", \"28852393.000000000000000000000000000000000000000000000000\\n\", \"32581534.000000000000000000000000000000000000000000000000\\n\", \"34071899.512944152847017656105041116183533147279676585852\\n\", \"4.000000000000000000000000000000000000000000000000\\n\", \"4.000000000000000000000000000000000000000000000000\\n\"]}",
  "difficulty": "interview",
  "url": "https://atcoder.jp/contests/abc139/tasks/abc139_f",
  "starter_code": ""
}