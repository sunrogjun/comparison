{
  "task_id": "APPS/147",
  "problem_id": 147,
  "prompt": "R3D3 spent some time on an internship in MDCS. After earning enough money, he decided to go on a holiday somewhere far, far away. He enjoyed suntanning, drinking alcohol-free cocktails and going to concerts of popular local bands. While listening to \"The White Buttons\" and their hit song \"Dacan the Baker\", he met another robot for whom he was sure is the love of his life. Well, his summer, at least. Anyway, R3D3 was too shy to approach his potential soulmate, so he decided to write her a love letter. However, he stumbled upon a problem. Due to a terrorist threat, the Intergalactic Space Police was monitoring all letters sent in the area. Thus, R3D3 decided to invent his own alphabet, for which he was sure his love would be able to decipher.\n\nThere are n letters in R3D3\u2019s alphabet, and he wants to represent each letter as a sequence of '0' and '1', so that no letter\u2019s sequence is a prefix of another letter's sequence. Since the Intergalactic Space Communications Service has lately introduced a tax for invented alphabets, R3D3 must pay a certain amount of money for each bit in his alphabet\u2019s code (check the sample test for clarifications). He is too lovestruck to think clearly, so he asked you for help.\n\nGiven the costs c_0 and c_1 for each '0' and '1' in R3D3\u2019s alphabet, respectively, you should come up with a coding for the alphabet (with properties as above) with minimum total cost.\n\n\n-----Input-----\n\nThe first line of input contains three integers n (2 \u2264 n \u2264 10^8), c_0 and c_1 (0 \u2264 c_0, c_1 \u2264 10^8)\u00a0\u2014 the number of letters in the alphabet, and costs of '0' and '1', respectively. \n\n\n-----Output-----\n\nOutput a single integer\u00a0\u2014 minimum possible total a cost of the whole alphabet.\n\n\n-----Example-----\nInput\n4 1 2\n\nOutput\n12\n\n\n\n-----Note-----\n\nThere are 4 letters in the alphabet. The optimal encoding is \"00\", \"01\", \"10\", \"11\". There are 4 zeroes and 4 ones used, so the total cost is 4\u00b71 + 4\u00b72 = 12.",
  "solutions": "[\"import sys\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\nn,a,b=map(int,input().split())\\n\\nif a<b: a,b=b,a\\n\\nif b==0:\\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\\n    print((n-1)*a)\\nelse:\\n    # pascal's triangle thing\\n    pascal=[[1]*20005]\\n    for i in range(20004):\\n        newrow=[1]\\n        for j in range(1,20005):\\n            newrow.append(newrow[-1]+pascal[-1][j])\\n            if newrow[-1]>n: break\\n        pascal.append(newrow)\\n    def getcom(a,b):\\n        # return a+b choose b\\n        # if larger than n, return infinite\\n        if len(pascal[a])>b: return pascal[a][b]\\n        if b==0: return 1\\n        if b==1: return a\\n        return 100000005\\n\\n    # start with the null node (prefix cost 0)\\n    # can split a node into two other nodes with added cost c+a+b\\n    # new nodes have prefix costs c+a, c+b\\n    # want n-1 splits in total\\n    n-=1    # now represents number of splits needed\\n\\n    # binary search the last cost added\\n    lo=0\\n    hi=a*int((n**0.5)*2+5)\\n\\n    while 1:\\n        mid=(lo+hi)//2\\n        # count stuff\\n        c0=0    # < mid\\n        c1=0    # = mid\\n        for i in range(mid//a+1):\\n            j=(mid-i*a)//b\\n            if (mid-i*a)%b!=0:\\n                # c0 += iC0 + (i+1)C1 + (i+2)C2 + ... + (i+j)Cj\\n                for k in range(j+1):\\n                    #print(mid,i,k)\\n                    c0+=getcom(i,k)\\n                    if c0>n: break\\n            else:\\n                for k in range(j):\\n                    #print(mid,i,k)\\n                    c0+=getcom(i,k)\\n                    if c0>n: break\\n                #print(mid,i,j,\\\"c1\\\")\\n                c1+=getcom(i,j)\\n        #print(mid,\\\"is\\\",c0,c1)\\n        if n<c0:\\n            hi=mid-1\\n        elif c0+c1<n:\\n            lo=mid+1\\n        else:\\n            # mid is correct cutoff\\n            lowcost=0   # sum of all cost, where cost < mid\\n            for i in range(mid//a+1):\\n                j=(mid-i*a)//b\\n                if (mid-i*a)%b!=0:\\n                    for k in range(j+1):\\n                        lowcost+=getcom(i,k)*(i*a+k*b)\\n                else:\\n                    for k in range(j):\\n                        lowcost+=getcom(i,k)*(i*a+k*b)\\n            temp=lowcost+(n-c0)*mid\\n            print(temp+n*(a+b))\\n            break\", \"import sys,heapq\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\nn,a,b=map(int,input().split())\\n\\nif a<b: a,b=b,a\\n\\nif b==0:\\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\\n    print((n-1)*a)\\nelse:\\n    # pascal's triangle thing\\n    pascal=[[1]*20005]\\n    for i in range(20004):\\n        newrow=[1]\\n        for j in range(1,20005):\\n            newrow.append(newrow[-1]+pascal[-1][j])\\n            if newrow[-1]>n: break\\n        pascal.append(newrow)\\n    def getcom(a,b):\\n        # return a+b choose b\\n        # if larger than n, return infinite\\n        if len(pascal[a])>b: return pascal[a][b]\\n        if b==0: return 1\\n        if b==1: return a\\n        return 100000005\\n\\n    # start with the null node (prefix cost 0)\\n    # can split a node into two other nodes with added cost c+a+b\\n    # new nodes have prefix costs c+a, c+b\\n    # want n-1 splits in total\\n    remain=n-1\\n    ans=0\\n    possible=[[a+b,1]]    # [c,count]\\n    while 1:\\n        # cost u, v leaves\\n        u,v=heapq.heappop(possible)\\n        while possible and possible[0][0]==u:\\n            v+=possible[0][1]\\n            heapq.heappop(possible)\\n        if remain<=v:\\n            ans+=u*remain\\n            break\\n        ans+=u*v\\n        remain-=v\\n        heapq.heappush(possible,[u+a,v])\\n        heapq.heappush(possible,[u+b,v])\\n    print(ans)\", \"import sys,heapq\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\n\\nn,a,b=map(int,input().split())\\n\\nif a<b: a,b=b,a\\n\\nif b==0:\\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\\n    print((n-1)*a)\\nelse:\\n    # start with the null node (prefix cost 0)\\n    # can split a node into two other nodes with added cost c+a+b\\n    # new nodes have prefix costs c+a, c+b\\n    # want n-1 splits in total\\n    remain=n-1\\n    ans=0\\n    possible=[[a+b,1]]    # [c,count]\\n    while 1:\\n        # cost u, v leaves\\n        u,v=heapq.heappop(possible)\\n        while possible and possible[0][0]==u:\\n            v+=possible[0][1]\\n            heapq.heappop(possible)\\n        if remain<=v:\\n            ans+=u*remain\\n            break\\n        ans+=u*v\\n        remain-=v\\n        heapq.heappush(possible,[u+a,v])\\n        heapq.heappush(possible,[u+b,v])\\n    print(ans)\", \"import sys,heapq\\n\\n#sys.stdin=open(\\\"data.txt\\\")\\n\\ninput=sys.stdin.readline\\n\\n\\n\\nn,a,b=list(map(int,input().split()))\\n\\n\\n\\nif a<b: a,b=b,a\\n\\n\\n\\nif b==0:\\n\\n    # 1 01 001 0001 ... is optimal, plus a long series of 0's\\n\\n    print((n-1)*a)\\n\\nelse:\\n\\n    # pascal's triangle thing\\n\\n    pascal=[[1]*20005]\\n\\n    for i in range(20004):\\n\\n        newrow=[1]\\n\\n        for j in range(1,20005):\\n\\n            newrow.append(newrow[-1]+pascal[-1][j])\\n\\n            if newrow[-1]>n: break\\n\\n        pascal.append(newrow)\\n\\n    def getcom(a,b):\\n\\n        # return a+b choose b\\n\\n        # if larger than n, return infinite\\n\\n        if len(pascal[a])>b: return pascal[a][b]\\n\\n        if b==0: return 1\\n\\n        if b==1: return a\\n\\n        return 100000005\\n\\n\\n\\n    # start with the null node (prefix cost 0)\\n\\n    # can split a node into two other nodes with added cost c+a+b\\n\\n    # new nodes have prefix costs c+a, c+b\\n\\n    # want n-1 splits in total\\n\\n    remain=n-1\\n\\n    ans=0\\n\\n    possible=[[a+b,1]]    # [c,count]\\n\\n    while 1:\\n\\n        # cost u, v leaves\\n\\n        u,v=heapq.heappop(possible)\\n\\n        while possible and possible[0][0]==u:\\n\\n            v+=possible[0][1]\\n\\n            heapq.heappop(possible)\\n\\n        if remain<=v:\\n\\n            ans+=u*remain\\n\\n            break\\n\\n        ans+=u*v\\n\\n        remain-=v\\n\\n        heapq.heappush(possible,[u+a,v])\\n\\n        heapq.heappush(possible,[u+b,v])\\n\\n    print(ans)\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"4 1 2\\n\",\n    \"2 1 5\\n\",\n    \"3 1 1\\n\",\n    \"5 5 5\\n\",\n    \"4 0 0\\n\",\n    \"6 0 6\\n\",\n    \"6 6 0\\n\",\n    \"2 1 2\\n\",\n    \"100000000 1 0\\n\",\n    \"2 0 0\\n\",\n    \"2 100000000 100000000\\n\",\n    \"2 100000000 0\\n\",\n    \"2 0 100000000\\n\",\n    \"100000000 0 0\\n\",\n    \"100000000 100000000 100000000\\n\",\n    \"100000000 100000000 0\\n\",\n    \"100000000 0 100000000\\n\",\n    \"2 50000000 0\\n\",\n    \"2 50000000 100000000\\n\",\n    \"2 50000000 0\\n\",\n    \"2 50000000 100000000\\n\",\n    \"100000000 50000000 0\\n\",\n    \"100000000 50000000 100000000\\n\",\n    \"100000000 50000000 0\\n\",\n    \"100000000 50000000 100000000\\n\",\n    \"96212915 66569231 66289469\\n\",\n    \"39969092 91869601 91924349\\n\",\n    \"26854436 29462638 67336233\\n\",\n    \"39201451 80233602 30662934\\n\",\n    \"92820995 96034432 40568102\\n\",\n    \"81913246 61174868 31286889\\n\",\n    \"74790405 66932852 48171076\\n\",\n    \"88265295 26984472 18821097\\n\",\n    \"39858798 77741429 44017779\\n\",\n    \"70931513 41663344 29095671\\n\",\n    \"68251617 52232534 34187120\\n\",\n    \"44440915 82093126 57268128\\n\",\n    \"61988457 90532323 72913492\\n\",\n    \"13756397 41019327 86510346\\n\",\n    \"84963589 37799442 20818727\\n\",\n    \"99338896 62289589 49020203\\n\",\n    \"1505663 3257962 1039115\\n\",\n    \"80587587 25402325 8120971\\n\",\n    \"64302230 83635846 22670768\\n\",\n    \"6508457 32226669 8706339\\n\",\n    \"1389928 84918086 54850899\\n\",\n    \"37142108 10188690 35774598\\n\",\n    \"86813943 11824369 38451380\\n\",\n    \"14913475 61391038 9257618\\n\",\n    \"25721978 63666459 14214946\\n\",\n    \"73363656 63565575 76409698\\n\",\n    \"34291060 92893503 64680754\\n\",\n    \"85779772 26434899 86820336\\n\",\n    \"7347370 2098650 66077918\\n\",\n    \"28258585 6194848 49146833\\n\",\n    \"9678 133 5955\\n\",\n    \"9251 4756 2763\\n\",\n    \"1736 5628 2595\\n\",\n    \"5195 1354 2885\\n\",\n    \"1312 5090 9909\\n\",\n    \"8619 6736 9365\\n\",\n    \"151 7023 3093\\n\",\n    \"5992 2773 6869\\n\",\n    \"3894 9921 3871\\n\",\n    \"1006 9237 1123\\n\",\n    \"9708 3254 2830\\n\",\n    \"1504 1123 626\\n\",\n    \"8642 5709 51\\n\",\n    \"8954 4025 7157\\n\",\n    \"4730 8020 8722\\n\",\n    \"2500 5736 4002\\n\",\n    \"6699 4249 1068\\n\",\n    \"4755 6759 4899\\n\",\n    \"8447 1494 4432\\n\",\n    \"6995 4636 8251\\n\",\n    \"4295 9730 4322\\n\",\n    \"8584 4286 9528\\n\",\n    \"174 6826 355\\n\",\n    \"5656 7968 3400\\n\",\n    \"2793 175 3594\\n\",\n    \"2888 9056 3931\\n\",\n    \"6222 7124 6784\\n\",\n    \"8415 8714 2475\\n\",\n    \"2179 7307 8608\\n\",\n    \"1189 1829 6875\\n\"\n  ],\n  \"outputs\": [\n    \"12\\n\",\n    \"6\\n\",\n    \"5\\n\",\n    \"60\\n\",\n    \"0\\n\",\n    \"30\\n\",\n    \"30\\n\",\n    \"3\\n\",\n    \"99999999\\n\",\n    \"0\\n\",\n    \"200000000\\n\",\n    \"100000000\\n\",\n    \"100000000\\n\",\n    \"0\\n\",\n    \"266578227200000000\\n\",\n    \"9999999900000000\\n\",\n    \"9999999900000000\\n\",\n    \"50000000\\n\",\n    \"150000000\\n\",\n    \"50000000\\n\",\n    \"150000000\\n\",\n    \"4999999950000000\\n\",\n    \"191720992950000000\\n\",\n    \"4999999950000000\\n\",\n    \"191720992950000000\\n\",\n    \"170023209909758400\\n\",\n    \"93003696194821620\\n\",\n    \"30373819153055635\\n\",\n    \"50953283386656312\\n\",\n    \"158135215198065044\\n\",\n    \"96084588586645841\\n\",\n    \"111690840882243696\\n\",\n    \"52835608063500861\\n\",\n    \"59709461677488470\\n\",\n    \"64816798089350400\\n\",\n    \"75694251898945158\\n\",\n    \"77907273273831800\\n\",\n    \"130757350538583270\\n\",\n    \"19895886795999000\\n\",\n    \"63754887412974663\\n\",\n    \"146320678028775569\\n\",\n    \"60023256524142\\n\",\n    \"32044560697691212\\n\",\n    \"77790985833197594\\n\",\n    \"2645634460061466\\n\",\n    \"1953921305304795\\n\",\n    \"19009588918065432\\n\",\n    \"51645349299460766\\n\",\n    \"9761450207212562\\n\",\n    \"20847031763747988\\n\",\n    \"133919836504944416\\n\",\n    \"66960630525688676\\n\",\n    \"114681463889615136\\n\",\n    \"3070602135161752\\n\",\n    \"14441957862691571\\n\",\n    \"196970292\\n\",\n    \"448302621\\n\",\n    \"73441521\\n\",\n    \"130236572\\n\",\n    \"98808420\\n\",\n    \"900966230\\n\",\n    \"5267919\\n\",\n    \"340564941\\n\",\n    \"299508763\\n\",\n    \"38974261\\n\",\n    \"391502526\\n\",\n    \"13538132\\n\",\n    \"135655830\\n\",\n    \"641304164\\n\",\n    \"484587068\\n\",\n    \"136264140\\n\",\n    \"196812772\\n\",\n    \"336456318\\n\",\n    \"298387478\\n\",\n    \"561476311\\n\",\n    \"346320888\\n\",\n    \"738058224\\n\",\n    \"2889605\\n\",\n    \"379249528\\n\",\n    \"36405762\\n\",\n    \"204521173\\n\",\n    \"547839384\\n\",\n    \"545452719\\n\",\n    \"192281235\\n\",\n    \"46521099\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/717/B",
  "starter_code": ""
}