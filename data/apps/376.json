{
  "task_id": "APPS/376",
  "problem_id": 376,
  "prompt": "Although Inzane successfully found his beloved bone, Zane, his owner, has yet to return. To search for Zane, he would need a lot of money, of which he sadly has none. To deal with the problem, he has decided to hack the banks. [Image] \n\nThere are n banks, numbered from 1 to n. There are also n - 1 wires connecting the banks. All banks are initially online. Each bank also has its initial strength: bank i has initial strength a_{i}.\n\nLet us define some keywords before we proceed. Bank i and bank j are neighboring if and only if there exists a wire directly connecting them. Bank i and bank j are semi-neighboring if and only if there exists an online bank k such that bank i and bank k are neighboring and bank k and bank j are neighboring.\n\nWhen a bank is hacked, it becomes offline (and no longer online), and other banks that are neighboring or semi-neighboring to it have their strengths increased by 1.\n\nTo start his plan, Inzane will choose a bank to hack first. Indeed, the strength of such bank must not exceed the strength of his computer. After this, he will repeatedly choose some bank to hack next until all the banks are hacked, but he can continue to hack bank x if and only if all these conditions are met:  Bank x is online. That is, bank x is not hacked yet.  Bank x is neighboring to some offline bank.  The strength of bank x is less than or equal to the strength of Inzane's computer. \n\nDetermine the minimum strength of the computer Inzane needs to hack all the banks.\n\n\n-----Input-----\n\nThe first line contains one integer n (1 \u2264 n \u2264 3\u00b710^5)\u00a0\u2014 the total number of banks.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} ( - 10^9 \u2264 a_{i} \u2264 10^9)\u00a0\u2014 the strengths of the banks.\n\nEach of the next n - 1 lines contains two integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n, u_{i} \u2260 v_{i})\u00a0\u2014 meaning that there is a wire directly connecting banks u_{i} and v_{i}.\n\nIt is guaranteed that the wires connect the banks in such a way that Inzane can somehow hack all the banks using a computer with appropriate strength.\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 the minimum strength of the computer Inzane needs to accomplish the goal.\n\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n1 2\n2 3\n3 4\n4 5\n\nOutput\n5\nInput\n7\n38 -29 87 93 39 28 -55\n1 2\n2 5\n3 2\n2 4\n1 7\n7 6\n\nOutput\n93\nInput\n5\n1 2 7 6 7\n1 5\n5 3\n3 4\n2 4\n\nOutput\n8\n\n\n-----Note-----\n\nIn the first sample, Inzane can hack all banks using a computer with strength 5. Here is how:  Initially, strengths of the banks are [1, 2, 3, 4, 5].  He hacks bank 5, then strengths of the banks become [1, 2, 4, 5,  - ].  He hacks bank 4, then strengths of the banks become [1, 3, 5,  - ,  - ].  He hacks bank 3, then strengths of the banks become [2, 4,  - ,  - ,  - ].  He hacks bank 2, then strengths of the banks become [3,  - ,  - ,  - ,  - ].  He completes his goal by hacking bank 1. \n\nIn the second sample, Inzane can hack banks 4, 2, 3, 1, 5, 7, and 6, in this order. This way, he can hack all banks using a computer with strength 93.",
  "solutions": "[\"def sol():\\n\\n    n = int(input())\\n    st = list(map(int, input().split(' ')))\\n    d = {}\\n    for x in range(n):\\n        d[x] = []\\n\\n    st = [(st[i], i) for i in range(len(st))]\\n    st = sorted(st)\\n\\n    for a0 in range(n - 1):\\n        u, v = map(int, input().split(' '))\\n        u, v = u - 1, v - 1\\n        d[u].append(v)\\n        d[v].append(u)\\n\\n    hardest = []\\n    almost = []\\n\\n    single_hardest = st[-1][0]\\n\\n    for x in st[::-1]:\\n        if x[0] == single_hardest:\\n            hardest.append(x[1])\\n        elif x[0] == single_hardest-1:\\n            almost.append(x[1])\\n        else:\\n            break\\n\\n    def inter(a, b):\\n        c = []\\n        for x in a:\\n            if x in b:\\n                c.append(x)\\n        return c\\n\\n    lower_bound = single_hardest\\n\\n    inte = d[hardest[0]]+[hardest[0]]\\n    for h in hardest[1:]:\\n        inte = inter(inte, d[h]+[h])\\n\\n    if not inte:\\n        return (single_hardest+2)\\n\\n    if len(hardest) > 1:\\n        return single_hardest+1\\n\\n    # hardest is len 1\\n    if not almost:\\n        return single_hardest\\n\\n    cand = st[-1][1]\\n\\n    for h in almost:\\n        if h not in d[cand]:\\n            return single_hardest+1\\n    return single_hardest\\n\\nprint(sol())\", \"n = int(input())\\n\\nstrengths = list(map(int, input().split()))\\nmax_strength = max(strengths)\\n\\ncount_max = strengths.count(max_strength)\\ncount_second_place = strengths.count(max_strength - 1)\\n\\nmaxes = [0 for i in range(n)]\\nsecond_places = [0 for i in range(n)]\\n\\nfor i in range(n - 1):\\n    a, b = list(map(int, input().split()))\\n    a -= 1\\n    b -= 1\\n    if strengths[a] == max_strength:\\n        maxes[b] += 1\\n    elif strengths[a] == max_strength - 1:\\n        second_places[b] += 1\\n\\n    if strengths[b] == max_strength:\\n        maxes[a] += 1\\n    elif strengths[b] == max_strength - 1:\\n        second_places[a] += 1\\n\\ntotal_max = 1000000009\\nfor i in range(n):\\n    here = 0\\n    if strengths[i] < max_strength:\\n        if maxes[i] == count_max:\\n            here = max_strength + 1\\n        else:\\n            here = max_strength + 2\\n    else:\\n        if count_max == 1:\\n            if second_places[i] == count_second_place:\\n                here = max_strength\\n            else:\\n                here = max_strength + 1\\n        else:\\n            if maxes[i] == count_max - 1:\\n                here = max_strength + 1\\n            else:\\n                here = max_strength + 2\\n    total_max = min(total_max, here)\\n\\nprint(total_max)\\n\", \"import sys\\n\\ndef solve():\\n    n = int(sys.stdin.readline().rstrip())\\n    a = [int(i) for i in sys.stdin.readline().split()]\\n    Adj = [[] for i in range(n)]\\n\\n    for i in range(n - 1):\\n        u, v = map(int, sys.stdin.readline().split())\\n        u, v = u-1, v-1\\n        Adj[u].append(v)\\n        Adj[v].append(u)\\n\\n    max_v = max(a)\\n    max_n = a.index(max_v)\\n    num_m = sum(ai == max_v for ai in a)\\n\\n    if num_m == 1:\\n        ans = max_v\\n\\n        rinsetu = [False] * n\\n\\n        for u in Adj[max_n]:\\n            rinsetu[u] = True\\n\\n        rinsetu[max_n] = True\\n\\n        for u in range(n):\\n            if rinsetu[u]:\\n                continue\\n            if a[u] == max_v - 1:\\n                ans = max_v + 1\\n                break\\n    else:\\n        for u in range(n):\\n            cnt = 0\\n\\n            if a[u] == max_v:\\n                cnt += 1\\n\\n            for v in Adj[u]:\\n                if a[v] == max_v:\\n                    cnt += 1\\n\\n            if cnt == num_m:\\n                ans = max_v + 1\\n                break\\n        else:\\n            ans = max_v + 2\\n\\n    print(ans)\\n\\n\\ndef debug(x, table):\\n    for name, val in table.items():\\n        if x is val:\\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\\n            return None\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\n\\ndef solve():\\n    n = int(sys.stdin.readline().rstrip())\\n    a = [int(i) for i in sys.stdin.readline().split()]\\n    Adj = [[] for i in range(n)]\\n\\n    for i in range(n - 1):\\n        u, v = map(int, sys.stdin.readline().split())\\n        u, v = u-1, v-1\\n        Adj[u].append(v)\\n        Adj[v].append(u)\\n\\n    max_v = max(a)\\n    max_n = a.index(max_v)\\n    num_m = sum(ai == max_v for ai in a)\\n\\n    if num_m == 1:\\n        ans = max_v\\n\\n        rinsetu = [False] * n\\n\\n        for u in Adj[max_n]:\\n            rinsetu[u] = True\\n\\n        rinsetu[max_n] = True\\n\\n        for u in range(n):\\n            if rinsetu[u]:\\n                continue\\n            if a[u] == max_v - 1:\\n                ans = max_v + 1\\n                break\\n    else:\\n        for u in range(n):\\n            cnt = 0\\n\\n            if a[u] == max_v:\\n                cnt += 1\\n\\n            for v in Adj[u]:\\n                if a[v] == max_v:\\n                    cnt += 1\\n\\n            if cnt == num_m:\\n                ans = max_v + 1\\n                break\\n        else:\\n            ans = max_v + 2\\n\\n    print(ans)\\n\\n\\ndef debug(x, table):\\n    for name, val in table.items():\\n        if x is val:\\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\\n            return None\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\n\\ndef solve():\\n    n = int(sys.stdin.readline().rstrip())\\n    a = [int(i) for i in sys.stdin.readline().split()]\\n    Adj = [[] for i in range(n)]\\n\\n    for i in range(n - 1):\\n        u, v = map(int, sys.stdin.readline().split())\\n        u, v = u-1, v-1\\n        Adj[u].append(v)\\n        Adj[v].append(u)\\n\\n    max_v = max(a)\\n    num_m = sum(ai == max_v for ai in a)\\n\\n    if num_m == 1:\\n        ans = max_v\\n        max_n = a.index(max_v)\\n\\n        rinsetu = set(Adj[max_n])\\n        rinsetu.add(max_n)\\n\\n        for u in range(n):\\n            if u in rinsetu:\\n                continue\\n            if a[u] == max_v - 1:\\n                ans = max_v + 1\\n                break\\n    else:\\n        for u in range(n):\\n            cnt = 0\\n\\n            if a[u] == max_v:\\n                cnt += 1\\n\\n            for v in Adj[u]:\\n                if a[v] == max_v:\\n                    cnt += 1\\n\\n            if cnt == num_m:\\n                ans = max_v + 1\\n                break\\n        else:\\n            ans = max_v + 2\\n\\n    print(ans)\\n\\n\\ndef debug(x, table):\\n    for name, val in table.items():\\n        if x is val:\\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\\n            return None\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\nn=int(sys.stdin.readline())\\nd=list(map(int,sys.stdin.readline().split()))\\ns=[[] for g in d]\\nmxpt=[-2e9,-2e9]\\nmxcnt=[0,0]\\nfor i in d:\\n\\tif i>mxpt[0]:\\n\\t\\tmxpt[1]=mxpt[0]\\n\\t\\tmxcnt[1]=mxcnt[0]\\n\\t\\tmxpt[0]=i\\n\\t\\tmxcnt[0]=1\\n\\telif i==mxpt[0]:\\n\\t\\tmxcnt[0]+=1\\n\\telif i>mxpt[1]:\\n\\t\\tmxpt[1]=i\\n\\t\\tmxcnt[1]=1\\n\\telse: mxcnt[1]+=(i==mxpt[1])\\nfor i in range(1,n):\\n\\ta,b=map(int,sys.stdin.readline().split())\\n\\ta-=1;\\n\\tb-=1;\\n\\ts[a]+=[b]\\n\\ts[b]+=[a]\\n\\nmx=int(2e9)\\nfor i in range(n):\\n\\tnmx=[]+mxcnt\\n\\ttmpmax=d[i]\\n\\tfor k in s[i]:\\n\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\tnmx[1]-=1\\n\\n\\tif nmx[0]!=mxcnt[0]:\\n\\t\\ttmpmax=mxpt[0]+1\\n\\telif nmx[1]!=mxcnt[1]:\\n\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\tif d[i]==mxpt[0]:\\n\\t\\tnmx[0]-=1\\n\\telif d[i]==mxpt[1]:\\n\\t\\tnmx[1]-=1\\n\\n\\tif nmx[0]:\\n\\t\\ttmpmax=mxpt[0]+2\\n\\telif nmx[1]:\\n\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\tmx=min(mx,tmpmax)\\nprint(mx)\", \"import sys\\nn=int(sys.stdin.readline())\\nd=list(map(int,sys.stdin.readline().split()))\\ns=[[] for g in d]\\nmx_tmp=max(d)\\nmx_tmp2=max(g for g in d+[-2e9] if g<mx_tmp)\\nmxpt=[mx_tmp,mx_tmp2]\\nmxcnt=[d.count(mx_tmp),d.count(mx_tmp2)]\\nfor i in range(1,n):\\n\\ta,b=map(int,sys.stdin.readline().split())\\n\\ta-=1;\\n\\tb-=1;\\n\\ts[a]+=[b]\\n\\ts[b]+=[a]\\n\\nmx=int(2e9)\\nfor i in range(n):\\n\\tnmx=[]+mxcnt\\n\\ttmpmax=d[i]\\n\\tfor k in s[i]:\\n\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\tnmx[1]-=1\\n\\n\\tif nmx[0]!=mxcnt[0]:\\n\\t\\ttmpmax=mxpt[0]+1\\n\\telif nmx[1]!=mxcnt[1]:\\n\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\tif d[i]==mxpt[0]:\\n\\t\\tnmx[0]-=1\\n\\telif d[i]==mxpt[1]:\\n\\t\\tnmx[1]-=1\\n\\n\\tif nmx[0]:\\n\\t\\ttmpmax=mxpt[0]+2\\n\\telif nmx[1]:\\n\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\tmx=min(mx,tmpmax)\\nprint(mx)\", \"import sys\\ndef solve():\\n\\tn=int(sys.stdin.readline())\\n\\td=list(map(int,sys.stdin.readline().split()))\\n\\ts=[[] for g in d]\\n\\tmx_tmp=max(d)\\n\\tmx_tmp2=max(g for g in d+[-2e9] if g<mx_tmp)\\n\\tmxpt=[mx_tmp,mx_tmp2]\\n\\tmxcnt=[d.count(mx_tmp),d.count(mx_tmp2)]\\n\\tfor i in range(1,n):\\n\\t\\ta,b=map(int,sys.stdin.readline().split())\\n\\t\\ta-=1;\\n\\t\\tb-=1;\\n\\t\\ts[a]+=[b]\\n\\t\\ts[b]+=[a]\\n\\n\\tmx=int(2e9)\\n\\tfor i in range(n):\\n\\t\\tnmx=[]+mxcnt\\n\\t\\ttmpmax=d[i]\\n\\t\\tfor k in s[i]:\\n\\t\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[0]-=1\\n\\t\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]!=mxcnt[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+1\\n\\t\\telif nmx[1]!=mxcnt[1]:\\n\\t\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\t\\tif d[i]==mxpt[0]:\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[i]==mxpt[1]:\\n\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+2\\n\\t\\telif nmx[1]:\\n\\t\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\t\\tmx=min(mx,tmpmax)\\n\\tprint(mx)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\ndef solve():\\n\\tn=int(sys.stdin.readline())\\n\\td=list(map(int,sys.stdin.readline().split()))\\n\\ts=[[] for g in d]\\n\\tmx_tmp=max(d)\\n\\tmx_tmp2=max(g for g in d+[-2e9] if g<mx_tmp)\\n\\tmxpt=[mx_tmp,mx_tmp2]\\n\\tmxcnt=[d.count(mx_tmp),d.count(mx_tmp2)]\\n\\tfor i in range(1,n):\\n\\t\\ta,b=map(int,sys.stdin.readline().split())\\n\\t\\ta-=1;\\n\\t\\tb-=1;\\n\\t\\ts[a]+=[b]\\n\\t\\ts[b]+=[a]\\n\\n\\tmx=int(2e9)\\n\\tfor i in range(n):\\n\\t\\tnmx=[]+mxcnt\\n\\t\\ttmpmax=d[i]\\n\\t\\tfor k in s[i]:\\n\\t\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[0]-=1\\n\\t\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]!=mxcnt[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+1\\n\\t\\telif nmx[1]!=mxcnt[1]:\\n\\t\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\t\\tif d[i]==mxpt[0]:\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[i]==mxpt[1]:\\n\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+2\\n\\t\\telif nmx[1]:\\n\\t\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\t\\tmx=min(mx,tmpmax)\\n\\tprint(mx)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\ndef solve():\\n\\tn=int(sys.stdin.readline())\\n\\td=list(map(int,sys.stdin.readline().split()))\\n\\ts=[[] for g in d]\\n\\tmx_tmp=max(d)\\n\\tmx_tmp2=max(g for g in d+[-2e9] if g<mx_tmp)\\n\\tmxpt=[mx_tmp,mx_tmp2]\\n\\tmxcnt=[d.count(mx_tmp),d.count(mx_tmp2)]\\n\\tfor i in range(1,n):\\n\\t\\ta,b=map(int,sys.stdin.readline().split())\\n\\t\\t\\n\\t\\ta-=1;\\n\\t\\tb-=1;\\n\\t\\ts[a]+=[b]\\n\\t\\ts[b]+=[a]\\n\\n\\tmx=int(2e9)\\n\\tfor i in range(n):\\n\\t\\tnmx=[]+mxcnt\\n\\t\\ttmpmax=d[i]\\n\\t\\tfor k in s[i]:\\n\\t\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[0]-=1\\n\\t\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]!=mxcnt[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+1\\n\\t\\telif nmx[1]!=mxcnt[1]:\\n\\t\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\t\\tif d[i]==mxpt[0]:\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[i]==mxpt[1]:\\n\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+2\\n\\t\\telif nmx[1]:\\n\\t\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\t\\tmx=min(mx,tmpmax)\\n\\tprint(mx)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\nn=int(sys.stdin.readline())\\nd=list(map(int,sys.stdin.readline().split()))\\ns=[[] for g in d]\\nmx_tmp=max(d)\\nmx_tmp2=max(g for g in d+[-2e9] if g<mx_tmp)\\nmxpt=[mx_tmp,mx_tmp2]\\nmxcnt=[d.count(mx_tmp),d.count(mx_tmp2)]\\nfor i in range(1,n):\\n\\ta,b=list(map(int,sys.stdin.readline().split()))\\n\\n\\ta-=1;\\n\\tb-=1;\\n\\ts[a]+=[b]\\n\\ts[b]+=[a]\\n\\nmx=int(2e9)\\nfor i in range(n):\\n\\tnmx=[]+mxcnt\\n\\ttmpmax=d[i]\\n\\tfor k in s[i]:\\n\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\tnmx[1]-=1\\n\\n\\tif nmx[0]!=mxcnt[0]:\\n\\t\\ttmpmax=mxpt[0]+1\\n\\telif nmx[1]!=mxcnt[1]:\\n\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\tif d[i]==mxpt[0]:\\n\\t\\tnmx[0]-=1\\n\\telif d[i]==mxpt[1]:\\n\\t\\tnmx[1]-=1\\n\\n\\tif nmx[0]:\\n\\t\\ttmpmax=mxpt[0]+2\\n\\telif nmx[1]:\\n\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\tmx=min(mx,tmpmax)\\nprint(mx)\\n\\n\", \"import sys\\ndef solve():\\n\\tn=int(sys.stdin.readline())\\n\\td=list(map(int,sys.stdin.readline().split()))\\n\\ts=[[] for g in d]\\n\\tmx_tmp=max(d)\\n\\tmx_tmp2=max(g for g in d+[-2e9] if g<mx_tmp)\\n\\tmxpt=[mx_tmp,mx_tmp2]\\n\\tmxcnt=[d.count(mx_tmp),d.count(mx_tmp2)]\\n\\tfor i in range(1,n):\\n\\t\\ta,b=map(int,sys.stdin.readline().split())\\n\\t\\t\\n\\t\\ta-=1;\\n\\t\\tb-=1;\\n\\t\\ts[a]+=[b]\\n\\t\\ts[b]+=[a]\\n\\n\\tmx=int(2e9)\\n\\tfor i in range(n):\\n\\t\\tnmx=[]+mxcnt\\n\\t\\ttmpmax=d[i]\\n\\t\\tfor k in s[i]:\\n\\t\\t\\tif d[k]==mxpt[0]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[0]-=1\\n\\t\\t\\telif d[k]==mxpt[1]:\\t\\t\\t\\n\\t\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]!=mxcnt[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+1\\n\\t\\telif nmx[1]!=mxcnt[1]:\\n\\t\\t\\ttmpmax=max(tmpmax,mxpt[1]+1)\\n\\n\\t\\tif d[i]==mxpt[0]:\\n\\t\\t\\tnmx[0]-=1\\n\\t\\telif d[i]==mxpt[1]:\\n\\t\\t\\tnmx[1]-=1\\n\\n\\t\\tif nmx[0]:\\n\\t\\t\\ttmpmax=mxpt[0]+2\\n\\t\\telif nmx[1]:\\n\\t\\t\\ttmpmax=max(mxpt[1]+2,tmpmax)\\n\\t\\tmx=min(mx,tmpmax)\\n\\tprint(mx)\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"import sys\\n\\ndef solve():\\n    n = int(sys.stdin.readline().rstrip())\\n    a = [int(i) for i in sys.stdin.readline().split()]\\n    Adj = [[] for i in range(n)]\\n\\n    for i in range(n - 1):\\n        u, v = map(int, sys.stdin.readline().split())\\n        u, v = u-1, v-1\\n        Adj[u].append(v)\\n        Adj[v].append(u)\\n\\n    max_v = max(a)\\n    max_n = a.index(max_v)\\n    num_m = sum(ai == max_v for ai in a)\\n\\n    if num_m == 1:\\n        ans = max_v\\n\\n        rinsetu = [False] * n\\n\\n        for u in Adj[max_n]:\\n            rinsetu[u] = True\\n\\n        rinsetu[max_n] = True\\n\\n        for u in range(n):\\n            if rinsetu[u]:\\n                continue\\n            if a[u] == max_v - 1:\\n                ans = max_v + 1\\n                break\\n    else:\\n        for u in range(n):\\n            cnt = 0\\n\\n            if a[u] == max_v:\\n                cnt += 1\\n\\n            for v in Adj[u]:\\n                if a[v] == max_v:\\n                    cnt += 1\\n\\n            if cnt == num_m:\\n                ans = max_v + 1\\n                break\\n        else:\\n            ans = max_v + 2\\n\\n    print(ans)\\n\\n\\ndef debug(x, table):\\n    for name, val in table.items():\\n        if x is val:\\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\\n            return None\\n\\ndef __starting_point():\\n    solve()\\n__starting_point()\", \"def main():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    graph = [[] for _ in range(n)]\\n    for i in range(n - 1):\\n        u, v = [int(x) - 1 for x in input().split()]\\n        graph[u].append(v)\\n        graph[v].append(u)\\n\\n    a_max = max(a)\\n    max_count_0 = sum(ai == a_max for ai in a)\\n    prev_count_0 = sum(ai == a_max - 1 for ai in a)\\n\\n    result = a_max + 2\\n    for u in range(n):\\n        max_count = max_count_0\\n        prev_count = prev_count_0\\n        if a[u] == a_max:\\n            max_count -= 1\\n        else:\\n            prev_count -= 1\\n\\n        for v in graph[u]:\\n            if a[v] == a_max:\\n                max_count -= 1\\n                prev_count += 1\\n            elif a[v] == a_max - 1:\\n                prev_count -= 1\\n\\n        if max_count == 0:\\n            if prev_count == 0:\\n                result = a_max\\n                break\\n            else:\\n                result = a_max + 1\\n\\n    print(result)\\n\\n\\ndef __starting_point():\\n    # import sys\\n    # sys.stdin = open(\\\"C.txt\\\")\\n    main()\\n\\n__starting_point()\", \"\\nimport random\\nn = int(input())\\nstrengths = list(map(int,input().split()))\\nl = [[] for i in range(n)]\\nfor j in range(n-1):\\n    a,b = list(map(int,input().split()))\\n    l[a-1].append(b-1)\\n    l[b-1].append(a-1)\\nhacked = max(strengths)\\ngreatest_value = sum(i==hacked for i in strengths)\\nresult = hacked\\nif greatest_value == 1:\\n    computer = strengths.index(result)\\n    adjlist = set(l[computer])\\n    adjlist.add(computer)\\n    for i in range(n):\\n        if i in adjlist:\\n            continue\\n        if strengths[i] == hacked - 1:\\n            result += 1\\n            break\\nelse:\\n    for i in range(n):\\n        count = 0\\n        if strengths[i] == hacked:\\n            count += 1\\n        for v in l[i]:\\n            if strengths[v] == hacked:\\n                count += 1\\n        if count == greatest_value:\\n            result += 1\\n            break\\n    else:\\n        result += 2\\nprint (result)\\n\\n\", \"from collections import defaultdict, Counter\\n\\nn = int(input())\\na = list(int(v) for v in input().split()) + [-1000000002]\\nc = Counter(a)\\n#print(a, set(a), sorted(set(a)))\\ntop, sec = sorted(set(a))[-1:-3:-1]\\ntopC, secC = [0]*n, [0]*n\\n#print(top, c[top], sec, c[sec])\\nfor i in range(n-1):\\n    u, v = (int(v) for v in input().split())\\n    if a[u-1] == top: topC[v-1] += 1\\n    if a[v-1] == top: topC[u-1] += 1\\n    if a[u-1] == sec: secC[v-1] += 1\\n    if a[v-1] == sec: secC[u-1] += 1\\n\\nans = top+2 # worst case\\nfor i in range(n):\\n    # Process top numbers\\n    add = 1 if a[i] == top else 0 # haista vittu\\n    if topC[i]+add < c[top]: continue # there are tops beyond connected\\n    best = top+1 if topC[i] else top # sole top or tops connected\\n    # Second top can be nexus only if all tops are connected to it\\n\\n    # Process second numbers\\n    add = 1 if a[i] == sec else 0 # haista vittu\\n    if secC[i]+add < c[sec]: best = max(best, sec+2) # seconds beyond\\n    # sec+1 <= top so we're done\\n\\n    ans = min(ans, best)\\n\\nprint(ans)\\n\", \"from collections import Counter\\n\\nn = int(input())\\na = list(int(v) for v in input().split()) + [-1000000002]\\nc = Counter(a)\\n\\ntop, sec = sorted(set(a))[-1:-3:-1]\\ntopC = [1 if v==top else 0 for v in a]\\nsecC = [1 if v==sec else 0 for v in a]\\n\\n#print(top, topC)\\n#print(sec, secC)\\n\\nfor i in range(n-1):\\n    u, v = (int(v) for v in input().split())\\n    if a[u-1] == top: topC[v-1] += 1\\n    if a[v-1] == top: topC[u-1] += 1\\n    if a[u-1] == sec: secC[v-1] += 1\\n    if a[v-1] == sec: secC[u-1] += 1\\n\\nans = top+2 # worst case\\nfor i in range(n):\\n    if topC[i] < c[top]: continue # can only get top+2 here\\n\\n    best = top if topC[i]==1 and a[i]==top else top+1 # sole top or else\\n\\n    if secC[i] < c[sec]: best = max(best, sec+2) # seconds beyond\\n\\n    ans = min(ans, best)\\n\\nprint(ans)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"5\\n1 2 3 4 5\\n1 2\\n2 3\\n3 4\\n4 5\\n\",\n    \"7\\n38 -29 87 93 39 28 -55\\n1 2\\n2 5\\n3 2\\n2 4\\n1 7\\n7 6\\n\",\n    \"5\\n1 2 7 6 7\\n1 5\\n5 3\\n3 4\\n2 4\\n\",\n    \"3\\n2 2 2\\n3 2\\n1 2\\n\",\n    \"3\\n999397 999397 999397\\n2 3\\n2 1\\n\",\n    \"5\\n1000000000 0 1000000000 0 1000000000\\n1 2\\n2 3\\n3 4\\n4 5\\n\",\n    \"10\\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000\\n10 3\\n7 4\\n2 6\\n9 2\\n5 10\\n1 8\\n7 8\\n7 2\\n10 6\\n\",\n    \"1\\n0\\n\",\n    \"2\\n0 0\\n2 1\\n\",\n    \"3\\n0 0 0\\n1 3\\n2 3\\n\",\n    \"1\\n0\\n\",\n    \"2\\n0 0\\n2 1\\n\",\n    \"2\\n0 1\\n2 1\\n\",\n    \"3\\n0 0 0\\n1 3\\n2 3\\n\",\n    \"3\\n1 0 0\\n2 1\\n3 2\\n\",\n    \"3\\n-2 -2 2\\n1 3\\n2 1\\n\",\n    \"4\\n0 0 0 0\\n2 4\\n1 4\\n3 2\\n\",\n    \"4\\n0 0 0 -1\\n3 1\\n4 1\\n2 4\\n\",\n    \"4\\n1 -2 2 2\\n4 3\\n2 4\\n1 2\\n\",\n    \"5\\n0 0 0 0 0\\n3 2\\n1 2\\n5 1\\n4 2\\n\",\n    \"5\\n-1 -1 -1 0 0\\n4 3\\n5 3\\n1 4\\n2 5\\n\",\n    \"5\\n-2 -1 -2 1 0\\n3 1\\n5 1\\n2 1\\n4 2\\n\",\n    \"1\\n-1000000000\\n\",\n    \"2\\n-1000000000 -1000000000\\n2 1\\n\",\n    \"2\\n-999999999 -1000000000\\n1 2\\n\",\n    \"3\\n-1000000000 -1000000000 -1000000000\\n3 1\\n2 1\\n\",\n    \"3\\n-1000000000 -999999999 -1000000000\\n1 2\\n3 1\\n\",\n    \"3\\n-999999999 -999999998 -1000000000\\n2 3\\n1 2\\n\",\n    \"1\\n1000000000\\n\",\n    \"2\\n1000000000 1000000000\\n2 1\\n\",\n    \"2\\n999999999 1000000000\\n2 1\\n\",\n    \"3\\n1000000000 1000000000 1000000000\\n1 3\\n2 1\\n\",\n    \"3\\n999999999 1000000000 1000000000\\n2 1\\n3 2\\n\",\n    \"3\\n999999998 999999998 999999998\\n1 3\\n2 1\\n\",\n    \"3\\n1000000000 -1000000000 1000000000\\n1 2\\n2 3\\n\",\n    \"4\\n1000000000 -1000000000 -1000000000 1000000000\\n1 2\\n3 2\\n4 3\\n\",\n    \"1\\n-1000000000\\n\",\n    \"2\\n-1000000000 -1\\n1 2\\n\",\n    \"3\\n-1 -1000000000 -1000000000\\n2 1\\n3 1\\n\",\n    \"5\\n-1 -1000000000 -1 -2 -1\\n5 2\\n1 2\\n3 2\\n4 1\\n\",\n    \"10\\n-2 -1000000000 -2 -1000000000 -2 -5 -3 -1 -2 -1000000000\\n8 6\\n10 6\\n5 10\\n3 10\\n7 5\\n2 8\\n1 6\\n4 1\\n9 5\\n\",\n    \"4\\n1 2 2 2\\n1 2\\n1 3\\n1 4\\n\",\n    \"5\\n1 1 7 7 7\\n1 3\\n2 3\\n3 4\\n4 5\\n\",\n    \"3\\n10 1 10\\n1 2\\n2 3\\n\",\n    \"3\\n8 7 8\\n1 2\\n2 3\\n\",\n    \"1\\n-11\\n\",\n    \"6\\n10 1 10 1 1 1\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n\",\n    \"3\\n7 6 7\\n1 2\\n2 3\\n\",\n    \"7\\n5 0 0 0 0 5 5\\n1 2\\n1 3\\n1 4\\n1 5\\n4 6\\n4 7\\n\",\n    \"4\\n7 1 1 7\\n1 2\\n1 3\\n3 4\\n\",\n    \"6\\n5 5 5 4 4 4\\n1 2\\n1 3\\n3 4\\n3 5\\n3 6\\n\",\n    \"4\\n1 93 93 93\\n1 2\\n1 3\\n1 4\\n\",\n    \"3\\n2 1 2\\n1 2\\n2 3\\n\",\n    \"6\\n10 10 10 1 1 1\\n1 2\\n2 3\\n3 4\\n1 5\\n1 6\\n\"\n  ],\n  \"outputs\": [\n    \"5\",\n    \"93\",\n    \"8\",\n    \"3\",\n    \"999398\",\n    \"1000000002\",\n    \"-999999998\",\n    \"0\",\n    \"1\",\n    \"1\",\n    \"0\",\n    \"1\",\n    \"1\",\n    \"1\",\n    \"2\",\n    \"2\",\n    \"2\",\n    \"2\",\n    \"3\",\n    \"2\",\n    \"1\",\n    \"2\",\n    \"-1000000000\",\n    \"-999999999\",\n    \"-999999999\",\n    \"-999999999\",\n    \"-999999998\",\n    \"-999999998\",\n    \"1000000000\",\n    \"1000000001\",\n    \"1000000000\",\n    \"1000000001\",\n    \"1000000001\",\n    \"999999999\",\n    \"1000000001\",\n    \"1000000002\",\n    \"-1000000000\",\n    \"-1\",\n    \"-1\",\n    \"0\",\n    \"0\",\n    \"3\",\n    \"8\",\n    \"11\",\n    \"9\",\n    \"-11\",\n    \"11\",\n    \"8\",\n    \"6\",\n    \"8\",\n    \"6\",\n    \"94\",\n    \"3\",\n    \"11\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/796/C",
  "starter_code": ""
}