{
  "task_id": "APPS/432",
  "problem_id": 432,
  "prompt": "Medicine faculty of Berland State University has just finished their admission campaign. As usual, about $80\\%$ of applicants are girls and majority of them are going to live in the university dormitory for the next $4$ (hopefully) years.\n\nThe dormitory consists of $n$ rooms and a single mouse! Girls decided to set mouse traps in some rooms to get rid of the horrible monster. Setting a trap in room number $i$ costs $c_i$ burles. Rooms are numbered from $1$ to $n$.\n\nMouse doesn't sit in place all the time, it constantly runs. If it is in room $i$ in second $t$ then it will run to room $a_i$ in second $t + 1$ without visiting any other rooms inbetween ($i = a_i$ means that mouse won't leave room $i$). It's second $0$ in the start. If the mouse is in some room with a mouse trap in it, then the mouse get caught into this trap.\n\nThat would have been so easy if the girls actually knew where the mouse at. Unfortunately, that's not the case, mouse can be in any room from $1$ to $n$ at second $0$.\n\nWhat it the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from?\n\n\n-----Input-----\n\nThe first line contains as single integers $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the number of rooms in the dormitory.\n\nThe second line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le 10^4$) \u2014 $c_i$ is the cost of setting the trap in room number $i$.\n\nThe third line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) \u2014 $a_i$ is the room the mouse will run to the next second after being in room $i$.\n\n\n-----Output-----\n\nPrint a single integer \u2014 the minimal total amount of burles girls can spend to set the traps in order to guarantee that the mouse will eventually be caught no matter the room it started from.\n\n\n-----Examples-----\nInput\n5\n1 2 3 2 10\n1 3 4 3 3\n\nOutput\n3\n\nInput\n4\n1 10 2 10\n2 4 2 2\n\nOutput\n10\n\nInput\n7\n1 1 1 1 1 1 1\n2 2 2 3 6 7 6\n\nOutput\n2\n\n\n\n-----Note-----\n\nIn the first example it is enough to set mouse trap in rooms $1$ and $4$. If mouse starts in room $1$ then it gets caught immideately. If mouse starts in any other room then it eventually comes to room $4$.\n\nIn the second example it is enough to set mouse trap in room $2$. If mouse starts in room $2$ then it gets caught immideately. If mouse starts in any other room then it runs to room $2$ in second $1$.\n\nHere are the paths of the mouse from different starts from the third example:\n\n  $1 \\rightarrow 2 \\rightarrow 2 \\rightarrow \\dots$;  $2 \\rightarrow 2 \\rightarrow \\dots$;  $3 \\rightarrow 2 \\rightarrow 2 \\rightarrow \\dots$;  $4 \\rightarrow 3 \\rightarrow 2 \\rightarrow 2 \\rightarrow \\dots$;  $5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 6 \\rightarrow \\dots$;  $6 \\rightarrow 7 \\rightarrow 6 \\rightarrow \\dots$;  $7 \\rightarrow 6 \\rightarrow 7 \\rightarrow \\dots$; \n\nSo it's enough to set traps in rooms $2$ and $6$.",
  "solutions": "[\"import sys\\n\\nrd = lambda : sys.stdin.readline().rstrip()\\n\\nn = int(rd())\\nc = list(map(int, rd().split()))\\na = list([int(x)-1 for x in rd().split()])\\n\\nvisited = [-1] * (n)\\nres = 0\\n\\nfor i in range(n):\\n    trace = []\\n    \\n    t = i\\n    mn = 1e9\\n    while visited[t] == -1:\\n        visited[t] = i\\n        trace.append(t)\\n        t = a[t]\\n        \\n    if visited[t] != i:\\n        continue\\n        \\n    while len(trace) > 0:\\n        v = trace.pop()\\n        mn = min(mn, c[v]) \\n        \\n        if t == v: break\\n    \\n    res += mn\\n    \\nprint(res)\\n\", \"input()\\nc = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\nu = [0] * len(a)\\n\\nans = 0\\n\\nfor i in range(len(a)):\\n    if u[i] != 0:\\n        continue\\n    idx = i\\n    while u[idx] == 0:\\n        u[idx] = 1\\n        idx = a[idx] - 1\\n    \\n    if (u[idx] == 2):\\n        idx = i\\n        while u[idx] == 1:\\n            u[idx] = 2\\n            idx = a[idx] - 1\\n        continue\\n\\n    start = idx\\n    mn = c[idx]\\n    u[idx] = 2\\n    while a[idx] - 1 != start:\\n        idx = a[idx] - 1\\n        mn = min(mn, c[idx])\\n        u[idx] = 2\\n\\n    idx = i\\n    while u[idx] == 1:\\n        u[idx] = 2\\n        idx = a[idx] - 1\\n    ans += mn\\nprint(ans)\\n\", \"input()\\nc = list(map(int, input().split()))\\na = list(map(int, input().split()))\\n\\nu = [0] * len(a)\\n\\nans = 0\\n\\nfor i in range(len(a)):\\n    if u[i] != 0:\\n        continue\\n    idx = i\\n    while u[idx] == 0:\\n        u[idx] = 1\\n        idx = a[idx] - 1\\n    \\n    if (u[idx] == 2):\\n        idx = i\\n        while u[idx] == 1:\\n            u[idx] = 2\\n            idx = a[idx] - 1\\n        continue\\n\\n    start = idx\\n    mn = c[idx]\\n    u[idx] = 2\\n    while a[idx] - 1 != start:\\n        idx = a[idx] - 1\\n        mn = min(mn, c[idx])\\n        u[idx] = 2\\n\\n    idx = i\\n    while u[idx] == 1:\\n        u[idx] = 2\\n        idx = a[idx] - 1\\n    ans += mn\\nprint(ans)\", \"n = int(input())\\nc = [0] + [int(j) for j in input().split()]\\na = [0] + [int(j) for j in input().split()]\\nvis = [0] * (n + 1)\\nans = 0\\nfor i in range(1, n + 1):\\n    x = i\\n    while vis[x] == 0:\\n        vis[x] = i\\n        x = a[x]\\n    if vis[x] != i:\\n        continue\\n    v = x\\n    mn = c[x]\\n    while a[x] != v:\\n        x = a[x]\\n        mn = min(mn, c[x])\\n    ans += mn\\nprint(ans)\\n\", \"n = int(input())\\nc  = [0] + [int(j) for j in input().split()]\\na  = [0] + [int(j) for j in input().split()]\\n\\nvis = [0] * (n+1)\\nans = 0\\nfor i in range(1,n+1):\\n    x = i\\n    while vis[x] == 0:\\n        vis[x] = i\\n        x = a[x]\\n    if vis[x] != i:\\n        continue\\n    v = x\\n    mn = c[x]\\n    while a[x] != v:\\n        x = a[x]\\n        mn = min(mn,c[x])\\n    ans+=mn\\nprint(ans)\\n\", \"n = int(input())\\nC = [int(s) for s in input().split(\\\" \\\")]\\nA = [int(s)-1 for s in input().split(\\\" \\\")]\\nal = [False for i in range(0, n)]\\nans = 0\\nfor v in range(0, n):\\n    if al[v]:\\n        continue\\n    sequence = []\\n    while not al[v]:\\n        sequence.append(v)\\n        al[v] = True\\n        v = A[v]\\n    if v in sequence:\\n        tek = C[v]\\n        for j in sequence[sequence.index(v)+1:]:\\n            tek = min(C[j], tek)\\n        ans += tek\\nprint(ans)\", \"n=int(input())\\ncst=list(map(int,input().split()))\\nroute=list(map(int,input().split()))\\nvisited=[0]*n\\ncost=0\\nfor i in range(n):\\n\\tif visited[i]==0:\\n\\t\\tmini=99999999\\n\\t\\tj=i\\n\\t\\twhile(visited[j]==0):\\n\\t\\t\\tvisited[j]=i+1\\n\\t\\t\\tj=route[j]-1\\n\\t\\t\\t#print(visited,j)\\n\\t\\t\\tif visited[j]==i+1:\\n\\t\\t\\t\\tmini=cst[j]\\n\\t\\t\\t\\tk=route[j]-1\\n\\t\\t\\t\\twhile(k!=j):\\n\\t\\t\\t\\t\\t#print(k,j)\\n\\t\\t\\t\\t\\tif cst[k]<mini:\\n\\t\\t\\t\\t\\t\\tmini=cst[k]\\n\\t\\t\\t\\t\\tk=route[k]-1\\n\\t\\tif mini!=99999999:\\n\\t\\t\\tcost+=mini\\nprint(cost)\\n\", \"n = int(input())\\nc = list(map(int, input().split()))\\na = list([int(x) - 1 for x in input().split()])\\nb = [None] * n\\nprocessed = [False for i in range(n)]\\nfor i in range(n):\\n    if not b[a[i]]:\\n        b[a[i]] = {i}\\n    else:\\n        b[a[i]].add(i)\\n\\nrings = []\\n\\n\\ndef processed_ring(ring):\\n    copy_ring = ring.copy()\\n    while copy_ring:\\n        new_ring = set()\\n        for el in copy_ring:\\n            processed[el] = True\\n            if b[el]:\\n                new_ring |= b[el]\\n        copy_ring = new_ring - copy_ring\\n\\n\\nfor i in range(n):\\n    if processed[i]:\\n        continue\\n    ring = set()\\n    position = set()\\n    next_pos = i\\n    while next_pos not in position:\\n        position.add(next_pos)\\n        next_pos = a[next_pos]\\n    while next_pos not in ring:\\n        ring.add(next_pos)\\n        next_pos = a[next_pos]\\n    processed_ring(ring)\\n    rings.append(ring)\\n\\nres = sum(min(c[i] for i in ring) for ring in rings)\\nprint(res)\\n\", \"def main():\\n        n=int(input())\\n        c=[int(i) for i in input().split()]\\n        a=[int(i) for i in input().split()]\\n        vis=[0]*(n+1)\\n        sum=0\\n        for i in range(1,n+1):\\n                x=i\\n                while(vis[x]==0):\\n                        vis[x]=i\\n                        x=a[x-1]\\n                if vis[x]!=i:\\n                        continue\\n                p=x\\n                cos=c[x-1]\\n                while(p!=a[x-1]):\\n                        x=a[x-1]\\n                        cos=min(c[x-1],cos)\\n                sum=sum+cos\\n        return sum\\nprint(main())\\n\", \"def count(n,c,a):\\n        vis=[0]*(n+1)\\n        z=[]\\n        p=[]\\n        for i in range(1,n+1):\\n                x=i\\n                while vis[x]==0:\\n                        vis[x]=i\\n                        x=a[x-1]\\n                if vis[x]==i:\\n                        p.append(x)\\n        return p\\ndef opium(n,c,a):\\n        sum=0\\n        p=list(set(count(n,c,a)))\\n        #print(p)\\n        for x in p:\\n                v=x\\n                cd=c[x-1]\\n                while v!=a[x-1]:\\n                        x=a[x-1]\\n                        cd=min(cd,c[x-1])\\n                sum=sum+cd\\n                #print(sum)\\n        return sum\\ndef main():\\n        n=int(input())\\n        c=[int(i) for i in input().split()]\\n        a=[int(i) for i in input().split()]\\n        return opium(n,c,a)\\nprint(main())\\n\", \"n = int(input())\\nc  = [0] + [int(j) for j in input().split()]\\na  = [0] + [int(j) for j in input().split()]\\n \\nvis = [0] * (n+1)\\nans = 0\\nfor i in range(1,n+1):\\n    x = i\\n    while vis[x] == 0:\\n        vis[x] = i\\n        x = a[x]\\n    if vis[x] != i:\\n        continue\\n    v = x\\n    mn = c[x]\\n    while a[x] != v:\\n        x = a[x]\\n        mn = min(mn,c[x])\\n    ans+=mn\\nprint(ans)\", \"def main():\\n    n, r = int(input()) + 1, 0\\n    cc = [0, *list(map(int, input().split()))]\\n    aa = [0, *list(map(int, input().split()))]\\n    avail = [True] * n\\n    for i, a in enumerate(avail):\\n        if a:\\n            j = i\\n            while avail[j]:\\n                avail[j] = False\\n                j = aa[j]\\n            c, j = cc[j], aa[j]\\n            if c:\\n                while cc[j]:\\n                    if c > cc[j]:\\n                        c = cc[j]\\n                    cc[j] = 0\\n                    j = aa[j]\\n                r += c\\n            while cc[i]:\\n                cc[i] = 0\\n                i = aa[i]\\n    print(r)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"# -------------------------SOLVE STACK OVERFFLOW WHILE DFS\\n# input\\nn = input()\\na = list(map(int, input().split())) # costs of each room\\na_next = list(map(int, input().split())) # a_next[i] : the next room of ith room\\nfor i in range(len(a_next)):\\n    a_next[i] -= 1\\n    \\ncycles = [] # list of cycles\\ncheck = [0]*len(a) # check array (0:unchecked, 1:visited, 2:belongs to a cycle)\\n\\n# dfs function. make cycles along the way\\ndef dfs(v):\\n    path = [] # path of dfs\\n    s = [] # dfs stack\\n    \\n    check[v] = 1\\n    path.append(v)\\n    s.append(v)\\n\\n    while s:\\n        next_v = a_next[s[-1]]\\n        \\n        if check[next_v] == 0:\\n            check[next_v] = 1\\n            path.append(next_v)\\n            s.append(next_v)\\n        else:\\n            if check[next_v] == 1: # a new cycle has been found\\n                cycle = []\\n                while path[-1] != next_v:\\n                    cycle.append(path.pop())\\n                cycle.append(next_v)\\n                cycles.append(cycle)\\n            # empty the stack\\n            while s:\\n                check[s.pop()] = 2\\n\\n# make a list of cycles\\nfor i in range(len(a)):\\n    if check[i] == 0:\\n        dfs(i)\\n\\n# add up all minimum costs for each cycle\\nans = 0 # answer\\nfor cycle in cycles:\\n    min_cost = a[cycle[0]]\\n    for v in cycle:\\n        if a[v] < min_cost:\\n            min_cost = a[v]\\n    ans += min_cost\\n\\n# print answer\\nprint(ans)\\n\", \"n = int(input())\\n\\nc = list(map(int, input().split()))\\n\\na = list([int(x) - 1 for x in input().split()])\\n\\ndeg_in = [0 for _ in range(n)]\\n\\nd_in_to_v_set = {i: set() for i in range(n + 1)}\\n\\nfor ai in a:\\n    deg_in[ai] += 1\\n\\nfor i in range(n):\\n    d_in_to_v_set[deg_in[i]].add(i)\\n\\nwhile d_in_to_v_set[0] != set():\\n    l = list(d_in_to_v_set[0])\\n    for u in l:\\n        d_in_to_v_set[deg_in[a[u]]].remove(a[u])\\n        d_in_to_v_set[deg_in[a[u]] - 1].add(a[u])\\n        d_in_to_v_set[0].remove(u)\\n        deg_in[a[u]] -= 1\\n\\np = [0 for _ in range(n)]\\n\\nfor v in d_in_to_v_set[1]:\\n    p[v] = 1\\n\\nans, cur = 0, 10**5\\n\\nfor i in range(n):\\n    s = i\\n    cur = 10**5\\n    while p[s] != 0:\\n        cur = min(cur, c[s])\\n        p[s] = 0\\n        s = a[s]\\n    ans += cur if cur < 10**5 else 0\\n\\nprint(ans)\\n\", \"n = int(input())\\n\\nc = list(map(int, input().split()))\\n\\na = list([int(x) - 1 for x in input().split()])\\n\\ndeg_in = [0 for _ in range(n)]\\n\\nd_in_to_v_set = {i: set() for i in range(n + 1)}\\n\\nfor ai in a:\\n    deg_in[ai] += 1\\n\\nfor i in range(n):\\n    d_in_to_v_set[deg_in[i]].add(i)\\n\\nwhile d_in_to_v_set[0] != set():\\n    l = list(d_in_to_v_set[0])\\n    for u in l:\\n        d_in_to_v_set[deg_in[a[u]]].remove(a[u])\\n        d_in_to_v_set[deg_in[a[u]] - 1].add(a[u])\\n        d_in_to_v_set[0].remove(u)\\n        deg_in[a[u]] -= 1\\n\\np = [0 for _ in range(n)]\\n\\nfor v in d_in_to_v_set[1]:\\n    p[v] = 1\\n\\nans, cur = 0, 10**5\\n\\nfor i in range(n):\\n    s = i\\n    cur = 10**5\\n    while p[s] != 0:\\n        cur = min(cur, c[s])\\n        p[s] = 0\\n        s = a[s]\\n    ans += cur if cur < 10**5 else 0\\n\\nprint(ans)\\n\", \"# -*- coding:utf-8 -*-\\n\\n\\\"\\\"\\\"\\n\\ncreated by shuangquan.huang at 12/10/18\\n\\n\\\"\\\"\\\"\\n\\nN = int(input())\\nC = [0] + [int(x) for x in input().split()]\\nA = [0] + [int(x) for x in input().split()]\\n\\n\\nans = 0\\nvis = [False] * (N+1)\\nfor i in range(1, N+1):\\n    if vis[i]:\\n        continue\\n    \\n    circle = []\\n    u = i\\n    while not vis[u]:\\n        circle.append(u)\\n        vis[u] = True\\n        u = A[u]\\n    \\n    if u in circle:\\n        ans += min([C[j] for j in circle[circle.index(u):]])\\n\\nprint(ans)\", \"n = int(input())\\nc = [0] + list(map(int, input().split()))\\na = [0] + list(map(int, input().split()))\\n\\ng = [0] * (n+1)\\nanswer = 0\\n\\nfor i in range(1,n+1):\\n    node = i\\n    while g[node] == 0:\\n        g[node] = i\\n        node = a[node]\\n    if g[node] != i:\\n        continue\\n    current = node\\n    min_cost = c[node]\\n    while a[node] != current:\\n        node = a[node]\\n        min_cost = min(min_cost,c[node])\\n    answer += min_cost\\n\\nprint(answer)\", \"# n = input()\\n# a = input()\\n# b = input()\\n# print(n)\\n# print(a)\\n# print(b)\\n# import sys\\n# sys.setrecursionlimit(1000000)\\n# try:\\nn = int(input())\\nburles = list(map(int, input().split()))\\ndirections = list(map(int, input().split()))\\n\\nburles.insert(0,0)\\ndirections.insert(0,0)\\n\\n\\nv = [0]*(n+1)# visitou\\ng = [0]*(n+1)# grupo\\n\\n\\n\\ndef passa(pos):\\n\\n\\tnonlocal current_group\\n\\tnonlocal v\\n\\tnonlocal g\\n\\tnonlocal soma_total\\n\\tpilha = [-1]\\n\\tavanco = True\\n\\t# print('posicao {} {}'.format(pos, v[pos]))\\n\\t# print('Visita {}'.format(pos))\\n\\tgrupo = 0\\n\\testa_no_ciclo = False\\n\\tmenor_local = 0\\n\\twhile pilha:\\n\\t\\t\\n\\t\\tif avanco:\\n\\n\\t\\t\\tif v[pos] == 1:\\n\\t\\t\\t\\tv[pos] = 2\\n\\t\\t\\t\\tif g[pos] == 0:\\n\\t\\t\\t\\t\\tg[pos] = current_group\\n\\t\\t\\t\\t\\t# print('atribui grupo {}'.format(current_group))\\n\\t\\t\\t\\t\\tcurrent_group+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tgrupo = g[pos]\\n\\t\\t\\t\\tavanco = False\\n\\t\\t\\t\\testa_no_ciclo = True\\n\\t\\t\\t\\tmenor_local = burles[pos]\\n\\n\\t\\t\\telif v[pos] == 2 or v[pos] == 3:\\n\\t\\t\\t\\tgrupo = g[pos]\\n\\t\\t\\t\\tavanco = False\\n\\t\\t\\t\\testa_no_ciclo = False\\n\\t\\t\\t\\tgrupo = g[pos]\\n\\t\\t\\telse:\\t\\n\\t\\t\\t\\tv[pos] = 1\\n\\t\\t\\t\\tpilha.append(pos)\\n\\t\\t\\t\\tpos = directions[pos]\\n\\t\\t\\n\\t\\t# g[pos], ver, minimo = passa(directions[pos])\\n\\t\\t\\n\\t\\telse:\\n\\t\\t\\tpos = pilha.pop(len(pilha)-1)\\n\\t\\t\\tif pos < 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tg[pos] = grupo\\n\\t\\t\\tif v[pos] ==2 and esta_no_ciclo:\\n\\t\\t\\t\\tsoma_total+=menor_local\\n\\t\\t\\t\\testa_no_ciclo = False\\n\\n\\t\\t\\t\\t# return g[pos], False, 0\\n\\n\\t\\t\\telif v[pos] ==1 and esta_no_ciclo:\\n\\t\\t\\t\\tv[pos] = 2\\n\\t\\t\\t\\tmenor_local = min(menor_local, burles[pos])\\n\\t\\t\\t\\t# return g[pos], True, min(minimo, burles[pos])\\n\\t\\t\\t\\n\\t\\t\\tif v[pos] ==1 and not esta_no_ciclo:\\n\\t\\t\\t\\tv[pos] = 3\\n\\n\\t\\t\\t\\t# return g[pos], False, 0\\n\\n\\n\\t\\t\\t# return g[pos], False, 0\\n\\t# print('atribui grupo {}'.format(g[pos]))\\n\\ncurrent_group = 1\\nsoma_total = 0\\nfor i in range(1, n+1):\\n\\tif v[i] ==0:\\n\\t\\tpassa(i)\\nprint(soma_total)\\n# except Exception:\\n# print(sys.exc_info()[2])\\n\\n\\n\\n# dicionario = {}\\n# for i in range(1, n+1):\\n# \\tif v[i] == 2:\\n# \\t\\tgrupo = g[i]\\n# \\t\\tmenor = dicionario.get(grupo, None)\\n# \\t\\tif menor:\\n# \\t\\t\\tdicionario[grupo] = min(menor, burles[i])\\n\\n# \\t\\telse:\\n# \\t\\t\\tdicionario[grupo] = burles[i]\\n\\n# print(int(sum(dicionario.values())))\\n\\n# except RuntimeError as e:\\n# \\tprint(1)\\n# \\tprint(str(e))\\n\\n# print(g)\\n# print(v)\\n\\n# conjunto = set()\\n# soma = 0\\n# for i in range(1, len(p)):\\n# \\tif g[i] not in conjunto:\\n# \\t\\tconjunto.add(g[i])\\n# \\t\\tsoma+=p[i]\\n\\n\\n\\n# answer = 0\\n\\n# for i in range(1,n+1):\\n#     node = i\\n#     while g[node] == 0:\\n#         g[node] = i\\n#         node = a[node]\\n#     if g[node] != i:\\n#         continue\\n#     current = node\\n#     min_cost = c[node]\\n#     while a[node] != current:\\n#         node = a[node]\\n#         min_cost = min(min_cost,c[node])\\n#     answer += min_cost\\n\\n# print(answer)\\n# print(v)\\n# print(g)\\n# print(p)\\n# print(dicionario)\\n\", \"# n = input()\\n# a = input()\\n# b = input()\\n# print(n)\\n# print(a)\\n# print(b)\\n# import sys\\n# sys.setrecursionlimit(1000000)\\n# try:\\nn = int(input())\\nburles = list(map(int, input().split()))\\ndirections = list(map(int, input().split()))\\n\\nburles.insert(0,0)\\ndirections.insert(0,0)\\n\\n\\nv = [0]*(n+1)# visitou\\ng = [0]*(n+1)# grupo\\n\\n\\n\\ndef passa(pos):\\n\\n\\tnonlocal current_group\\n\\tnonlocal v\\n\\tnonlocal g\\n\\tnonlocal soma_total\\n\\tpilha = [-1]\\n\\tavanco = True\\n\\t# print('posicao {} {}'.format(pos, v[pos]))\\n\\t# print('Visita {}'.format(pos))\\n\\tgrupo = 0\\n\\testa_no_ciclo = False\\n\\tmenor_local = 0\\n\\twhile pilha:\\n\\t\\t\\n\\t\\tif avanco:\\n\\n\\t\\t\\tif v[pos] == 1:\\n\\t\\t\\t\\tv[pos] = 2\\n\\t\\t\\t\\tif g[pos] == 0:\\n\\t\\t\\t\\t\\tg[pos] = current_group\\n\\t\\t\\t\\t\\t# print('atribui grupo {}'.format(current_group))\\n\\t\\t\\t\\t\\tcurrent_group+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tgrupo = g[pos]\\n\\t\\t\\t\\tavanco = False\\n\\t\\t\\t\\testa_no_ciclo = True\\n\\t\\t\\t\\tmenor_local = burles[pos]\\n\\n\\t\\t\\telif v[pos] == 2 or v[pos] == 3:\\n\\t\\t\\t\\tgrupo = g[pos]\\n\\t\\t\\t\\tavanco = False\\n\\t\\t\\t\\testa_no_ciclo = False\\n\\t\\t\\t\\tgrupo = g[pos]\\n\\t\\t\\telse:\\t\\n\\t\\t\\t\\tv[pos] = 1\\n\\t\\t\\t\\tpilha.append(pos)\\n\\t\\t\\t\\tpos = directions[pos]\\n\\t\\t\\n\\t\\t# g[pos], ver, minimo = passa(directions[pos])\\n\\t\\t\\n\\t\\telse:\\n\\t\\t\\tpos = pilha.pop(len(pilha)-1)\\n\\t\\t\\tif pos < 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tg[pos] = grupo\\n\\t\\t\\tif v[pos] ==2 and esta_no_ciclo:\\n\\t\\t\\t\\tsoma_total+=menor_local\\n\\t\\t\\t\\testa_no_ciclo = False\\n\\n\\t\\t\\t\\t# return g[pos], False, 0\\n\\n\\t\\t\\telif v[pos] ==1 and esta_no_ciclo:\\n\\t\\t\\t\\tv[pos] = 2\\n\\t\\t\\t\\tmenor_local = min(menor_local, burles[pos])\\n\\t\\t\\t\\t# return g[pos], True, min(minimo, burles[pos])\\n\\t\\t\\t\\n\\t\\t\\tif v[pos] ==1 and not esta_no_ciclo:\\n\\t\\t\\t\\tv[pos] = 3\\n\\n\\t\\t\\t\\t# return g[pos], False, 0\\n\\n\\n\\t\\t\\t# return g[pos], False, 0\\n\\t# print('atribui grupo {}'.format(g[pos]))\\n\\ncurrent_group = 1\\nsoma_total = 0\\nfor i in range(1, n+1):\\n\\tif v[i] ==0:\\n\\t\\tpassa(i)\\nprint(soma_total)\\n# except Exception:\\n# print(sys.exc_info()[2])\\n\\n\\n\\n# dicionario = {}\\n# for i in range(1, n+1):\\n# \\tif v[i] == 2:\\n# \\t\\tgrupo = g[i]\\n# \\t\\tmenor = dicionario.get(grupo, None)\\n# \\t\\tif menor:\\n# \\t\\t\\tdicionario[grupo] = min(menor, burles[i])\\n\\n# \\t\\telse:\\n# \\t\\t\\tdicionario[grupo] = burles[i]\\n\\n# print(int(sum(dicionario.values())))\\n\\n# except RuntimeError as e:\\n# \\tprint(1)\\n# \\tprint(str(e))\\n\\n# print(g)\\n# print(v)\\n\\n# conjunto = set()\\n# soma = 0\\n# for i in range(1, len(p)):\\n# \\tif g[i] not in conjunto:\\n# \\t\\tconjunto.add(g[i])\\n# \\t\\tsoma+=p[i]\\n\\n\\n\\n# answer = 0\\n\\n# for i in range(1,n+1):\\n#     node = i\\n#     while g[node] == 0:\\n#         g[node] = i\\n#         node = a[node]\\n#     if g[node] != i:\\n#         continue\\n#     current = node\\n#     min_cost = c[node]\\n#     while a[node] != current:\\n#         node = a[node]\\n#         min_cost = min(min_cost,c[node])\\n#     answer += min_cost\\n\\n# print(answer)\\n# print(v)\\n# print(g)\\n# print(p)\\n# print(dicionario)\\n\", \"def dfs(node,edges,costs,visited):\\n    cycle = False\\n    visited1 = set()\\n    while True:\\n        if node in visited:\\n            for i in visited1:\\n                visited.add(i)\\n            return 0\\n        if not edges[node]:\\n            visited1.add(node)\\n            break\\n        if node not in visited1:\\n            visited1.add(node)\\n            node = edges[node][0]\\n        else:\\n            cycle = True\\n            break\\n\\n    #print(node,cycle,visited)\\n    if cycle:\\n        x = edges[node][0]\\n        min_cost = costs[x-1]\\n        while x != node:\\n            x = edges[x][0]\\n            min_cost = min(min_cost,costs[x-1])\\n        cost = min_cost\\n    else:\\n        cost = costs[node-1]\\n\\n    for i in visited1:\\n        visited.add(i)\\n\\n    return cost\\n    \\n\\ndef solve(zero,edges,costs):\\n    n = len(costs)\\n    visited = set()\\n    cost = 0\\n\\n    for i in range(1,n+1):\\n        if i not in visited:\\n            cost += dfs(i,edges,costs,visited)\\n\\n    print(cost)\\n\\ndef main():\\n    n = int(input())\\n    costs = list(map(int,input().split()))\\n    mouse = list(map(int,input().split()))\\n    edges = {}\\n    for i in range(1,n+1):\\n        edges[i] = []\\n\\n    indegree = [0]*(n+1)\\n    for i in range(1,n+1):\\n        if i != mouse[i-1]:\\n            edges[i].append(mouse[i-1])\\n            indegree[mouse[i-1]] += 1\\n\\n    zero = []\\n    for i in range(1,n+1):\\n        if indegree[i] == 0:\\n            zero.append(i)\\n\\n    solve(zero,edges,costs)\\n\\n\\nmain()\\n\", \"n=int(input())\\nc=list(map(int,input().split()))\\na=list(map(int,input().split()))\\n\\nans=0\\nv=[False for i in range(n)]\\nfor i in range(n):\\n\\tif v[i]:continue\\n\\tp=set()\\n\\tpl=[]\\n\\ts=set([i])\\n\\tt=True\\n\\twhile s and t:\\n\\t\\tx=s.pop()\\n\\t\\tv[x]=True\\n\\t\\tp.add(x)\\n\\t\\tpl.append(x)\\n\\t\\tnex=a[x]-1\\n\\t\\ts.add(nex)\\n\\t\\tif nex in p:\\n\\t\\t\\tj=pl.index(nex)\\n\\t\\t\\tza=s.pop()\\n\\t\\telif v[nex]:t=False;za=s.pop()\\n\\t\\t\\n\\t\\n\\tif not t:continue\\n\\tan=float(\\\"INF\\\")\\n\\tfor k in range(j,len(pl)):\\n\\t\\tan=min(c[pl[k]],an)\\n\\tans+=an\\nprint(ans)\", \"# 1027D\\nimport collections\\ndef do():\\n    n = int(input())\\n    costs = [int(c) for c in input().split(\\\" \\\")]\\n    next = [int(c)-1 for c in input().split(\\\" \\\")]\\n    ind = [0] * n\\n    for i,c in enumerate(next):\\n        if i != c:\\n            ind[c] += 1\\n    seen = [0] * n\\n    res_seen = [0] * n\\n    res = 0\\n\\n    def get(entry):\\n        m = costs[entry]\\n        p = entry\\n        while True:\\n            if res_seen[p]:\\n                return 0\\n            res_seen[p] = 1\\n            m = min(m, costs[p])\\n            p = next[p]\\n            if p == entry:\\n                break\\n        return m\\n\\n    def dfs(i):\\n        stack = [i]\\n        seen[i] = 1\\n        while stack:\\n            cur = stack.pop()\\n            nei = next[cur]\\n            if seen[nei]:\\n                return get(nei)\\n            seen[nei] = 1\\n            stack.append(nei)\\n        return 0\\n\\n    for i in range(n):\\n        if ind[i] == 0:\\n            res += dfs(i)\\n    for i in range(n):\\n        if seen[i] == 0:\\n            res += dfs(i)\\n    return res\\n\\nprint(do())\\n\", \"import sys\\nreadline = sys.stdin.readline\\n\\n\\nN = int(readline())\\nC = list(map(int, readline().split()))\\nA = list(map(lambda x: int(x)-1, readline().split()))\\n\\n\\ninf = 10**9\\nused = set()\\nans = 0\\nfor i in range(N):\\n    if i in used:\\n        continue\\n    seen = set()\\n    stack = [i]\\n    cnt = 0\\n    st = None\\n    while stack:\\n        vn = stack.pop()\\n        vf = A[vn]\\n        if vf in used:\\n            break\\n        if vf in seen:\\n            st = vf\\n            break\\n        seen.add(vf)\\n        stack.append(vf)\\n        \\n    if st is not None:\\n        vn = st\\n        cnt = C[vn]\\n        vf = A[vn]\\n        vn = A[vn]\\n        while vn != st:\\n            cnt = min(cnt, C[vn])\\n            vn = A[vn]\\n    used |= seen\\n    ans += cnt\\nprint(ans)\", \"import sys\\ninput = sys.stdin.readline\\n\\nclass Unionfind:\\n    def __init__(self, n):\\n        self.par = [-1]*n\\n        self.rank = [1]*n\\n    \\n    def root(self, x):\\n        p = x\\n        \\n        while not self.par[p]<0:\\n            p = self.par[p]\\n        \\n        while x!=p:\\n            tmp = x\\n            x = self.par[x]\\n            self.par[tmp] = p\\n        \\n        return p\\n    \\n    def unite(self, x, y):\\n        rx, ry = self.root(x), self.root(y)\\n        \\n        if rx==ry: return False\\n        \\n        if self.rank[rx]<self.rank[ry]:\\n            rx, ry = ry, rx\\n        \\n        self.par[rx] += self.par[ry]\\n        self.par[ry] = rx\\n    \\n        if self.rank[rx]==self.rank[ry]:\\n            self.rank[rx] += 1\\n    \\n    def is_same(self, x, y):\\n        return self.root(x)==self.root(y)\\n    \\n    def count(self, x):\\n        return -self.par[self.root(x)]\\n        \\nn = int(input())\\nc = list(map(int, input().split()))\\nuf = Unionfind(n)\\na = list(map(int, input().split()))\\n\\nfor i in range(n):\\n    uf.unite(i, a[i]-1)\\n\\nroots = set(uf.root(i) for i in range(n))\\nans = 0\\n\\nfor r in roots:\\n    cur = r\\n    s = {r}\\n    \\n    while True:\\n        nex = a[cur]-1\\n        \\n        if nex in s:\\n            sta = nex\\n            break\\n        \\n        s.add(nex)\\n        cur = nex\\n    \\n    add = c[sta]\\n    cur = sta\\n    \\n    while True:\\n        nex = a[cur]-1\\n        \\n        if nex==sta:\\n            break\\n        \\n        add = min(add, c[nex])\\n        cur = nex\\n    \\n    ans += add\\n\\nprint(ans)\", \"n = int(input())\\nc = list(map(int, input().strip().split()))\\na = list(map(int, input().strip().split()))\\nresd = {}\\nres = 0\\ntmpd = {}\\nfor i in range(n):\\n    cur = i + 1\\n    d = {}\\n    group = []\\n    flag = False\\n    while cur not in d:\\n        if cur in tmpd:\\n            flag = True\\n            break\\n        d[cur] = 1\\n        tmpd[cur] = 1\\n        group.append(cur)\\n        cur = a[cur - 1]\\n    if flag:\\n        continue\\n    mmin = float('inf')\\n    ind = float('inf')\\n    flag = False\\n    for item in group:\\n        if item == cur:\\n            flag = True\\n        if flag:\\n            mmin = min(c[item - 1], mmin)\\n            ind = min(ind, item)\\n    if ind in resd:\\n        continue\\n    else:\\n        resd[ind] = 1\\n        res += mmin\\n\\nprint(res)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"5\\n1 2 3 2 10\\n1 3 4 3 3\\n\",\n    \"4\\n1 10 2 10\\n2 4 2 2\\n\",\n    \"7\\n1 1 1 1 1 1 1\\n2 2 2 3 6 7 6\\n\",\n    \"10\\n6 9 1 1 1 10 2 4 9 6\\n5 3 4 2 6 8 9 1 10 7\\n\",\n    \"10\\n9 19 19 1 3 9 1 12 10 8\\n7 1 6 3 4 8 5 10 2 9\\n\",\n    \"1\\n12\\n1\\n\",\n    \"2\\n62 49\\n1 2\\n\",\n    \"2\\n21 28\\n2 1\\n\",\n    \"3\\n80 6 67\\n1 2 3\\n\",\n    \"3\\n15 52 14\\n1 3 2\\n\",\n    \"3\\n17 34 88\\n2 1 3\\n\",\n    \"3\\n30 98 37\\n2 3 1\\n\",\n    \"3\\n40 26 88\\n3 1 2\\n\",\n    \"3\\n76 74 84\\n3 2 1\\n\",\n    \"4\\n97 27 70 99\\n1 2 3 4\\n\",\n    \"4\\n99 71 47 82\\n1 3 4 2\\n\",\n    \"4\\n4 95 20 62\\n2 1 4 3\\n\",\n    \"4\\n90 5 66 84\\n3 1 2 4\\n\",\n    \"4\\n2 58 52 89\\n3 1 4 2\\n\",\n    \"4\\n37 86 1 88\\n4 2 1 3\\n\",\n    \"4\\n81 69 80 19\\n4 3 1 2\\n\",\n    \"4\\n88 78 39 46\\n4 3 2 1\\n\",\n    \"10\\n7846 8354 1188 6898 8046 7561 8043 8588 8684 3699\\n1 1 2 3 4 5 6 7 8 9\\n\",\n    \"10\\n6724 5003 9029 376 7529 5554 1407 388 2632 981\\n2 3 4 5 1 4 6 7 8 9\\n\",\n    \"10\\n1337 4359 5138 5246 7859 8111 1154 8455 3711 1737\\n1 1 2 3 4 1 6 7 8 9\\n\",\n    \"10\\n6870 3547 3337 9426 3866 1873 4908 4628 7800 6716\\n2 3 4 5 1 4 6 2 8 9\\n\",\n    \"10\\n5620 2478 4051 7060 6327 2170 6912 2031 1781 7454\\n1 1 1 1 1 1 1 1 1 1\\n\",\n    \"5\\n1 2 3 4 5\\n3 4 5 3 2\\n\",\n    \"5\\n1 1 10 10 10\\n2 3 4 5 3\\n\",\n    \"4\\n2 1 2 2\\n2 3 3 2\\n\",\n    \"4\\n1 12 2 3\\n2 3 4 2\\n\",\n    \"10\\n10 10 10 10 1 10 10 10 10 10\\n2 3 4 5 3 2 6 9 5 8\\n\",\n    \"3\\n1 2 4\\n1 3 1\\n\",\n    \"3\\n1 2 4\\n2 2 1\\n\",\n    \"3\\n1 2 4\\n2 3 3\\n\",\n    \"3\\n1 2 4\\n3 2 2\\n\",\n    \"3\\n1 2 4\\n3 3 1\\n\",\n    \"5\\n5 4 2 6 10\\n2 4 3 3 2\\n\",\n    \"8\\n8 8 1 10 6 9 3 1\\n5 2 7 1 6 8 4 3\\n\",\n    \"2\\n1 2\\n2 2\\n\",\n    \"5\\n1 16 2 4 8\\n5 3 1 5 4\\n\",\n    \"8\\n1 8 32 4 16 64 128 2\\n6 4 1 5 4 4 1 3\\n\",\n    \"6\\n10 7 1 1 8 2\\n5 5 2 3 3 5\\n\",\n    \"8\\n1 2 2 9 7 5 6 5\\n8 4 1 5 5 1 1 8\\n\",\n    \"3\\n9 5 6\\n3 3 1\\n\",\n    \"7\\n2 1 64 8 32 4 16\\n5 7 2 4 2 4 6\\n\",\n    \"3\\n1 2 4\\n3 3 3\\n\",\n    \"4\\n1 2 4 8\\n2 3 3 2\\n\",\n    \"3\\n1 2 4\\n3 2 3\\n\",\n    \"7\\n4 32 8 1 16 64 2\\n6 1 5 2 1 4 5\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n\",\n    \"10\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"1\\n\",\n    \"12\\n\",\n    \"111\\n\",\n    \"21\\n\",\n    \"153\\n\",\n    \"29\\n\",\n    \"105\\n\",\n    \"30\\n\",\n    \"26\\n\",\n    \"150\\n\",\n    \"293\\n\",\n    \"146\\n\",\n    \"24\\n\",\n    \"89\\n\",\n    \"2\\n\",\n    \"87\\n\",\n    \"19\\n\",\n    \"85\\n\",\n    \"7846\\n\",\n    \"376\\n\",\n    \"1337\\n\",\n    \"3337\\n\",\n    \"5620\\n\",\n    \"2\\n\",\n    \"10\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"2\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"9\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"4\\n\",\n    \"1\\n\",\n    \"12\\n\",\n    \"6\\n\",\n    \"8\\n\",\n    \"4\\n\",\n    \"4\\n\",\n    \"6\\n\",\n    \"1\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1027/D",
  "starter_code": ""
}