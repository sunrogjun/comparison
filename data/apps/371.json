{
  "task_id": "APPS/371",
  "problem_id": 371,
  "prompt": "Bad news came to Mike's village, some thieves stole a bunch of chocolates from the local factory! Horrible! \n\nAside from loving sweet things, thieves from this area are known to be very greedy. So after a thief takes his number of chocolates for himself, the next thief will take exactly k times more than the previous one. The value of k (k > 1) is a secret integer known only to them. It is also known that each thief's bag can carry at most n chocolates (if they intend to take more, the deal is cancelled) and that there were exactly four thieves involved. \n\nSadly, only the thieves know the value of n, but rumours say that the numbers of ways they could have taken the chocolates (for a fixed n, but not fixed k) is m. Two ways are considered different if one of the thieves (they should be numbered in the order they take chocolates) took different number of chocolates in them.\n\nMike want to track the thieves down, so he wants to know what their bags are and value of n will help him in that. Please find the smallest possible value of n or tell him that the rumors are false and there is no such n.\n\n\n-----Input-----\n\nThe single line of input contains the integer m (1 \u2264 m \u2264 10^15)\u00a0\u2014 the number of ways the thieves might steal the chocolates, as rumours say.\n\n\n-----Output-----\n\nPrint the only integer n\u00a0\u2014 the maximum amount of chocolates that thieves' bags can carry. If there are more than one n satisfying the rumors, print the smallest one.\n\nIf there is no such n for a false-rumoured m, print  - 1.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n8\n\nInput\n8\n\nOutput\n54\n\nInput\n10\n\nOutput\n-1\n\n\n\n-----Note-----\n\nIn the first sample case the smallest n that leads to exactly one way of stealing chocolates is n = 8, whereas the amounts of stealed chocolates are (1, 2, 4, 8) (the number of chocolates stolen by each of the thieves).\n\nIn the second sample case the smallest n that leads to exactly 8 ways is n = 54 with the possibilities: (1, 2, 4, 8), \u2002(1, 3, 9, 27), \u2002(2, 4, 8, 16), \u2002(2, 6, 18, 54), \u2002(3, 6, 12, 24), \u2002(4, 8, 16, 32), \u2002(5, 10, 20, 40), \u2002(6, 12, 24, 48).\n\nThere is no n leading to exactly 10 ways of stealing chocolates in the third sample case.",
  "solutions": "[\"n = int(input())\\nl, r = 0, 10**16\\nD = [x ** 3.0 for x in range(2, 170417)]\\nDD = [x*x*x for x in range(2, 170417)]\\nwhile l < r:\\n    m = (l+r) // 2\\n    if sum(int(m/d) for d in D) < n:\\n        l = m + 1\\n    else:\\n        r = m;\\nif sum(l//d for d in DD) == n:\\n    print(l);\\nelse :\\n    print((-1));\\n\", \"SIZE = 171000\\nL = [i ** 3 for i in range(SIZE)]\\n\\ndef get_count(n):\\n    MAX = int(n ** (1 / 3)) + 1\\n    if L[MAX] > n:\\n        MAX -= 1\\n\\n    res = 0\\n    for i in range(2, MAX + 1):\\n        x = n // L[i]\\n        if x != 1:\\n            res += x\\n        else:\\n            res += MAX - i + 1\\n            break\\n    return res\\n\\ndef bin_search(m):\\n    beg = int(4.8 * m)\\n    end = min(8 * m, int(5e15))\\n    while beg <= end:\\n        mid = (beg + end) // 2\\n        count_mid = get_count(mid)\\n        if count_mid == m:\\n            if beg == end:\\n                return mid\\n            end = mid\\n        elif count_mid > m:\\n            end = mid - 1\\n        else:\\n            beg = mid + 1\\n    return -1\\n\\nm = int(input())\\nprint(bin_search(m))\\n\", \"def main():\\n    m = int(input())\\n    if m < 1000000:\\n        lo = m*4\\n        hi = m*8\\n    else:\\n        lo = int(4.949 * m)\\n        hi = int(4.9492 * m)\\n    while lo < hi - 1:\\n        mid = (lo + hi)//2\\n        nposs = countposs(mid)\\n        if nposs < m:\\n            lo = mid\\n        else:\\n            hi = mid\\n    if m == countposs(hi):\\n        print(hi)\\n    else:\\n        print(-1)\\n\\ndef countposs(maxtake):\\n    k = 2\\n    ans = 0\\n    while True:\\n        term = maxtake//(k*k*k)\\n        if term == 0:\\n            return ans\\n        ans += term\\n        k += 1\\n\\nmain()\", \"def main():\\n    m = int(input())\\n    lo = m*4\\n    hi = m*8\\n    loposs = countposs(lo)\\n    hiposs = countposs(hi)\\n    while lo < hi - 1:\\n        if hi - lo > 10000:\\n            mid = lo + int((m-loposs)/(hiposs-loposs)*(hi-lo))\\n            mid = max(lo + 1, min(hi - 1, mid))\\n        else:\\n            mid = (hi + lo)//2\\n        nposs = countposs(mid)\\n        if nposs < m:\\n            lo = mid\\n        else:\\n            hi = mid\\n    if m == countposs(hi):\\n        print(hi)\\n    else:\\n        print(-1)\\n\\ndef countposs(maxtake):\\n    k = 2\\n    ans = 0\\n    while True:\\n        term = maxtake//(k*k*k)\\n        if term == 0:\\n            return ans\\n        ans += term\\n        k += 1\\n\\nmain()\", \"n = int(input())\\nl, r = 0, 10**16\\nD = [x ** 3.0 for x in range(2, 170417)]\\nDD = [x*x*x for x in range(2, 170417)]\\nwhile l < r:\\n    m = (l+r) // 2\\n    if sum(int(m/d) for d in D) < n:\\n        l = m + 1\\n    else:\\n        r = m;\\nif sum(l//d for d in DD) == n:\\n    print(l);\\nelse :\\n    print((-1));\\n\", \"t = [k ** 3 for k in range(2, 170417)]\\ns = m = int(input())\\na, b = 1, 9 * m\\nwhile a < b:\\n    c = (a + b) // 2\\n    d = sum(int(c / k) for k in t)\\n    if d < m: a = c + 1\\n    else: s, b = d, c\\nprint(a if s == m else -1)\", \"cubes = [i**3.0 for i in range(2, int(1.8e5+5))]\\n\\ndef valid(mid):\\n    return sum([mid//i for i in cubes if i <= mid])\\n\\ndef binary_search(k):\\n    l = int(4.8 * k)\\n    r = min(8.0 * k, 5.0 * (10**15))\\n    while (l+1 < r):\\n        mid = (l+r) / 2.0\\n        res = valid(mid)\\n        if (res < k):\\n            l = mid\\n        else:\\n            r = mid\\n    return int(r) if int(valid(r)) == k else -1\\n\\ndef main():\\n    k = int(input())\\n    print(binary_search(k))\\n\\nmain()\\n\", \"n = int(input()) \\nl, r = 0, 10**16 \\nD = [x ** 3.0 for x in range(2, 170417)] \\nDD = [x*x*x for x in range(2, 170417)] \\nwhile l < r: \\n\\tm = (l+r) // 2 \\n\\tif sum(int(m/d) for d in D) < n: \\n\\t\\tl = m + 1 \\n\\telse: \\n\\t    r = m; \\nif sum(l//d for d in DD) == n: \\n\\tprint(l); \\nelse : \\n    print(-1);\", \"import math\\nfrom bisect import bisect_right, bisect_left\\nfrom collections import Counter, defaultdict\\nfrom heapq import heappop, heappush\\nfrom itertools import accumulate\\n\\nR = lambda: map(int, input().split())\\n\\nt = int(input())\\ntab = [x*x*x for x in range(2, 2*10**5)]\\nl, r = 1, 5*10**15\\nwhile l < r:\\n    n = (l + r) // 2\\n    s = sum(n // x for x in tab)\\n    if s < t:\\n        l = n + 1\\n    elif s > t:\\n        r = n - 1\\n    else:\\n        r = n\\ns = sum(l // x for x in tab)\\nif s != t:\\n    print(-1)\\nelse:\\n    print(l)\", \"N = int(2e5)\\nn = int(input()) \\ncb = [x*x*x for x in range(2, N)]\\n\\ndef valid(m):\\n    return sum(m//i for i in cb) < n\\n\\ndef binary_search():\\n    l, r = 0, int(1e16)\\n    while l < r:\\n        m = (l+r) // 2\\n        if valid(m):\\n            l = m + 1\\n        else:\\n            r = m\\n    return l\\n\\nres = binary_search()\\nprint(res if sum(res//i for i in cb) == n else -1)\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"1\\n\",\n    \"8\\n\",\n    \"10\\n\",\n    \"27\\n\",\n    \"28206\\n\",\n    \"32\\n\",\n    \"115\\n\",\n    \"81258\\n\",\n    \"116003\\n\",\n    \"149344197\\n\",\n    \"57857854\\n\",\n    \"999999999999999\\n\",\n    \"181023403153\\n\",\n    \"196071196742\\n\",\n    \"49729446417673\\n\",\n    \"14821870173923\\n\",\n    \"29031595887308\\n\",\n    \"195980601490039\\n\",\n    \"181076658641313\\n\",\n    \"166173583620704\\n\",\n    \"151269640772354\\n\",\n    \"136366565751970\\n\",\n    \"121463490731834\\n\",\n    \"106559547884220\\n\",\n    \"91656472864718\\n\",\n    \"184061307002930\\n\",\n    \"57857853\\n\",\n    \"1000000000000000\\n\",\n    \"375402146575334\\n\",\n    \"550368702711851\\n\",\n    \"645093839227897\\n\",\n    \"431\\n\",\n    \"99999\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"4\\n\",\n    \"5\\n\",\n    \"6\\n\",\n    \"7\\n\",\n    \"13\\n\",\n    \"999999999999998\\n\",\n    \"999999999999997\\n\",\n    \"999999999999996\\n\",\n    \"999999999999995\\n\",\n    \"999999999999993\\n\",\n    \"999999999999991\\n\",\n    \"999999999999992\\n\",\n    \"999999999999994\\n\",\n    \"4235246\\n\",\n    \"34\\n\",\n    \"998749999999991\\n\",\n    \"999999874999991\\n\",\n    \"987654129875642\\n\",\n    \"237648237648000\\n\"\n  ],\n  \"outputs\": [\n    \"8\\n\",\n    \"54\\n\",\n    \"-1\\n\",\n    \"152\\n\",\n    \"139840\\n\",\n    \"184\\n\",\n    \"608\\n\",\n    \"402496\\n\",\n    \"574506\\n\",\n    \"739123875\\n\",\n    \"286347520\\n\",\n    \"-1\\n\",\n    \"895903132760\\n\",\n    \"970376182648\\n\",\n    \"246116048009288\\n\",\n    \"73354931125416\\n\",\n    \"143680297402952\\n\",\n    \"969927770453672\\n\",\n    \"896166653569800\\n\",\n    \"822409831653228\\n\",\n    \"748648714769352\\n\",\n    \"674891892852776\\n\",\n    \"601135070936200\\n\",\n    \"527373954052328\\n\",\n    \"453617132135750\\n\",\n    \"910937979445720\\n\",\n    \"-1\\n\",\n    \"4949100894494448\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"16\\n\",\n    \"24\\n\",\n    \"27\\n\",\n    \"32\\n\",\n    \"40\\n\",\n    \"48\\n\",\n    \"80\\n\",\n    \"-1\\n\",\n    \"4949100894494440\\n\",\n    \"4949100894494432\\n\",\n    \"4949100894494424\\n\",\n    \"4949100894494416\\n\",\n    \"4949100894494400\\n\",\n    \"4949100894494408\\n\",\n    \"4949100894494421\\n\",\n    \"-1\\n\",\n    \"-1\\n\",\n    \"4942914518376840\\n\",\n    \"4949100275856792\\n\",\n    \"4887999937625136\\n\",\n    \"1176145105832192\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/689/C",
  "starter_code": ""
}