{
  "task_id": "APPS/219",
  "problem_id": 219,
  "prompt": "A sportsman starts from point x_{start} = 0 and runs to point with coordinate x_{finish} = m (on a straight line). Also, the sportsman can jump \u2014 to jump, he should first take a run of length of not less than s meters (in this case for these s meters his path should have no obstacles), and after that he can jump over a length of not more than d meters. Running and jumping is permitted only in the direction from left to right. He can start andfinish a jump only at the points with integer coordinates in which there are no obstacles. To overcome some obstacle, it is necessary to land at a point which is strictly to the right of this obstacle.\n\nOn the way of an athlete are n obstacles at coordinates x_1, x_2, ..., x_{n}. He cannot go over the obstacles, he can only jump over them. Your task is to determine whether the athlete will be able to get to the finish point.\n\n\n-----Input-----\n\nThe first line of the input containsd four integers n, m, s and d (1 \u2264 n \u2264 200 000, 2 \u2264 m \u2264 10^9, 1 \u2264 s, d \u2264 10^9)\u00a0\u2014 the number of obstacles on the runner's way, the coordinate of the finishing point, the length of running before the jump and the maximum length of the jump, correspondingly.\n\nThe second line contains a sequence of n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 m - 1)\u00a0\u2014 the coordinates of the obstacles. It is guaranteed that the starting and finishing point have no obstacles, also no point can have more than one obstacle, The coordinates of the obstacles are given in an arbitrary order.\n\n\n-----Output-----\n\nIf the runner cannot reach the finishing point, print in the first line of the output \"IMPOSSIBLE\" (without the quotes).\n\nIf the athlete can get from start to finish, print any way to do this in the following format:  print a line of form \"RUN X>\" (where \"X\" should be a positive integer), if the athlete should run for \"X\" more meters;  print a line of form \"JUMP Y\" (where \"Y\" should be a positive integer), if the sportsman starts a jump and should remain in air for \"Y\" more meters. \n\nAll commands \"RUN\" and \"JUMP\" should strictly alternate, starting with \"RUN\", besides, they should be printed chronologically. It is not allowed to jump over the finishing point but it is allowed to land there after a jump. The athlete should stop as soon as he reaches finish.\n\n\n-----Examples-----\nInput\n3 10 1 3\n3 4 7\n\nOutput\nRUN 2\nJUMP 3\nRUN 1\nJUMP 2\nRUN 2\n\nInput\n2 9 2 3\n6 4\n\nOutput\nIMPOSSIBLE",
  "solutions": "[\"n, m, s, d = list(map(int, input().split()))\\n\\nbeg = [float('-inf')]\\nend = [float('-inf')]\\n\\na = [int(i) for i in input().split()]\\n\\nfor x in sorted(a):\\n\\tif (x - end[-1] > s + 1):\\n\\t\\tbeg.append(x)\\n\\t\\tend.append(x)\\n\\telse:\\n\\t\\tend[-1] = x\\n\\nlast = 0\\nR = []\\nJ = []\\n\\nfor i in range(1, len(beg)):\\n\\tR.append(beg[i] - 1 - last)\\n\\tlast = (beg[i] - 1)\\n\\t\\n\\tJ.append(end[i] + 1 - last)\\n\\tlast = (end[i] + 1)\\n\\nok = True\\nfor x in J:\\n\\tif (x > d):\\n\\t\\tok = False\\nfor x in R:\\n\\tif (x < s):\\n\\t\\tok = False\\n\\n\\nif ok:\\n\\tfor i in range(len(R)):\\n\\t\\tprint('RUN', R[i])\\n\\t\\tprint('JUMP', J[i])\\n\\tif (last < m):\\n\\t\\tprint('RUN', m - last)\\nelse:\\n\\tprint('IMPOSSIBLE')\\n\", \"n, m, s, d = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\nif a[0] - 1 < s:\\n    print('IMPOSSIBLE')\\n    return\\nstrategy = []\\ni = 0\\nstand_point = 0\\nwhile i < n:\\n    strategy.append(a[i] - stand_point - 1)\\n    stand_point = a[i] - 1\\n    j = i + 1\\n    if j != n:\\n        a2, a1 = a[j], a[i]\\n    while j < n:\\n        if a2 - a1 - 2 < s:\\n            if a2 - a[i] + 2 > d:\\n                print('IMPOSSIBLE')\\n                return\\n            j += 1\\n            if j != n:\\n                a1 = a2\\n                a2 = a[j]\\n            continue\\n        else:\\n            strategy.append(a1 - a[i] + 2)\\n            i = j\\n            stand_point = a[i - 1] + 1\\n            break\\n    else:\\n        #print(stand_point, strategy_run, strategy_jump)\\n        if d >= a[-1] - stand_point + 1 and strategy[-1] >= s:\\n            strategy.append(a[-1] - stand_point + 1)\\n        else:\\n            print('IMPOSSIBLE')\\n            return\\n        i = j\\n        stand_point = a[i - 1] + 1\\n\\nif m - stand_point != 0:\\n    strategy.append(m - stand_point)\\nturn_flag = True\\nfor i in strategy:\\n    if turn_flag:\\n        print('RUN', i)\\n    else:\\n        print('JUMP', i)\\n    turn_flag = not turn_flag\\n\", \"import sys\\n\\ndef solve():\\n    n, m, s, d = [int(x) for x in input().split()]\\n    obstacles = [int(x) for x in input().split()]\\n    obstacles.sort()\\n    if obstacles[0] <= s: return False\\n    pieces = [[obstacles[0], obstacles[0]]]\\n    for x in obstacles:\\n        if pieces[-1][1] + s + 2 > x:\\n            pieces[-1][1] = x\\n        else:\\n            if pieces[-1][1] - pieces[-1][0] + 2 > d: return False\\n            pieces.append([x, x])\\n    if pieces[-1][1] - pieces[-1][0] + 2 > d: return False\\n    pos = 0\\n    for piece in pieces:\\n        sys.stdout.write('RUN ' + str(piece[0] - pos - 1) + '\\\\n')\\n        sys.stdout.write('JUMP ' + str(piece[1] - piece[0] + 2) + '\\\\n')\\n        pos = piece[1] + 1\\n    if pos < m:\\n        sys.stdout.write('RUN ' + str(m - pos) + '\\\\n')\\n    return True\\n\\nif not solve():\\n    print('IMPOSSIBLE')\\n\", \"n, m, s, d = map(int, input().split())\\nA = sorted(list(map(int, input().split())))\\n\\n# Intervals\\ninv = []\\nprev = -1\\nfor i in range(len(A)):\\n    if A[i] < m:\\n        inv.append((prev, A[i]))\\n        prev = A[i]\\n    else:\\n        inv.append((prev, m))\\n        break\\nif A[-1] < m:\\n    inv.append((A[-1], m))\\n\\noutput = [inv[-1]]\\n\\n# Use of intervals\\nlast = inv[-1]\\nfor i in range(len(inv) - 2, -1, -1):\\n    a, b = inv[i], last\\n    if a[1] - a[0] >= s + 2 and b[0] - a[1] <= d - 2:\\n        last = inv[i]\\n        output.append(last)\\noutput = output[::-1]\\n\\nif m < A[0]:\\n    print(\\\"RUN \\\" + str(m))\\nelif last[0] != -1 or A[0] <= s:\\n    print(\\\"IMPOSSIBLE\\\")\\nelse:\\n    last = 0\\n    for i in range(1, len(output)):\\n        a, b = output[i - 1], output[i]\\n        print(\\\"RUN \\\" + str(a[1] - a[0] - 2))\\n        print(\\\"JUMP \\\" + str(b[0] - a[1] + 2))\\n        last = b[0] + 1\\n    if last < m:\\n        print(\\\"RUN \\\" + str(m - last))\", \"import itertools\\n\\n\\nclass SolutionImpossible(Exception):\\n    pass\\n\\n\\nblocks_cnt, finish, min_sprint, max_jump = [int(x) for x in input().split()]\\n\\n\\ndef read_blocks_coords():\\n    it = (int(x) for x in input().split())\\n    return (x for x in it if x < finish)\\n\\n\\n# TODO: \\u043a\\u043e\\u0434 \\u043c\\u043e\\u0436\\u043d\\u043e \\u0441\\u043e\\u043a\\u0440\\u0430\\u0442\\u0438\\u0442\\u044c \\u0437\\u0430 \\u0441\\u0447\\u0435\\u0442 \\u0438\\u0437\\u0431\\u0430\\u0432\\u043b\\u0435\\u043d\\u0438\\u044f \\u043e\\u0442 \\u043b\\u0438\\u0448\\u043d\\u0435\\u0439 \\u0437\\u0430\\u043f\\u0438\\u0441\\u0438 \\u0432 `_grouper._current_key`\\ndef _grouper(value):\\n    if _grouper._prev_value is not None:\\n        # \\u043f\\u043e\\u0441\\u043b\\u0435 \\u043f\\u0440\\u044b\\u0436\\u043a\\u0430 \\u043c\\u044b \\u043f\\u0440\\u0438\\u0437\\u0435\\u043c\\u043b\\u044f\\u0435\\u043c\\u0441\\u044f \\u0417\\u0410 \\u043f\\u0440\\u0435\\u043f\\u044f\\u0442\\u0441\\u0442\\u0432\\u0438\\u0435\\u043c, \\u0443\\u0447\\u0438\\u0442\\u044b\\u0432\\u0430\\u0435\\u043c \\u044d\\u0442\\u043e\\n        if value - _grouper._prev_value - 1 <= min_sprint:\\n            # \\u0440\\u0430\\u0441\\u0441\\u0442\\u043e\\u044f\\u043d\\u0438\\u0435 \\u043c\\u0435\\u0436\\u0434\\u0443 \\u043f\\u0440\\u0435\\u043f\\u044f\\u0442\\u0441\\u0442\\u0432\\u0438\\u044f\\u043c\\u0438 \\u0441\\u043b\\u0438\\u0448\\u043a\\u043e\\u043c \\u043c\\u0430\\u043b\\u043e\\n            # \\u0447\\u0442\\u043e\\u0431\\u044b \\u043c\\u0435\\u0436\\u0434\\u0443 \\u043d\\u0438\\u043c\\u0438 \\u043f\\u0440\\u0438\\u0437\\u0435\\u043c\\u043b\\u044f\\u0442\\u044c\\u0441\\u044f, \\u0438 \\u0437\\u0430\\u0442\\u0435\\u043c \\u0440\\u0430\\u0437\\u043e\\u0433\\u043d\\u0430\\u0442\\u044c\\u0441\\u044f \\u0434\\u043b\\u044f \\u043d\\u043e\\u0432\\u043e\\u0433\\u043e \\u043f\\u0440\\u044b\\u0436\\u043a\\u0430, \\u0441\\u0447\\u0438\\u0442\\u0430\\u0435\\u043c \\u0438\\u0445 \\u0437\\u0430 \\u043e\\u0434\\u043d\\u043e\\n            _current_key = _grouper._current_key\\n        else:\\n            _current_key = id(value)\\n    else:\\n        # \\u043f\\u0435\\u0440\\u0432\\u043e\\u0435 \\u0432\\u0445\\u043e\\u0436\\u0434\\u0435\\u043d\\u0438\\u0435, \\u0441\\u0442\\u0430\\u0432\\u0438\\u043c \\u0434\\u0430\\u043d\\u043d\\u044b\\u0435 \\u043f\\u043e \\u0443\\u043c\\u043e\\u043b\\u0447\\u0430\\u043d\\u0438\\u044e\\n        _current_key = id(_grouper)\\n\\n    _grouper._prev_value = value\\n    _grouper._current_key = _current_key\\n\\n    return _current_key\\n\\n\\n_grouper._prev_value = None\\n_grouper._current_key = None\\n\\n\\ndef check_chunk(run_from, block=None):\\n    if block is None:\\n        return\\n\\n    next_run_from = block[-1] + 1  # \\u0441\\u043b\\u0435\\u0434\\u0443\\u044e\\u0449\\u0430\\u044f \\u0437\\u0430 \\u043f\\u0440\\u0435\\u0433\\u0440\\u0430\\u0434\\u043e\\u0439 \\u043f\\u043e\\u0437\\u0438\\u0446\\u0438\\u044f (\\u0442\\u043e\\u0447\\u043a\\u0430 \\u043f\\u0440\\u0438\\u0437\\u0435\\u043c\\u043b\\u0435\\u043d\\u0438\\u044f)\\n    if next_run_from - block[0] >= max_jump:\\n        # \\u0435\\u0441\\u043b\\u0438 \\u043f\\u0440\\u0435\\u0433\\u0440\\u0430\\u0434\\u0430 \\u0441\\u043b\\u0438\\u0448\\u043a\\u043e\\u043c \\u0434\\u043b\\u0438\\u043d\\u043d\\u0430\\u044f, \\u0442\\u043e \\u043c\\u044b \\u043d\\u0435 \\u043c\\u043e\\u0436\\u0435\\u043c \\u0435\\u0435 \\u043f\\u0435\\u0440\\u0435\\u0441\\u0435\\u0447\\u044c\\n        raise SolutionImpossible\\n\\n    if abs(run_from - block[0]) <= min_sprint:\\n        # \\u043d\\u0435\\u0442 \\u0432\\u043e\\u0437\\u043c\\u043e\\u0436\\u043d\\u043e\\u0441\\u0442\\u0438 \\u0434\\u043b\\u044f \\u0440\\u0430\\u0437\\u0431\\u0435\\u0433\\u0430\\n        raise SolutionImpossible\\n\\n\\ndef solve_chunk(run_from, block=None):\\n    if block is not None:\\n        run_len = block[0] - run_from - 1  # \\u0434\\u043e\\u0431\\u0435\\u0433\\u0430\\u0435\\u043c \\u0414\\u041e \\u043f\\u0440\\u0435\\u0433\\u0440\\u0430\\u0434\\u044b\\n        jump_len = block[-1] - block[0] + 2  # \\u043f\\u0440\\u044b\\u0433\\u0430\\u0435\\u043c \\u0417\\u0410 \\u043d\\u0435\\u0435\\n        print((\\n            \\\"RUN {run_len}\\\\n\\\"\\n            \\\"JUMP {jump_len}\\\".format(\\n                run_len=run_len,\\n                jump_len=jump_len,\\n            )\\n        ))\\n\\n    else:\\n        run_len = finish - run_from\\n        if run_len > 0:\\n            print(\\\"RUN {run_len}\\\".format(run_len=run_len))\\n\\n\\ndef main():\\n    # \\u043d\\u0435\\u043a\\u043e\\u0442\\u043e\\u0440\\u044b\\u0435 \\u043f\\u0440\\u0435\\u043f\\u044f\\u0442\\u0441\\u0442\\u0432\\u0438\\u044f \\u043c\\u043e\\u0433\\u0443\\u0442 \\u043d\\u0430\\u0445\\u043e\\u0434\\u0438\\u0442\\u044c\\u0441\\u044f \\u0442\\u0430\\u043a \\u0431\\u043b\\u0438\\u0437\\u043a\\u043e, \\u0447\\u0442\\u043e \\u043c\\u0435\\u0436\\u0434\\u0443 \\u043d\\u0438\\u043c\\u0438 \\u043d\\u0435\\u0442 \\u0432\\u043e\\u0437\\u043c\\u043e\\u0436\\u043d\\u043e\\u0441\\u0442\\u0438 \\u0440\\u0430\\u0437\\u043e\\u0433\\u043d\\u0430\\u0442\\u044c\\u0441\\u044f\\n    # \\u0441\\u0447\\u0438\\u0442\\u0430\\u0435\\u043c \\u0442\\u0430\\u043a\\u0438\\u0435 \\u043f\\u0440\\u0435\\u043f\\u044f\\u0442\\u0441\\u0442\\u0432\\u0438\\u044f \\u0437\\u0430 \\u043e\\u0434\\u043d\\u043e\\n    blocks = (list(g) for k, g in itertools.groupby(sorted(read_blocks_coords()), key=_grouper))\\n\\n    chunks = []\\n\\n    run_from = 0\\n    while True:\\n        block = next(blocks, None)\\n\\n        chunk = (run_from, block)\\n        check_chunk(*chunk)\\n\\n        chunks.append(chunk)\\n\\n        if block is None:\\n            break\\n\\n        # \\u043f\\u043e\\u0441\\u043b\\u0435 \\u043f\\u0440\\u044b\\u0436\\u043a\\u0430 \\u043c\\u044b \\u043f\\u0440\\u0438\\u0437\\u0435\\u043c\\u043b\\u044f\\u0435\\u043c\\u0441\\u044f \\u0417\\u0410 \\u043f\\u0440\\u0435\\u043f\\u044f\\u0442\\u0441\\u0442\\u0432\\u0438\\u0435\\u043c, \\u0443\\u0447\\u0438\\u0442\\u044b\\u0432\\u0430\\u0435\\u043c \\u044d\\u0442\\u043e\\n        run_from = block[-1] + 1\\n\\n    #print(chunks)\\n\\n    for chunk in chunks:\\n        solve_chunk(*chunk)\\n\\n\\ndef __starting_point():\\n    try:\\n        main()\\n    except SolutionImpossible:\\n        print(\\\"IMPOSSIBLE\\\")\\n\\n__starting_point()\", \"num_barriers, finish, min_run, max_jump = tuple(map(int, input().split()))\\n\\nbarriers = list(map(int, input().split())) + [-1]\\nbarriers.sort()\\n\\nfor i in range(len(barriers) - 1):\\n    if barriers[i + 1] - barriers[i] <= min_run + 1:\\n        barriers[i] = (0, barriers[i] + 1, barriers[i + 1] - 1)  # nope\\n    else:\\n        barriers[i] = (1, barriers[i] + 1, barriers[i + 1] - 1)  # ok\\n\\nbarriers[len(barriers) - 1] = (1, barriers[len(barriers) - 1] + 1, finish)\\n\\nif not barriers:\\n    pass\\nelif not barriers[0][0]:\\n    print('IMPOSSIBLE')\\nelse:\\n    commands = []\\n    pos = 0\\n\\n    for tpe, st, en in barriers:\\n        if tpe:\\n            if pos != st and st - pos <= max_jump:\\n                commands.append('JUMP %s' % (st - pos))\\n            elif pos != st:\\n                print('IMPOSSIBLE')\\n                break\\n            if en - st:\\n                commands.append('RUN %s' % (en - st))\\n            pos = en\\n    else:\\n        print('\\\\n'.join(commands))\\n\", \"n,m,s,d=map(int,input().split())\\nx=sorted(map(int,input().split()))+[m+s+1]\\ncur=l=0\\nans=[]\\nwhile l<m:\\n    r=min(x[cur]-1,m)\\n    ans+=['RUN '+str(r-l)]\\n    if r==m: break\\n    if r-l<s: ans=['IMPOSSIBLE']; break\\n    t=x[cur]+1\\n    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1\\n    if t-r>d: ans=['IMPOSSIBLE']; break\\n    ans+=['JUMP '+str(t-r)]\\n    l=t;cur+=1\\nprint('\\\\n'.join(ans))\", \"n, m, s, d=map(int, input().split())\\nx = sorted(map(int, input().split())) + [m + s + 1]\\ncur = l = 0\\nans = []\\nwhile l < m:\\n    r = min(x[cur] - 1, m)\\n    ans += ['RUN ' + str(r - l)]\\n    if r == m: break\\n    if r - l < s: ans = ['IMPOSSIBLE']; break\\n    t = x[cur] + 1\\n    while x[cur + 1] - 1 - t < s: cur += 1; t = x[cur] + 1\\n    if t - r > d: ans = ['IMPOSSIBLE']; break\\n    ans += ['JUMP ' + str(t - r)]\\n    l = t;cur += 1\\nprint('\\\\n'.join(ans))\", \"f = lambda: map(int, input().split())\\nn, m, s, d = f()\\np, x, z = [], -1, 1\\nfor y in sorted(f()) + [m + 1]:\\n    if y - x > s + 1 or y > m or x < 0:\\n        u = x - z + 2\\n        v = y - x - 2\\n        if u > d or v < s and x < 0:\\n            p = ['IMPOSSIBLE']\\n            break\\n        if u: p += ['JUMP ' + str(u)]\\n        if v: p += ['RUN ' + str(v)]\\n        z = y\\n    x = y\\nprint('\\\\n'.join(p))\", \"n,m,s,d=list(map(int,input().split()))\\nx=sorted(map(int,input().split()))+[m+s+1]\\ncur=l=0\\nans=[]\\nwhile l<m:\\n    r=min(x[cur]-1,m)\\n    ans+=['RUN '+str(r-l)]\\n    if r==m: break\\n    if r-l<s: ans=['IMPOSSIBLE']; break\\n    t=x[cur]+1\\n    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1\\n    if t-r>d: ans=['IMPOSSIBLE']; break\\n    ans+=['JUMP '+str(t-r)]\\n    l=t;cur+=1\\nprint('\\\\n'.join(ans))\\n\", \"n,m,s,d=list(map(int,input().split()))\\nx=sorted(map(int,input().split()))+[m+s+1]\\ncur=l=0\\nans=[]\\nwhile l<m:\\n    r=min(x[cur]-1,m)\\n    ans+=['RUN '+str(r-l)]\\n    if r==m: break\\n    if r-l<s: ans=['IMPOSSIBLE']; break\\n    t=x[cur]+1\\n    while x[cur+1]-1-t<s: cur+=1; t=x[cur]+1\\n    if t-r>d: ans=['IMPOSSIBLE']; break\\n    ans+=['JUMP '+str(t-r)]\\n    l=t;cur+=1\\nprint('\\\\n'.join(ans))\\n\", \"n, m ,s, d = [int(i) for i in input().split()]  # m is the end point\\n# s is length of run, d is the max jump distance\\nA = [-1] + sorted([int(i) for i in input().split()]) + [m+1]\\nans_size = 2 * 10**5\\nans = [0 for i in range(4*ans_size)]\\n\\n# use 0 to indicate run an 1 to indicate jump\\n\\ndef obstacle():\\n    run = -1\\n    jump = -1\\n    top = 0 # flag where are we at the dp\\n    for i in range(1,n+1):\\n        if s + 2 <= A[i] - A[i-1]:\\n            if jump != -1:\\n                if A[i-1] + 1 - jump <= d and top > 0 and ans[top-1][0] == 0 and ans[top-1][1] >= s:\\n                    ans[top] = (1, A[i-1]+1-jump)\\n                    top += 1\\n                else:\\n                    print(\\\"IMPOSSIBLE\\\")\\n                    return\\n            ans[top] = (0, A[i] - A[i-1]-2) # run\\n            top += 1\\n            jump = A[i] - 1 # jumping point\\n    if A[n] + 1 - jump <= d and top > 0 and ans[top-1][0] == 0 and ans[top-1][1] >= s:\\n        ans[top] = (1, A[n]+1 - jump)\\n        top += 1\\n    else:\\n        print(\\\"IMPOSSIBLE\\\")\\n        return\\n    if m != A[n] + 1:\\n        ans[top] = (0, m-A[n]-1)\\n        top += 1\\n    for i in range(top):\\n        if ans[i][0]:\\n            print(\\\"JUMP\\\", ans[i][1])\\n        else:\\n            print(\\\"RUN\\\", ans[i][1])\\nobstacle()\\n\", \"n, m, s, d = list(map(int, input().split()))\\na = list(map(int, input().split()))\\na.sort()\\npoints = [0, a[0] - 1]\\nif d == 1 or a[0] - 1 < s:\\n    print(\\\"IMPOSSIBLE\\\")\\n    return\\nfor i in range(0, n):\\n    if a[i] - a[i - 1] - 2 < s:\\n        if a[i] + 1 - points[-1] > d:\\n            print(\\\"IMPOSSIBLE\\\")\\n            return\\n    else:\\n        points.append(a[i - 1] + 1)\\n        points.append(a[i] - 1)\\n\\npoints.append(a[-1] + 1)\\nfor i in range(1, len(points)):\\n    if i % 2 == 1:\\n        print(\\\"RUN\\\", points[i] - points[i - 1])\\n    else:\\n        print(\\\"JUMP\\\", points[i] - points[i - 1])\\nif a[-1] + 1 != m:\\n    print(\\\"RUN\\\", m - 1 - a[-1])\\n\"]",
  "input_output": "{\"inputs\": [\"3 10 1 3\\n3 4 7\\n\", \"2 9 2 3\\n6 4\\n\", \"10 100 2 8\\n93 35 24 87 39 46 86 37 73 33\\n\", \"10 1000000000 8905990 20319560\\n233244997 997992814 242452779 497363176 572234096 126615858 886769539 662035052 989086824 716655858\\n\", \"100 1000 1 4\\n228 420 360 642 442 551 940 343 24 83 928 110 663 548 704 461 942 799 283 746 371 204 435 209 986 489 918 526 496 321 233 643 208 717 806 18 291 431 521 631 3 450 711 602 401 60 680 930 625 891 161 279 510 529 546 338 473 925 446 786 384 952 260 649 865 916 789 71 103 997 484 89 408 129 953 670 568 55 287 511 369 225 950 539 652 567 730 499 687 90 779 848 801 606 82 853 967 776 951 329\\n\", \"100 600 1 4\\n9 536 518 59 229 377 72 203 81 309 304 321 55 439 287 505 3 410 582 351 440 568 584 259 22 415 348 147 404 277 477 323 537 75 548 324 338 198 145 182 271 496 256 329 592 132 291 222 115 587 54 158 154 103 356 15 36 76 402 27 223 551 267 527 51 34 417 573 479 398 425 71 485 20 262 566 467 131 524 352 330 541 146 53 322 436 366 86 88 272 96 456 388 319 149 470 129 162 353 346\\n\", \"1 2 1 5\\n1\\n\", \"1 3 1 2\\n2\\n\", \"1 5 1 2\\n2\\n\", \"1 1000000000 1000000000 2\\n999999999\\n\", \"1 100 1 1\\n4\\n\", \"1 1000000000 1 1000000000\\n2\\n\", \"3 12000 2000 3000\\n3000 9002 7001\\n\", \"4 30000 5000 6000\\n6000 16000 15000 21001\\n\", \"3 12000 2000 245\\n3000 9003 7001\\n\", \"4 30000 5000 1654\\n6000 16000 14999 21002\\n\", \"4 10000 500 500\\n700 600 1099 2000\\n\", \"3 20000 4000 3502\\n5000 8500 15000\\n\", \"4 10000 500 500\\n700 601 1099 2000\\n\", \"3 20000 4000 3502\\n5000 8501 15000\\n\", \"1 10 1 2\\n9\\n\", \"1 10 2 9\\n5\\n\", \"1 9 6 4\\n4\\n\", \"1 10 7 4\\n5\\n\", \"2 14 8 8\\n5 9\\n\", \"2 23 12 8\\n8 16\\n\", \"2 14 4 2\\n2 7\\n\", \"3 21 6 2\\n7 11 16\\n\", \"3 29 3 4\\n7 16 19\\n\", \"3 24 2 6\\n6 12 17\\n\", \"4 31 12 9\\n7 13 21 28\\n\", \"4 10 1 7\\n2 4 6 8\\n\", \"4 36 8 4\\n4 13 19 27\\n\", \"5 25 10 2\\n6 12 13 15 22\\n\", \"5 19 7 10\\n3 7 9 12 16\\n\", \"5 28 6 8\\n3 9 15 21 25\\n\", \"6 35 12 4\\n7 12 17 21 24 28\\n\", \"6 22 5 7\\n4 6 10 13 15 18\\n\", \"6 55 3 5\\n10 18 24 34 39 45\\n\", \"7 51 6 1\\n8 17 18 23 27 33 42\\n\", \"7 36 11 4\\n6 11 17 19 22 24 30\\n\", \"7 28 10 2\\n5 10 14 19 21 23 27\\n\", \"8 46 4 5\\n3 6 15 21 24 26 36 42\\n\", \"8 51 2 1\\n6 14 20 26 29 35 40 48\\n\", \"8 56 2 9\\n7 11 20 28 34 39 40 48\\n\", \"9 57 2 2\\n5 11 15 21 24 30 36 43 50\\n\", \"9 82 14 4\\n10 18 28 38 46 55 64 74 79\\n\", \"9 40 6 3\\n5 10 14 18 22 27 30 31 36\\n\", \"10 44 6 2\\n4 8 13 19 23 29 32 33 37 41\\n\", \"10 42 1 3\\n1 6 10 15 17 22 24 29 33 38\\n\", \"10 82 2 5\\n9 17 27 37 44 51 57 62 67 72\\n\", \"11 69 4 9\\n7 14 20 26 29 35 40 46 52 58 64\\n\", \"11 65 1 7\\n7 11 14 21 24 30 37 44 50 56 59\\n\", \"11 77 10 10\\n7 14 17 24 29 34 38 47 56 64 69\\n\", \"12 78 3 1\\n4 11 19 22 30 38 43 51 56 59 67 73\\n\", \"12 89 14 9\\n6 11 18 24 33 37 45 51 60 69 71 80\\n\", \"12 13 6 7\\n1 2 3 4 5 6 7 8 9 10 11 12\\n\", \"13 91 1 3\\n5 12 17 22 29 36 43 49 57 64 70 74 84\\n\", \"13 87 5 6\\n7 10 18 24 31 40 41 48 54 63 69 78 81\\n\", \"13 46 2 4\\n1 4 9 13 15 19 21 23 25 30 35 37 42\\n\", \"14 93 1 1\\n8 15 19 21 28 36 44 51 56 63 67 74 79 85\\n\", \"14 62 11 4\\n5 10 15 18 22 26 31 34 39 42 44 47 52 57\\n\", \"14 109 10 1\\n8 15 25 29 38 48 57 65 70 79 81 89 94 100\\n\", \"15 97 4 4\\n3 7 13 23 29 35 39 45 49 50 60 68 72 81 87\\n\", \"15 77 4 8\\n7 14 16 20 26 33 36 43 44 48 52 59 61 66 70\\n\", \"15 56 1 5\\n5 10 15 20 21 25 29 31 34 37 38 41 43 47 52\\n\", \"2 1000000000 1 3\\n5 8\\n\", \"2 1000000000 1 2\\n5 8\\n\", \"2 1000000000 1 4\\n5 8\\n\", \"2 1000000000 2 4\\n5 8\\n\", \"2 1000000000 2 5\\n5 8\\n\"], \"outputs\": [\"RUN 2\\nJUMP 3\\nRUN 1\\nJUMP 2\\nRUN 2\\n\", \"IMPOSSIBLE\\n\", \"RUN 23\\nJUMP 2\\nRUN 7\\nJUMP 8\\nRUN 5\\nJUMP 2\\nRUN 25\\nJUMP 2\\nRUN 11\\nJUMP 3\\nRUN 4\\nJUMP 2\\nRUN 6\\n\", \"RUN 126615857\\nJUMP 2\\nRUN 106629137\\nJUMP 2\\nRUN 9207780\\nJUMP 2\\nRUN 254910395\\nJUMP 2\\nRUN 74870918\\nJUMP 2\\nRUN 89800954\\nJUMP 2\\nRUN 54620804\\nJUMP 2\\nRUN 170113679\\nJUMP 2\\nRUN 102317283\\nJUMP 8905992\\nRUN 2007185\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 1\\nJUMP 2\\n\", \"RUN 1\\nJUMP 2\\nRUN 2\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 1\\nJUMP 2\\nRUN 999999997\\n\", \"RUN 2999\\nJUMP 2\\nRUN 3999\\nJUMP 2003\\nRUN 2997\\n\", \"IMPOSSIBLE\\n\", \"RUN 2999\\nJUMP 2\\nRUN 3999\\nJUMP 2\\nRUN 2000\\nJUMP 2\\nRUN 2996\\n\", \"RUN 5999\\nJUMP 2\\nRUN 8997\\nJUMP 1003\\nRUN 5000\\nJUMP 2\\nRUN 8997\\n\", \"IMPOSSIBLE\\n\", \"RUN 4999\\nJUMP 3502\\nRUN 6498\\nJUMP 2\\nRUN 4999\\n\", \"RUN 600\\nJUMP 500\\nRUN 899\\nJUMP 2\\nRUN 7999\\n\", \"IMPOSSIBLE\\n\", \"RUN 8\\nJUMP 2\\n\", \"RUN 4\\nJUMP 2\\nRUN 4\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 5\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 6\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 9\\nJUMP 2\\nRUN 6\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 8\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 9\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 6\\nJUMP 2\\nRUN 2\\nJUMP 2\\nRUN 7\\nJUMP 2\\nRUN 6\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 3\\nJUMP 3\\nRUN 6\\nJUMP 2\\nRUN 7\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 8\\nJUMP 2\\nRUN 6\\nJUMP 2\\nRUN 8\\nJUMP 2\\nRUN 8\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 9\\n\", \"RUN 6\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 4\\nJUMP 5\\nRUN 4\\nJUMP 7\\nRUN 4\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 4\\n\", \"RUN 6\\nJUMP 2\\nRUN 2\\nJUMP 2\\nRUN 1\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 1\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 1\\nJUMP 2\\nRUN 5\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 4\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 6\\nJUMP 2\\nRUN 5\\nJUMP 2\\nRUN 4\\nJUMP 2\\nRUN 2\\nJUMP 2\\nRUN 8\\nJUMP 2\\nRUN 6\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"IMPOSSIBLE\\n\", \"RUN 4\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 3\\nJUMP 3\\nRUN 2\\nJUMP 2\\nRUN 2\\nJUMP 4\\nRUN 1\\nJUMP 2\\nRUN 1\\nJUMP 3\\nRUN 1\\nJUMP 4\\nRUN 2\\nJUMP 2\\nRUN 3\\nJUMP 2\\nRUN 3\\n\", \"RUN 4\\nJUMP 2\\nRUN 1\\nJUMP 2\\nRUN 999999991\\n\", \"RUN 4\\nJUMP 2\\nRUN 1\\nJUMP 2\\nRUN 999999991\\n\", \"RUN 4\\nJUMP 2\\nRUN 1\\nJUMP 2\\nRUN 999999991\\n\", \"IMPOSSIBLE\\n\", \"RUN 4\\nJUMP 5\\nRUN 999999991\\n\"]}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/637/D",
  "starter_code": ""
}