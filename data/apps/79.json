{
  "task_id": "APPS/79",
  "problem_id": 79,
  "prompt": "Vivek initially has an empty array $a$ and some integer constant $m$.\n\nHe performs the following algorithm:  Select a random integer $x$ uniformly in range from $1$ to $m$ and append it to the end of $a$.  Compute the greatest common divisor of integers in $a$.  In case it equals to $1$, break  Otherwise, return to step $1$. \n\nFind the expected length of $a$. It can be shown that it can be represented as $\\frac{P}{Q}$ where $P$ and $Q$ are coprime integers and $Q\\neq 0 \\pmod{10^9+7}$. Print the value of $P \\cdot Q^{-1} \\pmod{10^9+7}$.\n\n\n-----Input-----\n\nThe first and only line contains a single integer $m$ ($1 \\leq m \\leq 100000$).\n\n\n-----Output-----\n\nPrint a single integer\u00a0\u2014 the expected length of the array $a$ written as $P \\cdot Q^{-1} \\pmod{10^9+7}$.\n\n\n-----Examples-----\nInput\n1\n\nOutput\n1\n\nInput\n2\n\nOutput\n2\n\nInput\n4\n\nOutput\n333333338\n\n\n\n-----Note-----\n\nIn the first example, since Vivek can choose only integers from $1$ to $1$, he will have $a=[1]$ after the first append operation, and after that quit the algorithm. Hence the length of $a$ is always $1$, so its expected value is $1$ as well.\n\nIn the second example, Vivek each time will append either $1$ or $2$, so after finishing the algorithm he will end up having some number of $2$'s (possibly zero), and a single $1$ in the end. The expected length of the list is $1\\cdot \\frac{1}{2} + 2\\cdot \\frac{1}{2^2} + 3\\cdot \\frac{1}{2^3} + \\ldots = 2$.",
  "solutions": "[\"big = 100010\\ndef gen_mu():\\n    mu = [1]*big\\n    mu[0] = 0\\n    P = [True]*big\\n    P[0] = P[1] = False\\n    for i in range(2,big):\\n        if P[i]:\\n            j = i\\n            while j<big:\\n                P[j] = False\\n                mu[j] *= -1\\n                j += i\\n            j = i*i\\n            while j<big:\\n                mu[j] = 0\\n                j += i*i\\n    return mu\\n\\nm = int(input())\\nmu = gen_mu()\\n\\nMOD = 10**9+7\\ndef mod_inv(x):\\n    return pow(x, MOD-2, MOD)\\n\\ns = 1\\nfor i in range(2,big):\\n    # p is probabilty that i | a random number [1,m]\\n    p = (m//i)*mod_inv(m)\\n    s += (-mu[i])*(p)*mod_inv(1-p)\\nprint(s%MOD)\", \"# https://codeforces.com/blog/entry/66101?#comment-501153\\nMOD = 10 ** 9 + 7\\nm = int(input())\\nf = [0] * (m + 1)\\nans = 1\\nfor i in range(m, 1, -1):\\n    p = m // i * pow(m, MOD - 2, MOD)\\n    f[i] = p * pow(1 - p, MOD - 2, MOD) % MOD\\n    for j in range(2 * i, m + 1, i):\\n        f[i] = (f[i] - f[j]) % MOD\\n    ans += f[i]\\nprint(ans % MOD)\", \"q = 100010\\n\\n\\ndef rop():\\n    a = [1] * q\\n    a[0] = 0\\n    s = [True] * q\\n    s[0] = s[1] = False\\n    for i in range(2, q):\\n        if s[i]:\\n            o = i\\n            while o < q:\\n                s[o] = False\\n                a[o] *= -1\\n                o += i\\n            o = i ** 2\\n            while o < q:\\n                a[o] = 0\\n                o +=  i ** 2\\n    return a\\n\\nd = int(input())\\na = rop()\\n\\n\\ndef pro(x):\\n    return pow(x, 10 ** 9 + 5, 10 ** 9 + 7)\\n\\nf = 1\\nfor i in range(2, q):\\n    z = (d // i) * pro(d)\\n    f += (-a[i]) * z * pro(1 - z)\\nprint(f % (10 ** 9 + 7))\", \"'''\\nhttps://codeforces.com/contest/1139/problem/D\\nhttps://codeforces.com/blog/entry/66101?#comment-500999\\nhttps://brilliant.org/wiki/linearity-of-expectation/\\nhttps://en.wikipedia.org/wiki/Negative_binomial_distribution\\nSuppose there is a sequence of independent Bernoulli trials. Thus, each trial has two potential outcomes called \\\"success\\\" and \\\"failure\\\". In each trial the probability of success is p and of failure is (1 \\u2212 p). We are observing this sequence until a predefined number r of failures has occurred. Then the random number of successes we have seen, X, will have the negative binomial (or Pascal) distribution:\\n\\n{\\\\displaystyle X\\\\sim \\\\operatorname {NB} (r,p)} {\\\\displaystyle X\\\\sim \\\\operatorname {NB} (r,p)}\\n1. mobius function: \\n2. Negative binomial distribution\\n'''\\n\\nN = 100010\\n\\ndef gen_mobius_function():\\n    mu = [1] * N\\n    mu[0] = 0\\n    P = [True] * N\\n    P[0] = P[1] = False\\n    for i in range(2, N):\\n        if P[i]:\\n            j = i\\n            while j < N:\\n                P[j] = False\\n                mu[j] *= -1\\n                j += i\\n            j = i * i\\n            while j < N:\\n                mu[j] = 0\\n                j += i * i\\n    return mu\\n\\nm = int(input())\\nmu = gen_mobius_function()\\n\\nMOD = 10**9 + 7\\n\\ndef mod_inv(x):\\n    return pow(x, MOD - 2, MOD)\\n\\nE = 1\\nfor i in range(2, N):\\n    p = m // i * mod_inv(m)\\n    E += -mu[i] * p * mod_inv(1 - p) #mobius, Negative binomial function\\nprint(E % MOD)\\n\", \"from math import floor\\nfrom functools import reduce\\nMOD = floor(1e9+7)\\nexpected_len = [0, 1]\\n\\nn = int(input())\\n\\nfactors = [[] for i in range(n+1)]\\nprime_factors = [[] for i in range(n+1)]\\n\\ndef ext_euclid(a, b):\\n    if b == 0:\\n        return 1, 0, a\\n    x, y, q = ext_euclid(b, a % b)\\n    x, y = y, (x - (a//b) * y)\\n    return x, y, q\\n\\n\\ndef inverse(num):\\n    return ext_euclid(MOD, num)[1] % MOD\\n\\n\\ninv = [0] * (n+1)\\nfor i in range(n+1):\\n    inv[i] = inverse(i)\\n\\nfor i in range(1, n+1):\\n    prime_fact = False\\n    if len(prime_factors[i]) < 2:\\n        prime_factors[i].append(i)\\n        prime_fact = True\\n    \\n    factors[i].append(i)\\n    for j in range(2*i, n+ 1, i):\\n        factors[j].append(i)\\n        if prime_fact:\\n            prime_factors[j].append(i)\\n\\n# Calculate the number i = x * y\\n# Such that j in [1, n // x]  gcd(j, y) == 1\\n\\ndef f(x, y):\\n    remain = 0\\n    new_n = n // x\\n\\n    new_y = reduce(lambda x, y: x*y, prime_factors[y])\\n    for fact in factors[new_y]:\\n        if fact != 1:\\n            if len(prime_factors[fact]) & 1:\\n                remain -= new_n // fact\\n            else:\\n                remain += new_n // fact\\n    return new_n - remain\\n\\n\\nfor i in range(2, n+1):\\n    # i = y * b\\n    e_len = 0\\n    for ele in factors[i]:\\n        if ele != i:\\n            e_len += (f(ele, i // ele) * expected_len[ele] * inv[n]) % MOD\\n    e_len = ((e_len + 1)* n *  inv[n-f(i, 1)]) % MOD\\n    expected_len.append(e_len)\\n\\nprint((sum(expected_len) * inv[n]) % MOD)\\n\", \"\\\"\\\"\\\"\\n    Author : thekushalghosh\\n    Team   : CodeDiggers\\n\\\"\\\"\\\"\\nimport sys,math\\ninput = sys.stdin.readline\\n \\n############ ---- USER DEFINED INPUT FUNCTIONS ---- ############\\ndef inp():\\n    return(int(input()))\\ndef inlt():\\n    return(list(map(int,input().split())))\\ndef insr():\\n    s = input()\\n    return(s[:len(s) - 1])\\ndef invr():\\n    return(map(int,input().split()))\\n################################################################\\n############ ---- THE ACTUAL CODE STARTS BELOW ---- ############\\nt = 1\\nfor tt in range(t):\\n    m = int(input())\\n    q = [0] * (m + 1)\\n    c = 1\\n    for i in range(m, 1, -1):\\n        w = m // i * pow(m, 1000000007 - 2, 1000000007)\\n        q[i] = w * pow(1 - w, 1000000007 - 2, 1000000007) % 1000000007\\n        for j in range(2 * i, m + 1, i):\\n            q[i] = (q[i] - q[j]) % 1000000007\\n        c = c + q[i]\\n    print(c % 1000000007)\", \"from sys import *\\nm = int(input())\\nq = [0] * (m + 1)\\nc = 1\\nfor i in range(m, 1, -1):\\n    w = m // i * pow(m, 1000000007 - 2, 1000000007)\\n    q[i] = w * pow(1 - w, 1000000007 - 2, 1000000007) % 1000000007\\n    for j in range(2 * i, m + 1, i):\\n        q[i] = (q[i] - q[j]) % 1000000007\\n    c = c + q[i]\\nprint(c % 1000000007)\"]",
  "input_output": "{\n  \"inputs\": [\n    \"1\\n\",\n    \"2\\n\",\n    \"4\\n\",\n    \"3\\n\",\n    \"5\\n\",\n    \"6\\n\",\n    \"7\\n\",\n    \"8\\n\",\n    \"9\\n\",\n    \"10\\n\",\n    \"11\\n\",\n    \"12\\n\",\n    \"100000\\n\",\n    \"99991\\n\",\n    \"30030\\n\",\n    \"99594\\n\",\n    \"91402\\n\",\n    \"93493\\n\",\n    \"96917\\n\",\n    \"80555\\n\",\n    \"30238\\n\",\n    \"5447\\n\",\n    \"5714\\n\",\n    \"735\\n\",\n    \"64\\n\",\n    \"256\\n\",\n    \"2048\\n\",\n    \"32768\\n\",\n    \"65536\\n\",\n    \"23\\n\",\n    \"12167\\n\",\n    \"13\\n\",\n    \"14\\n\",\n    \"15\\n\",\n    \"16\\n\",\n    \"17\\n\",\n    \"18\\n\",\n    \"19\\n\",\n    \"20\\n\",\n    \"10609\\n\",\n    \"93179\\n\",\n    \"10859\\n\",\n    \"677\\n\",\n    \"919\\n\",\n    \"7635\\n\",\n    \"95835\\n\",\n    \"92138\\n\",\n    \"29019\\n\",\n    \"64444\\n\",\n    \"88373\\n\",\n    \"88439\\n\",\n    \"7710\\n\",\n    \"7404\\n\",\n    \"8616\\n\",\n    \"92386\\n\",\n    \"99622\\n\",\n    \"92171\\n\",\n    \"99360\\n\",\n    \"90661\\n\",\n    \"92213\\n\",\n    \"91068\\n\",\n    \"93378\\n\",\n    \"98179\\n\",\n    \"91286\\n\",\n    \"91568\\n\",\n    \"91086\\n\",\n    \"95539\\n\",\n    \"90740\\n\",\n    \"94998\\n\",\n    \"95042\\n\",\n    \"92239\\n\",\n    \"78088\\n\",\n    \"74792\\n\",\n    \"22028\\n\",\n    \"36884\\n\",\n    \"66917\\n\",\n    \"36312\\n\",\n    \"79162\\n\",\n    \"42626\\n\",\n    \"6752\\n\",\n    \"611\\n\",\n    \"2864\\n\",\n    \"9304\\n\",\n    \"1045\\n\",\n    \"9376\\n\",\n    \"8636\\n\",\n    \"75232\\n\",\n    \"48457\\n\",\n    \"60255\\n\",\n    \"54369\\n\",\n    \"46654\\n\",\n    \"83480\\n\",\n    \"22799\\n\",\n    \"68540\\n\",\n    \"47539\\n\",\n    \"64115\\n\",\n    \"41764\\n\",\n    \"99900\\n\",\n    \"99911\\n\",\n    \"99329\\n\",\n    \"99945\\n\",\n    \"99896\\n\",\n    \"99936\\n\",\n    \"82460\\n\",\n    \"74074\\n\",\n    \"55311\\n\",\n    \"15015\\n\",\n    \"77385\\n\",\n    \"86632\\n\"\n  ],\n  \"outputs\": [\n    \"1\\n\",\n    \"2\\n\",\n    \"333333338\\n\",\n    \"2\\n\",\n    \"166666670\\n\",\n    \"500000006\\n\",\n    \"716666674\\n\",\n    \"476190482\\n\",\n    \"225000004\\n\",\n    \"567460324\\n\",\n    \"430555561\\n\",\n    \"318181823\\n\",\n    \"534174612\\n\",\n    \"434191575\\n\",\n    \"723188569\\n\",\n    \"166105505\\n\",\n    \"347601361\\n\",\n    \"606807336\\n\",\n    \"838672461\\n\",\n    \"409222861\\n\",\n    \"750441533\\n\",\n    \"741627218\\n\",\n    \"559826101\\n\",\n    \"607779919\\n\",\n    \"572467262\\n\",\n    \"927439938\\n\",\n    \"665668016\\n\",\n    \"645842651\\n\",\n    \"458595757\\n\",\n    \"485745620\\n\",\n    \"831671589\\n\",\n    \"468253974\\n\",\n    \"966666676\\n\",\n    \"553571435\\n\",\n    \"85780889\\n\",\n    \"519841276\\n\",\n    \"625000007\\n\",\n    \"984514841\\n\",\n    \"935537382\\n\",\n    \"503257127\\n\",\n    \"765292545\\n\",\n    \"380490066\\n\",\n    \"948537108\\n\",\n    \"434774514\\n\",\n    \"874467055\\n\",\n    \"834924464\\n\",\n    \"751784127\\n\",\n    \"963174399\\n\",\n    \"249303275\\n\",\n    \"857337836\\n\",\n    \"567687036\\n\",\n    \"33998115\\n\",\n    \"785109731\\n\",\n    \"340579911\\n\",\n    \"159998877\\n\",\n    \"109597446\\n\",\n    \"323804671\\n\",\n    \"557358009\\n\",\n    \"413855313\\n\",\n    \"876201665\\n\",\n    \"917827355\\n\",\n    \"820319423\\n\",\n    \"674222305\\n\",\n    \"843541605\\n\",\n    \"866047090\\n\",\n    \"685679455\\n\",\n    \"125860916\\n\",\n    \"178533194\\n\",\n    \"123894686\\n\",\n    \"460012534\\n\",\n    \"736315231\\n\",\n    \"185311544\\n\",\n    \"683829911\\n\",\n    \"797695183\\n\",\n    \"120075637\\n\",\n    \"760262294\\n\",\n    \"657550913\\n\",\n    \"283204023\\n\",\n    \"9522345\\n\",\n    \"689855972\\n\",\n    \"328389339\\n\",\n    \"225651508\\n\",\n    \"891558121\\n\",\n    \"883481609\\n\",\n    \"362881216\\n\",\n    \"768818941\\n\",\n    \"376862836\\n\",\n    \"559402589\\n\",\n    \"917128937\\n\",\n    \"200047474\\n\",\n    \"500907462\\n\",\n    \"124910318\\n\",\n    \"767471115\\n\",\n    \"291762913\\n\",\n    \"442384963\\n\",\n    \"570892404\\n\",\n    \"65880203\\n\",\n    \"313467660\\n\",\n    \"55921825\\n\",\n    \"635418994\\n\",\n    \"47143644\\n\",\n    \"423867335\\n\",\n    \"129595366\\n\",\n    \"79287597\\n\",\n    \"472079813\\n\",\n    \"341088608\\n\",\n    \"618014296\\n\",\n    \"724140171\\n\",\n    \"626563584\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1139/D",
  "starter_code": ""
}