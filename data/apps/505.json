{
  "task_id": "APPS/505",
  "problem_id": 505,
  "prompt": "The Robot is in a rectangular maze of size n \u00d7 m. Each cell of the maze is either empty or occupied by an obstacle. The Robot can move between neighboring cells on the side left (the symbol \"L\"), right (the symbol \"R\"), up (the symbol \"U\") or down (the symbol \"D\"). The Robot can move to the cell only if it is empty. Initially, the Robot is in the empty cell.\n\nYour task is to find lexicographically minimal Robot's cycle with length exactly k, which begins and ends in the cell where the Robot was initially. It is allowed to the Robot to visit any cell many times (including starting).\n\nConsider that Robot's way is given as a line which consists of symbols \"L\", \"R\", \"U\" and \"D\". For example, if firstly the Robot goes down, then left, then right and up, it means that his way is written as \"DLRU\".\n\nIn this task you don't need to minimize the length of the way. Find the minimum lexicographical (in alphabet order as in the dictionary) line which satisfies requirements above.\n\n\n-----Input-----\n\nThe first line contains three integers n, m and k (1 \u2264 n, m \u2264 1000, 1 \u2264 k \u2264 10^6) \u2014 the size of the maze and the length of the cycle. \n\nEach of the following n lines contains m symbols \u2014 the description of the maze. If the symbol equals to \".\" the current cell is empty. If the symbol equals to \"*\" the current cell is occupied by an obstacle. If the symbol equals to \"X\" then initially the Robot is in this cell and it is empty. It is guaranteed that the symbol \"X\" is found in the maze exactly once. \n\n\n-----Output-----\n\nPrint the lexicographically minimum Robot's way with the length exactly k, which starts and ends in the cell where initially Robot is. If there is no such way, print \"IMPOSSIBLE\"(without quotes).\n\n\n-----Examples-----\nInput\n2 3 2\n.**\nX..\n\nOutput\nRL\n\nInput\n5 6 14\n..***.\n*...X.\n..*...\n..*.**\n....*.\n\nOutput\nDLDDLLLRRRUURU\n\nInput\n3 3 4\n***\n*X*\n***\n\nOutput\nIMPOSSIBLE\n\n\n\n-----Note-----\n\nIn the first sample two cyclic ways for the Robot with the length 2 exist \u2014 \"UD\" and \"RL\". The second cycle is lexicographically less. \n\nIn the second sample the Robot should move in the following way: down, left, down, down, left, left, left, right, right, right, up, up, right, up. \n\nIn the third sample the Robot can't move to the neighboring cells, because they are occupied by obstacles.",
  "solutions": "[\"import math\\nfrom collections import deque\\n\\ndef main():\\n\\tn, m, k = list(map(int, input().split()))\\n\\tgrid = [\\\"\\\" for _ in range(n)]\\n\\tx, y = 0, 0\\n\\n\\tfor i in range(n):\\n\\t\\tgrid[i] = input()\\n\\t\\tif 'X' in grid[i]:\\n\\t\\t\\tx, y = i, grid[i].index('X')\\n\\n\\tif k % 2 == 1:\\n\\t\\tprint(\\\"IMPOSSIBLE\\\")\\n\\t\\treturn\\n\\n\\tdx = [1, 0, 0, -1]\\t\\n\\tdy = [0, -1, 1, 0]\\n\\tnames = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \\\"DLRU\\\")}\\n\\trev_names = {x1: y1 for x1, y1 in zip(\\\"DLRU\\\", \\\"URLD\\\")}\\n\\n\\tdef ok(x, y):\\n\\t\\treturn (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\\n\\t\\n\\n\\tdef bfs(x, y):\\n\\t\\tMAX_DIST = (1 << 20)\\n\\t\\tdist = [[MAX_DIST for y in range(m)] for x in range(n)]\\n\\t\\tdist[x][y] = 0\\n\\t\\tq = deque()\\n\\t\\tq.append((x, y))\\n\\n\\t\\twhile len(q) > 0:\\n\\t\\t\\tx, y = q.popleft()\\n\\n\\t\\t\\tfor x0, y0 in zip(dx, dy):\\n\\t\\t\\t\\tif ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\\n\\t\\t\\t\\t\\tdist[x + x0][y + y0] = dist[x][y] + 1\\n\\t\\t\\t\\t\\tq.append((x + x0, y + y0))\\t\\t\\n\\n\\t\\treturn dist\\t\\t\\t\\n\\n\\tpath = []\\n\\tx_start, y_start = x, y\\n\\n\\tdist = bfs(x_start, y_start)\\n\\n\\tfor i in range(k // 2):\\n\\t\\tfor x1, y1 in zip(dx, dy):\\n\\t\\t\\tif ok(x + x1, y + y1):\\n\\t\\t\\t\\tpath.append(names.get((x1, y1)))\\t\\n\\t\\t\\t\\tx += x1\\n\\t\\t\\t\\ty += y1\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tprint(\\\"IMPOSSIBLE\\\")\\n\\t\\t\\treturn\\n\\n\\tmoves = k // 2\\t\\t\\n\\tfor i in range(k // 2):\\n\\t\\tfor x1, y1 in zip(dx, dy):\\n\\t\\t\\tif ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\\n\\t\\t\\t\\tpath.append(names.get((x1, y1)))\\n\\t\\t\\t\\tx += x1\\n\\t\\t\\t\\ty += y1\\n\\t\\t\\t\\tmoves -= 1\\n\\t\\t\\t\\tbreak\\n\\n\\tprint(\\\"\\\".join(x for x in path))\\n\\ndef __starting_point():\\n\\tmain()\\n__starting_point()\", \"import math\\nfrom collections import deque\\n\\ndef main():\\n\\tn, m, k = list(map(int, input().split()))\\n\\tgrid = [\\\"\\\" for _ in range(n)]\\n\\tx, y = 0, 0\\n\\n\\tfor i in range(n):\\n\\t\\tgrid[i] = input()\\n\\t\\tif 'X' in grid[i]:\\n\\t\\t\\tx, y = i, grid[i].index('X')\\n\\n\\tif k % 2 == 1:\\n\\t\\tprint(\\\"IMPOSSIBLE\\\")\\n\\t\\treturn\\n\\n\\tdx = [1, 0, 0, -1]\\t\\n\\tdy = [0, -1, 1, 0]\\n\\tnames = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \\\"DLRU\\\")}\\n\\trev_names = {x1: y1 for x1, y1 in zip(\\\"DLRU\\\", \\\"URLD\\\")}\\n\\n\\tdef ok(x, y):\\n\\t\\treturn (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\\n\\t\\n\\n\\tdef bfs(x, y):\\n\\t\\tMAX_DIST = (1 << 20)\\n\\t\\tdist = [[MAX_DIST for y in range(m)] for x in range(n)]\\n\\t\\tdist[x][y] = 0\\n\\t\\tq = deque()\\n\\t\\tq.append((x, y))\\n\\n\\t\\twhile len(q) > 0:\\n\\t\\t\\tx, y = q.popleft()\\n\\n\\t\\t\\tfor x0, y0 in zip(dx, dy):\\n\\t\\t\\t\\tif ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\\n\\t\\t\\t\\t\\tdist[x + x0][y + y0] = dist[x][y] + 1\\n\\t\\t\\t\\t\\tq.append((x + x0, y + y0))\\t\\t\\n\\n\\t\\treturn dist\\t\\t\\t\\n\\n\\tpath = []\\n\\tx_start, y_start = x, y\\n\\n\\tdist = bfs(x_start, y_start)\\n\\n\\tfor i in range(k // 2):\\n\\t\\tfor x1, y1 in zip(dx, dy):\\n\\t\\t\\tif ok(x + x1, y + y1):\\n\\t\\t\\t\\tpath.append(names.get((x1, y1)))\\t\\n\\t\\t\\t\\tx += x1\\n\\t\\t\\t\\ty += y1\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tprint(\\\"IMPOSSIBLE\\\")\\n\\t\\t\\treturn\\n\\n\\tmoves = k // 2\\t\\t\\n\\tfor i in range(k // 2):\\n\\t\\tfor x1, y1 in zip(dx, dy):\\n\\t\\t\\tif ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\\n\\t\\t\\t\\tpath.append(names.get((x1, y1)))\\n\\t\\t\\t\\tx += x1\\n\\t\\t\\t\\ty += y1\\n\\t\\t\\t\\tmoves -= 1\\n\\t\\t\\t\\tbreak\\n\\n\\tprint(\\\"\\\".join(x for x in path))\\n\\ndef __starting_point():\\n\\tmain()\\n__starting_point()\", \"from queue import Queue\\nimport sys\\n#sys.stdin = open('input.txt')\\n\\nn, m, k = [int(x) for x in input().split(' ')]\\n\\nif k&1:\\n  print('IMPOSSIBLE')\\n  return\\n\\ns = [None]*n\\nfor i in range(n):\\n  s[i] = [None]*m\\n  t = input()\\n  for j in range(m):\\n    s[i][j] = t[j]\\n    if t[j] == 'X': x, y = j, i\\n\\ndef bfs(x, y):\\n  res = [[10000000]*m for i in range(n)]\\n  if s[y][x] == '*': return res\\n  q = Queue()\\n  q.put((x, y))\\n  step = 0\\n\\n  def add(x, y):\\n    if res[y][x] != 10000000 or s[y][x] == '*' or step >= res[y][x]: return\\n    q.put((x, y))\\n    res[y][x] = step+1\\n\\n  res[y][x] = step\\n\\n  while not q.empty():\\n    x, y = q.get()\\n    step = res[y][x]\\n    #print('-')\\n    if y < n-1: add(x, y+1) #D\\n    if x > 0: add(x-1, y)   #L\\n    if x < m-1: add(x+1, y) #R\\n    if y > 0: add(x, y-1)   #U\\n  return res\\n\\nres = bfs(x, y)\\n\\n\\npath = []\\nadd = lambda s: path.append(s)\\nfor i in range(k):\\n  step = k-i\\n  #print(step, (y, x), k-i)\\n  if y < n-1 and res[y+1][x] <= step: #D\\n    add('D')\\n    y = y+1\\n  elif x > 0 and res[y][x-1] <= step: #L\\n    add('L')\\n    x = x-1\\n  elif x < m-1 and res[y][x+1] <= step: #R\\n    add('R')\\n    x = x+1\\n  elif y > 0 and res[y-1][x] <= step: #U\\n    add('U')\\n    y = y-1\\n  else:\\n    print('IMPOSSIBLE')\\n    return\\n\\nprint(str.join('', path))\\n\", \"import math\\nfrom collections import deque\\n\\ndef main():\\n\\tn, m, k = list(map(int, input().split()))\\n\\tgrid = [\\\"\\\" for _ in range(n)]\\n\\tx, y = 0, 0\\n\\n\\tfor i in range(n):\\n\\t\\tgrid[i] = input()\\n\\t\\tif 'X' in grid[i]:\\n\\t\\t\\tx, y = i, grid[i].index('X')\\n\\n\\tif k % 2 == 1:\\n\\t\\tprint(\\\"IMPOSSIBLE\\\")\\n\\t\\treturn\\n\\n\\tdx = [1, 0, 0, -1]\\t\\n\\tdy = [0, -1, 1, 0]\\n\\tnames = {(x1, y1): sym for x1, y1, sym in zip(dx, dy, \\\"DLRU\\\")}\\n\\trev_names = {x1: y1 for x1, y1 in zip(\\\"DLRU\\\", \\\"URLD\\\")}\\n\\n\\tdef ok(x, y):\\n\\t\\treturn (0 <= x < n) and (0 <= y < m) and grid[x][y] != '*'\\n\\t\\n\\n\\tdef bfs(x, y):\\n\\t\\tMAX_DIST = (1 << 20)\\n\\t\\tdist = [[MAX_DIST for y in range(m)] for x in range(n)]\\n\\t\\tdist[x][y] = 0\\n\\t\\tq = deque()\\n\\t\\tq.append((x, y))\\n\\n\\t\\twhile len(q) > 0:\\n\\t\\t\\tx, y = q.popleft()\\n\\n\\t\\t\\tfor x0, y0 in zip(dx, dy):\\n\\t\\t\\t\\tif ok(x + x0, y + y0) and dist[x][y] + 1 < dist[x + x0][y + y0]:\\n\\t\\t\\t\\t\\tdist[x + x0][y + y0] = dist[x][y] + 1\\n\\t\\t\\t\\t\\tq.append((x + x0, y + y0))\\t\\t\\n\\n\\t\\treturn dist\\t\\t\\t\\n\\n\\tpath = []\\n\\tx_start, y_start = x, y\\n\\n\\tdist = bfs(x_start, y_start)\\n\\n\\tfor i in range(k // 2):\\n\\t\\tfor x1, y1 in zip(dx, dy):\\n\\t\\t\\tif ok(x + x1, y + y1):\\n\\t\\t\\t\\tpath.append(names.get((x1, y1)))\\t\\n\\t\\t\\t\\tx += x1\\n\\t\\t\\t\\ty += y1\\n\\t\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tprint(\\\"IMPOSSIBLE\\\")\\n\\t\\t\\treturn\\n\\n\\tmoves = k // 2\\t\\t\\n\\tfor i in range(k // 2):\\n\\t\\tfor x1, y1 in zip(dx, dy):\\n\\t\\t\\tif ok(x + x1, y + y1) and dist[x + x1][y + y1] <= moves:\\n\\t\\t\\t\\tpath.append(names.get((x1, y1)))\\n\\t\\t\\t\\tx += x1\\n\\t\\t\\t\\ty += y1\\n\\t\\t\\t\\tmoves -= 1\\n\\t\\t\\t\\tbreak\\n\\n\\tprint(\\\"\\\".join(x for x in path))\\n\\ndef __starting_point():\\n\\tmain()\\n\\n\\n\\n# Made By Mostafa_Khaled\\n\\n__starting_point()\", \"#https://codeforces.com/contest/769/problem/C\\nimport collections\\nlis = input().split()\\nn,m,k = int(lis[0]),int(lis[1]),int(lis[2])\\nempty = [[False for i in range(m)] for j in range(n)]\\nmainrow,maincol = 0,0\\nfor i in range(n):\\n\\ts = input()\\n\\tfor j in range(m):\\n\\t\\tif(s[j]=='.'):\\n\\t\\t\\tempty[i][j] = True\\n\\t\\telif (s[j]=='X'):\\n\\t\\t\\tempty[i][j] = True\\n\\t\\t\\tmainrow = i\\n\\t\\t\\tmaincol = j\\nd = [[-1 for i in range(m)] for j in range(n)]\\nque = collections.deque([(mainrow,maincol)])\\nd[mainrow][maincol] = 0\\nchanges = [(1,0),(-1,0),(0,1),(0,-1)]\\nwhile(que):\\n\\t(x,y) = que.popleft()\\n\\tfor (i,j) in changes:\\n\\t\\txnex = x+i\\n\\t\\tynex = y+j\\n\\t\\tif(xnex>=0 and xnex<n and ynex>=0 and ynex<m and empty[xnex][ynex] and d[xnex][ynex]==-1):\\n\\t\\t\\td[xnex][ynex]=d[x][y]+1\\n\\t\\t\\tque.append((xnex,ynex))\\ncurrrow = mainrow\\ncurrcol = maincol\\nlis = []\\nif(k%2==0):\\n\\tflag = False\\n\\tfor (i,j) in changes:\\n\\t\\txnex = mainrow+i\\n\\t\\tynex = maincol+j\\n\\t\\tif(xnex>=0 and xnex<n and ynex>=0 and ynex<m and empty[xnex][ynex]):\\n\\t\\t\\tflag = True\\n\\tif(flag):\\n\\t\\twhile(k):\\n\\t\\t\\tif(currrow+1<n and empty[currrow+1][currcol] and d[currrow+1][currcol]<k):\\n\\t\\t\\t\\tlis.append('D')\\n\\t\\t\\t\\tcurrrow+=1\\n\\t\\t\\telif(currcol-1>=0 and empty[currrow][currcol-1] and d[currrow][currcol-1]<k):\\n\\t\\t\\t\\tlis.append('L')\\n\\t\\t\\t\\tcurrcol-=1\\n\\t\\t\\telif(currcol+1<m and empty[currrow][currcol+1] and d[currrow][currcol+1]<k):\\n\\t\\t\\t\\tlis.append('R')\\n\\t\\t\\t\\tcurrcol+=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlis.append('U')\\n\\t\\t\\t\\tcurrrow-=1\\n\\t\\t\\tk-=1\\n\\t\\tif(currcol == maincol and currrow == mainrow):\\n\\t\\t\\tprint(\\\"\\\".join(lis))\\n\\t\\telse:\\n\\t\\t\\tprint(\\\"IMPOSSIBLE WHY\\\")\\n\\telse:\\n\\t\\tprint(\\\"IMPOSSIBLE\\\")\\nelse:\\n\\tprint(\\\"IMPOSSIBLE\\\")\"]",
  "input_output": "{\n  \"inputs\": [\n    \"2 3 2\\n.**\\nX..\\n\",\n    \"5 6 14\\n..***.\\n*...X.\\n..*...\\n..*.**\\n....*.\\n\",\n    \"3 3 4\\n***\\n*X*\\n***\\n\",\n    \"1 1 1\\nX\\n\",\n    \"1 2 2\\nX.\\n\",\n    \"1 5 4\\n.X**.\\n\",\n    \"1 10 1\\n........X.\\n\",\n    \"1 20 10\\n*.*..............*.X\\n\",\n    \"1 25 24\\n..*.....X.*.**..*.*..*...\\n\",\n    \"2 1 1\\nX\\n.\\n\",\n    \"2 2 2\\nX*\\n.*\\n\",\n    \"2 5 2\\n.....\\n*.*.X\\n\",\n    \"2 10 4\\n******....\\n*.****.*X*\\n\",\n    \"2 20 26\\n.****..*.**.**.*....\\n.*.*.*.*...*.****..X\\n\",\n    \"2 25 46\\n.*...***X....*..*........\\n.....*...**.**.*....*...*\\n\",\n    \"5 1 2\\n*\\n.\\nX\\n*\\n.\\n\",\n    \"5 2 8\\n..\\n.*\\nX.\\n..\\n*.\\n\",\n    \"5 5 12\\n..**.\\n***..\\n..X*.\\n....*\\n**..*\\n\",\n    \"5 10 42\\n..**.**.**\\n......*..*\\n..**...X..\\n*.......*.\\n......*.**\\n\",\n    \"5 20 96\\n..............*.....\\n........*...*.......\\n.............*......\\n.................*..\\n....*.*......X......\\n\",\n    \"5 25 68\\n..*...***..******..***...\\n...*.****.*.......***..X.\\n**..**.****......**.**.*.\\n...*...*.***.*.....*.**..\\n**...***.*.**..**.**.....\\n\",\n    \"10 1 8\\n.\\n*\\n*\\n.\\n.\\nX\\n*\\n.\\n*\\n*\\n\",\n    \"10 2 16\\n.*\\n*.\\n*.\\n..\\n**\\nX.\\n..\\n*.\\n..\\n.*\\n\",\n    \"10 5 42\\n.*...\\n.....\\n.....\\n.*...\\n....*\\n...*.\\n....X\\n.....\\n.....\\n**...\\n\",\n    \"10 10 4\\n*..*...***\\nX...*.....\\n***...**..\\n..********\\n.*.*......\\n*.**..*...\\n.**.**..**\\n*.**.**..*\\n**.****.*.\\n...**..*.*\\n\",\n    \"10 20 102\\n..*.....*.....*.....\\n....*.X.............\\n..*.................\\n....................\\n........*...........\\n....................\\n*.....*.............\\n...............*...*\\n......*..**.........\\n*..........*........\\n\",\n    \"10 25 154\\n........*................\\n.........................\\n.........................\\n.......*.................\\n.........................\\n.....................*...\\n............*...*........\\n.........................\\n.....X................*..\\n.........................\\n\",\n    \"20 1 12\\n.\\n.\\n.\\n*\\n.\\nX\\n.\\n.\\n.\\n.\\n.\\n.\\n*\\n*\\n.\\n.\\n.\\n.\\n.\\n.\\n\",\n    \"20 2 22\\n.*\\n**\\n..\\n**\\n**\\n..\\n.*\\n.*\\n..\\n..\\n**\\n**\\n.*\\n**\\n..\\n.*\\n..\\n..\\nX*\\n..\\n\",\n    \"20 5 22\\n.....\\n...*.\\n**.*.\\n**.*.\\n.....\\n*....\\n.....\\n.**..\\n..*..\\n.**..\\n....*\\n..*..\\n.....\\n.*.**\\n***..\\n**...\\n.....\\n*...*\\n*X..*\\n*....\\n\",\n    \"20 10 116\\n..........\\n....*.....\\n.......*..\\n*.........\\n*....*....\\n*........*\\n..........\\n*.........\\n.......*..\\n...*..*...\\n..........\\n...*......\\n..*.......\\n.....**..*\\n........*.\\n........*.\\n...*......\\n.........*\\n.....*.X..\\n*......*.*\\n\",\n    \"20 20 118\\n..............*.....\\n........*.........*.\\n............*.......\\n*...................\\n....*......*..*.....\\n................*...\\n....................\\n...............*....\\n.......*..........*.\\n.*..........*.......\\n.*..............*..X\\n....................\\n...............*....\\n....................\\n.*.....*.......*....\\n.......**..*........\\n....................\\n..........**.......*\\n.....*...*..........\\n........*...........\\n\",\n    \"25 1 22\\n.\\n*\\n*\\n.\\n*\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n*\\n.\\n.\\n.\\n*\\n.\\n.\\n.\\n*\\n.\\nX\\n.\\n\",\n    \"25 2 26\\n.*\\n*.\\n..\\n.*\\n..\\n*.\\n.*\\n.*\\n.*\\n..\\n*.\\n..\\n..\\n..\\n..\\n..\\n*.\\n.*\\n.*\\n..\\n..\\n.*\\nX*\\n..\\n..\\n\",\n    \"25 5 22\\n.....\\n.....\\n.....\\n**...\\n...*.\\n...*.\\n*..*.\\n.....\\n...**\\n.*...\\n.....\\n*....\\n*....\\n*....\\n*...X\\n.....\\n.*...\\n...*.\\n.*..*\\n....*\\n.....\\n.....\\n*....\\n.....\\n..*..\\n\",\n    \"25 10 38\\n....*...**\\n.........*\\n.........*\\n**...*....\\n..........\\n.*.....*.*\\n***.*....*\\n..*****.**\\n*........*\\n*.........\\n.*..*.**.*\\n.*....*...\\n..*..**...\\n...*.*.*.*\\n.*.*.....*\\n.*.X.*...*\\n*...**...*\\n..........\\n.*..*.*.**\\n*.*..**.*.\\n*.....*..*\\n...**.*...\\n...*...*..\\n...*......\\n...*.....*\\n\",\n    \"1 2 2\\n.X\\n\",\n    \"2 1 2\\n.\\nX\\n\",\n    \"2 1 2\\nX\\n.\\n\",\n    \"2 1 2\\n*\\nX\\n\",\n    \"2 1 2\\nX\\n*\\n\",\n    \"1 2 2\\nX*\\n\",\n    \"1 2 2\\n*X\\n\",\n    \"1 1 1000000\\nX\\n\",\n    \"1 1 1\\nX\\n\",\n    \"1 1 2\\nX\\n\"\n  ],\n  \"outputs\": [\n    \"RL\\n\",\n    \"DLDDLLLRRRUURU\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"RL\\n\",\n    \"LRLR\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"LRLRLRLRLR\\n\",\n    \"LLLLLRLRLRLRLRLRLRLRRRRR\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"DU\\n\",\n    \"LR\\n\",\n    \"UDUD\\n\",\n    \"LLRLRLRLRLRLRLRLRLRLRLRLRR\\n\",\n    \"DLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRU\\n\",\n    \"UD\\n\",\n    \"DRDUDULU\\n\",\n    \"DDRLRLRLRLUU\\n\",\n    \"DDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUU\\n\",\n    \"LLLLLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRRRRR\\n\",\n    \"LDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUDUR\\n\",\n    \"UDUDUDUD\\n\",\n    \"DRDDLDUDUDURUULU\\n\",\n    \"DDDLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRUUU\\n\",\n    \"RLRL\\n\",\n    \"DDDDLDDDDLLLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRRRUUUURUUUU\\n\",\n    \"DLLLLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRRRRU\\n\",\n    \"DDDDDDUUUUUU\\n\",\n    \"DRLRLRLRLRLRLRLRLRLRLU\\n\",\n    \"DRLRLRLRLRLRLRLRLRLRLU\\n\",\n    \"LDLLLLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRRRRUR\\n\",\n    \"DDDDDDLDDDLLLLLLLLLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRLRRRRRRRRRUUURUUUUUU\\n\",\n    \"DUDUDUDUDUDUDUDUDUDUDU\\n\",\n    \"DDRLRLRLRLRLRLRLRLRLRLRLUU\\n\",\n    \"DDDUDUDUDUDUDUDUDUDUUU\\n\",\n    \"DDDDDLDDDDLLRLRLRLRLRLRLRLRRUUUURUUUUU\\n\",\n    \"LR\\n\",\n    \"UD\\n\",\n    \"DU\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\",\n    \"IMPOSSIBLE\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/769/C",
  "starter_code": ""
}