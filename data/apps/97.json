{
  "task_id": "APPS/97",
  "problem_id": 97,
  "prompt": "Consider a billiard table of rectangular size $n \\times m$ with four pockets. Let's introduce a coordinate system with the origin at the lower left corner (see the picture).  [Image] \n\nThere is one ball at the point $(x, y)$ currently. Max comes to the table and strikes the ball. The ball starts moving along a line that is parallel to one of the axes or that makes a $45^{\\circ}$ angle with them. We will assume that:   the angles between the directions of the ball before and after a collision with a side are equal,  the ball moves indefinitely long, it only stops when it falls into a pocket,  the ball can be considered as a point, it falls into a pocket if and only if its coordinates coincide with one of the pockets,  initially the ball is not in a pocket. \n\nNote that the ball can move along some side, in this case the ball will just fall into the pocket at the end of the side.\n\nYour task is to determine whether the ball will fall into a pocket eventually, and if yes, which of the four pockets it will be.\n\n\n-----Input-----\n\nThe only line contains $6$ integers $n$, $m$, $x$, $y$, $v_x$, $v_y$ ($1 \\leq n, m \\leq 10^9$, $0 \\leq x \\leq n$; $0 \\leq y \\leq m$; $-1 \\leq v_x, v_y \\leq 1$; $(v_x, v_y) \\neq (0, 0)$)\u00a0\u2014 the width of the table, the length of the table, the $x$-coordinate of the initial position of the ball, the $y$-coordinate of the initial position of the ball, the $x$-component of its initial speed and the $y$-component of its initial speed, respectively. It is guaranteed that the ball is not initially in a pocket.\n\n\n-----Output-----\n\nPrint the coordinates of the pocket the ball will fall into, or $-1$ if the ball will move indefinitely.\n\n\n-----Examples-----\nInput\n4 3 2 2 -1 1\n\nOutput\n0 0\nInput\n4 4 2 0 1 1\n\nOutput\n-1\nInput\n10 10 10 1 -1 0\n\nOutput\n-1\n\n\n-----Note-----\n\nThe first sample:  [Image] \n\nThe second sample:  [Image] \n\nIn the third sample the ball will never change its $y$ coordinate, so the ball will never fall into a pocket.",
  "solutions": "[\"def INV(a, m) :\\n    m0 = m\\n    y = 0\\n    x = 1 \\n    if (m == 1) :\\n        return 0 \\n    while (a > 1) : \\n        q = a // m \\n        t = m \\n        m = a % m\\n        a = t\\n        t = y \\n        y = x - q * y\\n        x = t\\n    if (x < 0) :\\n        x = x + m0 \\n    return x\\ndef GCD(a, b):\\n  if a == 0: return b\\n  return GCD(b%a,a)\\ndef solve():\\n  n, m, x, y, vx, vy = list(map(int, input().split()))\\n  if vx == 0:\\n    if x != 0 and x != n:\\n      print(\\\"-1\\\")\\n      return 0\\n    ans = [0,0]\\n    ans[0] = x\\n    if vy < 0: ans[1] = 0\\n    else: ans[1] = m\\n    print(ans[0],ans[1])\\n    return 0\\n  if vy == 0:\\n    if y != 0 and y != m:\\n      print(\\\"-1\\\")\\n      return 0\\n    ans = [0,0]\\n    ans[1] = y\\n    if vx < 0: ans[0] = 0\\n    else: ans[0] = n\\n    print(ans[0],ans[1])\\n    return 0\\n  if vx == -1 and x == 0: vx = 1\\n  if vx == 1 and x == n: vx = -1\\n  if vy == -1 and y == 0: vy = 1\\n  if vy == 1 and y == m: vy = -1\\n  g = GCD(n,m)\\n  m1 = n\\n  m2 = m\\n  a1 = -1 * vx * x % m1\\n  a2 = -1 * vy * y % m2\\n  if a1 % g != a2 % g:\\n    print(\\\"-1\\\")\\n    return 0\\n  if GCD(m1//g,m2) == 1:\\n    m1 = m1 // g\\n  else:\\n    m2 = m2 // g\\n  m1_bar = INV(m2,m1)\\n  m2_bar = INV(m1,m2)\\n  k = (a1 * m1_bar*m2 + a2 * m2_bar*m1) % (m1*m2)\\n  rowtouch = ((k+m-1)//m) % 2\\n  coltouch = ((k+n-1)//n) % 2\\n  ans = [0,0]\\n  if vx == 1: ans[0] = 0\\n  else: ans[0] = n\\n  if vy == 1: ans[1] = 0\\n  else: ans[1] = m\\n  if rowtouch == 1: ans[1] = m-ans[1]\\n  if coltouch == 1: ans[0] = n-ans[0]\\n  print(ans[0],ans[1])\\n  return 0\\nsolve()\\n\", \"#!/usr/bin/env python3\\n\\n[n, m, x, y, vx, vy] = list(map(int, input().strip().split()))\\n\\n# x, y >= 0, x + y > 0\\n# (d, p, q) : px + qy = d\\ndef mygcd(x, y):\\n\\tif x > y:\\n\\t\\td, p, q = mygcd(y, x)\\n\\t\\treturn d, q, p\\n\\tif x == 0:\\n\\t\\treturn y, 0, 1\\n\\tm, r = divmod(y, x)\\n\\td, p, q = mygcd(r, x)\\n\\treturn d, q - p*m, p\\n\\n\\n\\ndef solve(n, m, x, y, vx, vy):\\n#\\tprint ('solve', n, m, x, y, vx, vy)\\n\\tif vx < 0:\\n\\t\\tcx, cy = solve(n, m, n - x, y, -vx, vy)\\n\\t\\tif cx < 0:\\n\\t\\t\\treturn cx, cy\\n\\t\\telse:\\n\\t\\t\\treturn n - cx, cy\\n\\tif vy < 0:\\n\\t\\tcx, cy = solve(n, m, x, m - y, vx, -vy)\\n\\t\\tif cx < 0:\\n\\t\\t\\treturn cx, cy\\n\\t\\telse:\\n\\t\\t\\treturn cx, m - cy\\n\\t# vx, vy is nonnegative\\n\\tif vx == 0:\\n\\t\\tif x in (0, n):\\n\\t\\t\\treturn x, m\\n\\t\\telse:\\n\\t\\t\\treturn -1, -1\\n\\tif vy == 0:\\n\\t\\tif y in (0, m):\\n\\t\\t\\treturn n, y\\n\\t\\telse:\\n\\t\\t\\treturn -1, -1\\n\\t# vx = vy > 0\\n\\td, p, q = mygcd(n, m)\\n\\tif (x - y) % d != 0:\\n\\t\\treturn -1, -1\\n\\tif x == y and n == m:\\n\\t\\treturn n, m\\n\\tif x == y:\\n\\t\\treturn ((m // d) % 2) * n, ((n // d) % 2) * m\\n\\tmxy = min(x, y)\\n\\tx, y = x - mxy, y - mxy\\n\\tn //= d\\n\\tm //= d\\n\\tx //= d\\n\\ty //= d\\n\\tc = x - y\\n\\tp = (p * c) % m\\n\\tq = (-q * c) % n\\n#\\tprint ('nmxypq', n, m, x, y, p, q, '=', p*n - x, q*m - y)\\n\\tif p*n - x < 0:\\n\\t\\tp += m * (-((x - p*n) // m))\\n\\tif q*m - y < 0:\\n\\t\\tq += n * (-((y - q*m) // n))\\n\\treturn (p % 2) * n * d, (q % 2) * m * d\\n\\t\\ncx, cy = solve(n, m, x, y, vx, vy)\\nif cx < 0:\\n\\tprint(-1)\\nelse:\\n\\tprint(cx, cy)\\n\\n\\t\\n\", \"#!/usr/bin/env python2\\n[n, m, x, y, vx, vy] = list(map(int, input().strip().split()))\\ndef mygcd(x, y):\\n\\tif x > y:\\n\\t\\td, p, q = mygcd(y, x)\\n\\t\\treturn d, q, p\\n\\tif x == 0:\\n\\t\\treturn y, 0, 1\\n\\tm, r = divmod(y, x)\\n\\td, p, q = mygcd(r, x)\\n\\treturn d, q - p*m, p\\n\\ndef solve(n, m, x, y, vx, vy):\\n\\tif vx < 0:\\n\\t\\tcx, cy = solve(n, m, n - x, y, -vx, vy)\\n\\t\\tif cx < 0:\\n\\t\\t\\treturn cx, cy\\n\\t\\telse:\\n\\t\\t\\treturn n - cx, cy\\n\\tif vy < 0:\\n\\t\\tcx, cy = solve(n, m, x, m - y, vx, -vy)\\n\\t\\tif cx < 0:\\n\\t\\t\\treturn cx, cy\\n\\t\\telse:\\n\\t\\t\\treturn cx, m - cy\\n\\tif vx == 0:\\n\\t\\tif x in (0, n):\\n\\t\\t\\treturn x, m\\n\\t\\telse:\\n\\t\\t\\treturn -1, -1\\n\\tif vy == 0:\\n\\t\\tif y in (0, m):\\n\\t\\t\\treturn n, y\\n\\t\\telse:\\n\\t\\t\\treturn -1, -1\\n\\td, p, q = mygcd(n, m)\\n\\tif (x - y) % d != 0:\\n\\t\\treturn -1, -1\\n\\tif x == y and n == m:\\n\\t\\treturn n, m\\n\\tif x == y:\\n\\t\\treturn ((m // d) % 2) * n, ((n // d) % 2) * m\\n\\tmxy = min(x, y)\\n\\tx, y = x - mxy, y - mxy\\n\\tn //= d\\n\\tm //= d\\n\\tx //= d\\n\\ty //= d\\n\\tc = x - y\\n\\tp = (p * c) % m\\n\\tq = (-q * c) % n\\n\\tif p*n - x < 0:\\n\\t\\tp += m * (-((x - p*n) // m))\\n\\tif q*m - y < 0:\\n\\t\\tq += n * (-((y - q*m) // n))\\n\\treturn (p % 2) * n * d, (q % 2) * m * d\\n\\t\\ncx, cy = solve(n, m, x, y, vx, vy)\\nif cx < 0:\\n\\tprint(-1)\\nelse:\\n\\tprint(cx, cy)\\n\", \"def getIntList():\\n    return list(map(int, input().split()));\\ndef getTransIntList(n):\\n    first=getIntList();\\n    m=len(first);\\n    result=[[0]*n for _ in range(m)];\\n    for i in range(m):\\n        result[i][0]=first[i];\\n    for j in range(1, n):\\n        curr=getIntList();\\n        for i in range(m):\\n            result[i][j]=curr[i];\\n    return result;\\nn, m, x, y, vx, vy=getIntList();\\n#\\u0412\\u043e\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u041d\\u041e\\u0414 d \\u0438 \\u043a\\u043e\\u044d\\u0444\\u0444\\u0438\\u0446\\u0438\\u0435\\u043d\\u0442\\u044b k1, k2: k1*n1+k2*n2=d\\ndef GCDKoef(n1, n2):\\n    k11=1;\\n    k12=0;\\n    k21=0;\\n    k22=1;\\n    while n2>0:\\n        k, r=divmod(n1, n2);\\n        n1, n2= n2, r;\\n        #r=n1-n2*k\\n        k11, k12, k21, k22 = k21, k22, k11 - k21 * k, k12 - k22*k;\\n    return n1, k11, k12;\\ndef solveSystemCongruence(a1, n1, a2, n2):\\n    d, k1, k2=GCDKoef(n1, n2);\\n    if (a1-a2)%d!=0:\\n        return None;\\n    #t===a1(n1), t===a2(n2), d=GCD(n1, n2), d=n1*k1+n2*k2\\n    #r=a1%d=a2%d; a1=r+d*x1 a2=r+d*x2\\n    #t=r+x1*n2*k2+x2*n1*k1===r+d*x1=a1(n1) ===r+d*x2=a2(n2)\\n    r=a1%d;\\n    x1=(a1-r)//d;\\n    x2=(a2-r)//d;\\n    t=r+x1*n2*k2+x2*n1*k1;\\n    mod=n1*n2//d;\\n    t%=mod;\\n    if t<0:\\n        t+=mod;\\n    return t;\\nif vx==0:\\n    if x!=0 and x!=n:\\n        print(-1);\\n    elif vy==1:\\n        print(x, m)\\n    else:\\n        print(x, 0);\\nelif vy==0:\\n    if y!=0 and y!=m:\\n        print(-1);\\n    elif vx==1:\\n        print(n, y);\\n    else:\\n        print(0, y);\\nelse:\\n    t=solveSystemCongruence(-x*vx, n, -y*vy, m);\\n    if t==None:\\n        print(-1);\\n    else:\\n        x=x+t*vx;\\n        y=y+t*vy;\\n        x//=n;\\n        y//=m;\\n        x%=2;\\n        y%=2;\\n        x=abs(x);\\n        y=abs(y);\\n        print(x*n, y*m);\", \"def gcd(a, b):\\n    if (b == 0):\\n        return a\\n    return gcd(b, a % b)\\n\\ndef exgcd(a, b):\\n    if (b == 0):\\n        return (1, 0, a)\\n    (p, q, r) = exgcd(b, a % b)\\n    t = p\\n    p = q\\n    q = t - (a // b) * q\\n    return (p, q, r)\\nlist = input().split()\\nn = int(list[0]); m = int(list[1]);\\nx = int(list[2]); y = int(list[3])\\nvx = int(list[4]); vy = int(list[5])\\nif (vx == 0):\\n    if ((x != 0) and (x != n)):\\n        print(-1)\\n    else:\\n        if (vy == 1):\\n            print(x, m)\\n        else:\\n            print(x, 0)\\nif (vy == 0):\\n    if ((y != 0) and (y != m)):\\n        print(-1)\\n    else:\\n        if (vx == 1):\\n            print(n, y)\\n        else:\\n            print(0, y)\\nif ((vx != 0) and (vy != 0)):\\n    fx = 0; fy = 0\\n    if (vx == -1):\\n        fx = 1\\n        x = n - x\\n    if (vy == -1):\\n        fy = 1\\n        y = m - y\\n    (p, q, r) = exgcd(n, m)\\n    if ((x - y) % r != 0):\\n        print(-1)\\n    else:\\n        p *= (x - y) // r\\n        q *= (x - y) // r\\n        mn = m * n // gcd(m, n)\\n        a = (p * n - x) % mn\\n        while (a <= 0):\\n            a += mn\\n        p = (x + a) // n\\n        q = (y + a) // m\\n        ansx = 0; ansy = 0;\\n        if ((p + fx) % 2 == 1):\\n            ansx = n\\n        if ((q + fy) % 2 == 1):\\n            ansy = m\\n        print(ansx, ansy)\\n\", \"import fractions\\n\\ndef extendedEuclid(A, B):\\n\\tX = 0; Y = 0\\n\\tif B == 0:\\n\\t\\tX = 1; Y = 0\\n\\telse:\\n\\t\\tX, Y = extendedEuclid(B, A % B)\\n\\t\\ttemp = X\\n\\t\\tX = Y; Y = temp - (A // B) * Y\\n\\treturn X, Y\\n\\ndef DiophantusSolver(a, b, c):\\n\\tg = abs(fractions.gcd(a, b))\\n\\tif c % g != 0: return (10 ** 40, 10 ** 40)\\n\\tp, q = extendedEuclid(abs(a // g), abs(b // g))\\n\\tr11 = (p * c // g); r12 = (q * c // g)\\n\\tt1 = xi + r11 * n\\n\\tq, p = extendedEuclid(abs(b // g), abs(a // g))\\n\\tr21 = (p * c // g); r22 = (q * c // g)\\n\\tt2 = xi + r21 * n\\n\\tif (r11, r12) < (r21, r22): return r11, r12\\n\\treturn r21, r22\\n\\nn, m, x, y, vx, vy = map(int, input().split())\\n\\nif vx * vy == 0:\\n\\tif vx == 0:\\n\\t\\tif x > 0 and x < n: print('-1')\\n\\t\\telif vy < 0: print('{} 0'.format(x))\\n\\t\\telif vy > 0: print('{} {}'.format(x, m))\\n\\telif vy == 0:\\n\\t\\tif y > 0 and y < m: print('-1')\\n\\t\\telif vx < 0: print('0 {}'.format(y))\\n\\t\\telif vx > 0: print('{} {}'.format(n, y))\\nelse:\\n\\txi = x % n; yi = y % m\\n\\tLCM = (n * m // fractions.gcd(n, m))\\n\\tif vx > 0: xi = (n - x) % n\\n\\tif vy > 0: yi = (m - y) % m\\n\\ttx, ty = DiophantusSolver(n, -m, yi - xi)\\n\\tif (tx == 10 ** 40):\\n\\t\\tprint('-1')\\n\\telse:\\n\\t\\tt = (xi + tx * n) % LCM\\n\\t\\twhile t < 0: t += LCM\\n\\t\\tx1 = (x + t * vx) % (n * 2)\\n\\t\\twhile x1 < 0: x1 += (n * 2)\\n\\t\\ty1 = (y + t * vy) % (m * 2)\\n\\t\\twhile y1 < 0: y1 += (m * 2)\\n\\t\\tprint(x1, y1)\", \"\\ndef exgcd(a, b):\\n    if b == 0: return (a, 1, 0)\\n    g, y, x = exgcd(b, a%b)\\n    return (g, x, y-x*(a//b))\\n\\ndef crt(a1, m1, a2, m2):\\n    g = exgcd(m1, m2)[0]\\n    \\n    e1, e2 = a1%g, a2%g\\n    if e1 != e2: return None\\n\\n    a1 //= g \\n    m1 //= g \\n    a2 //= g\\n    m2 //= g\\n\\n    (_, m1i, m2i) = exgcd(m1, m2)\\n\\n    ans = a1*m2*m2i + a2*m1*m1i\\n    \\n    ans = ans%(m1*m2)\\n    if ans < 0: ans += m1*m2\\n\\n    return ans*g + e1\\n\\n\\ndef solve(N, M, x, y, vx, vy):\\n  if vx == 0:\\n    if x == 0 or x == N: return (x, 0)\\n    else: return None\\n  if vy == 0:\\n    if y == 0 or y == M: return (0, y)\\n    else: return None\\n  \\n  ans = crt(x, N, y, M)\\n  #print(ans)\\n  if ans is None: return ans\\n\\n  xhit, yhit = (ans+N-1) // N, (ans+M-1) // M\\n  if x == 0: xhit -= 1\\n  if y == 0: yhit -= 1\\n  #print(xhit, yhit)\\n\\n  return (N if xhit%2 == 0 else 0, M if yhit%2 == 0 else 0)\\n\\ndef main():\\n  N, M, x, y, vx, vy = map(int, input().split())\\n\\n  swapx, swapy = False, False\\n\\n  if vx > 0:\\n    swapx = True\\n    x = N-x\\n  \\n  if vy > 0:\\n    swapy = True\\n    y = M-y\\n    \\n  ans = solve(N, M, x, y, vx, vy)\\n  if ans is None: print(-1)\\n  else:\\n    ax, ay = ans\\n    if swapx: ax = N-ax\\n    if swapy: ay = M-ay \\n    print(ax, ay)\\n\\n\\ndef __starting_point():\\n  main()\\n__starting_point()\"]",
  "input_output": "{\n  \"inputs\": [\n    \"4 3 2 2 -1 1\\n\",\n    \"4 4 2 0 1 1\\n\",\n    \"10 10 10 1 -1 0\\n\",\n    \"1000000000 1000000000 1 1000000000 0 1\\n\",\n    \"2 1 1 0 -1 -1\\n\",\n    \"4 2 1 2 1 1\\n\",\n    \"5 3 4 3 1 -1\\n\",\n    \"15 9 1 1 1 1\\n\",\n    \"15 9 1 1 -1 -1\\n\",\n    \"15 9 2 1 1 1\\n\",\n    \"15 9 2 1 -1 1\\n\",\n    \"1000000000 999999999 999999998 999999999 -1 -1\\n\",\n    \"1000000000 999999999 999999998 999999999 -1 1\\n\",\n    \"15 9 3 2 1 1\\n\",\n    \"15 9 3 2 1 -1\\n\",\n    \"4 4 0 1 0 1\\n\",\n    \"4 4 4 2 0 -1\\n\",\n    \"1000000000 999999999 999999999 999999999 1 1\\n\",\n    \"1000000000 999999999 999999998 999999999 1 1\\n\",\n    \"1000000000 999999999 999999998 999999999 1 -1\\n\",\n    \"1000000000 999999999 999999998 999999999 0 1\\n\",\n    \"1000000000 999999999 999999998 999999999 -1 0\\n\",\n    \"1 99 0 16 -1 1\\n\",\n    \"6 8 1 1 1 1\\n\",\n    \"6 10 1 1 1 1\\n\",\n    \"8 6 7 1 -1 1\\n\",\n    \"10009 10007 1 1 1 1\\n\",\n    \"10007 10009 10006 10008 -1 -1\\n\",\n    \"1000 999 1 998 1 -1\\n\",\n    \"500 500 250 250 -1 1\\n\",\n    \"2705444 415131525 949293 337120042 1 -1\\n\",\n    \"603278410 844534002 499505824 32181172 1 -1\\n\",\n    \"316347709 122791181 255721626 19148895 -1 1\\n\",\n    \"226591495 303844168 64300938 148467902 -1 -1\\n\",\n    \"682138812 116415655 516825996 73682791 -1 1\\n\",\n    \"305675046 505376350 144451750 295580797 -1 1\\n\",\n    \"313157692 571680270 238352863 235464142 1 -1\\n\",\n    \"120717601 973035857 103171773 511250918 -1 1\\n\",\n    \"41373770 597127671 31867608 404367855 -1 1\\n\",\n    \"827285013 307724101 775951207 175683367 -1 -1\\n\",\n    \"110474424 613900860 31471099 442410471 -1 1\\n\",\n    \"84035810 39157280 10865763 24269978 1 -1\\n\",\n    \"75744115 329085002 22395692 81831548 -1 1\\n\",\n    \"20597226 82154419 5899110 71189386 1 1\\n\",\n    \"550269655 264187669 141601786 53516425 1 -1\\n\",\n    \"224819588 978615384 68538326 805268586 1 1\\n\",\n    \"979444430 110858783 607921615 88320790 1 -1\\n\",\n    \"853950494 911554949 428001551 108479491 1 1\\n\",\n    \"810387002 412176212 187695958 236085023 1 1\\n\",\n    \"20877471 722211317 8457280 75966699 -1 -1\\n\",\n    \"542708351 3475408 103232934 399149 1 1\\n\",\n    \"30609041 976052297 4229728 158676967 -1 1\\n\",\n    \"495082283 937762241 250777046 412284609 1 1\\n\",\n    \"68076815 985943633 40657983 165191148 1 -1\\n\",\n    \"209408006 202717192 115684862 96677080 -1 -1\\n\",\n    \"651520659 433737829 645844796 133999548 1 -1\\n\",\n    \"835624982 341676615 379293679 54053933 1 -1\\n\",\n    \"943609111 405753192 556398014 348647907 1 -1\\n\",\n    \"590709848 332238455 546245223 240305069 -1 1\\n\",\n    \"320049957 92820858 176731509 15650804 1 1\\n\",\n    \"233140029 827954502 99465884 170396111 1 1\\n\",\n    \"760904646 962606170 641547160 113696561 -1 1\\n\",\n    \"584801838 775270595 121061956 644380885 -1 1\\n\",\n    \"141190266 126518281 76515989 109124404 1 1\\n\",\n    \"225067174 487662889 175063389 447988824 1 1\\n\",\n    \"814170008 703690544 6953086 439080555 -1 1\\n\",\n    \"12671644 216092609 3707378 92213588 1 1\\n\",\n    \"686521539 766868053 668178904 36804229 1 1\\n\",\n    \"43760214 59779641 32562470 43565961 -1 1\\n\",\n    \"281776735 833828834 271604381 491447288 -1 1\\n\",\n    \"362762211 732244195 63812822 258610562 -1 1\\n\",\n    \"312319019 933972106 103989975 544805243 1 -1\\n\",\n    \"142096067 231234738 40134344 206132422 -1 1\\n\",\n    \"289285219 692430999 249276742 628721059 1 -1\\n\",\n    \"490696330 492707826 183410939 115542637 -1 -1\\n\",\n    \"916524063 555774494 499847875 268662592 -1 1\\n\",\n    \"101123973 722433301 46988094 586973439 -1 1\\n\",\n    \"808357574 854008109 9323335 342356143 -1 -1\\n\",\n    \"257447593 468889343 162885112 15431794 1 1\\n\",\n    \"688226257 305863798 134250684 285725084 -1 -1\\n\",\n    \"836255310 741706431 648685681 396741892 1 -1\\n\",\n    \"480678700 670120443 423401724 177051387 1 1\\n\",\n    \"35550087 590484118 10858303 37118846 1 1\\n\",\n    \"491475453 334831307 136826756 228553610 1 -1\\n\",\n    \"172057628 368934073 117631597 83410362 1 1\\n\",\n    \"611927194 869083092 295778083 541333563 -1 -1\\n\",\n    \"329666407 901295668 90510437 485008861 1 -1\\n\",\n    \"978089453 426264909 388420346 53798427 -1 1\\n\",\n    \"242449067 548221648 24810672 63078584 1 1\\n\",\n    \"583053442 353408 240939980 17207 -1 1\\n\",\n    \"10 9 8 9 -1 1\\n\",\n    \"999999997 999999999 500 500 -1 1\\n\",\n    \"1000000000 1000000000 999 100 -1 -1\\n\",\n    \"7 5 2 3 1 0\\n\",\n    \"11 13 5 7 -1 -1\\n\",\n    \"500 1000 200 200 1 1\\n\",\n    \"500 995 1 1 1 1\\n\",\n    \"1 100 0 1 1 1\\n\",\n    \"1 100 0 1 1 0\\n\",\n    \"999999999 999999998 2 3 -1 1\\n\",\n    \"500000000 499999999 499999999 499999999 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"0 0\",\n    \"-1\",\n    \"-1\",\n    \"-1\",\n    \"0 1\",\n    \"-1\",\n    \"0 3\",\n    \"15 9\",\n    \"0 0\",\n    \"-1\",\n    \"15 0\",\n    \"1000000000 999999999\",\n    \"1000000000 999999999\",\n    \"-1\",\n    \"-1\",\n    \"0 4\",\n    \"4 0\",\n    \"1000000000 0\",\n    \"0 999999999\",\n    \"0 999999999\",\n    \"-1\",\n    \"0 999999999\",\n    \"1 99\",\n    \"0 8\",\n    \"6 10\",\n    \"0 0\",\n    \"10009 10007\",\n    \"0 0\",\n    \"1000 999\",\n    \"0 500\",\n    \"2705444 415131525\",\n    \"603278410 844534002\",\n    \"316347709 0\",\n    \"0 303844168\",\n    \"0 116415655\",\n    \"-1\",\n    \"-1\",\n    \"120717601 0\",\n    \"41373770 597127671\",\n    \"827285013 307724101\",\n    \"-1\",\n    \"-1\",\n    \"0 0\",\n    \"0 0\",\n    \"550269655 0\",\n    \"224819588 978615384\",\n    \"979444430 110858783\",\n    \"853950494 0\",\n    \"-1\",\n    \"0 722211317\",\n    \"542708351 3475408\",\n    \"30609041 0\",\n    \"495082283 0\",\n    \"0 985943633\",\n    \"209408006 202717192\",\n    \"0 0\",\n    \"835624982 0\",\n    \"943609111 0\",\n    \"0 0\",\n    \"-1\",\n    \"233140029 827954502\",\n    \"-1\",\n    \"0 775270595\",\n    \"0 126518281\",\n    \"225067174 487662889\",\n    \"-1\",\n    \"12671644 0\",\n    \"686521539 0\",\n    \"-1\",\n    \"281776735 833828834\",\n    \"362762211 732244195\",\n    \"0 0\",\n    \"0 231234738\",\n    \"0 692430999\",\n    \"490696330 0\",\n    \"916524063 555774494\",\n    \"101123973 0\",\n    \"0 0\",\n    \"-1\",\n    \"0 305863798\",\n    \"-1\",\n    \"480678700 670120443\",\n    \"35550087 590484118\",\n    \"491475453 334831307\",\n    \"172057628 368934073\",\n    \"0 869083092\",\n    \"-1\",\n    \"0 426264909\",\n    \"0 548221648\",\n    \"-1\",\n    \"10 9\",\n    \"0 0\",\n    \"-1\",\n    \"-1\",\n    \"0 0\",\n    \"0 1000\",\n    \"500 0\",\n    \"1 100\",\n    \"-1\",\n    \"999999999 0\",\n    \"500000000 0\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/982/E",
  "starter_code": ""
}