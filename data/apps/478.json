{
  "task_id": "APPS/478",
  "problem_id": 478,
  "prompt": "You are given a string $s$ consisting of lowercase Latin letters. Let the length of $s$ be $|s|$. You may perform several operations on this string.\n\nIn one operation, you can choose some index $i$ and remove the $i$-th character of $s$ ($s_i$) if at least one of its adjacent characters is the previous letter in the Latin alphabet for $s_i$. For example, the previous letter for b is a, the previous letter for s is r, the letter a has no previous letters. Note that after each removal the length of the string decreases by one. So, the index $i$ should satisfy the condition $1 \\le i \\le |s|$ during each operation.\n\nFor the character $s_i$ adjacent characters are $s_{i-1}$ and $s_{i+1}$. The first and the last characters of $s$ both have only one adjacent character (unless $|s| = 1$).\n\nConsider the following example. Let $s=$ bacabcab.  During the first move, you can remove the first character $s_1=$ b because $s_2=$ a. Then the string becomes $s=$ acabcab.  During the second move, you can remove the fifth character $s_5=$ c because $s_4=$ b. Then the string becomes $s=$ acabab.  During the third move, you can remove the sixth character $s_6=$'b' because $s_5=$ a. Then the string becomes $s=$ acaba.  During the fourth move, the only character you can remove is $s_4=$ b, because $s_3=$ a (or $s_5=$ a). The string becomes $s=$ acaa and you cannot do anything with it. \n\nYour task is to find the maximum possible number of characters you can remove if you choose the sequence of operations optimally.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $|s|$ ($1 \\le |s| \\le 100$) \u2014 the length of $s$.\n\nThe second line of the input contains one string $s$ consisting of $|s|$ lowercase Latin letters.\n\n\n-----Output-----\n\nPrint one integer \u2014 the maximum possible number of characters you can remove if you choose the sequence of moves optimally.\n\n\n-----Examples-----\nInput\n8\nbacabcab\n\nOutput\n4\n\nInput\n4\nbcda\n\nOutput\n3\n\nInput\n6\nabbbbb\n\nOutput\n5\n\n\n\n-----Note-----\n\nThe first example is described in the problem statement. Note that the sequence of moves provided in the statement is not the only, but it can be shown that the maximum possible answer to this test is $4$.\n\nIn the second example, you can remove all but one character of $s$. The only possible answer follows.  During the first move, remove the third character $s_3=$ d, $s$ becomes bca.  During the second move, remove the second character $s_2=$ c, $s$ becomes ba.  And during the third move, remove the first character $s_1=$ b, $s$ becomes a.",
  "solutions": "[\"from sys import stdin\\ninput = stdin.readline\\n\\nn = int(input())\\ns = list(input().strip())\\n\\nfor i in range(26):\\n    char = chr(ord('z') - i)\\n    prev = chr(ord('z') - i - 1)\\n\\n    updated = True\\n    while updated:\\n        updated = False\\n        for idx in range(len(s)-1, -1, -1):\\n            if s[idx] == char:\\n                if idx < len(s)-1 and s[idx+1] == prev:\\n                    s.pop(idx)\\n                    updated = True\\n                elif idx > 0 and s[idx-1] == prev:\\n                    s.pop(idx)\\n                    updated = True\\n\\nprint( n - len(s))\\n\\n\", \"input()\\ns = list(input())\\norig = len(s)\\n\\nchanged = True\\nwhile changed:\\n    changed = False\\n    for c in sorted(list(set(s)), reverse=True):\\n        for i in range(len(s)):\\n            if s[i] == c and ((i-1 >= 0 and ord(s[i-1]) == ord(s[i]) - 1) or \\n                    (i + 1 < len(s) and ord(s[i+1]) == ord(s[i]) - 1)):\\n                s = s[:i] + s[i+1:]\\n                changed = True\\n                break\\n        if changed:\\n            break\\n\\nprint(orig - len(s))\\n\", \"import sys\\n\\n# inf = open('input.txt', 'r')\\n# reader = (line.rstrip() for line in inf)\\nreader = (line.rstrip() for line in sys.stdin)\\ninput = reader.__next__\\n\\nn = int(input())\\ns = [ord(c) for c in input()]\\nans = 0\\ncode = 122\\nwhile code >= 97:\\n    toDel = []\\n    k = len(s)\\n    for i, c in enumerate(s):\\n        if c != code:\\n            continue\\n        if i > 0 and s[i - 1] + 1 == code:\\n            toDel.append(i - len(toDel))\\n        elif i < k - 1 and s[i + 1] + 1 == code:\\n            toDel.append(i - len(toDel))\\n    if toDel:\\n        for i in toDel:\\n            del s[i]\\n            ans += 1\\n    else:\\n        code -= 1\\nprint(ans)\\n\\n# inf.close()\\n\", \"import sys\\nimport math\\nimport bisect\\n\\ndef solve(A):\\n    n = len(A)\\n    for i in range(25, -1, -1):\\n        to_loop = True\\n        while to_loop:\\n            to_loop = False\\n            for j in range(len(A)):\\n                #print('A: %s, j: %d' % (str(A), j))\\n                if A[j] == i and j - 1 >= 0 and A[j-1] == i - 1:\\n                    A = A[0:j] + A[j+1:]\\n                    to_loop = True\\n                    break\\n                elif A[j] == i and j + 1 < len(A) and A[j+1] == i - 1:\\n                    A = A[0:j] + A[j+1:]\\n                    to_loop = True\\n                    break\\n    return n - len(A)\\n\\ndef main():\\n    n = int(input())\\n    A = list(input())\\n    for i in range(n):\\n        A[i] = ord(A[i]) - ord('a')\\n    ans = solve(A)\\n    print(ans)\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n = int(input())\\ns = input()\\n\\n\\ndef remove(s):\\n    actC = 'a'\\n    actI = -1\\n    for i in range(len(s)):\\n        if i > 0:\\n            if ord(s[i])-ord(s[i-1]) == 1 and s[i] > actC:\\n                actC = s[i]\\n                actI = i\\n        if i < len(s)-1:\\n            if ord(s[i])-ord(s[i+1]) == 1 and s[i] > actC:\\n                actC = s[i]\\n                actI = i\\n\\n    return actC, actI\\n\\n\\nans = 0\\nactIdxToRem = remove(s)[1]\\nwhile actIdxToRem != -1:\\n    s = s[:actIdxToRem]+s[actIdxToRem+1:]\\n    ans += 1\\n    actIdxToRem = remove(s)[1]\\nprint(ans)\\n\", \"n = int(input())\\n\\ns = list(input())\\n\\nletters = [0] * 26\\nfor c in s:\\n    letters[ord(c) - ord('a')] += 1\\nit = 25\\n\\n\\ndef can_be_deleted(s, i):\\n    if i - 1 >= 0 and i + 1 < len(s):\\n        return ord(s[i - 1]) + 1 == ord(s[i]) or ord(s[i + 1]) + 1 == ord(s[i])\\n    if i == 0:\\n        return ord(s[i + 1]) + 1 == ord(s[i])\\n    if i == len(s) - 1:\\n        return ord(s[i - 1]) + 1 == ord(s[i])\\n\\n\\nscore = 0\\nwhile it >= 0:\\n    if letters[it] == 0:\\n        it -= 1\\n        continue\\n    i = 0\\n    deleted = False\\n    while i < len(s) and len(s) > 1:\\n        if s[i] == chr(ord('a') + it) and can_be_deleted(s, i):\\n            del s[i]\\n            score += 1\\n            deleted = True\\n            break\\n        i += 1\\n    if not deleted:\\n        it -= 1\\nprint(score)\\n\", \"import sys\\n\\ndef minp():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef mint():\\n\\treturn int(minp())\\n\\ndef mints():\\n\\treturn list(map(int, minp().split()))\\n\\ndef solve():\\n\\tn = mint()\\n\\ti = 0\\n\\ts = [0]*n\\n\\tfor c in minp():\\n\\t\\ts[i] = ord(c)-ord('a')\\n\\t\\ti += 1\\n\\t#print(s)\\n\\tfor c in range(25,0,-1):\\n\\t\\ti = 0\\n\\t\\twhile i < len(s):\\n\\t\\t\\tif s[i] == c \\\\\\n\\t\\t\\tand ((i > 0 and s[i-1] == c-1) \\\\\\n\\t\\t\\tor (i + 1 < len(s) and s[i+1] == c-1)):\\n\\t\\t\\t\\ts.pop(i)\\n\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\ti -= 1\\n\\t\\t\\t\\t#print(s)\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti += 1\\n\\tprint(n-len(s))\\n\\n#for i in range(mint())\\nsolve()\\n\", \"def go():\\n    n = int(input())\\n    # b = list(map(int, input().split()))\\n    s = list(map(ord,input()))\\n    letters = sorted(set(s),reverse=True)\\n    for l in letters:\\n        l1 = l-1\\n        if l-1 not in letters:\\n            continue\\n        i=0\\n        while i<len(s):\\n            if s[i]!=l1:\\n                i+=1\\n            elif i>0 and s[i-1]==l:\\n                del s[i-1]\\n                i-=1\\n            elif i<len(s)-1 and s[i+1]==l:\\n                del s[i+1]\\n            else:\\n                i+=1\\n    # print(''.join(map(chr,s)))\\n    return n-len(s)\\n\\n\\nprint (go())\", \"#Pye\\nfrom os import path\\nfrom sys import stdin, stdout\\nif path.exists('inp.txt'): stdin = open(\\\"inp.txt\\\", \\\"r\\\")\\ndef io(): return stdin.readline()\\n\\nmaxn = 100005\\nans = 0\\nq = int(io())\\ninp = io().split(); s = inp[0]\\nfor i in range(25, 0, -1):\\n    check = 1\\n    while check:\\n        check = 0\\n        for j in range(len(s)):\\n            if j >= len(s): break\\n            if ord(s[j]) - ord('a') == i and j+1 < len(s) and ord(s[j+1]) - ord('a') == i-1:\\n                s = s[0:j:] + s[j+1::]\\n                ans += 1\\n                check = 1\\n            elif ord(s[j]) - ord('a') == i and j > 0 and ord(s[j-1]) - ord('a') == i-1:\\n                s = s[0:j:] + s[j+1::]\\n                ans += 1\\n                check = 1\\nprint(ans)\", \"n=int(input())\\ns=input()\\nflag=True\\nwhile flag:\\n    s1=\\\"\\\"\\n    n1=len(s)\\n    m=95\\n    ind=-1\\n    for i in range(len(s)):\\n        k=0\\n        a=ord(s[i])\\n        if i<n1-1:\\n            if ord(s[i+1])-a==-1:\\n                if a>m:\\n                    m=a\\n                    ind=i\\n                continue\\n        if i>0:\\n            if ord(s[i-1])-a==-1:\\n                if a>m:\\n                    m=a\\n                    ind=i\\n                continue\\n    if ind==-1:\\n        break\\n    s=s[0:ind]+s[ind+1:n1]\\nprint(n-len(s))\", \"from sys import stdin, stdout\\nimport traceback\\nimport math\\nfrom collections import Counter\\n\\n\\nread = stdin.readline\\nwrite = stdout.write\\nwriteln = lambda x: write(str(x) + \\\"\\\\n\\\")\\n\\n\\ndef reads(typ=int):\\n    return list(map(typ, read().split()))\\n\\n\\nclass Sol:\\n    @classmethod\\n    def input(cls):\\n        s = cls()\\n        return s\\n\\n    def solve(self):\\n        n = int(read())\\n        s = read().strip()\\n        self.s = s\\n        counts = [0] * 26\\n        for c in s:\\n            i = ord(c) - ord(\\\"a\\\")\\n            counts[i] += 1\\n        for i in range(25, 0, -1):\\n            if counts[i] == 0:\\n                continue\\n            self.try_remove(i, counts[i])\\n        return n - len(self.s)\\n\\n    def try_remove(self, ci, count):\\n        while self.try_remove_one(ci) and count:\\n            count -= 1\\n\\n    def try_remove_one(self, ci):\\n        s = self.s\\n        ch = chr(ci + ord(\\\"a\\\"))\\n        chl = chr(ci - 1 + ord(\\\"a\\\"))\\n        for i, c in enumerate(s):\\n            if c != ch:\\n                continue\\n            if i > 0 and s[i - 1] == chl:\\n                self.s = s[:i] + s[i + 1 :]\\n                return True\\n            if i + 1 < len(self.s) and s[i + 1] == chl:\\n                self.s = s[:i] + s[i + 1 :]\\n                return True\\n        return False\\n\\n\\ndef __starting_point():\\n    try:\\n        writeln(Sol.input().solve())\\n    except Exception as e:\\n        print(\\\"Got exception:\\\", repr(e))\\n        print(traceback.format_exc())\\n\\n__starting_point()\", \"n = int(input())\\ns = list(input())\\nk = 0\\nanswer = 0\\nwhile k == 0:\\n    k = 1\\n    mas = []\\n    for i in range(1, len(s)):\\n        if ord(s[i]) - 1 == ord(s[i - 1]):\\n            k = 0\\n            mas.append([ord(s[i]), i])\\n        elif ord(s[i]) + 1 == ord(s[i - 1]):\\n            k = 0\\n            mas.append([ord(s[i - 1]), i - 1])\\n    if mas:\\n        mas.sort()\\n        answer += 1\\n        ind = mas[-1][1]\\n        s.pop(ind)\\nprint(answer)\"]",
  "input_output": "{\n  \"inputs\": [\n    \"8\\nbacabcab\\n\",\n    \"4\\nbcda\\n\",\n    \"6\\nabbbbb\\n\",\n    \"1\\na\\n\",\n    \"1\\nt\\n\",\n    \"100\\nciftajmzqbfkvbhnyugneialytrkwjlhzwltylptheadmypbjxdzkxnqovimgmzkwpuelzbbhciinfiyspfatgoexeezolulnliu\\n\",\n    \"100\\nyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\\n\",\n    \"100\\naaaaaabbcccccccddffffhhhhhhhhiiiiiikkkkkkkkmmmmmmooooooopppprrrrrrrrrttttttvvvvvvvvvvvvxxxxxxxzzzzzz\\n\",\n    \"100\\nbabaababbaabbabababbabbbababababbaabababaaababaababbbaaababbaabbababababbababbabaabbaabaaaaabbababba\\n\",\n    \"100\\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\",\n    \"100\\nacdfijmnorszzyyzzzzzzyzzyzzzzxwzzzzzyzzzzzzyzzzzzzzyzzzzzyzzzzzzyxzzzyzzzzzyzzzzzyzzyzzzzvutqplkhgeb\\n\",\n    \"100\\nabcdeghfgefedeefcabaaabcedfefedacbbcaaabehhjlkjikjloqrtuyzxwvspnmnlkjgfdcbacdcghfedfebaacbcbcdbccaaa\\n\",\n    \"100\\nababaaaabaabaaaaaaabaaaaaaaaaaaaacbaaaabaaaaaabaabaaaababaaaabaehijkmnpqvxzywutsrolgfdcbaaaabaabaaaa\\n\",\n    \"100\\naaaaaaabaaaaaabcaaaaaaaaaaaaaaaaaaaabbbaaaaaaabefhklmnopsuxzywvtrqjigdcaaaaaaaaaaaaaaaaaaaaaaaabaaaa\\n\",\n    \"100\\naaaaabcjkprsvxyzwutqonmlihgfedaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\",\n    \"100\\nyltrygcqmgjzsxoahbvovspancmoaltdrxgjnxwxbrehubvradguoqgiodzanljxtszdutuzgcnihmwevoloceyidyvoopnqbtlb\\n\",\n    \"100\\naaaabbbcccccccdddddeeeeeffgggghhhiijjjjkkkllmmnnnoooppqqqrrrrssssssttttuuuuuuuuvvvvvwwwwxxxxyyyyzzzz\\n\",\n    \"100\\nrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\n\",\n    \"100\\nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn\\n\",\n    \"100\\njupemetthxolktvhbmzdwlrekwmcugngajdgifwseksjlibsdgmegmqtmeeeqszqjxjhjenjxofvkesfjugbzephryjqqkxatrvl\\n\",\n    \"100\\nmxjrojjwtrauhhccftvjsyfyfsnbdnwjfltyjetsylbddrkoqjxbmientcowknrecfqcvxfgsbymwyvakmbulhvrxzvzbygajtgc\\n\",\n    \"100\\nbldubjepvkwhjbxrueydtpparjszjgwpxjlqlpsmdrjoaagfnrohfcabchmdwaoctmilfbpztwjrfdgdioqggokdftcniqywmvjd\\n\",\n    \"100\\nzbzevxgewibujtbyvhzohoobudkghaivlbpaywiesizahkdxmcpdoqzsxqglezenmsgvsmxcrzcntauvarpakddglhrjmzylfuyq\\n\",\n    \"100\\nwhkbjjjrpcgsfaxgcmktmwypyfhbzvvowkvxltbmnyndqkswixxqxriopddrygymbcvadjjheugxgikrlirnhhsmnjmzpizyltau\\n\",\n    \"1\\nz\\n\",\n    \"5\\nbabaa\\n\",\n    \"5\\nabbdd\\n\",\n    \"6\\naaaaaa\\n\",\n    \"6\\nbbbbab\\n\",\n    \"6\\nbaabbb\\n\",\n    \"6\\ndacbab\\n\",\n    \"7\\naaaaaaa\\n\",\n    \"7\\nbaaabab\\n\",\n    \"7\\nccababa\\n\",\n    \"7\\ncddcbcb\\n\",\n    \"8\\naaaaaaaa\\n\",\n    \"8\\naaabbaab\\n\",\n    \"8\\nabababbc\\n\",\n    \"8\\nbdaacddc\\n\",\n    \"9\\naaaaaaaaa\\n\",\n    \"9\\naabaaabab\\n\",\n    \"9\\nbaccbbaca\\n\",\n    \"9\\nacacaabaa\\n\",\n    \"10\\naaaaaaaaaa\\n\",\n    \"10\\nbbaabaabbb\\n\",\n    \"10\\ncbbbbcaaca\\n\",\n    \"10\\ncadbcdddda\\n\"\n  ],\n  \"outputs\": [\n    \"4\\n\",\n    \"3\\n\",\n    \"5\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"99\\n\",\n    \"21\\n\",\n    \"50\\n\",\n    \"99\\n\",\n    \"99\\n\",\n    \"85\\n\",\n    \"40\\n\",\n    \"32\\n\",\n    \"26\\n\",\n    \"9\\n\",\n    \"96\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"1\\n\",\n    \"2\\n\",\n    \"3\\n\",\n    \"4\\n\",\n    \"5\\n\",\n    \"0\\n\",\n    \"2\\n\",\n    \"2\\n\",\n    \"0\\n\",\n    \"5\\n\",\n    \"4\\n\",\n    \"3\\n\",\n    \"0\\n\",\n    \"3\\n\",\n    \"2\\n\",\n    \"5\\n\",\n    \"0\\n\",\n    \"3\\n\",\n    \"5\\n\",\n    \"2\\n\",\n    \"0\\n\",\n    \"3\\n\",\n    \"5\\n\",\n    \"1\\n\",\n    \"0\\n\",\n    \"6\\n\",\n    \"6\\n\",\n    \"6\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1321/C",
  "starter_code": ""
}