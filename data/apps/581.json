{
  "task_id": "APPS/581",
  "problem_id": 581,
  "prompt": "You are given an unweighted tree with n vertices. Then n - 1 following operations are applied to the tree. A single operation consists of the following steps:   choose two leaves;  add the length of the simple path between them to the answer;  remove one of the chosen leaves from the tree. \n\nInitial answer (before applying operations) is 0. Obviously after n - 1 such operations the tree will consist of a single vertex. \n\nCalculate the maximal possible answer you can achieve, and construct a sequence of operations that allows you to achieve this answer!\n\n\n-----Input-----\n\nThe first line contains one integer number n (2 \u2264 n \u2264 2\u00b710^5) \u2014 the number of vertices in the tree. \n\nNext n - 1 lines describe the edges of the tree in form a_{i}, b_{i} (1 \u2264 a_{i}, b_{i} \u2264 n, a_{i} \u2260 b_{i}). It is guaranteed that given graph is a tree.\n\n\n-----Output-----\n\nIn the first line print one integer number \u2014 maximal possible answer. \n\nIn the next n - 1 lines print the operations in order of their applying in format a_{i}, b_{i}, c_{i}, where a_{i}, b_{i} \u2014 pair of the leaves that are chosen in the current operation (1 \u2264 a_{i}, b_{i} \u2264 n), c_{i} (1 \u2264 c_{i} \u2264 n, c_{i} = a_{i} or c_{i} = b_{i}) \u2014 choosen leaf that is removed from the tree in the current operation. \n\nSee the examples for better understanding.\n\n\n-----Examples-----\nInput\n3\n1 2\n1 3\n\nOutput\n3\n2 3 3\n2 1 1\n\nInput\n5\n1 2\n1 3\n2 4\n2 5\n\nOutput\n9\n3 5 5\n4 3 3\n4 1 1\n4 2 2",
  "solutions": "[\"import sys\\nfrom collections import deque as dq\\nn = int(input())\\n\\nind = 0\\ninp = [int(x)-1 for line in sys.stdin.readlines() for x in line.split()]\\n\\ncoupl = [[] for _ in range(n)]\\nfor _ in range(n-1):\\n    a,b = inp[ind],inp[ind+1]\\n    ind+=2\\n    coupl[a].append(b)\\n    coupl[b].append(a)\\n\\nQ = dq()\\nfound = [False]*n\\nmaster = 0\\nfound[master] = True\\n\\ndia1 = 0\\nQ.append(master)\\nwhile Q:\\n    node = Q.popleft()\\n    dia1 = node\\n    for nei in coupl[node]:\\n        if not found[nei]:\\n            found[nei] = True\\n            Q.append(nei)\\n\\n\\ndia2 = 0\\nQ.append((dia1,0))\\ndist1 = [0]*n\\nfound = [False]*n\\nfound[dia1] = True\\nwhile Q:\\n    node,d = Q.popleft()\\n    dia2 = node\\n    dist1[node]=d\\n    for nei in coupl[node]:\\n        if not found[nei]:\\n            found[nei] = True\\n            Q.append((nei,d+1))\\n\\nQ = []\\nQ.append((dia2,0))\\ndist2 = [0]*n\\nfound = [False]*n\\nfound[dia2] = True\\nwhile Q:\\n    node,d = Q.pop()\\n    dist2[node]=d\\n    for nei in coupl[node]:\\n        if not found[nei]:\\n            found[nei] = True\\n            Q.append((nei,d+1))\\n\\nneigs = [0]*n\\n\\nleaves = []\\nfor i in range(n):\\n    if i != dia1 and i != dia2 and len(coupl[i])==1:\\n        leaves.append(i)\\n    neigs[i]=len(coupl[i])\\npoints = 0\\nlista = []\\n\\nwhile leaves:\\n    node = leaves.pop()\\n    if dist1[node]<dist2[node]:\\n        lista.append((dia2,node,node))\\n        points += dist2[node]\\n    else:\\n        lista.append((dia1,node,node))\\n        points += dist1[node]\\n    for nei in coupl[node]:\\n        neigs[nei]-=1\\n        if neigs[nei]==1:\\n            leaves.append(nei)\\nleaves.append(dia2)\\nwhile leaves:\\n    node = leaves.pop()\\n    lista.append((dia1,node,node))\\n    points += dist1[node]\\n    for nei in coupl[node]:\\n        neigs[nei]-=1\\n        if neigs[nei]==1:\\n            leaves.append(nei)\\nprint(points)\\nfor l in lista:\\n    a,b,c = l\\n    print(a+1,b+1,c+1)\\n\", \"import sys\\n\\n\\ndef main():\\n    n = int(input())\\n\\n    edges = list(map(int, sys.stdin.read().split()))\\n    tree_edges = dict()\\n    for i in range(n):\\n        tree_edges[i + 1] = set()\\n\\n    for i in range(0, len(edges) - 1, 2):\\n        tree_edges[edges[i]].add(edges[i + 1])\\n        tree_edges[edges[i + 1]].add(edges[i])\\n\\n    init_distants = [-1] * (n + 1)\\n\\n    queue = [1]\\n    init_distants[1] = 0\\n\\n    while queue:\\n        next_queue = []\\n        for process in queue:\\n            for next_vertex in tree_edges[process]:\\n                if init_distants[next_vertex] == -1:\\n                    init_distants[next_vertex] = init_distants[process] + 1\\n                    next_queue.append(next_vertex)\\n        queue = next_queue\\n\\n    head = init_distants.index(max(init_distants))\\n    distants_from_head = [-1] * (n + 1)\\n    queue = [head]\\n\\n    distants_from_head[head] = 0\\n\\n    while queue:\\n        next_queue = []\\n        for process in queue:\\n            for next_vertex in tree_edges[process]:\\n                if distants_from_head[next_vertex] == -1:\\n                    distants_from_head[next_vertex] = distants_from_head[process] + 1\\n                    next_queue.append(next_vertex)\\n        queue = next_queue\\n\\n    tail = distants_from_head.index(max(distants_from_head))\\n    distants_from_tail = [-1] * (n + 1)\\n    queue = [tail]\\n\\n    distants_from_tail[tail] = 0\\n\\n    while queue:\\n        next_queue = []\\n        for process in queue:\\n            for next_vertex in tree_edges[process]:\\n                if distants_from_tail[next_vertex] == -1:\\n                    distants_from_tail[next_vertex] = distants_from_tail[process] + 1\\n                    next_queue.append(next_vertex)\\n        queue = next_queue\\n\\n    path_len_sum = 0\\n    removal_history = list()\\n\\n    process_queue = []\\n\\n    for vertex, adj in list(tree_edges.items()):\\n        if len(adj) == 1:\\n            process_queue.append(vertex)\\n\\n    while process_queue:\\n        next_queue = []\\n\\n        for leaf in process_queue:\\n\\n            if leaf == head or leaf == tail:\\n                continue\\n\\n            if distants_from_tail[leaf] > distants_from_head[leaf]:\\n                path_len_sum += distants_from_tail[leaf]\\n                new_leaves = []\\n\\n                for w in tree_edges[leaf]:\\n                    tree_edges[w].remove(leaf)\\n                    if len(tree_edges[w]) == 1:\\n                        new_leaves.append(w)\\n                next_queue.extend(new_leaves)\\n                removal_history.append(\\\"{0} {1} {0}\\\".format(leaf, tail))\\n            else:\\n                path_len_sum += distants_from_head[leaf]\\n                new_leaves = []\\n\\n                for w in tree_edges[leaf]:\\n                    tree_edges[w].remove(leaf)\\n                    if len(tree_edges[w]) == 1:\\n                        new_leaves.append(w)\\n                next_queue.extend(new_leaves)\\n                removal_history.append(\\\"{0} {1} {0}\\\".format(leaf, head))\\n        process_queue = next_queue\\n\\n    process_queue = [tail]\\n\\n    while process_queue:\\n        leaf = process_queue[0]\\n\\n        if leaf == head:\\n            continue\\n\\n        path_len_sum += distants_from_head[leaf]\\n        new_leaves = []\\n\\n        for w in tree_edges[leaf]:\\n            tree_edges[w].remove(leaf)\\n            if len(tree_edges[w]) == 1:\\n                new_leaves.append(w)\\n        process_queue = new_leaves\\n        removal_history.append(\\\"{0} {1} {0}\\\".format(leaf, head))\\n\\n    print(str(path_len_sum))\\n    sys.stdout.write(\\\"\\\\n\\\".join(removal_history))\\n    sys.stdout.write(\\\"\\\\n\\\")\\n\\n\\nmain()\\n\", \"import sys\\n\\n\\ndef main():\\n    n = int(input())\\n\\n    edges = list(map(int, sys.stdin.read().split()))\\n    tree_edges = dict()\\n    for i in range(n):\\n        tree_edges[i + 1] = set()\\n\\n    for i in range(0, len(edges) - 1, 2):\\n        tree_edges[edges[i]].add(edges[i + 1])\\n        tree_edges[edges[i + 1]].add(edges[i])\\n\\n    init_distants = [-1] * (n + 1)\\n\\n    queue = [1]\\n    init_distants[1] = 0\\n\\n    while queue:\\n        next_queue = []\\n        for process in queue:\\n            for next_vertex in tree_edges[process]:\\n                if init_distants[next_vertex] == -1:\\n                    init_distants[next_vertex] = init_distants[process] + 1\\n                    next_queue.append(next_vertex)\\n        queue = next_queue\\n\\n    head = init_distants.index(max(init_distants))\\n    distants_from_head = [-1] * (n + 1)\\n    queue = [head]\\n\\n    distants_from_head[head] = 0\\n\\n    while queue:\\n        next_queue = []\\n        for process in queue:\\n            for next_vertex in tree_edges[process]:\\n                if distants_from_head[next_vertex] == -1:\\n                    distants_from_head[next_vertex] = distants_from_head[process] + 1\\n                    next_queue.append(next_vertex)\\n        queue = next_queue\\n\\n    tail = distants_from_head.index(max(distants_from_head))\\n    distants_from_tail = [-1] * (n + 1)\\n    queue = [tail]\\n\\n    distants_from_tail[tail] = 0\\n\\n    while queue:\\n        next_queue = []\\n        for process in queue:\\n            for next_vertex in tree_edges[process]:\\n                if distants_from_tail[next_vertex] == -1:\\n                    distants_from_tail[next_vertex] = distants_from_tail[process] + 1\\n                    next_queue.append(next_vertex)\\n        queue = next_queue\\n\\n    path_len_sum = 0\\n    removal_history = list()\\n\\n    process_queue = []\\n\\n    for vertex, adj in tree_edges.items():\\n        if len(adj) == 1:\\n            process_queue.append(vertex)\\n\\n    while process_queue:\\n        next_queue = []\\n\\n        for leaf in process_queue:\\n\\n            if leaf == head or leaf == tail:\\n                continue\\n\\n            if distants_from_tail[leaf] > distants_from_head[leaf]:\\n                path_len_sum += distants_from_tail[leaf]\\n                new_leaves = []\\n\\n                for w in tree_edges[leaf]:\\n                    tree_edges[w].remove(leaf)\\n                    if len(tree_edges[w]) == 1:\\n                        new_leaves.append(w)\\n                next_queue.extend(new_leaves)\\n                removal_history.append(\\\"{0} {1} {0}\\\".format(leaf, tail))\\n            else:\\n                path_len_sum += distants_from_head[leaf]\\n                new_leaves = []\\n\\n                for w in tree_edges[leaf]:\\n                    tree_edges[w].remove(leaf)\\n                    if len(tree_edges[w]) == 1:\\n                        new_leaves.append(w)\\n                next_queue.extend(new_leaves)\\n                removal_history.append(\\\"{0} {1} {0}\\\".format(leaf, head))\\n        process_queue = next_queue\\n\\n    process_queue = [tail]\\n\\n    while process_queue:\\n        leaf = process_queue[0]\\n\\n        if leaf == head:\\n            continue\\n\\n        path_len_sum += distants_from_head[leaf]\\n        new_leaves = []\\n\\n        for w in tree_edges[leaf]:\\n            tree_edges[w].remove(leaf)\\n            if len(tree_edges[w]) == 1:\\n                new_leaves.append(w)\\n        process_queue = new_leaves\\n        removal_history.append(\\\"{0} {1} {0}\\\".format(leaf, head))\\n\\n    print(str(path_len_sum))\\n    sys.stdout.write(\\\"\\\\n\\\".join(removal_history))\\n    sys.stdout.write(\\\"\\\\n\\\")\\n\\n\\nmain()\"]",
  "input_output": "{\n  \"inputs\": [\n    \"3\\n1 2\\n1 3\\n\",\n    \"5\\n1 2\\n1 3\\n2 4\\n2 5\\n\",\n    \"2\\n1 2\\n\",\n    \"4\\n1 3\\n1 4\\n1 2\\n\",\n    \"4\\n2 1\\n1 3\\n3 4\\n\",\n    \"4\\n4 3\\n3 2\\n2 1\\n\",\n    \"5\\n2 1\\n2 3\\n2 4\\n2 5\\n\",\n    \"5\\n4 5\\n4 1\\n1 2\\n2 3\\n\",\n    \"5\\n1 4\\n4 3\\n3 2\\n2 5\\n\",\n    \"6\\n4 5\\n4 1\\n4 6\\n4 2\\n4 3\\n\",\n    \"6\\n6 5\\n6 2\\n2 3\\n5 4\\n4 1\\n\",\n    \"6\\n1 5\\n5 4\\n4 2\\n2 6\\n6 3\\n\",\n    \"7\\n7 5\\n7 3\\n7 6\\n7 4\\n7 1\\n7 2\\n\",\n    \"7\\n7 6\\n7 5\\n7 2\\n7 1\\n5 4\\n5 3\\n\",\n    \"7\\n2 7\\n7 6\\n6 5\\n5 4\\n4 1\\n1 3\\n\",\n    \"8\\n8 6\\n8 7\\n8 2\\n8 5\\n8 1\\n8 4\\n8 3\\n\",\n    \"8\\n6 3\\n3 7\\n6 1\\n1 2\\n3 5\\n5 4\\n2 8\\n\",\n    \"8\\n4 1\\n1 3\\n3 6\\n6 2\\n2 7\\n7 5\\n5 8\\n\",\n    \"9\\n3 2\\n3 1\\n3 8\\n3 5\\n3 6\\n3 9\\n3 4\\n3 7\\n\",\n    \"9\\n2 6\\n6 1\\n2 8\\n6 7\\n1 5\\n7 3\\n8 9\\n5 4\\n\",\n    \"9\\n9 4\\n4 6\\n6 2\\n2 1\\n1 3\\n3 5\\n5 8\\n8 7\\n\",\n    \"10\\n3 2\\n3 7\\n3 6\\n3 8\\n3 1\\n3 5\\n3 9\\n3 4\\n3 10\\n\",\n    \"10\\n8 2\\n8 10\\n10 3\\n2 4\\n3 6\\n8 1\\n2 7\\n10 9\\n4 5\\n\",\n    \"10\\n7 10\\n10 6\\n6 4\\n4 5\\n5 8\\n8 2\\n2 1\\n1 3\\n3 9\\n\",\n    \"4\\n3 4\\n4 1\\n1 2\\n\",\n    \"5\\n1 4\\n4 2\\n2 3\\n3 5\\n\",\n    \"6\\n5 3\\n3 6\\n6 1\\n1 4\\n4 2\\n\",\n    \"7\\n1 2\\n2 3\\n3 6\\n6 7\\n7 4\\n4 5\\n\",\n    \"8\\n6 2\\n2 1\\n1 8\\n8 5\\n5 7\\n7 3\\n3 4\\n\",\n    \"9\\n1 6\\n6 4\\n4 5\\n5 9\\n9 8\\n8 7\\n7 3\\n3 2\\n\",\n    \"10\\n5 1\\n1 6\\n6 2\\n2 8\\n8 3\\n3 4\\n4 10\\n10 9\\n9 7\\n\",\n    \"4\\n3 4\\n3 1\\n3 2\\n\",\n    \"5\\n1 4\\n1 2\\n1 3\\n1 5\\n\",\n    \"6\\n5 3\\n5 6\\n5 1\\n5 4\\n5 2\\n\",\n    \"7\\n1 2\\n1 3\\n1 6\\n1 7\\n1 4\\n1 5\\n\",\n    \"8\\n6 2\\n6 1\\n6 8\\n6 5\\n6 7\\n6 3\\n6 4\\n\",\n    \"9\\n1 6\\n1 4\\n1 5\\n1 9\\n1 8\\n1 7\\n1 3\\n1 2\\n\",\n    \"10\\n5 1\\n5 6\\n5 2\\n5 8\\n5 3\\n5 4\\n5 10\\n5 9\\n5 7\\n\",\n    \"10\\n4 10\\n10 5\\n5 1\\n1 6\\n6 8\\n8 9\\n9 2\\n9 3\\n9 7\\n\",\n    \"10\\n5 8\\n8 4\\n4 9\\n9 6\\n6 1\\n6 2\\n6 7\\n6 3\\n6 10\\n\",\n    \"10\\n5 6\\n6 7\\n7 3\\n7 8\\n7 4\\n7 2\\n7 1\\n7 10\\n7 9\\n\"\n  ],\n  \"outputs\": [\n    \"3\\n2 3 3\\n2 1 1\\n\",\n    \"9\\n3 5 5\\n4 3 3\\n4 1 1\\n4 2 2\\n\",\n    \"1\\n2 1 1\\n\",\n    \"5\\n3 4 4\\n2 3 3\\n2 1 1\\n\",\n    \"6\\n4 2 2\\n4 1 1\\n4 3 3\\n\",\n    \"6\\n4 1 1\\n4 2 2\\n4 3 3\\n\",\n    \"7\\n1 4 4\\n1 5 5\\n3 1 1\\n3 2 2\\n\",\n    \"10\\n3 5 5\\n3 4 4\\n3 1 1\\n3 2 2\\n\",\n    \"10\\n5 1 1\\n5 4 4\\n5 3 3\\n5 2 2\\n\",\n    \"9\\n1 5 5\\n1 6 6\\n1 3 3\\n2 1 1\\n2 4 4\\n\",\n    \"15\\n3 1 1\\n3 4 4\\n3 5 5\\n3 6 6\\n3 2 2\\n\",\n    \"15\\n3 1 1\\n3 5 5\\n3 4 4\\n3 2 2\\n3 6 6\\n\",\n    \"11\\n1 5 5\\n1 3 3\\n1 6 6\\n1 4 4\\n2 1 1\\n2 7 7\\n\",\n    \"15\\n3 6 6\\n3 2 2\\n1 4 4\\n3 1 1\\n3 7 7\\n3 5 5\\n\",\n    \"21\\n2 3 3\\n2 1 1\\n2 4 4\\n2 5 5\\n2 6 6\\n2 7 7\\n\",\n    \"13\\n1 6 6\\n1 7 7\\n1 5 5\\n1 4 4\\n1 3 3\\n2 1 1\\n2 8 8\\n\",\n    \"26\\n8 7 7\\n4 8 8\\n4 2 2\\n4 1 1\\n4 6 6\\n4 3 3\\n4 5 5\\n\",\n    \"28\\n8 4 4\\n8 1 1\\n8 3 3\\n8 6 6\\n8 2 2\\n8 7 7\\n8 5 5\\n\",\n    \"15\\n1 8 8\\n1 5 5\\n1 6 6\\n1 9 9\\n1 4 4\\n1 7 7\\n2 1 1\\n2 3 3\\n\",\n    \"30\\n4 3 3\\n4 7 7\\n9 4 4\\n9 5 5\\n9 1 1\\n9 6 6\\n9 2 2\\n9 8 8\\n\",\n    \"36\\n7 9 9\\n7 4 4\\n7 6 6\\n7 2 2\\n7 1 1\\n7 3 3\\n7 5 5\\n7 8 8\\n\",\n    \"17\\n1 7 7\\n1 6 6\\n1 8 8\\n1 5 5\\n1 9 9\\n1 4 4\\n1 10 10\\n2 1 1\\n2 3 3\\n\",\n    \"35\\n5 9 9\\n6 1 1\\n6 7 7\\n5 6 6\\n5 3 3\\n5 10 10\\n5 8 8\\n5 2 2\\n5 4 4\\n\",\n    \"45\\n7 9 9\\n7 3 3\\n7 1 1\\n7 2 2\\n7 8 8\\n7 5 5\\n7 4 4\\n7 6 6\\n7 10 10\\n\",\n    \"6\\n3 2 2\\n3 1 1\\n3 4 4\\n\",\n    \"10\\n5 1 1\\n5 4 4\\n5 2 2\\n5 3 3\\n\",\n    \"15\\n5 2 2\\n5 4 4\\n5 1 1\\n5 6 6\\n5 3 3\\n\",\n    \"21\\n5 1 1\\n5 2 2\\n5 3 3\\n5 6 6\\n5 7 7\\n5 4 4\\n\",\n    \"28\\n4 6 6\\n4 2 2\\n4 1 1\\n4 8 8\\n4 5 5\\n4 7 7\\n4 3 3\\n\",\n    \"36\\n2 1 1\\n2 6 6\\n2 4 4\\n2 5 5\\n2 9 9\\n2 8 8\\n2 7 7\\n2 3 3\\n\",\n    \"45\\n7 5 5\\n7 1 1\\n7 6 6\\n7 2 2\\n7 8 8\\n7 3 3\\n7 4 4\\n7 10 10\\n7 9 9\\n\",\n    \"5\\n1 4 4\\n2 1 1\\n2 3 3\\n\",\n    \"7\\n3 4 4\\n3 5 5\\n2 3 3\\n2 1 1\\n\",\n    \"9\\n1 3 3\\n1 6 6\\n1 4 4\\n2 1 1\\n2 5 5\\n\",\n    \"11\\n3 6 6\\n3 7 7\\n3 4 4\\n3 5 5\\n2 3 3\\n2 1 1\\n\",\n    \"13\\n1 8 8\\n1 5 5\\n1 7 7\\n1 3 3\\n1 4 4\\n2 1 1\\n2 6 6\\n\",\n    \"15\\n3 6 6\\n3 4 4\\n3 5 5\\n3 9 9\\n3 8 8\\n3 7 7\\n2 3 3\\n2 1 1\\n\",\n    \"17\\n1 6 6\\n1 8 8\\n1 3 3\\n1 4 4\\n1 10 10\\n1 9 9\\n1 7 7\\n2 1 1\\n2 5 5\\n\",\n    \"42\\n4 3 3\\n4 7 7\\n2 4 4\\n2 10 10\\n2 5 5\\n2 1 1\\n2 6 6\\n2 8 8\\n2 9 9\\n\",\n    \"35\\n5 2 2\\n5 7 7\\n5 3 3\\n5 10 10\\n5 1 1\\n5 6 6\\n5 9 9\\n5 4 4\\n5 8 8\\n\",\n    \"24\\n5 3 3\\n5 8 8\\n5 4 4\\n5 2 2\\n5 10 10\\n5 9 9\\n5 1 1\\n5 7 7\\n5 6 6\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/911/F",
  "starter_code": ""
}