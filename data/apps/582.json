{
  "task_id": "APPS/582",
  "problem_id": 582,
  "prompt": "VK news recommendation system daily selects interesting publications of one of $n$ disjoint categories for each user. Each publication belongs to exactly one category. For each category $i$ batch algorithm selects $a_i$ publications.\n\nThe latest A/B test suggests that users are reading recommended publications more actively if each category has a different number of publications within daily recommendations. The targeted algorithm can find a single interesting publication of $i$-th category within $t_i$ seconds. \n\nWhat is the minimum total time necessary to add publications to the result of batch algorithm execution, so all categories have a different number of publications? You can't remove publications recommended by the batch algorithm.\n\n\n-----Input-----\n\nThe first line of input consists of single integer $n$\u00a0\u2014 the number of news categories ($1 \\le n \\le 200\\,000$).\n\nThe second line of input consists of $n$ integers $a_i$\u00a0\u2014 the number of publications of $i$-th category selected by the batch algorithm ($1 \\le a_i \\le 10^9$).\n\nThe third line of input consists of $n$ integers $t_i$\u00a0\u2014 time it takes for targeted algorithm to find one new publication of category $i$ ($1 \\le t_i \\le 10^5)$.\n\n\n-----Output-----\n\nPrint one integer\u00a0\u2014 the minimal required time for the targeted algorithm to get rid of categories with the same size.\n\n\n-----Examples-----\nInput\n5\n3 7 9 7 8\n5 2 5 7 5\n\nOutput\n6\n\nInput\n5\n1 2 3 4 5\n1 1 1 1 1\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first example, it is possible to find three publications of the second type, which will take 6 seconds.\n\nIn the second example, all news categories contain a different number of publications.",
  "solutions": "[\"import sys\\nfrom heapq import heappush, heappop\\n\\nn = int(input())\\na = list(map(int, input().split()))\\n\\ncount = {}\\n\\nfor x in a:\\n\\tif x in count:\\n\\t\\tcount[x] = count[x] + 1\\n\\telse:\\n\\t\\tcount[x] = 1\\n\\ncount = sorted(list(count.items()))\\n#print(count)\\n\\ncost= list(map(int, input().split()))\\nmax_cost = max(cost)\\n\\na = list(zip(a, cost))\\na = sorted(a)\\npriority = list([max_cost - x for x in [x[1] for x in a]])\\na = list(zip(priority, a))\\n\\ni = 0\\nqueue = []\\nqueue_cost = 0\\nresult = 0\\n\\n#print(a)\\n\\nfor j in range(len(count)):\\n\\tx, c = count[j]\\n\\t#print('x = ', x)\\n\\twhile i < len(a) and a[i][1][0] == x:\\n\\t\\tqueue_cost += a[i][1][1]\\n\\t\\theappush(queue, a[i])\\n\\t\\ti += 1\\n\\n\\t#print('queue = ', queue)\\n\\ty = x\\n\\twhile len(queue) > 0 and (j == len(count) - 1 or count[j + 1][0] != y):\\n\\t\\tpopped = heappop(queue)\\n\\t\\t#print(popped, queue)\\n\\t\\tqueue_cost -= popped[1][1]\\n\\t\\t#print(queue_cost)\\n\\t\\tresult += queue_cost\\n\\t\\ty += 1\\n\\n# while len(queue) > 0:\\n# \\tpopped = heappop(queue)\\n# \\tqueue_cost -= popped[1][1]\\n# \\tresult += queue_cost\\n\\nprint(result)\\n\", \"from heapq import *\\nn = int(input())\\n_a = list(map(int, input().split(\\\" \\\")))\\n_t = list(map(int, input().split(\\\" \\\")))\\nat = [[0, 0]]\\nfor i in range(n):\\n    at.append([_a[i], _t[i]])\\nat.append([int(1e11), 0])\\nat.sort()\\n\\ndef __starting_point():\\n    Q = []\\n    s = 0\\n    cost  = 0\\n    for i in range(1, n+2):\\n        a = at[i-1]\\n        b = at[i]\\n        num = a[0]\\n        while len(Q) > 0 and num < b[0]:\\n            s += heappop(Q)\\n            num += 1\\n            cost += s\\n        s += b[1]\\n        heappush(Q, -b[1])\\n        #print(\\\"{}, {}, {}\\\".format(i, s, cost))\\n    print(cost)\\n\\n__starting_point()\", \"import sys\\nimport heapq\\nfrom collections import defaultdict\\nn=int(sys.stdin.readline())\\narr=list(map(int,sys.stdin.readline().split()))\\ncost=list(map(int,sys.stdin.readline().split()))\\nfor i in range(n):\\n    arr[i]=[arr[i],cost[i]]\\narr.sort()\\nl=[]\\nheapq.heapify(l)\\nprev=0\\nans=0\\ns=0\\n#print(arr,'arr')\\nfor i in range(n):\\n    #print(l,'l',s,ans)\\n    while l and prev<arr[i][0]:\\n        s-=(l[0])\\n        ans+=(-s)\\n        prev+=1\\n        heapq.heappop(l)\\n    prev=arr[i][0]\\n    s+=(-arr[i][1])\\n    heapq.heappush(l,-arr[i][1])\\nwhile l:\\n    s-=(l[0])\\n    ans+=(-s)\\n    heapq.heappop(l)\\nprint(ans)\\n\", \"#!python3\\n\\\"\\\"\\\"\\nAuthor: w1ld [at] inbox [dot] ru\\n\\\"\\\"\\\"\\n\\nfrom collections import deque, Counter\\nimport array\\nfrom itertools import combinations, permutations\\nfrom math import sqrt\\nfrom heapq import heappush as push, heappop as pop\\n# import unittest\\n\\n\\ndef read_int():\\n    return int(input().strip())\\n\\n\\ndef read_int_array():\\n    return [int(i) for i in input().strip().split(' ')]\\n\\n######################################################\\n\\nn = read_int()\\na = read_int_array()\\nt = read_int_array()\\nsrt = list(sorted((a[i], t[i]) for i in range(n)))\\ncnt = [(-srt[0][1], 0)]\\ni = 1\\ncntValue = srt[0][0]\\nans = 0\\nwhile cnt or i < n:\\n    if i < n and srt[i][0] == cntValue:\\n        push(cnt, (-srt[i][1], i))\\n        i += 1\\n    elif any(cnt):\\n        ti, inx = pop(cnt)\\n        ti = -ti\\n        ans += (cntValue - srt[inx][0]) * ti\\n        cntValue += 1\\n    else:\\n        cntValue = srt[i][0]\\nprint(ans)\\n\\n\\n\\n\\n\\n\", \"import heapq\\nh = []\\nn = int(input())\\na = [int(x) for x in input().strip().split()]\\nt = [int(x) for x in input().strip().split()]\\nfor i in range(len(t)):\\n    a[i] = [a[i], t[i]]\\na.sort(key = lambda x: (x[0], -x[1]))\\nprev, i, ans= a[0][0], 1, 0\\n#print(a)\\nwhile(i<len(a)):\\n    #print(prev, ans, h)\\n    if h:\\n        if a[i][0] == prev:\\n            heapq.heappush(h, [-a[i][1], a[i][0]])\\n            i += 1\\n        elif a[i][0] == prev+1:\\n            heapq.heappush(h, [-a[i][1], a[i][0]])\\n            p = heapq.heappop(h)\\n            ans += (-p[0]*(prev + 1 - p[1]))\\n            prev = prev+1\\n            i += 1\\n        else:\\n            p = heapq.heappop(h)\\n            ans += (-p[0]*(prev + 1 - p[1]))\\n            prev = prev+1\\n    else:\\n        if a[i][0] != prev:\\n            prev = a[i][0]\\n            i+=1\\n        else:\\n            heapq.heappush(h, [-a[i][1], a[i][0]])\\n            i+=1\\nwhile h:\\n    p = heapq.heappop(h)\\n    ans += (-p[0]*(prev + 1 - p[1]))\\n    prev = prev+1\\nprint(ans)\\n    \\n\", \"import sys\\ninput = sys.stdin.readline\\nimport heapq\\nh = []\\nn = int(input())\\na = [int(x) for x in input().strip().split()]\\nt = [int(x) for x in input().strip().split()]\\nfor i in range(len(t)):\\n    a[i] = [a[i], t[i]]\\na.sort(key = lambda x: (x[0], -x[1]))\\nprev, i, ans= a[0][0], 1, 0\\n#print(a)\\nwhile(i<len(a)):\\n    #print(prev, ans, h)\\n    if h:\\n        if a[i][0] == prev:\\n            heapq.heappush(h, [-a[i][1], a[i][0]])\\n            i += 1\\n        elif a[i][0] == prev+1:\\n            heapq.heappush(h, [-a[i][1], a[i][0]])\\n            p = heapq.heappop(h)\\n            ans += (-p[0]*(prev + 1 - p[1]))\\n            prev = prev+1\\n            i += 1\\n        else:\\n            p = heapq.heappop(h)\\n            ans += (-p[0]*(prev + 1 - p[1]))\\n            prev = prev+1\\n    else:\\n        if a[i][0] != prev:\\n            prev = a[i][0]\\n            i+=1\\n        else:\\n            heapq.heappush(h, [-a[i][1], a[i][0]])\\n            i+=1\\nwhile h:\\n    p = heapq.heappop(h)\\n    ans += (-p[0]*(prev + 1 - p[1]))\\n    prev = prev+1\\nprint(ans)\\n    \\n\", \"# n = int(input())\\n# a = [int(i) for i in input().split(' ')]\\n# t = [int(i) for i in input().split(' ')]\\n#\\n# import collections\\n# from heapq import heapify, heappop, heappush\\n#\\n#\\n# l = collections.defaultdict(list)\\n# at = [[a[i], t[i]] for i in range(n)]\\n# at.sort(key = lambda x: x[0])\\n# for aa, tt in at:\\n#     l[aa].append(tt)\\n#\\n# for k in l.keys():\\n#     heapify(l[k])\\n#\\n#\\n# # print(at)\\n# # print(l)\\n# res = 0\\n#\\n# # tmp = []\\n#\\n# q = sorted(l.keys())[::-1]\\n# while q:\\n#     i = q.pop()\\n#     # print(\\\"i\\\", i, l[i])\\n#     # l[i].extend(tmp)\\n#     if len(l[i]) == 1:\\n#         continue\\n#     else:\\n#         tmp = sorted(l[i])\\n#         sums = sum(tmp)\\n#         # res += sums - maxx # leave the one with max time and increase all other by 1, cost their time\\n#         idx = i\\n#         while tmp and ((q and idx + 1 != q[-1]) or not q):\\n#             # print(i, idx, q, tmp)\\n#             p = tmp.pop()\\n#             res += sums - p\\n#             sums -= p\\n#             idx += 1\\n#         if tmp:\\n#             p = tmp.pop()\\n#             res += sums - p\\n#             sums -= p\\n#             l[idx+1].extend(tmp)\\n#             if not q:\\n#                 q.append(idx+1)\\n# print(res)\\n#\\n#\\n#\\n#\\n#\\n#\\n#\\n\\n\\nimport sys\\n\\ninp = sys.stdin.readline\\ninput = lambda: inp().strip()\\n\\n\\n# flush= sys.stdout.flush\\n# import threading\\n# sys.setrecursionlimit(10**6)\\n# threading.stack_size(2**26)\\n\\ndef iin(): return int(input())\\n\\n\\ndef lin(): return list(map(int, input().split()))\\n\\n\\ndef main():\\n    import heapq as hq\\n    n = iin()\\n    a = lin()\\n    t = lin()\\n    dc = {}\\n    for i in range(n):\\n        try:\\n            dc[a[i]].append(t[i])\\n        except:\\n            dc[a[i]] = [t[i], ]\\n    # print(dc)\\n    sa = list(dc.keys())\\n    sa.sort()\\n    n = len(sa)\\n    ch = 0\\n    pt = sa[ch]\\n    temp = []\\n    sm = 0\\n    ans = 0\\n    hq.heapify(temp)\\n    done = 0\\n    while ch < n:\\n        # print(temp, sa[ch])\\n        pt = sa[ch]\\n        if len(dc[pt]) > 1 or done:\\n            a1 = sorted(dc[pt])\\n            for item in a1:\\n                hq.heappush(temp, -item)\\n                sm += item\\n            x = hq.heappop(temp) * (-1)\\n            dc[pt] = [x]\\n            sm -= x\\n            while len(temp):\\n                # print('A', ch, pt, temp )\\n                ans += sm\\n                pt += 1\\n                if pt in dc:\\n                    ch += 1\\n                    done = 1\\n                    break\\n                else:\\n                    x = hq.heappop(temp) * (-1)\\n                    sm -= x\\n            else:\\n                done = 0\\n        else:\\n            ch += 1\\n            done = 0\\n    # print(dc)\\n    print(ans)\\n\\nmain()\\n\", \"n = int(input())\\na = [int(i) for i in input().split(' ')]\\nt = [int(i) for i in input().split(' ')]\\n\\nimport collections\\nfrom heapq import heapify, heappop, heappush\\n\\n\\nl = collections.defaultdict(list)\\nat = [[a[i], t[i]] for i in range(n)]\\nat.sort(key = lambda x: x[0])\\nfor aa, tt in at:\\n    l[aa].append(tt)\\n\\n\\n\\n# print(at)\\n# print(l)\\nres = 0\\n\\n# tmp = []\\n\\nq = sorted(l.keys())[::-1]\\ntmp = []\\nheapify(tmp)\\nsums = 0\\nwhile q:\\n\\n    i = q.pop()\\n    if len(l[i]) == 1 and not tmp:\\n        continue\\n    else:\\n        for ll in l[i]:\\n            heappush(tmp, -ll)\\n            sums += ll\\n        idx = i\\n        # print(i, idx, q, tmp, sums)\\n        while tmp and ((q and idx + 1 != q[-1]) or not q):\\n            # print(i, idx, q, tmp)\\n            p = -heappop(tmp)\\n            res += sums - p # leave the one with max time and increase all other by 1, cost their time\\n            sums -= p\\n            idx += 1\\n        if tmp:\\n            # print('tmp', i, tmp)\\n            p = -heappop(tmp)\\n            res += sums - p\\n            sums -= p\\n            # print(res, p)\\n            # l[idx+1].extend(tmp)\\n            if not q:\\n                q.append(idx+1)\\nprint(res)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# import sys\\n#\\n# inp = sys.stdin.readline\\n# input = lambda: inp().strip()\\n#\\n#\\n# # flush= sys.stdout.flush\\n# # import threading\\n# # sys.setrecursionlimit(10**6)\\n# # threading.stack_size(2**26)\\n#\\n# def iin(): return int(input())\\n#\\n#\\n# def lin(): return list(map(int, input().split()))\\n#\\n#\\n# def main():\\n#     import heapq as hq\\n#     n = iin()\\n#     a = lin()\\n#     t = lin()\\n#     dc = {}\\n#     for i in range(n):\\n#         try:\\n#             dc[a[i]].append(t[i])\\n#         except:\\n#             dc[a[i]] = [t[i], ]\\n#     # print(dc)\\n#     sa = list(dc.keys())\\n#     sa.sort()\\n#     n = len(sa)\\n#     ch = 0\\n#     pt = sa[ch]\\n#     temp = []\\n#     sm = 0\\n#     ans = 0\\n#     hq.heapify(temp)\\n#     done = 0\\n#     while ch < n:\\n#         # print(temp, sa[ch])\\n#         pt = sa[ch]\\n#         if len(dc[pt]) > 1 or done:\\n#             a1 = sorted(dc[pt])\\n#             for item in a1:\\n#                 hq.heappush(temp, -item)\\n#                 sm += item\\n#             x = hq.heappop(temp) * (-1)\\n#             dc[pt] = [x]\\n#             sm -= x\\n#             while len(temp):\\n#                 # print('A', ch, pt, temp )\\n#                 ans += sm\\n#                 pt += 1\\n#                 if pt in dc:\\n#                     ch += 1\\n#                     done = 1\\n#                     break\\n#                 else:\\n#                     x = hq.heappop(temp) * (-1)\\n#                     sm -= x\\n#             else:\\n#                 done = 0\\n#         else:\\n#             ch += 1\\n#             done = 0\\n#     # print(dc)\\n#     print(ans)\\n#\\n# main()\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"5\\n3 7 9 7 8\\n5 2 5 7 5\\n\",\n    \"5\\n1 2 3 4 5\\n1 1 1 1 1\\n\",\n    \"5\\n12 4 19 18 19\\n15467 14873 66248 58962 90842\\n\",\n    \"40\\n19 20 8 13 13 17 1 14 15 20 14 17 2 9 9 10 19 16 6 12 9 7 20 5 12 6 4 4 12 5 4 11 8 1 2 8 11 19 18 4\\n52258 5648 46847 9200 63940 79328 64407 54479 1788 60107 8234 64215 15419 84411 50307 78075 92548 17867 43456 7970 1390 99373 97297 90662 82950 678 79356 51351 2794 82477 16508 19254 81295 9711 72350 11578 21595 69230 82626 25134\\n\",\n    \"1\\n204\\n74562\\n\",\n    \"1\\n1\\n72\\n\",\n    \"1\\n1\\n40825\\n\",\n    \"1\\n5\\n16\\n\",\n    \"1\\n4\\n85648\\n\",\n    \"1\\n3\\n31\\n\",\n    \"1\\n23\\n29532\\n\",\n    \"1\\n743365444\\n98\\n\",\n    \"1\\n380100964\\n63923\\n\",\n    \"1\\n1000000000\\n100000\\n\",\n    \"2\\n5 3\\n96 59\\n\",\n    \"2\\n3 2\\n55839 83916\\n\",\n    \"2\\n8 4\\n57 28\\n\",\n    \"2\\n7 6\\n2374 9808\\n\",\n    \"2\\n84 18\\n96 92\\n\",\n    \"2\\n86 67\\n77701 9079\\n\",\n    \"2\\n624526990 51492804\\n74 4\\n\",\n    \"2\\n759394108 613490963\\n19556 57005\\n\",\n    \"2\\n1000000000 1000000000\\n100000 100000\\n\",\n    \"5\\n4 2 4 3 3\\n8 9 34 54 14\\n\",\n    \"5\\n1 5 1 2 1\\n49027 92184 18591 86401 84238\\n\",\n    \"5\\n8 2 3 10 1\\n2 37 19 73 60\\n\",\n    \"5\\n3 10 9 5 8\\n12157 40766 83283 22455 29741\\n\",\n    \"5\\n2 52 60 67 26\\n51 96 75 41 88\\n\",\n    \"5\\n82 90 21 10 3\\n37195 83314 87379 83209 32491\\n\",\n    \"5\\n298137706 371378543 159326899 423775489 643749813\\n1 90 76 23 14\\n\",\n    \"5\\n487208130 193137490 653652531 77955217 628457798\\n37995 12724 66478 45619 87697\\n\",\n    \"5\\n1000000000 1000000000 1000000000 1000000000 1000000000\\n100000 100000 100000 100000 100000\\n\",\n    \"10\\n4 4 1 2 2 2 5 4 1 5\\n28 81 36 44 2 40 39 43 36 33\\n\",\n    \"10\\n1 4 2 3 5 1 3 5 4 2\\n95757 10134 79392 48220 34450 34587 61472 88154 76492 38800\\n\",\n    \"10\\n2 2 2 6 4 4 10 2 2 8\\n18 13 94 43 72 62 23 47 94 41\\n\",\n    \"10\\n2 5 1 9 1 2 7 8 1 10\\n38888 43309 35602 62895 51161 96523 20607 20309 21976 21231\\n\",\n    \"10\\n14 31 50 67 42 44 86 82 35 63\\n76 17 26 44 60 54 50 73 71 70\\n\",\n    \"10\\n97 75 68 98 56 44 68 24 40 18\\n75753 53146 17573 59200 87853 73083 67536 45475 70260 99681\\n\",\n    \"10\\n69564153 558821634 273092444 121621442 354953668 157021146 918149509 902159900 772175415 945981912\\n29 26 22 78 90 35 24 75 52 53\\n\",\n    \"10\\n400625724 498124775 960958038 697226708 233136478 292118728 33139194 339478293 914271877 828083523\\n9789 90524 51162 97707 59267 60261 43260 60358 64419 44097\\n\",\n    \"10\\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000\\n100000 100000 100000 100000 100000 100000 100000 100000 100000 100000\\n\"\n  ],\n  \"outputs\": [\n    \"6\\n\",\n    \"0\\n\",\n    \"66248\\n\",\n    \"6113465\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"100000\\n\",\n    \"44\\n\",\n    \"153827\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"1000000\\n\",\n    \"593\\n\",\n    \"779373\\n\",\n    \"630\\n\",\n    \"255574\\n\",\n    \"0\\n\",\n    \"17573\\n\",\n    \"0\\n\",\n    \"0\\n\",\n    \"4500000\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/1310/A",
  "starter_code": ""
}