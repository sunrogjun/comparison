{
  "task_id": "APPS/385",
  "problem_id": 385,
  "prompt": "Recently Polycarp started to develop a text editor that works only with correct bracket sequences (abbreviated as CBS). \n\nNote that a bracket sequence is correct if it is possible to get a correct mathematical expression by adding \"+\"-s and \"1\"-s to it. For example, sequences \"(())()\", \"()\" and \"(()(()))\" are correct, while \")(\", \"(()\" and \"(()))(\" are not. Each bracket in CBS has a pair. For example, in \"(()(()))\":  1st bracket is paired with 8th,  2d bracket is paired with 3d,  3d bracket is paired with 2d,  4th bracket is paired with 7th,  5th bracket is paired with 6th,  6th bracket is paired with 5th,  7th bracket is paired with 4th,  8th bracket is paired with 1st. \n\nPolycarp's editor currently supports only three operations during the use of CBS. The cursor in the editor takes the whole position of one of the brackets (not the position between the brackets!). There are three operations being supported:  \u00abL\u00bb\u00a0\u2014 move the cursor one position to the left,  \u00abR\u00bb\u00a0\u2014 move the cursor one position to the right,  \u00abD\u00bb\u00a0\u2014 delete the bracket in which the cursor is located, delete the bracket it's paired to and all brackets between them (that is, delete a substring between the bracket in which the cursor is located and the one it's paired to). \n\nAfter the operation \"D\" the cursor moves to the nearest bracket to the right (of course, among the non-deleted). If there is no such bracket (that is, the suffix of the CBS was deleted), then the cursor moves to the nearest bracket to the left (of course, among the non-deleted). \n\nThere are pictures illustrated several usages of operation \"D\" below. [Image] \n\nAll incorrect operations (shift cursor over the end of CBS, delete the whole CBS, etc.) are not supported by Polycarp's editor.\n\nPolycarp is very proud of his development, can you implement the functionality of his editor?\n\n\n-----Input-----\n\nThe first line contains three positive integers n, m and p (2 \u2264 n \u2264 500 000, 1 \u2264 m \u2264 500 000, 1 \u2264 p \u2264 n)\u00a0\u2014 the number of brackets in the correct bracket sequence, the number of operations and the initial position of cursor. Positions in the sequence are numbered from left to right, starting from one. It is guaranteed that n is even.\n\nIt is followed by the string of n characters \"(\" and \")\" forming the correct bracket sequence.\n\nThen follow a string of m characters \"L\", \"R\" and \"D\"\u00a0\u2014 a sequence of the operations. Operations are carried out one by one from the first to the last. It is guaranteed that the given operations never move the cursor outside the bracket sequence, as well as the fact that after all operations a bracket sequence will be non-empty.\n\n\n-----Output-----\n\nPrint the correct bracket sequence, obtained as a result of applying all operations to the initial sequence.\n\n\n-----Examples-----\nInput\n8 4 5\n(())()()\nRDLD\n\nOutput\n()\n\nInput\n12 5 3\n((()())(()))\nRRDLD\n\nOutput\n(()(()))\n\nInput\n8 8 8\n(())()()\nLLLLLLDD\n\nOutput\n()()\n\n\n\n-----Note-----\n\nIn the first sample the cursor is initially at position 5. Consider actions of the editor:  command \"R\"\u00a0\u2014 the cursor moves to the position 6 on the right;  command \"D\"\u00a0\u2014 the deletion of brackets from the position 5 to the position 6. After that CBS takes the form (())(), the cursor is at the position 5;  command \"L\"\u00a0\u2014 the cursor moves to the position 4 on the left;  command \"D\"\u00a0\u2014 the deletion of brackets from the position 1 to the position 4. After that CBS takes the form (), the cursor is at the position 1. \n\nThus, the answer is equal to ().",
  "solutions": "[\"n, m, p = [int(x) for x in input().split()]\\nA = input().rstrip()\\nB = input().rstrip()\\n\\npair = [0] * n\\nstack = []\\nfor (i, c) in enumerate(A):\\n    if c == '(':\\n        stack.append(i)\\n    else:\\n        j = stack.pop()\\n        pair[i] = j\\n        pair[j] = i\\n\\nstart = 0\\npointer = p - 1\\nleft = list(range(-1, n-1))\\nright = list(range(1, n+1))\\nleft[0] = None\\nright[-1] = None\\n\\nfor c in B:\\n    if c == 'R':\\n        pointer = right[pointer]\\n    elif c == 'L':\\n        pointer = left[pointer]\\n    else:\\n        if pair[pointer] < pointer:\\n            if right[pointer] is not None:\\n                left[right[pointer]] = left[pair[pointer]]\\n            if left[pair[pointer]] is not None:\\n                right[left[pair[pointer]]] = right[pointer]\\n            else:\\n                start = right[pointer]\\n\\n            if right[pointer] is None:\\n                pointer = left[pair[pointer]]\\n            else:\\n                pointer = right[pointer]\\n        else:\\n            if right[pair[pointer]] is not None:\\n                left[right[pair[pointer]]] = left[pointer]\\n            if left[pointer] is not None:\\n                right[left[pointer]] = right[pair[pointer]]\\n            else:\\n                start = right[pair[pointer]]\\n\\n\\n            if right[pair[pointer]] is None:\\n                pointer = left[pointer]\\n            else:\\n                pointer = right[pair[pointer]]\\n\\ni = start\\nwhile right[i] is not None:\\n    print(A[i], end = '')\\n    i = right[i]\\nprint(A[i])\\n\", \"def main():\\n    n, m, p = list(map(int, input().split()))\\n    xlat, l, s, ll, lr = [0] * n, [], input(), list(range(-1, n)), list(range(1, n + 2))\\n    p -= 1\\n    for i, c in enumerate(s):\\n        if c == '(':\\n            l.append(i)\\n        else:\\n            j = l.pop()\\n            xlat[i] = j\\n            xlat[j] = i\\n    for c in input():\\n        if c == 'D':\\n            if s[p] == '(':\\n                p = xlat[p]\\n            q = ll[xlat[p]]\\n            p = lr[p]\\n            ll[p], lr[q] = q, p\\n            if p == n:\\n                p = ll[p]\\n        else:\\n            p = (lr if c == 'R' else ll)[p]\\n    q = p\\n    while p != -1:\\n        l.append(s[p])\\n        p = ll[p]\\n    l.reverse()\\n    del l[-1]\\n    while q != n:\\n        l.append(s[q])\\n        q = lr[q]\\n    print(''.join(l))\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"n, m, p = list(map(int, input().split())); x, v, s, l, r = [0]*n, [], input(), list(range(-1, n)), list(range(1, n+2))\\np -= 1\\nfor i, c in enumerate(s):\\n        if c == '(': v.append(i)\\n        else:\\n                j = v.pop()\\n                x[i] = j\\n                x[j] = i\\nfor c in input():\\n        if c == 'D':\\n                if s[p] == '(':\\n                        p = x[p]\\n                q = l[x[p]]\\n                p = r[p]\\n                l[p], r[q] = q, p\\n                if p == n:\\n                        p = l[p]\\n        else:\\n                p = (r if c == 'R' else l)[p]\\nq = p\\nwhile p != -1:\\n        v.append(s[p])\\n        p = l[p]\\nv.reverse()\\ndel v[-1]\\nwhile q != n:\\n        v.append(s[q])\\n        q = r[q]\\nprint(''.join(v))\\n\", \"def preproc(str, leng):\\n\\tli = []\\n\\tres = [-1]*leng\\n\\tfor i in range(leng):\\n\\t\\tif str[i] == '(':\\n\\t\\t\\tli.append(i)\\n\\t\\telse:\\n\\t\\t\\tstart, end = li.pop(), i\\n\\t\\t\\tres[start] = end\\n\\t\\t\\tres[end] = start\\n\\treturn res\\n\\t\\ndef delete(flags, cursor, pairs):\\n\\tpos = pairs[cursor]\\n\\tdirection = 1 if pos > cursor else -1\\n\\twhile(pos+direction > 0 and pos+direction < len(flags) and flags[pos+direction] != -1):\\n\\t\\tpos = flags[pos+direction]\\n\\treturn pos\\n\\nleng, op_num, cursor = map(int, input().strip().split())\\ncursor = cursor-1\\nstr = input().strip()\\nops = input().strip()\\npairs = preproc(str, leng)\\nflags = [-1]*leng\\n#print(leng, op_num, cursor, str, ops, pairs)\\nfor i in ops:\\n\\t#print(i, cursor, flags)\\n\\tif i == 'R' or i == 'L':\\n\\t\\tcursor = {\\n\\t\\t\\t'R':(lambda cursor=cursor, flags=flags: cursor+1 if flags[cursor+1] == -1 else flags[cursor+1]+1),\\n\\t\\t\\t'L':(lambda cursor=cursor, flags=flags: cursor-1 if flags[cursor-1] == -1 else flags[cursor-1]-1)\\n\\t\\t}[i]()\\n\\telse:\\n\\t\\tdelete_to = delete(flags, cursor, pairs)\\n\\t\\tdelete_from = delete(flags, pairs[cursor], pairs)\\n\\t\\tflags[delete_from] = delete_to\\n\\t\\tflags[delete_to] = delete_from\\n\\t\\tcursor = max(delete_to, delete_from)\\n\\t\\tif cursor+1 < leng and flags[cursor+1] == -1:\\n\\t\\t\\tcursor = cursor+1\\n\\t\\telif cursor+1 < leng and flags[cursor+1] != -1 and flags[cursor+1]+1 < leng:\\n\\t\\t\\tcursor = flags[cursor+1]+1\\n\\t\\telif min(delete_from, delete_to) -1 > 0 and flags[min(delete_from, delete_to)-1] == -1:\\n\\t\\t\\tcursor = min(delete_from, delete_to)-1\\n\\t\\telse:\\n\\t\\t\\tcursor = flags[min(delete_from, delete_to)-1]-1\\nidx = 0\\nres = ''\\nwhile idx < leng:\\n\\tif flags[idx] != -1:\\n\\t\\tidx = flags[idx]+1\\n\\t\\tcontinue\\n\\tres += str[idx]\\n\\tidx = idx+1\\nprint(res)\", \"class Node:\\n    def __init__(self, index):\\n        self.left = index - 1\\n        self.right = index + 1\\n        self.pair = -1\\n\\ndef __starting_point():\\n    n, m, p = map(int, input().split())\\n    brackets = input()\\n    operations = input()\\n\\n    nodes = [Node(i) for i in range(n + 1)]\\n    stack = []\\n\\n    for i in range(n):\\n        if brackets[i] == \\\"(\\\":\\n            stack.append(i + 1)\\n        else:\\n            pair_id = stack.pop()\\n            nodes[pair_id].pair = i + 1\\n            nodes[i + 1].pair = pair_id\\n\\n    for i in range(m):\\n        if operations[i] == \\\"L\\\":\\n            p = nodes[p].left\\n        elif operations[i] == \\\"R\\\":\\n            p = nodes[p].right\\n        else:\\n            pair_id = nodes[p].pair\\n            left = 0\\n            right = 0\\n\\n            if p < pair_id:\\n                left = p\\n                right = pair_id\\n            else:\\n                left = pair_id\\n                right = p\\n\\n            left_node = nodes[left].left\\n            right_node = nodes[right].right\\n\\n            nodes[left_node].right = right_node\\n            if right_node != n + 1:\\n                nodes[right_node].left = left_node\\n                p = right_node\\n            else:\\n                p = left_node\\n\\n    p = nodes[0].right\\n    result = []\\n    while p != n + 1:\\n        result.append(brackets[p - 1])\\n        p = nodes[p].right\\n        \\n    print(\\\"\\\".join(result))\\n__starting_point()\", \"class Node:\\n    def __init__(self, index):\\n        self.left = index - 1\\n        self.right = index + 1\\n        self.pair = -1\\n\\ndef __starting_point():\\n    n, m, p = map(int, input().split())\\n    brackets = input()\\n    operations = input()\\n\\n    nodes = [Node(i) for i in range(n + 1)]\\n    stack = []\\n\\n    for i in range(n):\\n        if brackets[i] == \\\"(\\\":\\n            stack.append(i + 1)\\n        else:\\n            pair_id = stack.pop()\\n            nodes[pair_id].pair = i + 1\\n            nodes[i + 1].pair = pair_id\\n\\n    for i in range(m):\\n        if operations[i] == \\\"L\\\":\\n            p = nodes[p].left\\n        elif operations[i] == \\\"R\\\":\\n            p = nodes[p].right\\n        else:\\n            pair_id = nodes[p].pair\\n            \\n            left = min(p, pair_id)\\n            right = max(p, pair_id)\\n\\n            left_node = nodes[left].left\\n            right_node = nodes[right].right\\n\\n            nodes[left_node].right = right_node\\n            if right_node != n + 1:\\n                nodes[right_node].left = left_node\\n                p = right_node\\n            else:\\n                p = left_node\\n\\n    p = nodes[0].right\\n    result = []\\n    while p != n + 1:\\n        result.append(brackets[p - 1])\\n        p = nodes[p].right\\n\\n    print(\\\"\\\".join(result))\\n__starting_point()\", \"jump_r = {}\\njump_l = {}\\n\\ndef bracket_to_value(bracket):\\n    if bracket == '(':\\n        return 1\\n    if bracket == ')':\\n        return -1\\n\\ndef move_r(c):\\n    if c+1 in jump_r:\\n        return jump_r[c+1]+1\\n    else:\\n        return c+1\\n\\ndef move_l(c):\\n        if c-1 in jump_l:\\n            return jump_l[c-1]-1\\n        else:\\n            return c-1\\n\\ndef remove_bracket(s, c, length):\\n\\n    val = bracket_to_value(s[c])\\n    initial_c = c\\n    dir = bracket_to_value(s[c])\\n    #print(f'started at c ={c} and dir = {dir}')\\n    if dir == 1:\\n        c = move_r(c)\\n    if dir == -1:\\n        c = move_l(c)\\n    val += bracket_to_value(s[c])\\n    while val != 0:\\n        #print(f'wwwc = {c} val = {val} s[c] = {s[c]}')\\n        if dir == 1:\\n            c = move_r(c)\\n        if dir == -1:\\n            c = move_l(c)\\n        val += bracket_to_value(s[c])\\n    final_c = c\\n\\n    left_end = min(initial_c, final_c)\\n    right_end = max(initial_c, final_c)\\n    real_r_end = right_end\\n    real_l_end = left_end\\n    #print(f'left_end = {left_end} roght_end = {right_end}')\\n    jump_r[left_end] = right_end\\n    jump_l[right_end] = left_end\\n    if right_end + 1 in jump_r:\\n        real_r_end = jump_r[right_end+1]\\n    if left_end - 1 in jump_l:\\n        real_l_end = jump_l[left_end-1]\\n\\n    jump_l[real_r_end] = real_l_end\\n    jump_r[real_l_end] = real_r_end\\n\\n    if real_r_end < length - 1:\\n        new_c = real_r_end+1\\n    else:\\n        new_c = real_l_end - 1\\n\\n\\n    return new_c\\n\\ndef smart_print(s):\\n    i = 0\\n    while i < n:\\n        if i not in jump_r:\\n            print(s[i], end='')\\n            i += 1\\n        else:\\n            i = jump_r[i]+1\\n\\n\\ndef perform_order(order, s, c, length):\\n    if order == 'R':\\n        return move_r(c)\\n    if order == 'L':\\n        return move_l(c)\\n    if order == 'D':\\n        return remove_bracket(s, c, length)\\n\\nn, m, p = [int(x) for x in input().split()]\\np = p-1\\nse = input()\\norders = input()\\nfor ord in orders:\\n    p = perform_order(ord, se, p, n)\\n    #print(f'jump_r = {jump_r} jump_l = {jump_l} p = {p} s = {se}')\\n\\nsmart_print(se)\\n   # print(f'se = {se} p = {p}')\\n#print(jump_r)\\n\\n# 3->6\\n#\\n# 0 1 2 3 4 5 6 7 8 9 10 11\\n# ( ( ( ) ( ) ) ( ( ) )  )\"]",
  "input_output": "{\n  \"inputs\": [\n    \"8 4 5\\n(())()()\\nRDLD\\n\",\n    \"12 5 3\\n((()())(()))\\nRRDLD\\n\",\n    \"8 8 8\\n(())()()\\nLLLLLLDD\\n\",\n    \"4 2 2\\n()()\\nLD\\n\",\n    \"6 4 1\\n()()()\\nDRRD\\n\",\n    \"8 2 4\\n(())()()\\nRR\\n\",\n    \"10 7 3\\n(()())()()\\nRDLRDRD\\n\",\n    \"12 10 11\\n(())()()()()\\nDLRDLRDDLR\\n\",\n    \"14 8 13\\n((())())((()))\\nDLRLLRLR\\n\",\n    \"16 2 10\\n(((())())())()()\\nLD\\n\",\n    \"18 8 11\\n((()))(()()()())()\\nLLLRRRRD\\n\",\n    \"20 16 3\\n(()()())()(())()()()\\nLDRRRRRRLRLRLLLL\\n\",\n    \"22 9 12\\n(()())((()()())())()()\\nRDLLLRDRL\\n\",\n    \"24 15 14\\n((()())()()())(())()()()\\nLDRRLDLDRRDDLRL\\n\",\n    \"26 3 15\\n((())())(((())()()))(())()\\nRDL\\n\",\n    \"28 13 16\\n(()()())(()()())(())(())()()\\nLRLDRRRRRLLLR\\n\",\n    \"30 18 15\\n(()((()()())()(())())())()()()\\nRRRLRRRLRRDLLLDRDR\\n\",\n    \"32 6 19\\n((()())((())())())((())()(()))()\\nLDRLRR\\n\",\n    \"34 8 20\\n(())((()())()((())())()()())()()()\\nRLLDLRRL\\n\",\n    \"36 11 36\\n(()()()()())((())())(()()())((())())\\nLDLRLLLLRLR\\n\",\n    \"38 8 26\\n((((())())(()))(()()))(((())())())()()\\nDDDLRLDR\\n\",\n    \"40 22 35\\n(((()()()())()()())((())())()(())())()()\\nDRRLDRLRLLLDLLLDRLLRLD\\n\",\n    \"42 7 29\\n(((())()(()())())(((()())())(()())())())()\\nDDRRRRD\\n\",\n    \"44 13 42\\n((()()())()()()())(((()()())())()())(()())()\\nLRRRLLDRDLDLR\\n\",\n    \"46 3 11\\n(()()(())())(()())((()((())())(()())(())())())\\nDDD\\n\",\n    \"48 33 11\\n((((())())((()()())())()()(()()))()(()())())()()\\nRLRDLDRLLLRRRLRDLRLDDRRDRLRRDRLRD\\n\",\n    \"50 32 32\\n(()()())(())(())((()())())((())())((()())())(())()\\nLRLLLRDRRDLRRRLRLLDDRLLRDLRDLRLD\\n\",\n    \"52 24 39\\n((()(()())(()())()())()())((()())(())())(())(()())()\\nDRRDLDRLRRLLRRDRRLDRRLLL\\n\",\n    \"54 22 3\\n(((()())(())()())((()())())())((())((()()())()())())()\\nLRLRDLRDLLRLDRLRRDRLRD\\n\",\n    \"56 43 9\\n(((((())())(()()))()()()())(()()(()))(()())(())())()()()\\nRLRLDLRLLRLRLDLLRLRRLLLRLRRLDLDRDLLRLRRLLDR\\n\",\n    \"58 3 22\\n((((())()())())((())())(())())(((())()()())(())()())()(())\\nLLR\\n\",\n    \"60 50 23\\n((((())(()())()())(()())()()()(()())())((())()())()())(())()\\nDRDLLDDLLLLDDRRDRDLLLRRRLRLDDDLRLLRRDLRLRRDDDRDRRL\\n\",\n    \"62 34 43\\n(()((()())()()))(((())())()(()())(())())((())(()(()())()))()()\\nRLDDDDDDLRDLLRLDRLLDLRLDLLDRLLRRLL\\n\",\n    \"64 19 15\\n((((())((())())()())(())())(()())(()())())((()()())(())())()()()\\nDRRLRLRDDDDLLDRLRLD\\n\",\n    \"66 55 24\\n(((())(((()())()()))(()())(()())())(())((()())())(()()())())()()()\\nRDLRLRRRLRDLRRLLDDRDRRDLRLDRRDRDLRDDLLRRDRDRLRRLLLDLRRR\\n\",\n    \"68 34 8\\n((()(()())()())(()))((()())()())((()()())())(((())(()))(())()(())())\\nDLRRLRRRDLLDLLDDDLRRLRLRRRDDRLRRLL\\n\",\n    \"70 33 26\\n((()(())()())((())())(()())(())())((()((()())()())())()()(())())(()())\\nDLDRRRLRLDLRLLRDDRLRRLLLRDRLRLDRL\\n\",\n    \"72 23 38\\n(((((()()())()())(((()()))(())())()(()())(()(())())))(())((())())())()()\\nRDLRLRRRDLLRDLRDLLRRLLD\\n\",\n    \"74 26 27\\n(((()()())())(())()())((()()(())())()())((()()())()())(()()())(()()())()()\\nLDRLLRLRLLDDDLDRRDRLLRDLRD\\n\",\n    \"76 51 69\\n(((())()())())(()()()()())(((((())(())())())())(((()(())())(()()())())()))()\\nLRLLRRLLLDRDDRLLDLRLRDRLRDLRLRLRLLDLRLRLLLDDLLRRDLD\\n\",\n    \"78 33 22\\n(((()((()()())())()()())((()())()())(())())(((((())())()())()())(())())())()()\\nRDRRRRRLDRDLDRLLLLDRDRRRDLDRDLLRD\\n\",\n    \"2 1 1\\n()\\nR\\n\",\n    \"80 31 30\\n(((()()())(((())())((()())()()())()()))(()()()())(()())(()())(())(())()()()())()\\nDDDLLDLDDLRLRLDDRDRRLDRDLLDRLRL\\n\",\n    \"82 16 6\\n(((())())(())()())(((()()((()()))())()(())())(()())(())((())())()()())(()()()())()\\nRLLLLRRDDRRLRRRL\\n\",\n    \"84 18 78\\n(())(((()(()))()((((()())())(()())())()())((()())())())(((())(())())(())())())()()()\\nLLLRDDLRDRLDDLLRRL\\n\",\n    \"86 11 62\\n(((())())(((()())())()()())(()())(()()())()())((()()())())(((())()())((())(()())())())\\nDLDLRLRLRRR\\n\",\n    \"88 33 12\\n(())((((())()((()())())())(((())())(())()())(()))((()())())())(((())()())(())()())()()()\\nLLLRRLRDRDRLDDLLRDLLDRLRDDLDRDLRR\\n\",\n    \"90 44 6\\n(((((())()())(((()())())())()()))(()())((())()())(()())((())())(()()())())(())((())())()()\\nRLDLRRLLDRDDDLRDRRDLLRRDDDDLRLRDRLLDRDLRDDRR\\n\",\n    \"92 51 30\\n(()(((()())(()())())())(()())()()()())((()()())(())(())(()((())()())())(())())((())()())()()\\nLRLRLLLLRRRLLRRLDLRLRRLRDLDLDLDDRRLRRRLLRDRLDDRLRRD\\n\",\n    \"94 48 47\\n(((()(())())(((())())())()())()()())((()()())(()(()()()())())())(()())(()(())(())()())(()())()\\nLLLLLLDLDRLLDLRRDLLLLRLLDLLRRDDRDRRLLRRDRRRDRLLD\\n\",\n    \"96 37 18\\n((()()()())((((())()())())(())()())()()())(((())()(()(())())()()())(())())((()())()()())(()())()\\nDDLRRDDLDLRDDDRLDLRRDDDLLDRRRDDLDLLRL\\n\",\n    \"98 38 40\\n((()((((()))(())(()(())))))((())()())(())()())((((()())(((()()))()))()(())()()())())((()))(())()()\\nLRLRRDLDDRRLRDRDDLDRDLDRDLRLRLRLRLRLRR\\n\",\n    \"100 57 80\\n(((())(()))(()())())((((()()()())((())())()())(()((()())()()()))())()()())((())()((())()))((()))()()\\nLLRRLLLRLRLRLDLLRRRDDLRDDDLRLRLLLRLRRRLLDRLRDLLDLRLRLDDLR\\n\",\n    \"10 3 3\\n(())((()))\\nDRD\\n\"\n  ],\n  \"outputs\": [\n    \"()\\n\",\n    \"(()(()))\\n\",\n    \"()()\\n\",\n    \"()\\n\",\n    \"()\\n\",\n    \"(())()()\\n\",\n    \"()\\n\",\n    \"(())\\n\",\n    \"((())())()\\n\",\n    \"(())()()\\n\",\n    \"((()))(()()())()\\n\",\n    \"(()())()(())()()()\\n\",\n    \"(()())((())())()()\\n\",\n    \"()\\n\",\n    \"((())())(((())()))(())()\\n\",\n    \"(()()())(()())(())(())()()\\n\",\n    \"()()\\n\",\n    \"((())()(()))()\\n\",\n    \"(())((()())()((()))()()())()()()\\n\",\n    \"(()()()()())((())())(()()())((()))\\n\",\n    \"((((())())(()))(()()))(())()()\\n\",\n    \"(())()\\n\",\n    \"(((())()(()())())(((()())()))())\\n\",\n    \"((()()())()()()())(((()()())())())\\n\",\n    \"((()((())())(()())(())())())\\n\",\n    \"(()(()())())()()\\n\",\n    \"(()()())(())(())((()()))\\n\",\n    \"((()(()())(()())()())()())((()())(()))()()\\n\",\n    \"(()())()\\n\",\n    \"()()()\\n\",\n    \"((((())()())())((())())(())())(((())()()())(())()())()(())\\n\",\n    \"(()())(())()\\n\",\n    \"(())\\n\",\n    \"()()()\\n\",\n    \"()()()()\\n\",\n    \"((()())()())((()()())())(((())(()))(())()(())())\\n\",\n    \"(()())\\n\",\n    \"()()\\n\",\n    \"()()()\\n\",\n    \"(((())()()))\\n\",\n    \"((((((())())()())()())(())())())()()\\n\",\n    \"()\\n\",\n    \"()\\n\",\n    \"((())(())()())(((()()((()()))())()(())())(()())(())((())())()()())(()()()())()\\n\",\n    \"(())\\n\",\n    \"(((())())(((()())())()()())(()())(()()())()())((()()())())((()())((())(()())())())\\n\",\n    \"(())()()\\n\",\n    \"()()\\n\",\n    \"(()()())()()\\n\",\n    \"((())()())(()())()\\n\",\n    \"((()()()))((()())()()())(()())()\\n\",\n    \"()()()\\n\",\n    \"(((())(()))(()())())\\n\",\n    \"()\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/670/E",
  "starter_code": ""
}