{
  "task_id": "APPS/580",
  "problem_id": 580,
  "prompt": "Berland has n cities, the capital is located in city s, and the historic home town of the President is in city t (s \u2260 t). The cities are connected by one-way roads, the travel time for each of the road is a positive integer.\n\nOnce a year the President visited his historic home town t, for which his motorcade passes along some path from s to t (he always returns on a personal plane). Since the president is a very busy man, he always chooses the path from s to t, along which he will travel the fastest.\n\nThe ministry of Roads and Railways wants to learn for each of the road: whether the President will definitely pass through it during his travels, and if not, whether it is possible to repair it so that it would definitely be included in the shortest path from the capital to the historic home town of the President. Obviously, the road can not be repaired so that the travel time on it was less than one. The ministry of Berland, like any other, is interested in maintaining the budget, so it wants to know the minimum cost of repairing the road. Also, it is very fond of accuracy, so it repairs the roads so that the travel time on them is always a positive integer.\n\n\n-----Input-----\n\nThe first lines contain four integers n, m, s and t (2 \u2264 n \u2264 10^5;\u00a01 \u2264 m \u2264 10^5;\u00a01 \u2264 s, t \u2264 n) \u2014 the number of cities and roads in Berland, the numbers of the capital and of the Presidents' home town (s \u2260 t).\n\nNext m lines contain the roads. Each road is given as a group of three integers a_{i}, b_{i}, l_{i} (1 \u2264 a_{i}, b_{i} \u2264 n;\u00a0a_{i} \u2260 b_{i};\u00a01 \u2264 l_{i} \u2264 10^6) \u2014 the cities that are connected by the i-th road and the time needed to ride along it. The road is directed from city a_{i} to city b_{i}.\n\nThe cities are numbered from 1 to n. Each pair of cities can have multiple roads between them. It is guaranteed that there is a path from s to t along the roads.\n\n\n-----Output-----\n\nPrint m lines. The i-th line should contain information about the i-th road (the roads are numbered in the order of appearance in the input).\n\nIf the president will definitely ride along it during his travels, the line must contain a single word \"YES\" (without the quotes).\n\nOtherwise, if the i-th road can be repaired so that the travel time on it remains positive and then president will definitely ride along it, print space-separated word \"CAN\" (without the quotes), and the minimum cost of repairing.\n\nIf we can't make the road be such that president will definitely ride along it, print \"NO\" (without the quotes).\n\n\n-----Examples-----\nInput\n6 7 1 6\n1 2 2\n1 3 10\n2 3 7\n2 4 8\n3 5 3\n4 5 2\n5 6 1\n\nOutput\nYES\nCAN 2\nCAN 1\nCAN 1\nCAN 1\nCAN 1\nYES\n\nInput\n3 3 1 3\n1 2 10\n2 3 10\n1 3 100\n\nOutput\nYES\nYES\nCAN 81\n\nInput\n2 2 1 2\n1 2 1\n1 2 2\n\nOutput\nYES\nNO\n\n\n\n-----Note-----\n\nThe cost of repairing the road is the difference between the time needed to ride along it before and after the repairing.\n\nIn the first sample president initially may choose one of the two following ways for a ride: 1 \u2192 2 \u2192 4 \u2192 5 \u2192 6 or 1 \u2192 2 \u2192 3 \u2192 5 \u2192 6.",
  "solutions": "[\"from heapq import *\\nimport sys\\n\\nMOD = 1000000181\\n\\ndef addM(a,b):\\n    return (a+b)%MOD\\ndef mulM(a,b):\\n    return (a*b)%MOD\\n\\ndef dijk(adj,n,s):\\n    dist = [10**18]*n\\n    ways = [0]*n\\n    frontier = []\\n    dist[s] = 0\\n    ways[s] = 1\\n    heappush(frontier,(0,s))\\n    while (len(frontier)>0):\\n        x = heappop(frontier)\\n        if x[0]!=dist[x[1]]:\\n            continue\\n        x = x[1]\\n        for (i,l) in adj[x]:\\n            if dist[x]+l<dist[i]:\\n                dist[i] = dist[x]+l\\n                ways[i] = ways[x]\\n                heappush(frontier,(dist[i],i))\\n            elif dist[x]+l==dist[i]:\\n                ways[i] = addM(ways[i],ways[x])\\n    return (dist,ways)\\n\\nn,m,s,t = map(int,sys.stdin.readline().split())\\ns-=1\\nt-=1\\nadj = [[] for i in range(n)]\\njda = [[] for i in range(n)]\\nedges = []\\n\\nfor i in range(m):\\n    a,b,l = map(int,sys.stdin.readline().split())\\n    a-=1\\n    b-=1\\n    adj[a].append((b,l))\\n    jda[b].append((a,l))\\n    edges.append((a,b,l))\\n\\none = dijk(adj,n,s)\\ntwo = dijk(jda,n,t)\\n\\nfor i in edges:\\n    if one[0][i[0]]+i[2]+two[0][i[1]]==one[0][t] and mulM(one[1][i[0]],two[1][i[1]])==one[1][t]:\\n        sys.stdout.write(\\\"YES\\\\n\\\")\\n    else:\\n        x = one[0][t]-1-one[0][i[0]]-two[0][i[1]]\\n        if x<=0:\\n            sys.stdout.write(\\\"NO\\\\n\\\")\\n        else:\\n            sys.stdout.write(\\\"CAN \\\"+str(i[2]-x)+\\\"\\\\n\\\")\", \"from heapq import *\\nimport sys\\n\\nMOD1 = 1000000007\\nMOD2 = 1000000123\\n\\ndef addM(a,b):\\n    return ((a[0]+b[0])%MOD1,(a[1]+b[1])%MOD2)\\ndef mulM(a,b):\\n    return ((a[0]*b[0])%MOD1,(a[1]*b[1])%MOD2)\\n\\ndef dijk(adj,n,s):\\n    dist = [10**18]*n\\n    ways = [(0,0)]*n\\n    frontier = []\\n    dist[s] = 0\\n    ways[s] = (1,1)\\n    heappush(frontier,(0,s))\\n    while (len(frontier)>0):\\n        x = heappop(frontier)\\n        if x[0]!=dist[x[1]]:\\n            continue\\n        x = x[1]\\n        for (i,l) in adj[x]:\\n            if dist[x]+l<dist[i]:\\n                dist[i] = dist[x]+l\\n                ways[i] = ways[x]\\n                heappush(frontier,(dist[i],i))\\n            elif dist[x]+l==dist[i]:\\n                ways[i] = addM(ways[i],ways[x])\\n    return (dist,ways)\\n\\nn,m,s,t = map(int,sys.stdin.readline().split())\\ns-=1\\nt-=1\\nadj = [[] for i in range(n)]\\njda = [[] for i in range(n)]\\nedges = []\\n\\nfor i in range(m):\\n    a,b,l = map(int,sys.stdin.readline().split())\\n    a-=1\\n    b-=1\\n    adj[a].append((b,l))\\n    jda[b].append((a,l))\\n    edges.append((a,b,l))\\n\\none = dijk(adj,n,s)\\ntwo = dijk(jda,n,t)\\n\\nfor i in edges:\\n    if one[0][i[0]]+i[2]+two[0][i[1]]==one[0][t] and mulM(one[1][i[0]],two[1][i[1]])==one[1][t]:\\n        sys.stdout.write(\\\"YES\\\\n\\\")\\n    else:\\n        x = one[0][t]-1-one[0][i[0]]-two[0][i[1]]\\n        if x<=0:\\n            sys.stdout.write(\\\"NO\\\\n\\\")\\n        else:\\n            sys.stdout.write(\\\"CAN \\\"+str(i[2]-x)+\\\"\\\\n\\\")\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\", \"from heapq import *\\nfrom collections import defaultdict\\ndef D(v,g):\\n\\th,p,o=[],defaultdict(lambda:1e99),[]\\n\\theappush(h,(0,v))\\n\\twhile h:\\n\\t\\tl,w=heappop(h)\\n\\t\\tif w in p:continue\\n\\t\\tp[w]=l\\n\\t\\to.append(w)\\n\\t\\tfor u,L in g[w]:\\n\\t\\t\\theappush(h,(L+l,u))\\n\\treturn p,o\\nn,m,s,t=list(map(int,input().split()))\\nr=[]\\ng={i+1:[] for i in range(n)}\\nG={i+1:[] for i in range(n)}\\nfor _ in range(m):\\n\\ta,b,l=list(map(int,input().split()))\\n\\tr.append((a,b,l))\\n\\tg[a].append((b,l))\\n\\tG[b].append((a,l))\\nS,o=D(s,g)\\nT,_=D(t,G)\\nL=S[t]\\nH={v:[w for w,l in e if S[v]+T[w]+l==L] for v,e in list(g.items())}\\nB,A=set(),{s}\\nfor v in o:\\n\\tif not H[v]:continue\\n\\tif 1==len(A)==len(H[v]):B.add(v)\\n\\tA.update(H[v])\\n\\tA.remove(v)\\nprint('\\\\n'.join(\\\"YES\\\" if a in B and S[a]+T[b]+l==L else \\\"CAN \\\"+str(S[a]+T[b]+l-L+1) if S[a]+T[b]+1<L else \\\"NO\\\" for a,b,l in r))\\n\\n\"]",
  "input_output": "{\n  \"inputs\": [\n    \"6 7 1 6\\n1 2 2\\n1 3 10\\n2 3 7\\n2 4 8\\n3 5 3\\n4 5 2\\n5 6 1\\n\",\n    \"3 3 1 3\\n1 2 10\\n2 3 10\\n1 3 100\\n\",\n    \"2 2 1 2\\n1 2 1\\n1 2 2\\n\",\n    \"2 1 1 2\\n1 2 1\\n\",\n    \"3 3 1 3\\n1 2 10\\n2 3 10\\n1 3 19\\n\",\n    \"4 3 1 4\\n1 2 1\\n2 3 1\\n3 4 1\\n\",\n    \"4 4 1 4\\n1 2 1\\n2 3 1\\n3 4 1\\n1 3 2\\n\",\n    \"4 4 1 4\\n1 2 1\\n2 3 1\\n3 4 1\\n1 3 1\\n\",\n    \"6 6 1 6\\n1 2 2\\n2 3 4\\n2 4 3\\n3 5 2\\n4 5 3\\n5 6 10\\n\",\n    \"6 6 1 6\\n1 2 2\\n2 3 3\\n2 4 3\\n3 5 2\\n4 5 3\\n5 6 10\\n\",\n    \"2 1 1 2\\n1 2 1\\n\",\n    \"2 2 1 2\\n1 2 6\\n1 2 6\\n\",\n    \"2 3 1 2\\n1 2 7\\n1 2 7\\n1 2 7\\n\",\n    \"2 10 1 2\\n1 2 5\\n1 2 5\\n1 2 7\\n1 2 5\\n1 2 6\\n1 2 5\\n1 2 5\\n1 2 6\\n1 2 5\\n1 2 6\\n\",\n    \"3 2 1 2\\n3 2 3\\n1 3 6\\n\",\n    \"3 3 1 3\\n2 3 7\\n2 3 7\\n1 2 6\\n\",\n    \"3 4 3 1\\n2 1 4\\n2 1 2\\n3 2 1\\n2 1 2\\n\",\n    \"3 5 1 2\\n1 3 3\\n1 2 9\\n3 2 6\\n1 2 10\\n1 3 3\\n\",\n    \"3 7 1 3\\n1 3 11\\n1 3 12\\n1 2 2\\n1 3 11\\n1 2 2\\n2 3 9\\n2 3 9\\n\",\n    \"5 7 3 2\\n5 4 8\\n3 1 2\\n1 2 20\\n1 5 8\\n4 2 4\\n1 5 8\\n5 4 9\\n\",\n    \"7 8 5 3\\n4 3 5\\n7 1 8\\n2 1 16\\n2 7 7\\n2 6 21\\n5 2 10\\n6 4 4\\n1 6 5\\n\",\n    \"6 8 1 6\\n1 2 13\\n3 2 3\\n4 5 6\\n1 6 28\\n1 3 10\\n1 4 18\\n2 4 4\\n5 6 4\\n\",\n    \"7 10 4 7\\n6 3 9\\n2 1 4\\n3 7 3\\n5 2 6\\n1 3 12\\n5 2 6\\n4 5 4\\n4 5 3\\n1 6 3\\n4 6 16\\n\",\n    \"10 13 2 10\\n7 3 5\\n6 1 10\\n9 6 4\\n4 10 48\\n9 5 2\\n1 10 3\\n5 6 2\\n7 6 19\\n4 8 8\\n2 4 8\\n8 7 7\\n7 6 20\\n3 9 10\\n\",\n    \"4 4 1 4\\n1 2 1\\n2 3 1\\n3 4 1\\n1 4 3\\n\",\n    \"5 6 1 5\\n1 2 2\\n2 5 5\\n2 3 4\\n1 4 1\\n4 3 3\\n3 5 1\\n\",\n    \"5 6 1 5\\n1 2 2\\n2 5 5\\n2 3 4\\n1 4 1\\n4 3 3\\n3 5 1\\n\",\n    \"2 1 1 2\\n1 2 1\\n\",\n    \"3 3 1 3\\n1 2 1\\n1 3 2\\n2 3 1\\n\",\n    \"10 10 1 10\\n1 5 178\\n1 8 221\\n2 7 92\\n2 8 159\\n3 5 55\\n3 6 179\\n3 10 237\\n4 8 205\\n5 6 191\\n8 10 157\\n\",\n    \"10 10 1 10\\n1 4 201\\n2 3 238\\n3 4 40\\n3 6 231\\n3 8 45\\n4 5 227\\n4 6 58\\n4 9 55\\n5 7 14\\n6 10 242\\n\",\n    \"3 3 1 3\\n1 2 1\\n2 3 1\\n1 3 2\\n\",\n    \"6 7 1 6\\n1 2 1000000\\n2 3 1000000\\n2 5 1000000\\n1 3 1000000\\n3 5 1000000\\n2 4 1000000\\n5 6 1000000\\n\",\n    \"2 1 1 2\\n1 2 1000000\\n\",\n    \"2 2 1 2\\n1 2 1000000\\n1 2 1000000\\n\",\n    \"2 2 1 2\\n1 2 1000000\\n1 2 1000000\\n\",\n    \"2 9 1 2\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n1 2 1\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n\",\n    \"2 9 1 2\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n1 2 2\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n1 2 1000000\\n\",\n    \"3 2 1 3\\n1 3 1\\n1 2 1\\n\",\n    \"4 5 1 4\\n1 2 1\\n1 2 1\\n2 3 1\\n3 4 1\\n3 4 1\\n\",\n    \"3 3 1 3\\n1 2 666\\n2 3 555\\n3 1 1\\n\"\n  ],\n  \"outputs\": [\n    \"YES\\nCAN 2\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 1\\nYES\\n\",\n    \"YES\\nYES\\nCAN 81\\n\",\n    \"YES\\nNO\\n\",\n    \"YES\\n\",\n    \"CAN 2\\nCAN 2\\nYES\\n\",\n    \"YES\\nYES\\nYES\\n\",\n    \"NO\\nNO\\nYES\\nCAN 1\\n\",\n    \"NO\\nNO\\nYES\\nYES\\n\",\n    \"YES\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 1\\nYES\\n\",\n    \"YES\\nYES\\nCAN 2\\nYES\\nCAN 2\\nYES\\n\",\n    \"YES\\n\",\n    \"CAN 1\\nCAN 1\\n\",\n    \"CAN 1\\nCAN 1\\nCAN 1\\n\",\n    \"CAN 1\\nCAN 1\\nCAN 3\\nCAN 1\\nCAN 2\\nCAN 1\\nCAN 1\\nCAN 2\\nCAN 1\\nCAN 2\\n\",\n    \"YES\\nYES\\n\",\n    \"CAN 1\\nCAN 1\\nYES\\n\",\n    \"CAN 3\\nCAN 1\\nYES\\nCAN 1\\n\",\n    \"CAN 1\\nCAN 1\\nCAN 1\\nCAN 2\\nCAN 1\\n\",\n    \"CAN 1\\nCAN 2\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 1\\n\",\n    \"CAN 1\\nYES\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 2\\n\",\n    \"YES\\nYES\\nCAN 2\\nYES\\nCAN 2\\nYES\\nYES\\nYES\\n\",\n    \"CAN 1\\nCAN 1\\nYES\\nCAN 2\\nCAN 1\\nCAN 2\\nYES\\nYES\\n\",\n    \"CAN 1\\nCAN 1\\nYES\\nCAN 1\\nCAN 1\\nCAN 1\\nCAN 2\\nCAN 1\\nCAN 1\\nCAN 1\\n\",\n    \"CAN 1\\nYES\\nCAN 1\\nCAN 2\\nCAN 1\\nYES\\nCAN 1\\nCAN 1\\nYES\\nYES\\nYES\\nCAN 2\\nCAN 1\\n\",\n    \"NO\\nNO\\nNO\\nCAN 1\\n\",\n    \"NO\\nCAN 3\\nCAN 3\\nYES\\nYES\\nYES\\n\",\n    \"NO\\nCAN 3\\nCAN 3\\nYES\\nYES\\nYES\\n\",\n    \"YES\\n\",\n    \"NO\\nCAN 1\\nNO\\n\",\n    \"NO\\nYES\\nNO\\nNO\\nNO\\nNO\\nNO\\nNO\\nNO\\nYES\\n\",\n    \"YES\\nNO\\nNO\\nNO\\nNO\\nNO\\nYES\\nNO\\nNO\\nYES\\n\",\n    \"NO\\nNO\\nCAN 1\\n\",\n    \"CAN 1\\nNO\\nCAN 1\\nCAN 1\\nCAN 1\\nNO\\nYES\\n\",\n    \"YES\\n\",\n    \"CAN 1\\nCAN 1\\n\",\n    \"CAN 1\\nCAN 1\\n\",\n    \"NO\\nNO\\nNO\\nNO\\nYES\\nNO\\nNO\\nNO\\nNO\\n\",\n    \"CAN 999999\\nCAN 999999\\nCAN 999999\\nCAN 999999\\nYES\\nCAN 999999\\nCAN 999999\\nCAN 999999\\nCAN 999999\\n\",\n    \"YES\\nNO\\n\",\n    \"NO\\nNO\\nYES\\nNO\\nNO\\n\",\n    \"YES\\nYES\\nNO\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/567/E",
  "starter_code": ""
}