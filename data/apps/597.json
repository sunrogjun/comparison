{
  "task_id": "APPS/597",
  "problem_id": 597,
  "prompt": "Ari the monster is not an ordinary monster. She is the hidden identity of Super M, the Byteforces\u2019 superhero. Byteforces is a country that consists of n cities, connected by n - 1 bidirectional roads. Every road connects exactly two distinct cities, and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads. There are m cities being attacked by humans. So Ari... we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans. Super M can pass from one city to another only using the given roads. Moreover, passing through one road takes her exactly one kron - the time unit used in Byteforces.  [Image] \n\nHowever, Super M is not on Byteforces now - she is attending a training camp located in a nearby country Codeforces. Fortunately, there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces. The way back is too long, so for the purpose of this problem teleportation is used exactly once.\n\nYou are to help Super M, by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time (measured in krons). Also, provide her with this time so she can plan her way back to Codeforces.\n\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (1 \u2264 m \u2264 n \u2264 123456) - the number of cities in Byteforces, and the number of cities being attacked respectively.\n\nThen follow n - 1 lines, describing the road system. Each line contains two city numbers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n) - the ends of the road i.\n\nThe last line contains m distinct integers - numbers of cities being attacked. These numbers are given in no particular order.\n\n\n-----Output-----\n\nFirst print the number of the city Super M should teleport to. If there are many possible optimal answers, print the one with the lowest city number.\n\nThen print the minimum possible time needed to scare all humans in cities being attacked, measured in Krons.\n\nNote that the correct answer is always unique.\n\n\n-----Examples-----\nInput\n7 2\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n2 7\n\nOutput\n2\n3\n\nInput\n6 4\n1 2\n2 3\n2 4\n4 5\n4 6\n2 4 5 6\n\nOutput\n2\n4\n\n\n\n-----Note-----\n\nIn the first sample, there are two possibilities to finish the Super M's job in 3 krons. They are:\n\n$2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 7$ and $7 \\rightarrow 3 \\rightarrow 1 \\rightarrow 2$.\n\nHowever, you should choose the first one as it starts in the city with the lower number.",
  "solutions": "[\"from collections import deque\\nn,m = [int(x) for x in input().split()]\\nadj = [[] for x in range(n+1)]\\nfor _ in range(1,n):\\n\\ta,b = [int(x) for x in input().split()]\\n\\tadj[a].append(b)\\n\\tadj[b].append(a)\\nchaos = [int(x) for x in input().split()]\\ns = chaos[0]\\nchaos = set(chaos)\\ncc = [0]*(n+1)\\nst = deque()\\nst.append((s,-1))\\nwhile len(st):\\n\\tu,e = st.pop()\\n\\tif u<0:\\n\\t\\tif e>=0:\\n\\t\\t\\tcc[e] += cc[-u]\\n\\t\\tcontinue\\n\\tif u in chaos:\\n\\t\\tcc[u] +=1\\n\\tst.append((-u,e))\\n\\t\\n\\tfor v in adj[u]:\\n\\t\\tif v!=e:\\n\\t\\t\\tst.append((v,u))\\n\\t\\n#dfs(s,-1)\\nadj = [list([v for v in u if cc[v]>0]) for u in adj]\\na = (s,0)\\nst = deque()\\nst.append((a[0],-1,0))\\nwhile len(st):\\n\\tu,e,h = st.pop()\\n\\tif h>a[1]:\\n\\t\\ta = (u,h)\\n\\telif h==a[1] and u<a[0]:\\n\\t\\ta = (u,h)\\n\\tfor v in adj[u]:\\n\\t\\tif v!=e:\\n\\t\\t\\tst.append((v,u,h+1))\\nb = a\\na = (a[0],0)\\nst = deque()\\nst.append((a[0],-1,0))\\nwhile len(st):\\n\\tu,e,h = st.pop()\\n\\tif h>a[1]:\\n\\t\\ta = (u,h)\\n\\telif h==a[1] and u<a[0]:\\n\\t\\ta = (u,h)\\n\\tfor v in adj[u]:\\n\\t\\tif v!=e:\\n\\t\\t\\tst.append((v,u,h+1))\\nprint(min(a[0],b[0]))\\nprint(2*(n-cc.count(0))-a[1])\\n\", \"from collections import deque\\nfrom sys import stdin\\n\\n#parser\\ndef parser():\\n    return map(int, stdin.readline().split())\\n\\ndef DFS_Discriminiting():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    intrudoction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                if attacked_city[u]:\\n                    count_attacked_cities_subtree[u]+=1\\n                stack.append(u)\\n                intrudoction_order.append(u)    \\n    for v in intrudoction_order[::-1]:\\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\\n        if count_attacked_cities_subtree[v]==0:\\n            important_cities[v]=False\\n\\ndef DFS_Heigths():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    intrudoction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                stack.append(u)\\n                intrudoction_order.append(u)\\n    for v in intrudoction_order[::-1]:\\n        if heights1[pi[v]] < heights1[v]+1:\\n            heights2[pi[v]]=heights1[pi[v]]\\n            heights1[pi[v]]=heights1[v]+1\\n        elif heights2[pi[v]]<heights1[v]+1:\\n            heights2[pi[v]]=heights1[v]+1\\n\\ndef Distance_Root(s):\\n    for v in adjacents_list[s]:\\n        if heights1[v]+1>distances1[s]:\\n            distances2[s]=distances1[s]\\n            distances1[s]=heights1[v]+1\\n        elif heights1[v]+1>distances2[s]:\\n            distances2[s]=heights1[v]+1\\n\\ndef DFS_Distances():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    Distance_Root(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                determinate=False\\n                stack.append(u)\\n                if heights1[u]+1==distances1[v]:\\n                    if heights1[u]+1>distances2[v]:\\n                        determinate=True\\n                        distances1[u]=max(heights1[u],distances2[v]+1)\\n                        if distances1[u]==heights1[u]:\\n                            distances2[u]=max(distances2[v]+1,heights2[u])\\n                        else:\\n                            distances2[u]=heights1[u]\\n                if not determinate:\\n                    distances1[u]=distances1[v]+1\\n                    distances2[u]=heights1[u]\\n\\ndef BFS(s):\\n    distance=[-1 for x in range(n)]\\n    distance[s]=0\\n    q=deque()\\n    q.append(s)\\n    while len(q)>0:\\n        v=q.popleft()\\n        for u in adjacents_list[v]:\\n            if distance[u] == -1:\\n                distance[u]=distance[v]+1\\n                q.append(u)\\n    return distance\\n\\n\\nn,m=parser()\\n#Creando los arrays necesarios para la ejecucion de DFS\\n#padres\\npi=[0 for x in range(n)]\\n#ciudades atacadas en el subarbol\\ncount_attacked_cities_subtree=[0 for x in range(n)]\\n#ciudad atacada o no atacada\\nattacked_city=[False for x in range(n)]\\n#ciudades_que_son atacadas o sirven para llegar a las mismas\\nimportant_cities=[True for x in range(n)]\\n\\nadjacents_list=[[] for x in range(n)]\\nfor i in range(n-1):\\n    v1,v2=parser()\\n    adjacents_list[v1-1].append(v2-1)\\n    adjacents_list[v2-1].append(v1-1)\\n\\n#numero de ciudades atacadas\\nnumbers_of_attacked_cities=[x-1 for x in parser()]\\n\\nif m==1:\\n    print(numbers_of_attacked_cities[0]+1)\\n    print(0)\\n    return\\n\\n#marcando las ciudades atacadas\\nfor i in numbers_of_attacked_cities:\\n    attacked_city[i]=True\\n\\nDFS_Discriminiting()\\n\\nadjacents_list=[[] for x in range(n)]\\n\\ncount_edges=0\\nfor v in range(n):\\n    if v==numbers_of_attacked_cities[0]:\\n        continue\\n    elif important_cities[v] and important_cities[pi[v]]:\\n        adjacents_list[v].append(pi[v])\\n        adjacents_list[pi[v]].append(v)\\n        count_edges+=1\\n\\n#padres\\npi=[0 for x in range(n)]\\n\\n#alturas\\nheights1=[0 for x in range(n)]\\nheights2=[0 for x in range(n)]\\n\\nDFS_Heigths()\\n\\n#distances\\ndistances1=[0 for x in range(n)]\\ndistances2=[0 for x in range(n)]\\n\\nDFS_Distances()\\n\\nlower=distances1[numbers_of_attacked_cities[0]]\\nfor i in range(n):\\n    if important_cities[i] and lower>distances1[i]:\\n        lower=distances1[i]\\n\\ncenters=[]\\nfor i in range(n):\\n    if distances1[i]==lower:\\n        centers.append(i)\\n\\n\\nposibles_begin_cities=[]\\n\\nfor i in centers:\\n    distances_center=BFS(i)\\n    max_distance=0\\n    for j in range(n):\\n        if distances_center[j]>max_distance:\\n            max_distance=distances_center[j]\\n    for j in range(n):\\n        if distances_center[j]==max_distance:\\n            posibles_begin_cities.append(j)\\n\\n\\nprint(min(posibles_begin_cities)+1)\\n\\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))\", \"from collections import deque\\nfrom sys import stdin\\n\\n#parser\\ndef parser():\\n    return map(int, stdin.readline().split())\\n\\ndef DFS_Discriminiting():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    intrudoction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                if attacked_city[u]:\\n                    count_attacked_cities_subtree[u]+=1\\n                stack.append(u)\\n                intrudoction_order.append(u)    \\n    for v in intrudoction_order[::-1]:\\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\\n        if count_attacked_cities_subtree[v]==0:\\n            important_cities[v]=False\\n\\ndef DFS_Heigths():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    intrudoction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                stack.append(u)\\n                intrudoction_order.append(u)\\n    for v in intrudoction_order[::-1]:\\n        if heights1[pi[v]] < heights1[v]+1:\\n            heights2[pi[v]]=heights1[pi[v]]\\n            heights1[pi[v]]=heights1[v]+1\\n        elif heights2[pi[v]]<heights1[v]+1:\\n            heights2[pi[v]]=heights1[v]+1\\n\\ndef Distance_Root(s):\\n    for v in adjacents_list[s]:\\n        if heights1[v]+1>distances1[s]:\\n            distances2[s]=distances1[s]\\n            distances1[s]=heights1[v]+1\\n        elif heights1[v]+1>distances2[s]:\\n            distances2[s]=heights1[v]+1\\n\\ndef DFS_Distances():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    Distance_Root(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                determinate=False\\n                stack.append(u)\\n                if heights1[u]+1==distances1[v]:\\n                    if heights1[u]+1>distances2[v]:\\n                        determinate=True\\n                        distances1[u]=max(heights1[u],distances2[v]+1)\\n                        if distances1[u]==heights1[u]:\\n                            distances2[u]=max(distances2[v]+1,heights2[u])\\n                        else:\\n                            distances2[u]=heights1[u]\\n                if not determinate:\\n                    distances1[u]=distances1[v]+1\\n                    distances2[u]=heights1[u]\\n\\ndef BFS(s):\\n    distance=[-1 for x in range(n)]\\n    distance[s]=0\\n    q=deque()\\n    q.append(s)\\n    while len(q)>0:\\n        v=q.popleft()\\n        for u in adjacents_list[v]:\\n            if distance[u] == -1:\\n                distance[u]=distance[v]+1\\n                q.append(u)\\n    return distance\\n\\n\\nn,m=parser()\\n#Creando los arrays necesarios para la ejecucion de DFS\\n#padres\\npi=[0 for x in range(n)]\\n#ciudades atacadas en el subarbol\\ncount_attacked_cities_subtree=[0 for x in range(n)]\\n#ciudad atacada o no atacada\\nattacked_city=[False for x in range(n)]\\n#ciudades_que_son atacadas o sirven para llegar a las mismas\\nimportant_cities=[True for x in range(n)]\\n\\nadjacents_list=[[] for x in range(n)]\\nfor i in range(n-1):\\n    v1,v2=parser()\\n    adjacents_list[v1-1].append(v2-1)\\n    adjacents_list[v2-1].append(v1-1)\\n\\n#numero de ciudades atacadas\\nnumbers_of_attacked_cities=[x-1 for x in parser()]\\n\\nif m==1:\\n    print(numbers_of_attacked_cities[0]+1)\\n    print(0)\\n    return\\n\\n#marcando las ciudades atacadas\\nfor i in numbers_of_attacked_cities:\\n    attacked_city[i]=True\\n\\nDFS_Discriminiting()\\n\\nadjacents_list=[[] for x in range(n)]\\n\\ncount_edges=0\\nfor v in range(n):\\n    if v==numbers_of_attacked_cities[0]:\\n        continue\\n    elif important_cities[v] and important_cities[pi[v]]:\\n        adjacents_list[v].append(pi[v])\\n        adjacents_list[pi[v]].append(v)\\n        count_edges+=1\\n\\n#padres\\npi=[0 for x in range(n)]\\n\\n#alturas\\nheights1=[0 for x in range(n)]\\nheights2=[0 for x in range(n)]\\n\\nDFS_Heigths()\\n\\n#distances\\ndistances1=[0 for x in range(n)]\\ndistances2=[0 for x in range(n)]\\n\\nDFS_Distances()\\n\\nlower=distances1[numbers_of_attacked_cities[0]]\\nfor i in range(n):\\n    if important_cities[i] and lower>distances1[i]:\\n        lower=distances1[i]\\n\\ncenters=[]\\nfor i in range(n):\\n    if distances1[i]==lower:\\n        centers.append(i)\\n\\n\\nposibles_begin_cities=[]\\n\\nfor i in centers:\\n    distances_center=BFS(i)\\n    max_distance=0\\n    for j in range(n):\\n        if distances_center[j]>max_distance:\\n            max_distance=distances_center[j]\\n    for j in range(n):\\n        if distances_center[j]==max_distance:\\n            posibles_begin_cities.append(j)\\n\\n\\nprint(min(posibles_begin_cities)+1)\\n\\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))\", \"from collections import deque\\n\\n#parser\\ndef parser():\\n    return [int(x) for x in input().split()]\\n\\ndef DFS_Discriminiting():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    intrudoction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                if attacked_city[u]:\\n                    count_attacked_cities_subtree[u]+=1\\n                stack.append(u)\\n                intrudoction_order.append(u)    \\n    for v in intrudoction_order[::-1]:\\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\\n        if count_attacked_cities_subtree[v]==0:\\n            important_cities[v]=False\\n\\ndef DFS_Heigths():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    intrudoction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                stack.append(u)\\n                intrudoction_order.append(u)\\n    for v in intrudoction_order[::-1]:\\n        if heights1[pi[v]] < heights1[v]+1:\\n            heights2[pi[v]]=heights1[pi[v]]\\n            heights1[pi[v]]=heights1[v]+1\\n        elif heights2[pi[v]]<heights1[v]+1:\\n            heights2[pi[v]]=heights1[v]+1\\n\\ndef Distance_Root(s):\\n    for v in adjacents_list[s]:\\n        if heights1[v]+1>distances1[s]:\\n            distances2[s]=distances1[s]\\n            distances1[s]=heights1[v]+1\\n        elif heights1[v]+1>distances2[s]:\\n            distances2[s]=heights1[v]+1\\n\\ndef DFS_Distances():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    Distance_Root(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                determinate=False\\n                stack.append(u)\\n                if heights1[u]+1==distances1[v]:\\n                    if heights1[u]+1>distances2[v]:\\n                        determinate=True\\n                        distances1[u]=max(heights1[u],distances2[v]+1)\\n                        if distances1[u]==heights1[u]:\\n                            distances2[u]=max(distances2[v]+1,heights2[u])\\n                        else:\\n                            distances2[u]=heights1[u]\\n                if not determinate:\\n                    distances1[u]=distances1[v]+1\\n                    distances2[u]=heights1[u]\\n\\ndef BFS(s):\\n    distance=[-1 for x in range(n)]\\n    distance[s]=0\\n    q=deque()\\n    q.append(s)\\n    while len(q)>0:\\n        v=q.popleft()\\n        for u in adjacents_list[v]:\\n            if distance[u] == -1:\\n                distance[u]=distance[v]+1\\n                q.append(u)\\n    return distance\\n\\n\\nn,m=parser()\\n#Creando los arrays necesarios para la ejecucion de DFS\\n#padres\\npi=[0 for x in range(n)]\\n#ciudades atacadas en el subarbol\\ncount_attacked_cities_subtree=[0 for x in range(n)]\\n#ciudad atacada o no atacada\\nattacked_city=[False for x in range(n)]\\n#ciudades_que_son atacadas o sirven para llegar a las mismas\\nimportant_cities=[True for x in range(n)]\\n\\nadjacents_list=[[] for x in range(n)]\\nfor i in range(n-1):\\n    edge=parser()\\n    adjacents_list[edge[0]-1].append(edge[1]-1)\\n    adjacents_list[edge[1]-1].append(edge[0]-1)\\n\\n#numero de ciudades atacadas\\nnumbers_of_attacked_cities=[]\\nfor i in parser():\\n    numbers_of_attacked_cities.append(i-1)\\n\\nif m==1:\\n    print(numbers_of_attacked_cities[0]+1)\\n    print(0)\\n    return\\n\\n#marcando las ciudades atacadas\\nfor i in numbers_of_attacked_cities:\\n    attacked_city[i]=True\\n\\nDFS_Discriminiting()\\n\\nadjacents_list=[[] for x in range(n)]\\n\\ncount_edges=0\\nfor v in range(n):\\n    if v==numbers_of_attacked_cities[0]:\\n        continue\\n    elif important_cities[v] and important_cities[pi[v]]:\\n        adjacents_list[v].append(pi[v])\\n        adjacents_list[pi[v]].append(v)\\n        count_edges+=1\\n\\n#padres\\npi=[0 for x in range(n)]\\n\\n#alturas\\nheights1=[0 for x in range(n)]\\nheights2=[0 for x in range(n)]\\n\\nDFS_Heigths()\\n\\n#distances\\ndistances1=[0 for x in range(n)]\\ndistances2=[0 for x in range(n)]\\n\\nDFS_Distances()\\n\\nlower=distances1[numbers_of_attacked_cities[0]]\\nfor i in range(n):\\n    if important_cities[i] and lower>distances1[i]:\\n        lower=distances1[i]\\n\\ncenters=[]\\nfor i in range(n):\\n    if distances1[i]==lower:\\n        centers.append(i)\\n\\n\\nposibles_begin_cities=[]\\n\\nfor i in centers:\\n    distances_center=BFS(i)\\n    max_distance=0\\n    for j in range(n):\\n        if distances_center[j]>max_distance:\\n            max_distance=distances_center[j]\\n    for j in range(n):\\n        if distances_center[j]==max_distance:\\n            posibles_begin_cities.append(j)\\n\\n\\nprint(min(posibles_begin_cities)+1)\\n\\nprint(2*count_edges-(distances1[centers[0]]+distances2[centers[0]]))\", \"from heapq import *\\nINF = float('inf')\\nn, m = list(map(int, input().split()))\\nadj = [[] for _ in range(n+1)]\\nwg= ng = [0 for _ in range(n+1)]\\n\\nfor _ in range(n-1):\\n    a, b = list(map(int, input().split()))\\n    adj[a].append(b)\\n    adj[b].append(a)\\n\\naaa = set(map(int, input().split()))\\nif len(aaa) == 1:print((min(aaa)));print((0));return\\nrm = []\\nfor i in range(n+1):\\n    ng[i] = len(adj[i])\\n    if i not in aaa and ng[i] == 1: rm.append(i)\\n\\nfor a in aaa: ng[a] = 0\\n\\ndef remove_node(index):\\n    while adj[index]:\\n        nx = adj[index].pop()\\n        adj[nx].remove(index)\\n        ng[nx] -= 1\\n        if ng[nx] == 1: rm.append(nx)\\n\\n    ng[index] = 0\\n\\nwhile rm: remove_node(rm.pop())\\n\\nstate = [0 for _ in range(n+1)]\\nque = [(min(aaa), None)]\\nres = 0\\nfor _ in range(2):\\n    deep = [0 for _ in range(n + 1)]\\n    while que:\\n        res += 1\\n        root, proot = que.pop()\\n        for nx in adj[root]:\\n            if proot == nx:\\n                continue\\n            if _: state[nx] = root\\n            deep[nx] = deep[root] + 1\\n            que.append((nx, root))\\n    if _: break\\n\\n    start = max(1,deep.index(max(deep)))\\n    que = [(start, None)]\\n\\nend = max(1, deep.index(max(deep)))\\ni = end\\npath = 1\\nwhile i != start:\\n    path += 1\\n    i = state[i]\\n\\nprint(min(start,end))\\nprint(res -1 -path)\\n\", \"from collections import deque\\nfrom sys import stdin\\n\\n#parsea una l\\u00ednea\\ndef parser():\\n    return map(int, stdin.readline().split())\\n\\n#M\\u00e9todo usado para obtener los v\\u00e9rtices por los que debe pasar Super M\\ndef DFS_Discriminiting():\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    introduction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                pi[u]=v\\n                visited[u]=True\\n                if attacked_city[u]:\\n                    count_attacked_cities_subtree[u]+=1\\n                stack.append(u)\\n                introduction_order.append(u)    \\n    for v in introduction_order[::-1]:\\n        count_attacked_cities_subtree[pi[v]]+=count_attacked_cities_subtree[v]\\n        if count_attacked_cities_subtree[v]==0:\\n            important_cities[v]=False\\n\\n#M\\u00e9todo usado para calcular las alturas\\ndef DFS_Heigths():\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    introduction_order=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                visited[u]=True\\n                stack.append(u)\\n                introduction_order.append(u)\\n    for v in introduction_order[::-1]:\\n        if heights1[pi[v]] < heights1[v]+1:\\n            heights2[pi[v]]=heights1[pi[v]]\\n            heights1[pi[v]]=heights1[v]+1\\n        elif heights2[pi[v]]<heights1[v]+1:\\n            heights2[pi[v]]=heights1[v]+1\\n\\n#M\\u00e9todo usado para calcular la primera y segunda distancia de la ra\\u00edz \\ndef Distance_Root(s):\\n    for v in adjacents_list[s]:\\n        if heights1[v]+1>distances1[s]:\\n            distances2[s]=distances1[s]\\n            distances1[s]=heights1[v]+1\\n        elif heights1[v]+1>distances2[s]:\\n            distances2[s]=heights1[v]+1\\n\\n#M\\u00e9todo usado para calcular la primera distancia y segunda distancia de cada v\\u00e9rtice\\ndef DFS_Distances():\\n    #visitados\\n    visited=[False for x in range(n)]\\n    visited[numbers_of_attacked_cities[0]]=True\\n    stack=[]\\n    stack.append(numbers_of_attacked_cities[0])\\n    Distance_Root(numbers_of_attacked_cities[0])\\n    while len(stack)>0:\\n        v=stack.pop()\\n        for u in adjacents_list[v]:\\n            if not visited[u]:\\n                visited[u]=True\\n                stack.append(u)\\n                determinate=False\\n                if heights1[u]+1==distances1[v]:\\n                    if heights1[u]+1>distances2[v]:\\n                        determinate=True\\n                        distances1[u]=max(heights1[u],distances2[v]+1)\\n                        if distances1[u]==heights1[u]:\\n                            distances2[u]=max(distances2[v]+1,heights2[u])\\n                        else:\\n                            distances2[u]=heights1[u]\\n                if not determinate:\\n                    distances1[u]=distances1[v]+1\\n                    distances2[u]=heights1[u]\\n\\n#M\\u00e9todo usado para calcular las distancias de un v\\u00e9tice al resto de los v\\u00e9rtices\\ndef BFS(s):\\n    distance=[-1 for x in range(n)]\\n    distance[s]=0\\n    q=deque()\\n    q.append(s)\\n    while len(q)>0:\\n        v=q.popleft()\\n        for u in adjacents_list[v]:\\n            if distance[u] == -1:\\n                distance[u]=distance[v]+1\\n                q.append(u)\\n    return distance\\n\\n#Recibiendo los valores de n y m\\nn,m=parser()\\n#padres\\npi=[0 for x in range(n)]\\n#ciudades atacadas en el subarbol\\ncount_attacked_cities_subtree=[0 for x in range(n)]\\n#ciudad atacada o no atacada\\nattacked_city=[False for x in range(n)]\\n#ciudades_que_son atacadas o sirven para llegar a las mismas\\nimportant_cities=[True for x in range(n)]\\n\\n#Armando el \\u00e1rbol que representa a Byteforces\\nadjacents_list=[[] for x in range(n)]\\nfor i in range(n-1):\\n    v1,v2=parser()\\n    adjacents_list[v1-1].append(v2-1)\\n    adjacents_list[v2-1].append(v1-1)\\n\\n#n\\u00famero de ciudades atacadas\\nnumbers_of_attacked_cities=[x-1 for x in parser()]\\nif m==1:\\n    print(numbers_of_attacked_cities[0]+1)\\n    print(0)\\n    return\\n\\n#marcando las ciudades atacadas\\nfor i in numbers_of_attacked_cities:\\n    attacked_city[i]=True\\n\\n#Obteniendo las ciudades que recorre Super M\\nDFS_Discriminiting()\\n\\n#Creando el nuevo \\u00e1rbol que representa el recorrido de Super M\\nadjacents_list=[[] for x in range(n)]\\n\\n#Armando el nuevo \\u00e1rbol y contando sus aristas\\ncount_edges=0\\nfor v in range(n):\\n    if v==numbers_of_attacked_cities[0]:\\n        continue\\n    elif important_cities[v] and important_cities[pi[v]]:\\n        adjacents_list[v].append(pi[v])\\n        adjacents_list[pi[v]].append(v)\\n        count_edges+=1\\n\\n#alturas\\nheights1=[0 for x in range(n)]\\nheights2=[0 for x in range(n)]\\n\\n#Calculando las alturas\\nDFS_Heigths()\\n\\n#distancias\\ndistances1=[0 for x in range(n)]\\ndistances2=[0 for x in range(n)]\\n\\n#Calculando las distancias\\nDFS_Distances()\\n\\n#Hallando la mayor distancia de las primeras distancias\\nmin_distance=distances1[numbers_of_attacked_cities[0]]\\nfor i in range(n):\\n    if important_cities[i] and min_distance>distances1[i]:\\n        min_distance=distances1[i]\\n\\n#Hallando el centro\\ncenter=[]\\nfor i in range(n):\\n    if distances1[i]==min_distance:\\n        center.append(i)\\n\\nposibles_begin_cities=[]\\n\\n#Hallando la ciudad por la cual comenzar\\nfor i in center:\\n    distances_center=BFS(i)\\n    max_distance=0\\n    for j in range(n):\\n        if distances_center[j]>max_distance:\\n            max_distance=distances_center[j]\\n    for j in range(n):\\n        if distances_center[j]==max_distance:\\n            posibles_begin_cities.append(j)\\n\\n#Imprimiendo la respuesta\\nprint(min(posibles_begin_cities)+1)\\nprint(2*count_edges-(distances1[center[0]]+distances2[center[0]]))\"]",
  "input_output": "{\n  \"inputs\": [\n    \"7 2\\n1 2\\n1 3\\n1 4\\n3 5\\n3 6\\n3 7\\n2 7\\n\",\n    \"6 4\\n1 2\\n2 3\\n2 4\\n4 5\\n4 6\\n2 4 5 6\\n\",\n    \"2 1\\n2 1\\n1\\n\",\n    \"1 1\\n1\\n\",\n    \"10 2\\n6 9\\n6 2\\n1 6\\n4 10\\n3 7\\n9 4\\n9 5\\n6 7\\n2 8\\n7 6\\n\",\n    \"15 2\\n7 12\\n13 11\\n6 8\\n2 15\\n10 9\\n5 1\\n13 5\\n5 4\\n14 3\\n8 9\\n8 4\\n4 7\\n12 14\\n5 2\\n7 4\\n\",\n    \"20 2\\n1 16\\n12 5\\n15 19\\n18 9\\n8 4\\n10 16\\n9 16\\n20 15\\n14 19\\n7 4\\n18 12\\n17 12\\n2 20\\n6 14\\n3 19\\n7 19\\n18 15\\n19 13\\n9 11\\n12 18\\n\",\n    \"4 2\\n4 3\\n3 1\\n1 2\\n3 4\\n\",\n    \"8 5\\n2 5\\n1 8\\n6 7\\n3 4\\n6 8\\n8 5\\n5 3\\n1 6 7 3 8\\n\",\n    \"16 8\\n16 12\\n16 15\\n15 9\\n15 13\\n16 3\\n15 2\\n15 10\\n1 2\\n6 16\\n5 15\\n2 7\\n15 4\\n14 15\\n11 16\\n8 5\\n5 10 14 6 8 3 1 9\\n\",\n    \"32 28\\n30 12\\n30 27\\n24 32\\n6 13\\n11 5\\n4 30\\n8 28\\n9 20\\n8 20\\n7 20\\n5 30\\n18 5\\n20 14\\n23 20\\n17 20\\n8 26\\n20 1\\n15 2\\n20 13\\n24 20\\n22 24\\n25 16\\n2 3\\n19 5\\n16 10\\n31 2\\n29 5\\n20 16\\n2 20\\n5 21\\n5 20\\n32 11 6 12 22 30 23 21 14 13 1 20 7 25 9 29 10 27 5 19 24 31 15 26 8 3 28 17\\n\",\n    \"10 3\\n10 5\\n3 2\\n6 8\\n1 5\\n10 4\\n6 1\\n9 8\\n2 9\\n7 3\\n3 9 1\\n\",\n    \"7 5\\n6 4\\n5 6\\n6 7\\n2 3\\n5 2\\n2 1\\n4 6 1 7 3\\n\",\n    \"15 7\\n5 4\\n12 5\\n7 13\\n10 11\\n3 8\\n6 12\\n3 15\\n1 3\\n5 14\\n7 9\\n1 10\\n6 1\\n12 7\\n10 2\\n4 10 8 13 1 7 9\\n\",\n    \"31 16\\n3 25\\n8 1\\n1 9\\n1 23\\n16 15\\n10 6\\n25 30\\n20 29\\n2 24\\n3 7\\n19 22\\n2 12\\n16 4\\n7 26\\n31 10\\n17 13\\n25 21\\n7 18\\n28 2\\n6 27\\n19 5\\n13 3\\n17 31\\n10 16\\n20 14\\n8 19\\n6 11\\n28 20\\n13 28\\n31 8\\n31 27 25 20 26 8 28 15 18 17 10 23 4 16 30 22\\n\",\n    \"63 20\\n35 26\\n54 5\\n32 56\\n56 53\\n59 46\\n37 31\\n46 8\\n4 1\\n2 47\\n59 42\\n55 11\\n62 6\\n30 7\\n60 24\\n41 36\\n34 22\\n24 34\\n21 2\\n12 52\\n8 44\\n60 21\\n24 30\\n48 35\\n48 25\\n32 57\\n20 37\\n11 54\\n11 62\\n42 58\\n31 43\\n12 23\\n55 48\\n51 55\\n41 27\\n25 33\\n21 18\\n42 12\\n4 15\\n51 60\\n62 39\\n46 41\\n57 9\\n30 61\\n31 4\\n58 13\\n34 29\\n37 32\\n18 16\\n57 45\\n2 49\\n40 51\\n43 17\\n40 20\\n20 59\\n8 19\\n58 10\\n43 63\\n54 50\\n18 14\\n25 38\\n56 28\\n35 3\\n41 36 18 28 54 22 20 6 23 38 33 52 48 44 29 56 63 4 27 50\\n\",\n    \"4 2\\n2 3\\n2 1\\n2 4\\n3 4\\n\",\n    \"13 11\\n4 11\\n2 7\\n4 13\\n8 12\\n8 9\\n8 6\\n3 8\\n4 1\\n2 10\\n2 5\\n3 4\\n3 2\\n10 4 5 6 1 2 3 9 13 7 12\\n\",\n    \"7 5\\n1 5\\n4 1\\n1 3\\n7 1\\n1 6\\n1 2\\n2 4 1 3 7\\n\",\n    \"12 9\\n11 12\\n1 10\\n1 7\\n5 6\\n8 7\\n9 8\\n4 5\\n1 4\\n2 3\\n1 2\\n10 11\\n4 9 11 3 5 12 8 6 7\\n\",\n    \"56 34\\n7 31\\n47 6\\n13 4\\n51 29\\n13 12\\n10 52\\n10 41\\n1 47\\n47 54\\n9 1\\n4 27\\n4 40\\n49 19\\n21 26\\n24 33\\n56 49\\n41 56\\n7 23\\n41 48\\n16 34\\n35 9\\n56 51\\n5 43\\n44 46\\n10 25\\n49 2\\n1 21\\n9 32\\n33 20\\n16 5\\n5 35\\n55 50\\n55 53\\n37 44\\n43 15\\n4 55\\n8 10\\n8 24\\n21 42\\n37 8\\n39 13\\n49 38\\n39 16\\n50 3\\n55 7\\n51 45\\n21 11\\n51 28\\n50 18\\n50 30\\n5 37\\n7 17\\n35 22\\n47 36\\n35 14\\n3 38 47 22 34 10 54 50 9 52 36 1 21 29 28 6 13 39 4 40 53 51 35 55 45 18 44 20 42 31 11 46 41 12\\n\",\n    \"26 22\\n20 16\\n2 7\\n7 19\\n5 9\\n20 23\\n22 18\\n24 3\\n8 22\\n16 10\\n5 2\\n7 15\\n22 14\\n25 4\\n25 11\\n24 13\\n8 24\\n13 1\\n20 8\\n22 6\\n7 26\\n16 12\\n16 5\\n13 21\\n25 17\\n2 25\\n16 4 7 24 10 12 2 23 20 1 26 14 8 9 3 6 21 13 11 18 22 17\\n\",\n    \"43 13\\n7 28\\n17 27\\n39 8\\n21 3\\n17 20\\n17 2\\n9 6\\n35 23\\n43 22\\n7 41\\n5 24\\n26 11\\n21 43\\n41 17\\n16 5\\n25 15\\n39 10\\n18 7\\n37 33\\n39 13\\n39 16\\n10 12\\n1 21\\n2 25\\n14 36\\n12 7\\n16 34\\n24 4\\n25 40\\n5 29\\n37 31\\n3 32\\n22 14\\n16 35\\n5 37\\n10 38\\n25 19\\n9 1\\n26 42\\n43 26\\n10 30\\n33 9\\n28 6 42 38 27 32 8 11 36 7 41 29 19\\n\",\n    \"21 20\\n16 9\\n7 11\\n4 12\\n2 17\\n17 7\\n5 2\\n2 8\\n4 10\\n8 19\\n6 15\\n2 6\\n12 18\\n16 5\\n20 16\\n6 14\\n5 3\\n5 21\\n20 1\\n17 13\\n6 4\\n6 4 18 11 14 1 19 15 10 8 9 17 16 3 20 13 2 5 12 21\\n\",\n    \"29 6\\n16 9\\n20 13\\n24 3\\n24 28\\n22 12\\n10 11\\n10 26\\n22 4\\n10 27\\n5 1\\n2 23\\n23 5\\n16 7\\n8 24\\n7 19\\n19 17\\n8 10\\n20 16\\n20 25\\n24 20\\n23 15\\n22 29\\n2 8\\n7 22\\n2 21\\n23 14\\n19 18\\n19 6\\n19 17 18 27 29 4\\n\",\n    \"31 29\\n10 14\\n16 6\\n23 22\\n25 23\\n2 27\\n24 17\\n20 8\\n5 2\\n8 24\\n16 5\\n10 26\\n8 7\\n5 29\\n20 16\\n13 9\\n13 21\\n24 30\\n13 1\\n10 15\\n23 3\\n25 10\\n2 25\\n20 13\\n25 11\\n8 12\\n30 28\\n20 18\\n5 4\\n23 19\\n16 31\\n13 14 3 30 5 6 26 22 25 1 23 7 31 12 16 28 17 2 8 18 24 4 20 21 15 11 9 29 10\\n\",\n    \"54 8\\n33 9\\n39 36\\n22 14\\n24 13\\n8 50\\n34 52\\n47 2\\n35 44\\n16 54\\n34 25\\n1 3\\n39 11\\n9 17\\n43 19\\n10 40\\n47 38\\n5 37\\n21 47\\n37 12\\n16 6\\n37 7\\n32 26\\n39 42\\n44 10\\n1 18\\n37 8\\n9 1\\n8 24\\n10 33\\n33 53\\n5 4\\n21 30\\n9 31\\n24 28\\n24 49\\n16 5\\n34 35\\n21 48\\n47 43\\n13 34\\n39 16\\n10 27\\n22 32\\n43 22\\n13 46\\n33 23\\n44 15\\n1 21\\n8 41\\n43 45\\n5 29\\n35 20\\n13 51\\n40 50 33 14 48 25 44 9\\n\",\n    \"17 12\\n5 2\\n4 3\\n8 17\\n2 4\\n2 8\\n17 12\\n8 10\\n6 11\\n16 7\\n4 14\\n15 13\\n6 9\\n4 6\\n15 16\\n16 5\\n9 1\\n4 8 1 9 3 12 15 10 13 6 14 16\\n\",\n    \"28 6\\n25 21\\n9 18\\n25 1\\n16 5\\n9 11\\n28 19\\n5 2\\n20 16\\n20 13\\n2 23\\n5 25\\n8 24\\n14 27\\n3 15\\n24 28\\n8 10\\n22 14\\n14 17\\n13 9\\n3 22\\n22 26\\n16 7\\n2 8\\n25 3\\n3 12\\n14 4\\n9 6\\n28 27 22 24 20 16\\n\",\n    \"10 9\\n3 9\\n4 8\\n10 1\\n2 3\\n5 6\\n4 3\\n1 2\\n5 4\\n6 7\\n9 1 5 8 7 3 4 6 10\\n\",\n    \"9 6\\n1 6\\n3 4\\n9 7\\n3 2\\n8 7\\n2 1\\n6 7\\n3 5\\n2 5 1 6 3 9\\n\",\n    \"19 11\\n8 9\\n10 13\\n16 15\\n6 4\\n3 2\\n17 16\\n4 7\\n1 14\\n10 11\\n15 14\\n4 3\\n10 12\\n4 5\\n2 1\\n16 19\\n8 1\\n10 9\\n18 16\\n10 14 18 12 17 11 19 8 1 3 9\\n\",\n    \"36 5\\n36 33\\n11 12\\n14 12\\n25 24\\n27 26\\n23 24\\n20 19\\n1 2\\n3 2\\n17 18\\n33 34\\n23 1\\n32 31\\n12 15\\n25 26\\n4 5\\n5 8\\n5 6\\n26 29\\n1 9\\n35 33\\n33 32\\n16 1\\n3 4\\n31 30\\n16 17\\n19 21\\n1 30\\n7 5\\n9 10\\n13 12\\n19 18\\n10 11\\n22 19\\n28 26\\n29 12 11 17 33\\n\",\n    \"10 2\\n5 1\\n1 3\\n3 4\\n4 2\\n5 10\\n1 9\\n3 8\\n4 7\\n2 6\\n3 4\\n\",\n    \"53 30\\n41 42\\n27 24\\n13 11\\n10 11\\n32 33\\n34 33\\n37 40\\n21 22\\n21 20\\n46 47\\n2 1\\n31 30\\n29 30\\n11 14\\n42 43\\n50 51\\n34 35\\n36 35\\n24 23\\n48 47\\n41 1\\n28 29\\n45 44\\n16 15\\n5 4\\n6 5\\n18 19\\n9 8\\n37 38\\n11 12\\n39 37\\n49 48\\n50 49\\n43 44\\n50 53\\n3 4\\n50 52\\n24 25\\n7 6\\n46 45\\n2 3\\n17 18\\n31 32\\n19 20\\n7 8\\n15 1\\n36 37\\n23 22\\n9 10\\n17 16\\n24 26\\n28 1\\n38 52 41 35 53 43 3 29 36 4 23 20 46 5 40 30 49 25 16 48 17 27 21 9 45 44 15 13 14 2\\n\",\n    \"10 4\\n2 3\\n4 2\\n8 9\\n6 5\\n8 1\\n5 1\\n8 10\\n7 5\\n1 2\\n4 10 2 5\\n\",\n    \"10 5\\n4 5\\n9 1\\n1 2\\n7 1\\n5 1\\n10 1\\n7 3\\n6 3\\n5 8\\n5 2 7 10 1\\n\",\n    \"10 4\\n8 7\\n7 6\\n1 2\\n3 2\\n3 4\\n6 5\\n10 7\\n7 9\\n5 4\\n9 5 10 4\\n\",\n    \"5 4\\n2 3\\n2 1\\n3 5\\n4 3\\n4 2 5 1\\n\",\n    \"5 1\\n1 2\\n2 3\\n3 4\\n4 5\\n4\\n\"\n  ],\n  \"outputs\": [\n    \"2\\n3\\n\",\n    \"2\\n4\\n\",\n    \"1\\n0\\n\",\n    \"1\\n0\\n\",\n    \"6\\n1\\n\",\n    \"4\\n1\\n\",\n    \"12\\n1\\n\",\n    \"3\\n1\\n\",\n    \"3\\n6\\n\",\n    \"1\\n16\\n\",\n    \"3\\n53\\n\",\n    \"1\\n5\\n\",\n    \"1\\n8\\n\",\n    \"4\\n14\\n\",\n    \"4\\n34\\n\",\n    \"6\\n66\\n\",\n    \"3\\n2\\n\",\n    \"1\\n18\\n\",\n    \"2\\n6\\n\",\n    \"6\\n16\\n\",\n    \"3\\n70\\n\",\n    \"1\\n37\\n\",\n    \"19\\n41\\n\",\n    \"1\\n32\\n\",\n    \"4\\n16\\n\",\n    \"3\\n46\\n\",\n    \"14\\n21\\n\",\n    \"1\\n20\\n\",\n    \"27\\n13\\n\",\n    \"7\\n11\\n\",\n    \"5\\n6\\n\",\n    \"11\\n18\\n\",\n    \"12\\n21\\n\",\n    \"3\\n1\\n\",\n    \"13\\n74\\n\",\n    \"4\\n6\\n\",\n    \"2\\n6\\n\",\n    \"4\\n6\\n\",\n    \"1\\n5\\n\",\n    \"4\\n0\\n\"\n  ]\n}",
  "difficulty": "interview",
  "url": "https://codeforces.com/problemset/problem/592/D",
  "starter_code": ""
}